var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AddWadoServerController = /** @class */ (function () {
        function AddWadoServerController($scope, $modalInstance, server, blockUI, $translate, dialogs) {
            var notifyTitle = '';
            var errorTitle = '';
            $scope.title = 'DIALOGS_ADD_WADO_TITLE';
            if (server) {
                $scope.title = 'DIALOGS_EDIT_WADO_TITLE';
                if (typeof server.isDefault == "string") {
                    server.isDefault = (server.isDefault) == "true" ? true : false;
                }
            }
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                errorTitle = translation;
            });
            $scope.server = server || new Models.WadoConnection();
            $scope.ok = function () {
                $modalInstance.close($scope.server);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        AddWadoServerController.$inject = ['$scope', '$modalInstance', 'server', 'blockUI', '$translate', 'dialogs'];
        return AddWadoServerController;
    }());
    Controllers.AddWadoServerController = AddWadoServerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var CodeSequenceEditorController = /** @class */ (function () {
        function CodeSequenceEditorController($scope, $modalInstance, item, title) {
            $scope.item = item || new Models.CodeSequence();
            $scope.title = title;
            $scope.isFormValid = function () {
                var valid = $scope.isCodeValueValid() && $scope.isCodeSchemeDesignatorValid() && $scope.isCodeMeaningValid();
                return valid;
            };
            $scope.isCodeValueValid = function () {
                var errorMessage = $scope.getCodeValueError();
                return errorMessage.length == 0;
            };
            // SH -- short string (16 characters)
            $scope.getCodeValueError = function () {
                var errorMessage = "";
                var codeValue = $scope.item.CodeValue.trim();
                if (codeValue.length == 0) {
                    errorMessage = "Value must not be empty.";
                }
                if (codeValue.length > 16) {
                    errorMessage = "Must be less than 16 characters.";
                }
                return errorMessage;
            };
            $scope.isCodeSchemeDesignatorValid = function () {
                var errorMessage = $scope.getCodeSchemeDesignatorError();
                return errorMessage.length == 0;
            };
            // SH -- short string (16 characters)
            $scope.getCodeSchemeDesignatorError = function () {
                var errorMessage = "";
                var codeSchemeDesignator = $scope.item.CodeSchemeDesignator.trim();
                if (codeSchemeDesignator.length > 16) {
                    errorMessage = "Must be less than 16 characters.";
                }
                return errorMessage;
            };
            $scope.isCodeMeaningValid = function () {
                var errorMessage = $scope.getCodeMeaningError();
                return errorMessage.length == 0;
            };
            // LO -- long string (64 characters)
            $scope.getCodeMeaningError = function () {
                var errorMessage = "";
                var codeMeaning = $scope.item.CodeMeaning.trim();
                if (codeMeaning.length > 64) {
                    errorMessage = "Must be less than 64 characters.";
                }
                return errorMessage;
            };
            $scope.ok = function () {
                $modalInstance.close($scope.item);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        CodeSequenceEditorController.$inject = ['$scope', '$modalInstance', 'item', 'title'];
        return CodeSequenceEditorController;
    }());
    Controllers.CodeSequenceEditorController = CodeSequenceEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var EmailURLController = /** @class */ (function () {
        function EmailURLController($scope, $modalInstance, Upload, templateService, eventService, $translate, dialogs, patientInfo, authenticationService, optionsService, seriesManagerService) {
            this.notifyTitle = 'Notification';
            this.errorTitle = 'Error';
            this.successMessage = 'Templates successfully imported';
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this.notifyTitle = translation;
            }.bind(this));
            $translate('DIALOGS_ERROR').then(function (translation) {
                this.errorTitle = translation;
            }.bind(this));
            $translate('DIALOGS_TEMPLATES_IMPORTED').then(function (translation) {
                this.successMessage = translation;
            }.bind(this));
            var __this = this;
            $scope.file = '';
            $scope.InNetwork = true;
            $scope.parameters = {};
            $scope.parameters.Email = '';
            $scope.parameters.confirmEmail = '';
            $scope.parameters.miniToolbar = "full";
            $scope.parameters.body = "";
            $scope.parameters.title = "";
            $scope.parameters.sharedLink = '';
            $scope.parameters.requireAuthentication = true;
            $scope.seriesInstanceUID = '';
            $scope.linkGenerated = false;
            this._authenticationService = authenticationService;
            var _patientID;
            var _name;
            var _lastName;
            var _dateOfBirth;
            var _sex;
            var _seriesInstanceUID;
            if (patientInfo != null) {
                if (patientInfo.PatientID) {
                    _patientID = patientInfo.PatientID;
                    _name = patientInfo.PatientName;
                    _dateOfBirth = patientInfo.PatientBirthDate;
                    _sex = patientInfo.PatientSex;
                    _seriesInstanceUID = "";
                }
                else {
                    _patientID = DicomHelper.getDicomTagValue(patientInfo, DicomTag.PatientID);
                    _name = DicomHelper.getPatientName(patientInfo, DicomTag.PatientName);
                    _dateOfBirth = DicomHelper.getDicomTagValue(patientInfo, DicomTag.PatientBirthDate);
                    _sex = DicomHelper.getDicomTagValue(patientInfo, DicomTag.PatientSex);
                    _seriesInstanceUID = DicomHelper.getDicomTagValue(patientInfo, DicomTag.SeriesInstanceUID);
                }
                if (!_name)
                    _name = "";
                var nameArray = _name.split('^');
                var last = nameArray[0];
                var first = nameArray.length > 1 ? nameArray[1] : "";
                $scope.patientID = _patientID ? _patientID : "N/A";
                $scope.firstName = first ? first : "N/A";
                $scope.lastName = last ? last : "N/A";
                $scope.dateOfBirth = _dateOfBirth ? _dateOfBirth : "N/A";
                $scope.sex = _sex ? _sex : "N/A";
                $scope.isSD = (seriesManagerService.currentStructuredDisplay != null);
                $scope.seriesInstanceUID = $scope.isSD ? seriesManagerService.currentStructuredDisplay.SeriesInstanceUID : _seriesInstanceUID;
                this.fillupEmail($scope, patientInfo, optionsService.get(OptionNames.TwoFactorsAuthenticationMessage));
            }
            $scope.uploadFile = this.uploadFile.bind(this);
            $scope.keyDown = function ($event) {
                $event.originalEvent.stopPropagation();
            };
            $scope.ok = function () {
                $modalInstance.close();
            };
            $scope.troubleShoot = function () {
                window.open("https://www.leadtools.com/support/guides/medicalWebViewer-Email-Configuration-Guide.pdf");
            };
            $scope.cancel = function () {
                $modalInstance.close();
            };
            $scope.send = function () {
                var result = __this.parametersValid($scope);
                if (result == "success") {
                    $modalInstance.close();
                    __this._authenticationService.sendPatientURLAsEmail($scope.patientID.trim(), $scope.seriesInstanceUID, $scope.parameters.Email, "1111111111" /*$scope.PhoneNumber*/, $scope.parameters.miniToolbar, $scope.parameters.title, $scope.parameters.body, $scope.isSD, $scope.parameters.requireAuthentication).then(function (result) {
                        if (result.data != "success")
                            alert(result.data);
                    });
                }
                else {
                    alert(result);
                }
            };
            $scope.close = function () {
                $modalInstance.close();
            };
            $scope.miniToolbarChanged = function () {
                $scope.textChanged();
            };
            $scope.textChanged = function () {
                if (__this.parametersValid($scope) == "success") {
                    __this.generateLink($scope);
                }
                else
                    $scope.sharedLink = "";
            };
            this._Upload = Upload;
            this._templateService = templateService;
            this._eventService = eventService;
            this._dialogs = dialogs;
        }
        EmailURLController.prototype.fillupEmail = function ($scope, json, emailData) {
            var sep = emailData.indexOf('\n');
            $scope.parameters.title = emailData.substring(0, sep);
            $scope.parameters.body = emailData.substring(sep + 1);
            $scope.parameters.title = tokenizeFileName(json, json, $scope.parameters.title, ["urlinterfacelink"], false, "N/A");
            $scope.parameters.body = tokenizeFileName(json, json, $scope.parameters.body, ["urlinterfacelink"], false, "N/A");
        };
        EmailURLController.prototype.parametersValid = function ($scope) {
            if (!this.emailIsValid($scope.parameters.Email))
                return "E-mail is not valid";
            if (!this.emailIsValid($scope.parameters.confirmEmail))
                return "confirm E-mail does not match";
            if ($scope.parameters.confirmEmail.toLowerCase().trim() != $scope.parameters.Email.toLowerCase().trim())
                return "confirm E-mail does not match";
            return "success";
        };
        EmailURLController.prototype.generateLink = function ($scope) {
            var cmd = "ShowPatient";
            var user = this._authenticationService.user;
            // this is for testing purposes, if you want to get the url directly instad of sending it as an e-mail.
            //this._authenticationService.getPatientURL($scope.patientID.trim(), $scope.parameters.Email, "7047802994"/*$scope.PhoneNumber*/, $scope.parameters.miniToolbar, 0, $scope.requireAuthentication).then(function (result) {
            //    $scope.parameters.sharedLink = result.data;
            //});
        };
        EmailURLController.prototype.emailIsValid = function (email) {
            return /\S+@\S+\.\S+/.test(email);
        };
        EmailURLController.prototype.uploadFile = function (file) {
            var __this = this;
            this._templateService.ImportTemplates(this._Upload, file)
                .success(function (data, status, headers, config) {
                if (data.length == 1 && data[0].Id == 'GetImportTemplatesError_0F649AC6-0D07-49EA-906C-413256B8A43E') {
                    var errorString = "Import Failed: " + data[0].Name;
                    __this._dialogs.error(__this.errorTitle, errorString);
                }
                else {
                    __this._eventService.publish(EventNames.TemplatesImported, { templates: data });
                    __this._dialogs.notify(__this.notifyTitle, __this.successMessage);
                }
            })
                .error(function (data, status, headers, config, aaa, bbb, ccc, ddd) {
                __this._dialogs.error(__this.errorTitle, data);
            });
        };
        EmailURLController.$inject = ['$scope', '$modalInstance', 'Upload', 'templateService', 'eventService', '$translate', 'dialogs', 'patientInfo', 'authenticationService', 'optionsService', 'seriesManagerService'];
        return EmailURLController;
    }());
    Controllers.EmailURLController = EmailURLController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var HPDefinitionSequenceDialogControllerScope = /** @class */ (function () {
        function HPDefinitionSequenceDialogControllerScope($scope, $modalInstance, $translate, authenticationService, hpDefinition, dataset) {
            var modalities = hpDefinition.Modality.split('\\');
            var self = this;
            this._$scope = $scope;
            $scope.modalities = Utils.get_Modalities();
            angular.forEach($scope.modalities, function (item, key) {
                item.ticked = false;
            });
            angular.forEach(modalities, function (item, key) {
                self.selectModality(item);
            });
            $scope.selectedModalities = new Array();
            $scope.hpDefinition = hpDefinition;
            $scope.extractLaterality = this.extractLaterality.bind(this);
            $scope.extractModality = this.extractModality.bind(this);
            $scope.extractStudyDescription = this.extractStudyDescription.bind(this);
            $scope.extractBodyPartExamined = this.extractBodyPartExamined.bind(this);
            $scope.extractProtocolName = this.extractProtocolName.bind(this);
            $scope.deleteSequenceItem = this.deleteSequenceItem.bind(this);
            $scope.cancel = function () {
                $modalInstance.dismiss("cancel");
            };
            $scope.ok = function () {
                var modalities = new Array();
                angular.forEach($scope.modalities, function (item, key) {
                    if (item.ticked) {
                        modalities.push(item.name);
                    }
                });
                hpDefinition.Modality = modalities.join('\\');
                $modalInstance.close(hpDefinition);
            };
            this.init_grid($scope, 'PCSOptions', 'Procedure Code Sequence', DicomHelper.getCodeSequenceList(hpDefinition["metadata"], DicomTag.ProcedureCodeSequence, null), this.PCSSelectionChanged, 'ProcedureCodeSequence');
            this.init_grid($scope, 'RFROptions', 'Reason For Requested Procedure Code Sequence', DicomHelper.getCodeSequenceList(hpDefinition["metadata"], DicomTag.ReasonForRequestedProcedureCodeSequence, null), this.PCSSelectionChanged, 'ReasonForRequestedProcedureCodeSequence');
            this.init_grid($scope, 'ARSOptions', 'Anatomic Region Sequence', DicomHelper.getCodeSequenceList(hpDefinition["metadata"], DicomTag.AnatomicRegionSequence, null), this.ARSSelectionChanged, 'AnatomicRegionSequence');
            this._dataset = dataset;
        }
        HPDefinitionSequenceDialogControllerScope.prototype.get_ColumnDefs = function (headerName) {
            var columnDefs = [
                {
                    headerName: headerName,
                    children: [
                        {
                            headerName: "Code Scheme",
                            field: "CodeSchemeDesignator",
                            width: 95,
                            checkboxSelection: true,
                        },
                        {
                            headerName: "Code Value",
                            field: "CodeValue",
                            width: 95
                        },
                        {
                            headerName: "Code Meaning",
                            field: "CodeMeaning",
                            width: 95
                        },
                        {
                            headerName: "Coding Scheme Version",
                            field: "CodingSchemeVersion",
                            width: 125
                        }
                    ]
                }
            ];
            return columnDefs;
        };
        HPDefinitionSequenceDialogControllerScope.prototype.init_grid = function ($scope, optionName, headerName, data, callback, property) {
            $scope[optionName] = {
                groupHeaders: true,
                angularCompileHeaders: true,
                rowSelection: 'multiple',
                suppressRowClickSelection: true,
                enableColResize: true,
                columnDefs: this.get_ColumnDefs(headerName),
                rowData: data,
                onGridReady: function () {
                    $scope[optionName].api.hideOverlay();
                    $scope[optionName].api.sizeColumnsToFit();
                    this.doSelection($scope[optionName].api, property);
                }.bind(this),
                onSelectionChanged: callback.bind(this),
            };
        };
        HPDefinitionSequenceDialogControllerScope.prototype.doSelection = function (api, property) {
            var sequence = this._$scope.hpDefinition[property];
            if (sequence && sequence.length > 0) {
                api.forEachNode(function (node, index) {
                    var nodeItem = node.data;
                    var item = Utils.findFirst(sequence, function (item) {
                        return item.CodeMeaning == nodeItem.CodeMeaning && item.CodeValue == nodeItem.CodeValue && item.CodeSchemeDesignator == nodeItem.CodeSchemeDesignator;
                    });
                    if (item) {
                        api.selectNode(node);
                    }
                });
            }
        };
        HPDefinitionSequenceDialogControllerScope.prototype.ARSSelectionChanged = function (evt) {
            this._$scope.hpDefinition.AnatomicRegionSequence = evt.selectedRows;
        };
        HPDefinitionSequenceDialogControllerScope.prototype.RFRSelectionChanged = function (evt) {
            this._$scope.hpDefinition.ReasonForRequestedProcedureCodeSequence = evt.selectedRows;
        };
        HPDefinitionSequenceDialogControllerScope.prototype.PCSSelectionChanged = function (evt) {
            this._$scope.hpDefinition.ProcedureCodeSequence = evt.selectedRows;
        };
        HPDefinitionSequenceDialogControllerScope.prototype.extractLaterality = function () {
            var laterality = DicomHelper.getDicomTagValue(this._dataset, DicomTag.Laterality);
            if (!laterality || laterality.length == 0) {
                laterality = DicomHelper.getDicomTagValue(this._dataset, DicomTag.ImageLaterality);
            }
            if (laterality && laterality.length > 0) {
                switch (laterality.toUpperCase()) {
                    case "L":
                        this._$scope.hpDefinition.Laterality = Models.Laterality.Left;
                        break;
                    case "R":
                        this._$scope.hpDefinition.Laterality = Models.Laterality.Right;
                        break;
                    case "B":
                        this._$scope.hpDefinition.Laterality = Models.Laterality.Both;
                        break;
                    case "U":
                        this._$scope.hpDefinition.Laterality = Models.Laterality.Unpaired;
                        break;
                }
            }
        };
        HPDefinitionSequenceDialogControllerScope.prototype.extractModality = function () {
            var modality = DicomHelper.getDicomTagValue(this._dataset, DicomTag.Modality);
            if (modality && modality.length > 0) {
                this.selectModality(modality);
            }
        };
        HPDefinitionSequenceDialogControllerScope.prototype.selectModality = function (modality) {
            var item = Utils.findFirst(this._$scope.modalities, function (item) {
                return item.name == modality;
            });
            if (item) {
                item.ticked = true;
            }
        };
        HPDefinitionSequenceDialogControllerScope.prototype.extractStudyDescription = function () {
            this._$scope.hpDefinition.StudyDescription = DicomHelper.getDicomTagValue(this._dataset, DicomTag.StudyDescription);
        };
        HPDefinitionSequenceDialogControllerScope.prototype.deleteSequenceItem = function (options) {
            var nodes = options.api.getSelectedNodes();
            if (nodes.length > 0) {
                var index = options.rowData.indexOf(nodes[0].data);
                options.rowData.splice(index, 1);
                options.api.setRowData(options.rowData);
            }
        };
        HPDefinitionSequenceDialogControllerScope.prototype.extractBodyPartExamined = function () {
            this._$scope.hpDefinition.BodyPartExamined = DicomHelper.getDicomTagValue(this._dataset, DicomTag.BodyPartExamined);
        };
        HPDefinitionSequenceDialogControllerScope.prototype.extractProtocolName = function () {
            this._$scope.hpDefinition.ProtocolName = DicomHelper.getDicomTagValue(this._dataset, DicomTag.ProtocolName);
        };
        HPDefinitionSequenceDialogControllerScope.$inject = ["$scope", "$modalInstance", "$translate", 'authenticationService', 'hpDefinition', 'dataset'];
        return HPDefinitionSequenceDialogControllerScope;
    }());
    Controllers.HPDefinitionSequenceDialogControllerScope = HPDefinitionSequenceDialogControllerScope;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var Tag = /** @class */ (function () {
        function Tag(name, code) {
            this.name = name;
            this.code = code;
        }
        return Tag;
    }());
    Controllers.Tag = Tag;
    var HPDialogControllerScope = /** @class */ (function () {
        function HPDialogControllerScope($scope, $modalInstance, $translate, authenticationService, dataset, $modal, hp, objectStoreService, dialogs) {
            this._activeStepIndex = -1;
            // VRs that do not support multiValue: 
            //      LT : Long Text
            //      ST : Short Text
            //      UT : Unlimited Text
            //      UI : Unique Identifier
            this.multiValueVR = ["AT", "CS", "IS", "LO", "PN", "SH", "DS", "FD", "FL", "UL", "US", "SL", "SS"];
            var self = this;
            $scope.steps = new Array({
                templateUrl: 'views/dialogs/HangingProtocol-Step1.html',
                title: 'Definition'
            }, {
                templateUrl: 'views/dialogs/HangingProtocol-Step2.html',
                title: 'Selection Criteria'
            }, {
                templateUrl: 'views/dialogs/HangingProtocol-Step3.html',
                title: 'Image/Series Selection'
            }, {
                templateUrl: 'views/dialogs/HangingProtocol-Step4.html',
                title: 'Display Sets'
            });
            this._$modal = $modal;
            this._$scope = $scope;
            this._dataset = dataset;
            this._$translate = $translate;
            this._dialogs = dialogs;
            $scope.selectedDisplaySetChanged = this.selectedDisplaySetChanged.bind(this);
            $scope.selectedImageSetChanged = this.selectedImageSetChanged.bind(this);
            // $scope.selectedTimeBasedImageSetChanged = this.selectedTimeBasedImageSetChanged.bind(this);
            authenticationService.getRoles().
                success(function (result) {
                $scope.roles = result.GetRolesResult;
                if ($scope.roles != null && $scope.roles.length > 0) {
                    $scope.selectedRole = $scope.roles[0];
                    $scope.hp.HangingProtocolUserGroupName = $scope.selectedRole.Name;
                }
            }).
                error(function (error) {
            });
            $scope.hp = hp;
            $scope.objectStoreService = objectStoreService;
            this.init_HangingProtocolDefinitionGrid($scope);
            this.init_ImageSetSelectorGrid($scope);
            this.init_TimeBasedImageSetSelectorGrid($scope);
            this.init_FilterOperationsGrid($scope);
            $scope.selectedRoleChanged = this.selectedRoleChanged.bind(this);
            $scope.selectedLevelChanged = this.selectedLevelChanged.bind(this);
            $scope.editHPDefinition = this.editHPDefinition.bind(this);
            $scope.deleteHPDefinition = this.deleteHPDefinition.bind(this);
            $scope.isHPDefinitionSelected = this.isHPDefinitionSelected.bind(this);
            $scope.addImageSetSelector = this.addImageSetSelector.bind(this);
            $scope.editImageSetSelector = this.editImageSetSelector.bind(this);
            $scope.deleteImageSetSelector = this.deleteImageSetSelector.bind(this);
            $scope.isImageSetSelectorSelected = this.isImageSetSelectorSelected.bind(this);
            $scope.editTimeBasedImageSets = this.editTimeBasedImageSets.bind(this);
            $scope.isTimeBasedImageSetsSelected = this.isTimeBasedImageSetsSelected.bind(this);
            $scope.addFilterOperation = this.addFilterOperation.bind(this);
            $scope.editFilterOperation = this.editFilterOperation.bind(this);
            $scope.mergeFilterOperation = this.mergeFilterOperation.bind(this);
            $scope.cloneFilterOperation = this.cloneFilterOperation.bind(this);
            $scope.canMergeFilterOperation = this.canMergeFilterOperation.bind(this);
            $scope.deleteFilterOperation = this.deleteFilterOperation.bind(this);
            $scope.deleteSimilarFilterOperations = this.deleteSimilarFilterOperations.bind(this);
            $scope.isFilterOperationSelected = this.isFilterOperationSelected.bind(this);
            // ****
            $scope.isHangingProtocolNameValid = this.isHangingProtocolNameValid.bind(this);
            $scope.getHangingProtocolNameError = this.getHangingProtocolNameError.bind(this);
            $scope.isHangingProtocolDescriptionValid = this.isHangingProtocolDescriptionValid.bind(this);
            $scope.isLevelUserGroup = this.isLevelUserGroup.bind(this);
            $scope.getHangingProtocolDescriptionError = this.getHangingProtocolDescriptionError.bind(this);
            $scope.isFormValid = this.isFormValid.bind(this);
            // ****
            $scope.addMultipleTags = this.addMultipleTags.bind(this);
            $scope.addMulitipleImageSetTags = this.addMulitipleImageSetTags.bind(this);
            $scope.editImageSetLabel = this.editImageSetLabel.bind(this);
            $scope.editDisplaySetLabel = this.editDisplaySetLabel.bind(this);
            $scope.falseFunction = this.falseFunction.bind(this);
            $scope.trueFunction = this.trueFunction.bind(this);
            $scope.saveHangingProtocol = this.saveHangingProtocol.bind(this);
            $scope.getButtonStyle = this.getButtonStyle.bind(this);
            $scope.isAdmin = function () {
                return authenticationService.permissions.isAdmin;
            };
            // Fills the dropdown for HangingProtocolOptions (i.e. Manufacturer, Site, UserGroup, SingleUser)
            this.setHangingProtocolLevelOptions();
            $scope.modalities = Utils.get_Modalities();
            if (hp.DisplaySets.length > 0) {
                this.selectedDisplaySetChanged(hp.DisplaySets[0]);
            }
            if (hp.ImageSetsSequence.length > 0) {
                this.selectedImageSetChanged(hp.ImageSetsSequence[0]);
                //if (hp.ImageSetsSequence[0].TimeBasedImageSetsSequence.length > 0) {
                //    this.selectedTimeBasedImageSetChanged(hp.ImageSetsSequence[0].TimeBasedImageSetsSequence[0]);
                // }
            }
            $scope.onStepChange = function () {
                var cell = self._$scope.selectedDisplaySet['cell'];
                self._activeStepIndex = this.$getActiveIndex();
                if (self._activeStepIndex == 4) {
                    cell.viewer.layout.highlightedItems.add(cell);
                }
                else
                    cell.viewer.layout.highlightedItems.clear();
            };
            $scope.filterByImageSetNumber = function () {
                return function (displaySet) {
                    return displaySet.ImageSetNumber != -1;
                };
            };
        }
        HPDialogControllerScope.prototype.selectedLevelChanged = function () {
        };
        HPDialogControllerScope.prototype.selectedRoleChanged = function (selectedRole) {
            var myHp = this._$scope.hp;
            myHp.HangingProtocolUserGroupName = selectedRole.Name;
        };
        HPDialogControllerScope.prototype.editHPDefinition = function () {
            var modalInstance;
            var self = this;
            var originalDefinition;
            modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/HangingProtocolDefinitionSequence.html',
                controller: Controllers.HPDefinitionSequenceDialogControllerScope,
                backdrop: 'static',
                resolve: {
                    hpDefinition: function () {
                        var nodes = self._$scope.HPPDOptions.api.getSelectedNodes();
                        if (nodes.length > 0) {
                            originalDefinition = nodes[0].data;
                            return angular.copy(originalDefinition);
                        }
                        return null;
                    },
                    dataset: function () {
                        return self._dataset;
                    }
                }
            });
            modalInstance.result.then(function (hpDefinition) {
                var diff = Utils.diff(originalDefinition, hpDefinition);
                if (diff.changed != "equal") {
                    var index = self._$scope.HPPDOptions.rowData.indexOf(originalDefinition);
                    if (index != -1) {
                        self._$scope.HPPDOptions.rowData[index] = hpDefinition;
                        self._$scope.HPPDOptions.api.setRowData(self._$scope.HPPDOptions.rowData);
                        self._$scope.HPPDOptions.api.selectIndex(index);
                    }
                }
            });
        };
        HPDialogControllerScope.prototype.deleteHPDefinition = function () {
            var nodes = this._$scope.HPPDOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var index = this._$scope.HPPDOptions.rowData.indexOf(nodes[0].data);
                this._$scope.HPPDOptions.rowData.splice(index, 1);
                this._$scope.HPPDOptions.api.setRowData(this._$scope.HPPDOptions.rowData);
            }
        };
        HPDialogControllerScope.prototype.isHPDefinitionSelected = function () {
            return angular.isDefined(this._$scope.HPPDOptions.api) && this._$scope.HPPDOptions.api.getSelectedNodes().length > 0;
        };
        HPDialogControllerScope.prototype.addImageSetSelector = function () {
            var self = this;
            this._$translate('DIALOGS_IMAGESET_SELECTOR_ADD_TITLE').then(function (translation) {
                var modalInstance = this._$modal.open({
                    templateUrl: 'views/dialogs/HPImageSetSelectorEditor.html',
                    controller: Controllers.HPImageSetSelectorEditorController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            var selector = new Models.ImageSetSelector();
                            selector.SelectorValueNumber = 1;
                            selector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.NoMatch;
                            return selector;
                        },
                        title: function () {
                            return translation;
                        },
                        dicom: function () {
                            return self._$scope.selectedImageSet['metadata'];
                        },
                        currentTags: function () {
                            return self.get_currentSelectorTags();
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    if (!self._$scope.HPImageSetSelectorOptions.rowData) {
                        self._$scope.HPImageSetSelectorOptions.rowData = [];
                    }
                    self._$scope.HPImageSetSelectorOptions.rowData.push(item);
                    self._$scope.HPImageSetSelectorOptions.api.onNewRows();
                    self._$scope.HPImageSetSelectorOptions.api.selectIndex(self._$scope.HPImageSetSelectorOptions.rowData.indexOf(item));
                });
            }.bind(this));
        };
        HPDialogControllerScope.prototype.editImageSetSelector = function () {
            var self = this;
            var originalSelector;
            this._$translate('DIALOGS_IMAGESET_SELECTOR_EDIT_TITLE').then(function (translation) {
                var modalInstance = this._$modal.open({
                    templateUrl: 'views/dialogs/HPImageSetSelectorEditor.html',
                    controller: Controllers.HPImageSetSelectorEditorController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            var nodes = self._$scope.HPImageSetSelectorOptions.api.getSelectedNodes();
                            originalSelector = nodes[0].data;
                            return angular.copy(originalSelector);
                        },
                        title: function () {
                            return translation;
                        },
                        dicom: function () {
                            return self._$scope.selectedImageSet['metadata'];
                        },
                        currentTags: function () {
                            return self.get_currentSelectorTags();
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var diff = Utils.diff(originalSelector, item);
                    if (diff.changed != "equal") {
                        var index = self._$scope.HPImageSetSelectorOptions.rowData.indexOf(originalSelector);
                        if (index != -1) {
                            self._$scope.HPImageSetSelectorOptions.rowData[index] = item;
                            self._$scope.HPImageSetSelectorOptions.api.setRowData(self._$scope.HPImageSetSelectorOptions.rowData);
                            self._$scope.HPImageSetSelectorOptions.api.selectIndex(index);
                        }
                    }
                });
            }.bind(this));
        };
        HPDialogControllerScope.prototype.editTimeBasedImageSets = function () {
            var self = this;
            var originalTimeBasedImageSet;
            this._$translate('DIALOGS_TIME_BASED_IMAGE_SETS_EDIT_TITLE').then(function (translation) {
                var modalInstance = this._$modal.open({
                    templateUrl: 'views/dialogs/HPTimeBasedImageSetsEditor.html',
                    controller: Controllers.HPTimeBasedImageSetsEditorController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            var nodes = self._$scope.HPTimeBasedImageSetsOptions.api.getSelectedNodes();
                            originalTimeBasedImageSet = nodes[0].data;
                            return angular.copy(originalTimeBasedImageSet);
                        },
                        title: function () {
                            return translation;
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var diff = Utils.diff(originalTimeBasedImageSet, item);
                    if (diff.changed != "equal") {
                        var index = self._$scope.HPTimeBasedImageSetsOptions.rowData.indexOf(originalTimeBasedImageSet);
                        if (index != -1) {
                            self._$scope.HPTimeBasedImageSetsOptions.rowData[index] = item;
                            self._$scope.HPTimeBasedImageSetsOptions.api.setRowData(self._$scope.HPTimeBasedImageSetsOptions.rowData);
                            self._$scope.HPTimeBasedImageSetsOptions.api.selectIndex(index);
                        }
                    }
                });
            }.bind(this));
        };
        HPDialogControllerScope.prototype.deleteImageSetSelector = function () {
            var nodes = this._$scope.HPImageSetSelectorOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var index = this._$scope.HPImageSetSelectorOptions.rowData.indexOf(nodes[0].data);
                this._$scope.HPImageSetSelectorOptions.rowData.splice(index, 1);
                this._$scope.HPImageSetSelectorOptions.api.setRowData(this._$scope.HPImageSetSelectorOptions.rowData);
            }
        };
        HPDialogControllerScope.prototype.isImageSetSelectorSelected = function () {
            return angular.isDefined(this._$scope.HPImageSetSelectorOptions.api) && this._$scope.HPImageSetSelectorOptions.api.getSelectedNodes().length > 0;
        };
        HPDialogControllerScope.prototype.isTimeBasedImageSetsSelected = function () {
            return angular.isDefined(this._$scope.HPTimeBasedImageSetsOptions.api) && this._$scope.HPTimeBasedImageSetsOptions.api.getSelectedNodes().length > 0;
        };
        HPDialogControllerScope.prototype.addFilterOperation = function () {
            var self = this;
            this._$translate('DIALOGS_FILTER_OPERATION_ADD_TITLE').then(function (translation) {
                var modalInstance = this._$modal.open({
                    templateUrl: 'views/dialogs/DSFilterOperationEditor.html',
                    controller: Controllers.DSFilterOperationEditorController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            var operation = new Models.FilterOperation();
                            operation.SelectorValueNumber = 1;
                            operation.FilterByOperator = Models.FilterByOperator.MemberOf;
                            return operation;
                        },
                        title: function () {
                            return translation;
                        },
                        dicom: function () {
                            return self._$scope.selectedDisplaySet['metadata'];
                        },
                        currentTags: function () {
                            return self.get_currentFilterOperationTags();
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    if (!self._$scope.DSFilterOperationsOptions.rowData) {
                        self._$scope.DSFilterOperationsOptions.rowData = [];
                    }
                    self._$scope.DSFilterOperationsOptions.rowData.push(item);
                    self._$scope.DSFilterOperationsOptions.api.onNewRows();
                    self._$scope.DSFilterOperationsOptions.api.selectIndex(self._$scope.DSFilterOperationsOptions.rowData.indexOf(item));
                });
            }.bind(this));
        };
        HPDialogControllerScope.prototype.addMultipleTags = function () {
            var self = this;
            this.select_tags(function (tags) {
                if (!self._$scope.DSFilterOperationsOptions.rowData) {
                    self._$scope.DSFilterOperationsOptions.rowData = [];
                }
                for (var i = 0; i < tags.length; i++) {
                    var operation = new Models.FilterOperation();
                    var data = tags[i];
                    operation.SelectorName = data.name;
                    operation.WCFSelectorAttribute = data.tag;
                    operation.SelectorValueNumber = 1;
                    operation.FilterByOperator = Models.FilterByOperator.MemberOf;
                    operation.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.Match;
                    if (!data['isCodeSequence']) {
                        operation.SelectorValue = data.value;
                        operation.SelectorAttributeVr = data.vr;
                        operation.SelectorCodeSequenceValue = undefined;
                        operation.SelectorValueNumber = 1;
                        operation.FilterByOperator = Models.FilterByOperator.MemberOf;
                        if (data['selectorSequencePointer']) {
                            operation.WCFSelectorSequencePointer = data['selectorSequencePointer'];
                            operation['SequencePointerName'] = data['sequencePointerName'];
                            operation.WCFSelectorSequencePointerItems = data['selectorSequencePointerItems'];
                        }
                        else {
                            operation.WCFSelectorSequencePointer = '';
                            delete operation['SequencePointerName'];
                        }
                    }
                    else {
                        operation.WCFSelectorSequencePointer = data['selectorSequencePointer'];
                        operation.WCFSelectorSequencePointerItems = data['selectorSequencePointerItems'];
                        var tagList = data['selectorSequencePointer'];
                        var itemList = data['selectorSequencePointerItems'];
                        operation.SelectorCodeSequenceValue = DicomHelper.getCodeSequenceList(self._$scope.selectedDisplaySet['metadata'], tagList, itemList);
                        if (operation.SelectorCodeSequenceValue && operation.SelectorCodeSequenceValue.length > 0) {
                            operation.SelectorValue = operation.SelectorCodeSequenceValue[0].toFullString();
                        }
                        else {
                            operation.SelectorValue = '';
                        }
                    }
                    // Do not add the filter operation if the SelectorValue is empty
                    // This would allow the user to create an invalid HP
                    if (operation.SelectorValue != null && operation.SelectorValue.trim().length > 0) {
                        self._$scope.DSFilterOperationsOptions.rowData.push(operation);
                    }
                }
                self._$scope.DSFilterOperationsOptions.api.onNewRows();
            }, this.get_currentFilterOperationTags());
        };
        HPDialogControllerScope.prototype.addMulitipleImageSetTags = function () {
            var self = this;
            this.select_tags(function (tags) {
                if (!self._$scope.HPImageSetSelectorOptions.rowData) {
                    self._$scope.HPImageSetSelectorOptions.rowData = [];
                }
                for (var i = 0; i < tags.length; i++) {
                    var selector = new Models.ImageSetSelector();
                    var data = tags[i];
                    selector.SelectorName = data.name;
                    selector.WCFSelectorAttribute = data.tag;
                    if (!data['isCodeSequence']) {
                        selector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.Match;
                        selector.SelectorValue = data.value;
                        selector.SelectorValueNumber = 1;
                        selector.SelectorCodeSequenceValue = undefined;
                        if (data['selectorSequencePointer']) {
                            selector.WCFSelectorSequencePointer = data['selectorSequencePointer'];
                            selector['SequencePointerName'] = data['sequencePointerName'];
                        }
                        else {
                            selector.WCFSelectorSequencePointer = '';
                            delete selector['SequencePointerName'];
                        }
                    }
                    else {
                        selector.WCFSelectorSequencePointer = '';
                        selector.SelectorCodeSequenceValue = DicomHelper.getCodeSequenceList(self._$scope.selectedImageSet['metadata'], data.tag.replace(':', ''), null);
                        if (selector.SelectorCodeSequenceValue && selector.SelectorCodeSequenceValue.length > 0) {
                            selector.SelectorValue = selector.SelectorCodeSequenceValue[0].toFullString();
                        }
                        else {
                            selector.SelectorValue = '';
                        }
                    }
                    self._$scope.HPImageSetSelectorOptions.rowData.push(selector);
                }
                self._$scope.HPImageSetSelectorOptions.api.onNewRows();
            }, this.get_currentSelectorTags());
        };
        HPDialogControllerScope.prototype.get_currentFilterOperationTags = function () {
            var currentTags = new Array();
            this._$scope.DSFilterOperationsOptions.api.forEachNode(function (node, index) {
                var operation = node.data;
                currentTags.push(operation.WCFSelectorAttribute);
            });
            return currentTags;
        };
        HPDialogControllerScope.prototype.get_currentSelectorTags = function () {
            var currentTags = new Array();
            this._$scope.HPImageSetSelectorOptions.api.forEachNode(function (node, index) {
                var selector = node.data;
                currentTags.push(selector.WCFSelectorAttribute);
            });
            return currentTags;
        };
        HPDialogControllerScope.prototype.select_tags = function (callback, currentTags) {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/TagChooserDialog.html',
                controller: Controllers.TagChooserController,
                backdrop: 'static',
                resolve: {
                    dicom: function () {
                        return self._$scope.selectedDisplaySet['metadata'];
                    },
                    selector: function () {
                        return null;
                    },
                    currentTags: function () {
                        return currentTags;
                    }
                }
            });
            modalInstance.result.then(function (tags) {
                callback(tags);
            });
        };
        HPDialogControllerScope.prototype.editFilterOperation = function () {
            var self = this;
            var originalFilterOperation;
            this._$translate('DIALOGS_FILTER_OPERATION_EDIT_TITLE').then(function (translation) {
                var modalInstance = this._$modal.open({
                    templateUrl: 'views/dialogs/DSFilterOperationEditor.html',
                    controller: Controllers.DSFilterOperationEditorController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            var nodes = self._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
                            originalFilterOperation = nodes[0].data;
                            return angular.copy(originalFilterOperation);
                        },
                        title: function () {
                            return translation;
                        },
                        dicom: function () {
                            return self._$scope.selectedDisplaySet['metadata'];
                        },
                        currentTags: function () {
                            return self.get_currentSelectorTags();
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var diff = Utils.diff(originalFilterOperation, item);
                    if (diff.changed != "equal") {
                        var index = self._$scope.DSFilterOperationsOptions.rowData.indexOf(originalFilterOperation);
                        if (index != -1) {
                            self._$scope.DSFilterOperationsOptions.rowData[index] = item;
                            self._$scope.DSFilterOperationsOptions.api.setRowData(self._$scope.DSFilterOperationsOptions.rowData);
                            self._$scope.DSFilterOperationsOptions.api.selectIndex(index);
                        }
                    }
                });
            }.bind(this));
        };
        HPDialogControllerScope.prototype.deleteFilterOperation = function () {
            var nodes = this._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var index = this._$scope.DSFilterOperationsOptions.rowData.indexOf(nodes[0].data);
                this._$scope.DSFilterOperationsOptions.rowData.splice(index, 1);
                this._$scope.DSFilterOperationsOptions.api.setRowData(this._$scope.DSFilterOperationsOptions.rowData);
            }
        };
        HPDialogControllerScope.prototype.deleteSimilarFilterOperations = function () {
            var myHp = this._$scope.hp;
            var nodes = this._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var selectedFilterOperation = nodes[0].data;
                var index = this._$scope.DSFilterOperationsOptions.rowData.indexOf(selectedFilterOperation);
                myHp.deleteSimilarFilterOperations(selectedFilterOperation);
                this._$scope.DSFilterOperationsOptions.api.refreshView();
                if (index != -1) {
                    this._$scope.DSFilterOperationsOptions.api.setRowData(this._$scope.DSFilterOperationsOptions.rowData);
                }
            }
        };
        HPDialogControllerScope.prototype.cloneFilterOperation = function () {
            var myHp = this._$scope.hp;
            var nodes = this._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var selectedFilterOperation = nodes[0].data;
                myHp.cloneFilterOperation(selectedFilterOperation);
                myHp.sortFilterOperations();
            }
        };
        HPDialogControllerScope.prototype.mergeFilterOperation = function () {
            var myHp = this._$scope.hp;
            var nodes = this._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var selectedFilterOperation = nodes[0].data;
                var index = this._$scope.DSFilterOperationsOptions.rowData.indexOf(selectedFilterOperation);
                var selectorValue = selectedFilterOperation.SelectorValue;
                // go through all hp DisplaySets
                myHp.mergeFilterOperationValues(selectedFilterOperation);
            }
            if (index != -1) {
                this._$scope.DSFilterOperationsOptions.api.setRowData(this._$scope.DSFilterOperationsOptions.rowData);
            }
        };
        HPDialogControllerScope.prototype.canMergeFilterOperation = function () {
            var canMerge = false;
            var nodes = this._$scope.DSFilterOperationsOptions.api.getSelectedNodes();
            if (nodes.length > 0) {
                var selectedFilterOperation = nodes[0].data;
                if (selectedFilterOperation.SelectorAttributeVr != null) {
                    canMerge = (this.multiValueVR.indexOf(selectedFilterOperation.SelectorAttributeVr) != -1);
                }
                else {
                    canMerge = true;
                }
            }
            return canMerge;
        };
        HPDialogControllerScope.prototype.falseFunction = function () {
            return false;
        };
        HPDialogControllerScope.prototype.trueFunction = function () {
            return true;
        };
        HPDialogControllerScope.prototype.saveHangingProtocol = function () {
            var hpTemp = this._$scope.hp;
            var hpCloned = Utils.myclone(hpTemp, ['cell', 'metadata']);
            var dialogs = this._dialogs;
            // angular.copy(this._$scope.hp, hpCloned);
            // var hpCloned = Utils.myclone(this._$scope.hp, ['cell', 'metadata']);
            //angular.forEach(hpTemp.DisplaySets, function (displaySet: Models.DisplaySet, index) {
            //    delete displaySet['cell'];
            //    delete displaySet['metadata'];
            //});
            //angular.forEach(hpTemp.ImageSetsSequence, function (imageSet: Models.ImageSet, index) {
            //    delete imageSet['metadata'];
            //});
            // var hpCloned : Models.HangingProtocol = Utils.myclone(hpTemp, ['cell', 'metadata']);
            // var successMessage: string = "Hanging Protocol Saved: " + hpCloned.HangingProtocolName + " (" + hpCloned.HangingProtocolDescription + ")";
            var successMessage;
            var title;
            //this._$translate('DIALOGS_NOTIFICATION').then(function (translation) {
            //    title = translation;
            //});
            this._$translate('NOTIFY_SAVE_HP_SUCCESS').then(function (translation) {
                title = translation;
            });
            //this._$translate('NOTIFY_SAVE_HP_SUCCESS').then(function (translation) {
            //    successMessage = translation + "\n" + hpCloned.HangingProtocolName + " (" + hpCloned.HangingProtocolDescription + ")";
            //});
            successMessage = hpCloned.HangingProtocolName + " (" + hpCloned.HangingProtocolDescription + ")";
            this._$scope.objectStoreService.StoreHangingProtocol(hpCloned).success(function (response) {
                if (angular.isDefined(response.FaultType)) {
                    alert(response.Message);
                }
                else {
                    dialogs.notify(title, successMessage);
                }
            }).
                error(function (error) {
                alert(error);
            });
            ;
        };
        HPDialogControllerScope.prototype.getButtonStyle = function () {
            return "color: grey";
        };
        HPDialogControllerScope.prototype.isFilterOperationSelected = function () {
            var isSelected = angular.isDefined(this._$scope.DSFilterOperationsOptions.api) && this._$scope.DSFilterOperationsOptions.api.getSelectedNodes().length > 0;
            return isSelected;
        };
        // ****
        HPDialogControllerScope.prototype.isHangingProtocolNameValid = function () {
            var error = this.getHangingProtocolNameError();
            return Utils.isStringEmpty(error);
        };
        HPDialogControllerScope.prototype.getHangingProtocolNameError = function () {
            var errorMessage = "";
            var hangingProtocolName = this._$scope.hp.HangingProtocolName;
            if (Utils.isStringEmpty(hangingProtocolName)) {
                errorMessage = "Must have a value.";
            }
            if (hangingProtocolName.trim().length > 16) {
                errorMessage = "Must be 1 to 16 characters.";
            }
            return errorMessage;
        };
        HPDialogControllerScope.prototype.isHangingProtocolDescriptionValid = function () {
            var error = this.getHangingProtocolDescriptionError();
            return Utils.isStringEmpty(error);
        };
        HPDialogControllerScope.prototype.isLevelUserGroup = function () {
            var userGroupSelected = this._$scope.hp.HangingProtocolLevel == Models.HangingProtocolLevel.UserGroup;
            return userGroupSelected;
        };
        HPDialogControllerScope.prototype.getHangingProtocolDescriptionError = function () {
            var errorMessage = "";
            var hangingProtocolDescription = this._$scope.hp.HangingProtocolDescription;
            if (Utils.isStringEmpty(hangingProtocolDescription)) {
                errorMessage = "Must have a value.";
            }
            if (hangingProtocolDescription.trim().length > 64) {
                errorMessage = "Must be 1 to 64 characters.";
            }
            return errorMessage;
        };
        HPDialogControllerScope.prototype.isFormValid = function () {
            return this.isHangingProtocolNameValid() && this.isHangingProtocolDescriptionValid();
        };
        // ****
        HPDialogControllerScope.prototype.init_HangingProtocolDefinitionGrid = function ($scope) {
            $scope.HPPDOptions = {
                groupHeaders: true,
                angularCompileHeaders: true,
                rowSelection: 'single',
                enableColResize: true,
                columnDefs: [
                    {
                        headerName: "Modality",
                        field: "Modality",
                        width: 75
                    },
                    {
                        headerName: "Study Description",
                        field: "StudyDescription",
                        width: 150
                    },
                    {
                        headerName: "Anatomic Region Sequence",
                        field: "AnatomicRegionSequence",
                        cellRenderer: this.codeSequenceRenderer.bind(this),
                        width: 200
                    },
                    {
                        headerName: "Laterality",
                        field: "Laterality",
                        width: 100,
                        cellRenderer: this.lateralityRenderer.bind(this)
                    },
                    {
                        headerName: "Procedure Code Sequence",
                        field: "ProcedureCodeSequence",
                        cellRenderer: this.codeSequenceRenderer.bind(this),
                        width: 200
                    },
                    {
                        headerName: "Reason for Requested Procedure",
                        field: "ReasonForRequestedProcedureCodeSequence",
                        cellRenderer: this.codeSequenceRenderer.bind(this),
                        width: 200
                    },
                    {
                        headerName: "Body Part Examined",
                        field: "BodyPartExamined",
                        width: 200
                    },
                    {
                        headerName: "Protocol Name",
                        field: "ProtocolName",
                        width: 200
                    }
                ],
                rowData: $scope.hp.HangingProtocolDefinitionSequence,
                onGridReady: function () {
                    $scope.HPPDOptions.api.hideOverlay();
                    if ($scope.HPPDOptions.rowData && $scope.HPPDOptions.rowData.length > 0) {
                        $scope.HPPDOptions.api.selectIndex(0);
                    }
                },
            };
        };
        HPDialogControllerScope.prototype.init_TimeBasedImageSetSelectorGrid = function ($scope) {
            $scope.HPTimeBasedImageSetsOptions = {
                groupHeaders: true,
                angularCompileHeaders: true,
                rowSelection: 'single',
                enableColResize: true,
                suppressNoRowsOverlay: true,
                columnDefs: [
                    {
                        headerName: "Time Based Image Sets",
                        children: [
                            {
                                headerName: "#",
                                field: "ImageSetNumber",
                                width: 50 // (length * 95 / 11)
                            },
                            {
                                headerName: "Label",
                                field: "ImageSetLabel",
                                width: 100
                            },
                            {
                                headerTooltip: "Selector Category",
                                headerName: "Image Set Selector Category",
                                field: "ImageSetSelectorCategory",
                                width: 115,
                                cellRenderer: this.imageSetSelectorCategoryRenderer
                            },
                            {
                                headerName: "Relative Time",
                                field: "RelativeTime",
                                width: 110
                            },
                            {
                                headerName: "Relative Time Units",
                                field: "RelativeTimeUnits",
                                width: 165,
                                cellRenderer: this.relativeTimeUnitsRenderer
                            },
                            {
                                headerName: "Abstract Prior Value",
                                field: "AbstractPriorValue",
                                width: 175
                            },
                            {
                                headerName: "Study Date",
                                field: "StudyDateTime",
                                width: 175
                            },
                        ]
                    }
                ],
                rowData: [],
                onGridReady: function () {
                    $scope.HPTimeBasedImageSetsOptions.api.hideOverlay();
                },
            };
        };
        HPDialogControllerScope.prototype.init_ImageSetSelectorGrid = function ($scope) {
            $scope.HPImageSetSelectorOptions = {
                groupHeaders: true,
                angularCompileHeaders: true,
                rowSelection: 'single',
                enableColResize: true,
                suppressNoRowsOverlay: true,
                columnDefs: [
                    {
                        headerName: "Image Set Selector",
                        children: [
                            {
                                headerName: "Usage",
                                field: "ImageSetSelectorUsageFlag",
                                width: 75,
                                cellRenderer: this.selectorUsageRenderer
                            },
                            {
                                headerName: "Attribute",
                                field: "WCFSelectorAttribute",
                                width: 95
                            },
                            {
                                headerName: "Tag Name",
                                field: "SelectorName",
                                width: 95
                            },
                            {
                                headerName: "Value",
                                field: "SelectorValue",
                                width: 95
                            },
                            {
                                headerName: "Value Index",
                                field: "SelectorValueNumber",
                                width: 95
                            },
                            {
                                headerName: "Selector Sequence Pointer",
                                field: "WCFSelectorSequencePointer",
                                width: 215,
                            },
                            {
                                headerName: "Sequence Pointer Name",
                                field: "SequencePointerName",
                                width: 180,
                            }
                        ]
                    }
                ],
                rowData: [],
                onGridReady: function () {
                    $scope.HPImageSetSelectorOptions.api.hideOverlay();
                },
            };
        };
        HPDialogControllerScope.prototype.init_FilterOperationsGrid = function ($scope) {
            var self = this;
            $scope.DSFilterOperationsOptions = {
                groupHeaders: true,
                angularCompileHeaders: true,
                rowSelection: 'single',
                enableColResize: true,
                suppressNoRowsOverlay: true,
                columnDefs: [
                    {
                        headerName: "Filter Operations",
                        children: [
                            {
                                headerName: "Usage",
                                field: "ImageSetSelectorUsageFlag",
                                width: 75,
                                cellRenderer: this.selectorUsageRenderer
                            },
                            {
                                headerName: "Attribute",
                                field: "WCFSelectorAttribute",
                                width: 95
                            },
                            {
                                headerName: "Tag Name",
                                field: "SelectorName",
                                width: 95
                            },
                            {
                                headerName: "Value",
                                field: "SelectorValue",
                                width: 150
                            },
                            {
                                headerName: "Value Index",
                                field: "SelectorValueNumber",
                                width: 95
                            },
                            {
                                headerName: "Filter By Operator",
                                field: "FilterByOperator",
                                width: 125,
                                cellRenderer: this.filterByOperatorRenderer
                            },
                            // IMAGE_PLANE or empty
                            //{
                            //    headerName: "Filter By Category",
                            //    field: "FilterByCategory",
                            //    width: 125
                            //},
                            {
                                headerName: "Selector Sequence Pointer",
                                field: "WCFSelectorSequencePointer",
                                width: 180,
                            },
                            {
                                headerName: "Selector Sequence Pointer Items",
                                field: "WCFSelectorSequencePointerItems",
                                width: 180,
                            },
                            {
                                headerName: "Sequence Pointer Name",
                                field: "SequencePointerName",
                                width: 180,
                            }
                        ]
                    }
                ],
                rowData: [],
                onGridReady: function () {
                    $scope.DSFilterOperationsOptions.api.hideOverlay();
                    $scope.DSFilterOperationsOptions.api.setRowData($scope.selectedDisplaySet.FilterOperationsSequence);
                },
            };
        };
        HPDialogControllerScope.prototype.imageSetSelectorCategoryRenderer = function (evt) {
            switch (parseInt(evt.data.ImageSetSelectorCategory)) {
                case Models.ImageSetSelectorCategory.AbstractPrior:
                    return 'Abstract Prior';
                case Models.ImageSetSelectorCategory.RelativeTime:
                    return 'Relative Time';
            }
            return '';
        };
        HPDialogControllerScope.prototype.relativeTimeUnitsRenderer = function (evt) {
            switch (parseInt(evt.data.RelativeTimeUnits)) {
                case Models.RelativeTimeUnits.Days:
                    return 'Days';
                case Models.RelativeTimeUnits.Hours:
                    return 'Hours';
                case Models.RelativeTimeUnits.Minutes:
                    return 'Minutes';
                case Models.RelativeTimeUnits.Months:
                    return 'Months';
                case Models.RelativeTimeUnits.Seconds:
                    return 'Seconds';
                case Models.RelativeTimeUnits.Weeks:
                    return 'Weeks';
                case Models.RelativeTimeUnits.Years:
                    return 'Years';
            }
            return '';
        };
        HPDialogControllerScope.prototype.selectorUsageRenderer = function (evt) {
            switch (parseInt(evt.data.ImageSetSelectorUsageFlag)) {
                case Models.ImageSetSelectorUsage.Match:
                    return 'Match';
                case Models.ImageSetSelectorUsage.NoMatch:
                    return 'No Match';
            }
            return '';
        };
        HPDialogControllerScope.prototype.filterByOperatorRenderer = function (evt) {
            switch (parseInt(evt.data.FilterByOperator)) {
                case Models.FilterByOperator.GreaterOrEqual:
                    return 'Greater Or Equal';
                case Models.FilterByOperator.GreaterThan:
                    return 'Greater Than';
                case Models.FilterByOperator.LessOrEqual:
                    return 'Less Or Equal';
                case Models.FilterByOperator.LessThan:
                    return 'Less Than';
                case Models.FilterByOperator.MemberOf:
                    return 'Member Of';
                case Models.FilterByOperator.NotMemberOf:
                    return 'Not Member Of';
                case Models.FilterByOperator.RangeExclusive:
                    return 'Range Exclusive';
                case Models.FilterByOperator.RangeInclusive:
                    return 'Range Inclusive';
            }
            return '';
        };
        HPDialogControllerScope.prototype.lateralityRenderer = function (evt) {
            var hpDefinition = evt.data;
            if (!hpDefinition.Laterality)
                return "";
            switch (parseInt(hpDefinition.Laterality.toString())) {
                case Models.Laterality.Both:
                    return "Both";
                case Models.Laterality.Left:
                    return "Left";
                case Models.Laterality.Right:
                    return "Right";
                case Models.Laterality.Unpaired:
                    return "Unpaired";
            }
            return "";
        };
        HPDialogControllerScope.prototype.codeSequenceRenderer = function (evt) {
            var hpDefinition = evt.data;
            if (hpDefinition[evt.colDef.field] && hpDefinition[evt.colDef.field].length > 0) {
                return this.get_CodeSequenceString(hpDefinition[evt.colDef.field]);
            }
            return "";
        };
        HPDialogControllerScope.prototype.get_CodeSequenceString = function (sequence) {
            var sequenceString = "";
            for (var i = 0; i < sequence.length; i++) {
                var item = sequence[i];
                sequenceString += item.toFullString();
                if ((i + 1) < sequence.length) {
                    sequenceString += ", ";
                }
            }
            return sequenceString;
        };
        HPDialogControllerScope.prototype.selectedDisplaySetChanged = function (displaySet) {
            var cell = displaySet['cell'];
            if (cell && this._activeStepIndex == 4) {
                cell.viewer.layout.highlightedItems.clear();
                cell.viewer.layout.highlightedItems.add(cell);
            }
            if (angular.isDefined(this._$scope.DSFilterOperationsOptions.api)) {
                this._$scope.DSFilterOperationsOptions.api.setRowData(displaySet.FilterOperationsSequence);
            }
            this._$scope.selectedDisplaySet = displaySet;
        };
        HPDialogControllerScope.prototype.selectedImageSetChanged = function (imageSet) {
            if (imageSet) {
                if (this._$scope.HPImageSetSelectorOptions.api) {
                    this._$scope.HPImageSetSelectorOptions.api.setRowData(imageSet.ImageSetSelectorSequence);
                    this._$scope.HPTimeBasedImageSetsOptions.api.sizeColumnsToFit();
                    this._$scope.HPTimeBasedImageSetsOptions.api.setRowData(imageSet.TimeBasedImageSetsSequence);
                    this._$scope.HPTimeBasedImageSetsOptions.api.sizeColumnsToFit();
                }
                else {
                    this._$scope.HPImageSetSelectorOptions.rowData = imageSet.ImageSetSelectorSequence;
                    this._$scope.HPTimeBasedImageSetsOptions.rowData = imageSet.TimeBasedImageSetsSequence;
                }
            }
            this._$scope.selectedImageSet = imageSet;
        };
        HPDialogControllerScope.prototype.editImageSetLabel = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/Prompt.html',
                controller: Controllers.PromptController,
                backdrop: 'static',
                resolve: {
                    label: function () {
                        return "Image Set Label";
                    },
                    text: function () {
                        return self._$scope.selectedImageSet.Name;
                    }
                }
            });
            modalInstance.result.then(function (text) {
                if (text != self._$scope.selectedImageSet.Name) {
                    self._$scope.selectedImageSet.Name = text;
                }
            });
        };
        HPDialogControllerScope.prototype.editDisplaySetLabel = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/Prompt.html',
                controller: Controllers.PromptController,
                backdrop: 'static',
                resolve: {
                    label: function () {
                        return "Display Set Label";
                    },
                    text: function () {
                        return self._$scope.selectedDisplaySet.DisplaySetLabel;
                    }
                }
            });
            modalInstance.result.then(function (text) {
                var imageSet = Utils.findFirst(self._$scope.hp.ImageSetsSequence, function (item) {
                    var is = Utils.findFirst(item.TimeBasedImageSetsSequence, function (tsItem) {
                        return tsItem.ImageSetNumber == self._$scope.selectedDisplaySet.ImageSetNumber;
                    });
                    return is ? true : false;
                });
                if (text != self._$scope.selectedDisplaySet.DisplaySetLabel && text.length > 0) {
                    self._$scope.selectedDisplaySet.DisplaySetLabel = text;
                    self._$scope.selectedDisplaySet["CombinedName"] = text + " - " + imageSet.Name;
                }
            });
        };
        HPDialogControllerScope.prototype.setHangingProtocolLevelOptions = function () {
            this._$scope.hangingProtocolLevelOptions = [];
            if (this._$scope.isAdmin()) {
                this._$scope.hangingProtocolLevelOptions.push(new Models.DropDownItem(0, "Manufacturer"));
                this._$scope.hangingProtocolLevelOptions.push(new Models.DropDownItem(1, "Site"));
                this._$scope.hangingProtocolLevelOptions.push(new Models.DropDownItem(2, "User Group"));
            }
            this._$scope.hangingProtocolLevelOptions.push(new Models.DropDownItem(3, "Single User"));
            // Default for dropdown
            this._$scope.hp.HangingProtocolLevel = Models.HangingProtocolLevel.SingleUser;
        };
        HPDialogControllerScope.$inject = ["$scope", "$modalInstance", "$translate", 'authenticationService', 'dataset', '$modal', 'hp', 'objectStoreService', 'dialogs'];
        return HPDialogControllerScope;
    }());
    Controllers.HPDialogControllerScope = HPDialogControllerScope;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var GridSettingsController = /** @class */ (function () {
        function GridSettingsController($scope, $modalInstance, label, spacing, length, title) {
            $scope.title = title;
            $scope.label = label;
            $scope.input = {
                spacing: parseInt(spacing),
                length: parseInt(length)
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.ok = function () {
                $modalInstance.close({
                    spacing: $scope.input.spacing,
                    length: $scope.input.length
                });
            };
        }
        GridSettingsController.$inject = ['$scope', '$modalInstance', 'label', 'spacing', 'length', 'title'];
        return GridSettingsController;
    }());
    Controllers.GridSettingsController = GridSettingsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var DSFilterOperationEditorController = /** @class */ (function () {
        function DSFilterOperationEditorController($scope, $modal, $modalInstance, item, title, dicom, currentTags) {
            $scope.operation = item;
            $scope.title = title;
            $scope.filterByOperatorList = [
                { "value": 6, "text": "Member Of" },
                { "value": 7, "text": "Not Member Of" },
            ];
            this._$scope = $scope;
            this._$modal = $modal;
            this._dicom = dicom;
            this._currentTags = currentTags;
            $scope.chooseTag = this.chooseTag.bind(this);
            $scope.isSequence = this.isSequence.bind(this);
            $scope.isMprPlane = this.isMprPlane.bind(this);
            $scope.editCodeSequence = this.editCodeSequence.bind(this);
            $scope.isFormValid = function () {
                return this.isSelectorValueValid() && this.isSelectorIndexValid();
            };
            $scope.initializeFilterByOperatorList = this.initializeFilterByOperatorList.bind(this);
            $scope.ok = function () {
                $modalInstance.close($scope.operation);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isMprPlane = function () {
                var isMprPlane = $scope.operation.FilterByCategory == "IMAGE_PLANE";
                return isMprPlane;
            };
            $scope.isSelectorAttributeValid = function () {
                var errorMessage = this.getSelectorAttributeError();
                return errorMessage.length == 0;
            };
            $scope.getSelectorAttributeError = function () {
                var errorMessage = "";
                var selectorAttribute = $scope.operation.WCFSelectorAttribute.trim();
                if (selectorAttribute.length == 0) {
                    errorMessage = "Value must not be empty.";
                }
                return errorMessage;
            };
            $scope.isSelectorValueValid = function () {
                var errorMessage = this.getSelectorValueError();
                return errorMessage.length == 0;
            };
            $scope.getSelectorValueError = function () {
                // Split into an array and remove the empty values
                var selectorValues = $scope.operation.SelectorValue.split("\\", 5).filter(function (el) { return el.length != 0; });
                var separatorCount = $scope.operation.SelectorValue.split("\\", 5).length - 1;
                var selectorValueCount = selectorValues.length;
                var errorMessage = "";
                switch ($scope.operation.FilterByOperator) {
                    case Models.FilterByOperator.RangeInclusive:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 2);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 2);
                        }
                        if (errorMessage.length == 0) {
                            errorMessage = this.verifyInequality($scope.operation.SelectorValue, true);
                        }
                        break;
                    case Models.FilterByOperator.RangeExclusive:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 2);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 2);
                        }
                        if (errorMessage.length == 0) {
                            errorMessage = this.verifyInequality($scope.operation.SelectorValue, false);
                        }
                        break;
                    case Models.FilterByOperator.GreaterOrEqual:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 1);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 1);
                        }
                        break;
                    case Models.FilterByOperator.GreaterThan:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 1);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 1);
                        }
                        break;
                    case Models.FilterByOperator.LessOrEqual:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 1);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 1);
                        }
                        break;
                    case Models.FilterByOperator.LessThan:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 1);
                        if (errorMessage.length == 0) {
                            errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 1);
                        }
                        break;
                    case Models.FilterByOperator.MemberOf:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 0);
                        break;
                    case Models.FilterByOperator.NotMemberOf:
                        errorMessage = this.verifyCount($scope.operation.SelectorValue, 0);
                        break;
                }
                if (errorMessage.length == 0) {
                    // Test if VR is numeric
                    if (Utils.isNumericVr($scope.operation.SelectorAttributeVr))
                        errorMessage = Utils.verifyNumeric($scope.operation.SelectorValue, 0);
                }
                return errorMessage;
            };
            $scope.verifyCount = this.verifyCount.bind(this);
            $scope.verifyInequality = this.verifyInequality.bind(this);
            $scope.isSelectorIndexValid = this.isSelectorIndexValid.bind(this);
            $scope.getSelectorIndexError = this.getSelectorIndexError.bind(this);
            this.initializeFilterByOperatorList();
        }
        DSFilterOperationEditorController.prototype.verifyInequality = function (selectorValue, inclusive) {
            var errorMessage = "";
            var selectorValues = selectorValue.split("\\", 5).filter(function (el) { return el.length != 0; });
            if (selectorValues.length != 2) {
                errorMessage = "Must have exactly two values. (Example: 1\\3)";
            }
            var number0 = parseFloat(selectorValues[0]);
            if (isNaN(number0)) {
                errorMessage = "First value is not a number.";
                return errorMessage;
            }
            var number1 = parseFloat(selectorValues[1]);
            if (isNaN(number1)) {
                errorMessage = "Second value is not a number.";
                return errorMessage;
            }
            if (inclusive) {
                // inclusive
                if (number0 > number1) {
                    errorMessage = "First value must be less than or equal to Second value. (Example: 1\\3)";
                }
            }
            else {
                // exclusive
                if (number0 >= number1) {
                    errorMessage = "First value must be less than Second value. (Example: 1\\3)";
                }
            }
            return errorMessage;
        };
        DSFilterOperationEditorController.prototype.verifyCount = function (selectorValue, requiredCount) {
            return Utils.verifySelectorCount(selectorValue, requiredCount);
        };
        DSFilterOperationEditorController.prototype.initializeFilterByOperatorList = function () {
            if (this.isMprPlane() || !Utils.isNumericVr(this._$scope.operation.SelectorAttributeVr)) {
                // this._$scope.operation.ImagePlaneSelectorValue = "TRANSVERSE";
                this._$scope.filterByOperatorList = [
                    { "value": 6, "text": "Member Of" },
                    { "value": 7, "text": "Not Member Of" },
                ];
            }
            else {
                // this._$scope.operation.ImagePlaneSelectorValue = "";
                this._$scope.filterByOperatorList = [
                    { "value": 0, "text": "Range Inclusive" },
                    { "value": 1, "text": "Range Exclusive" },
                    { "value": 2, "text": "Greater Or Equal" },
                    { "value": 3, "text": "Less Or Equal" },
                    { "value": 4, "text": "Greater Than" },
                    { "value": 5, "text": "Less Than" },
                    { "value": 6, "text": "Member Of" },
                    { "value": 7, "text": "Not Member Of" },
                ];
            }
        };
        DSFilterOperationEditorController.prototype.chooseTag = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/TagChooserDialog.html',
                controller: Controllers.TagChooserController,
                backdrop: 'static',
                resolve: {
                    dicom: function () {
                        return self._dicom;
                    },
                    selector: function () {
                        return self._$scope.operation;
                    },
                    currentTags: function () {
                        return self._currentTags;
                    }
                }
            });
            modalInstance.result.then(function (tag) {
                var isSameTag = (tag.tag == self._$scope.operation.WCFSelectorAttribute);
                if (isSameTag) {
                    if (tag.hasOwnProperty('selectorSequencePointerItems')) {
                        isSameTag = (self._$scope.operation.WCFSelectorSequencePointerItems == tag['selectorSequencePointerItems']);
                    }
                }
                if (!isSameTag) {
                    self._$scope.operation.SelectorName = tag.name;
                    self._$scope.operation.WCFSelectorAttribute = tag.tag;
                    if (!tag['isCodeSequence']) {
                        self._$scope.operation.SelectorValue = tag.value;
                        self._$scope.operation.SelectorAttributeVr = tag.vr;
                        self._$scope.operation.SelectorCodeSequenceValue = undefined;
                        if (tag['selectorSequencePointer']) {
                            self._$scope.operation.WCFSelectorSequencePointer = tag['selectorSequencePointer'];
                            self._$scope.operation['SequencePointerName'] = tag['sequencePointerName'];
                            self._$scope.operation.WCFSelectorSequencePointerItems = tag['selectorSequencePointerItems'];
                        }
                        else {
                            self._$scope.operation.WCFSelectorSequencePointer = '';
                            delete self._$scope.operation['SequencePointerName'];
                        }
                    }
                    else {
                        self._$scope.operation.WCFSelectorSequencePointer = tag['selectorSequencePointer']; //'';
                        self._$scope.operation.WCFSelectorSequencePointerItems = tag['selectorSequencePointerItems'];
                        var tagList = tag['selectorSequencePointer'];
                        var itemList = tag['selectorSequencePointerItems'];
                        self._$scope.operation.SelectorCodeSequenceValue = DicomHelper.getCodeSequenceList(self._dicom, tagList, itemList);
                        if (self._$scope.operation.SelectorCodeSequenceValue && self._$scope.operation.SelectorCodeSequenceValue.length > 0) {
                            self._$scope.operation.SelectorValue = self._$scope.operation.SelectorCodeSequenceValue[0].toFullString();
                        }
                        else {
                            self._$scope.operation.SelectorValue = '';
                        }
                    }
                    self._$scope.initializeFilterByOperatorList();
                }
            });
        };
        DSFilterOperationEditorController.prototype.isSequence = function () {
            return this._$scope.operation.SelectorCodeSequenceValue && this._$scope.operation.SelectorCodeSequenceValue.length > 0;
        };
        DSFilterOperationEditorController.prototype.isMprPlane = function () {
            return (this._$scope.operation.FilterByCategory != null) && (this._$scope.operation.FilterByCategory == "IMAGE_PLANE");
        };
        DSFilterOperationEditorController.prototype.editCodeSequence = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/CodeSequenceEditor.html',
                controller: Controllers.CodeSequenceEditorController,
                backdrop: 'static',
                resolve: {
                    item: function () {
                        return angular.copy(self._$scope.operation.SelectorCodeSequenceValue[0]);
                    },
                    title: function () {
                        return "Edit Code Sequence";
                    }
                }
            });
            modalInstance.result.then(function (codeSequence) {
                var diff = Utils.diff(self._$scope.operation.SelectorCodeSequenceValue[0], codeSequence);
                if (diff.changed != "equal") {
                    self._$scope.operation.SelectorCodeSequenceValue = new Array();
                    self._$scope.operation.SelectorCodeSequenceValue.push(codeSequence);
                    self._$scope.operation.SelectorValue = self._$scope.operation.SelectorCodeSequenceValue[0].toFullString();
                }
            });
        };
        DSFilterOperationEditorController.prototype.isSelectorIndexValid = function () {
            if (!$.isNumeric(this._$scope.operation.SelectorValueNumber)) {
                return false;
            }
            if (this._$scope.operation.SelectorValueNumber < 0 || this._$scope.operation.SelectorValueNumber > 9)
                return false;
            return true;
        };
        DSFilterOperationEditorController.prototype.getSelectorIndexError = function () {
            var valid = $.isNumeric(this._$scope.operation.SelectorValueNumber) &&
                (this._$scope.operation.SelectorValueNumber >= 0 && this._$scope.operation.SelectorValueNumber <= 9);
            if (!valid)
                return "Must be 0 through 9.";
            return "";
        };
        DSFilterOperationEditorController.$inject = ['$scope', '$modal', '$modalInstance', 'item', 'title', 'dicom', 'currentTags'];
        return DSFilterOperationEditorController;
    }());
    Controllers.DSFilterOperationEditorController = DSFilterOperationEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var HPImageSetSelectorEditorController = /** @class */ (function () {
        function HPImageSetSelectorEditorController($scope, $modal, $modalInstance, item, title, dicom, currentTags) {
            $scope.selector = item;
            $scope.title = title;
            this._$scope = $scope;
            this._$modal = $modal;
            this._dicom = dicom;
            this._currentTags = currentTags;
            $scope.chooseTag = this.chooseTag.bind(this);
            $scope.isSequence = this.isSequence.bind(this);
            $scope.editCodeSequence = this.editCodeSequence.bind(this);
            $scope.isFormValid = function () {
                var valid = this.isSelectorIndexValid() && this.isSelectorValueValid();
                return valid;
            };
            $scope.ok = function () {
                $modalInstance.close($scope.selector);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isSelectorAttributeValid = function () {
                var errorMessage = this.getSelectorAttributeError();
                return errorMessage.length == 0;
            };
            $scope.getSelectorAttributeError = function () {
                var errorMessage = "";
                var selectorAttribute = $scope.selector.WCFSelectorAttribute.trim();
                if (selectorAttribute.length == 0) {
                    errorMessage = "Value must not be empty.";
                }
                return errorMessage;
            };
            $scope.isSelectorValueValid = function () {
                var errorMessage = this.getSelectorValueError();
                return errorMessage.length == 0;
            };
            $scope.getSelectorValueError = function () {
                // Split into an array and remove the empty values
                var selectorValues = $scope.selector.SelectorValue.split("\\", 5).filter(function (el) { return el.length != 0; });
                var separatorCount = $scope.selector.SelectorValue.split("\\", 5).length - 1;
                var selectorValueCount = selectorValues.length;
                var errorMessage = Utils.verifySelectorCount($scope.selector.SelectorValue, 0);
                if (errorMessage.length == 0) {
                    // Test if VR is numeric
                    if (Utils.isNumericVr($scope.selector.SelectorAttributeVr))
                        errorMessage = Utils.verifyNumeric($scope.selector.SelectorValue, 0);
                }
                return errorMessage;
            };
            $scope.isSelectorIndexValid = this.isSelectorIndexValid.bind(this);
            $scope.getSelectorIndexError = this.getSelectorIndexError.bind(this);
        }
        HPImageSetSelectorEditorController.prototype.isSelectorIndexValid = function () {
            if (!$.isNumeric(this._$scope.selector.SelectorValueNumber)) {
                return false;
            }
            if (this._$scope.selector.SelectorValueNumber < 0 || this._$scope.selector.SelectorValueNumber > 9)
                return false;
            return true;
        };
        HPImageSetSelectorEditorController.prototype.getSelectorIndexError = function () {
            if (!$.isNumeric(this._$scope.selector.SelectorValueNumber)) {
                return "Must be 0 through 9.";
            }
            return "";
        };
        HPImageSetSelectorEditorController.prototype.chooseTag = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/TagChooserDialog.html',
                controller: Controllers.TagChooserController,
                backdrop: 'static',
                resolve: {
                    dicom: function () {
                        return self._dicom;
                    },
                    selector: function () {
                        return self._$scope.selector;
                    },
                    currentTags: function () {
                        return self._currentTags;
                    }
                }
            });
            modalInstance.result.then(function (tag) {
                var isSameTag = (tag.tag == self._$scope.selector.WCFSelectorAttribute);
                // Commented out because Models.ImageSetSelector does not have a 'WCFSelectorSequencePointerItems' property
                //if (isSameTag) {
                //    if (tag.hasOwnProperty('selectorSequencePointerItems')) {
                //        isSameTag = (self._$scope.selector.WCFSelectorSequencePointerItems == tag['selectorSequencePointerItems']);
                //    }
                //}
                if (!isSameTag) {
                    if (!tag['isCodeSequence']) {
                        self._$scope.selector.WCFSelectorAttribute = tag.tag;
                        self._$scope.selector.SelectorValue = tag.value;
                        self._$scope.selector.SelectorName = tag.name;
                        self._$scope.selector.SelectorAttributeVr = tag.vr;
                        self._$scope.selector.SelectorCodeSequenceValue = undefined;
                        if (tag['selectorSequencePointer']) {
                            self._$scope.selector.WCFSelectorSequencePointer = tag['selectorSequencePointer'];
                            self._$scope.selector['SequencePointerName'] = tag['sequencePointerName'];
                        }
                        else {
                            self._$scope.selector.WCFSelectorSequencePointer = '';
                            delete self._$scope.selector['SequencePointerName'];
                        }
                    }
                    else {
                        self._$scope.selector.WCFSelectorSequencePointer = '';
                        self._$scope.selector.WCFSelectorAttribute = tag.tag;
                        self._$scope.selector.SelectorName = tag.name;
                        self._$scope.selector.SelectorCodeSequenceValue = DicomHelper.getCodeSequenceList(self._dicom, tag.tag.replace(':', ''), null);
                        if (self._$scope.selector.SelectorCodeSequenceValue && self._$scope.selector.SelectorCodeSequenceValue.length > 0) {
                            self._$scope.selector.SelectorValue = self._$scope.selector.SelectorCodeSequenceValue[0].toFullString();
                        }
                        else {
                            self._$scope.selector.SelectorValue = '';
                        }
                    }
                }
            });
        };
        HPImageSetSelectorEditorController.prototype.isSequence = function () {
            return this._$scope.selector.SelectorCodeSequenceValue && this._$scope.selector.SelectorCodeSequenceValue.length > 0;
        };
        HPImageSetSelectorEditorController.prototype.editCodeSequence = function () {
            var self = this;
            var modalInstance = this._$modal.open({
                templateUrl: 'views/dialogs/CodeSequenceEditor.html',
                controller: Controllers.CodeSequenceEditorController,
                backdrop: 'static',
                resolve: {
                    item: function () {
                        return angular.copy(self._$scope.selector.SelectorCodeSequenceValue[0]);
                    },
                    title: function () {
                        return "Edit Code Sequence";
                    }
                }
            });
            modalInstance.result.then(function (codeSequence) {
                var diff = Utils.diff(self._$scope.selector.SelectorCodeSequenceValue[0], codeSequence);
                if (diff.changed != "equal") {
                    self._$scope.selector.SelectorCodeSequenceValue = new Array();
                    self._$scope.selector.SelectorCodeSequenceValue.push(codeSequence);
                }
            });
        };
        HPImageSetSelectorEditorController.$inject = ['$scope', '$modal', '$modalInstance', 'item', 'title', 'dicom', 'currentTags'];
        return HPImageSetSelectorEditorController;
    }());
    Controllers.HPImageSetSelectorEditorController = HPImageSetSelectorEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var HPTimeBasedImageSetsEditorController = /** @class */ (function () {
        //private _oldRelativeTime: number[];   
        //private _oldAbstractPriorValue: number[];   
        function HPTimeBasedImageSetsEditorController($scope, $modal, $modalInstance, item, title) {
            $scope.timeBasedImageSet = item;
            $scope.title = title;
            //$scope.oldRelativeTime = oldRelativeTime;
            //$scope.oldAbstractPriorValue = oldAbstractPriorValue;         
            this._$scope = $scope;
            this._$modal = $modal;
            $scope.oldRelativeTime = [0, 0];
            $scope.oldAbstractPriorValue = [1, 1];
            $scope.oldRelativeTimeUnits = Models.RelativeTimeUnits.Days;
            $scope.getIsFormValidError = function () {
                var errorMessage = "";
                if ($scope.isRelativeTime()) {
                    var relativeTime = $scope.timeBasedImageSet.RelativeTime;
                    if (relativeTime.length != 2) {
                        return "";
                    }
                    if ($scope.timeBasedImageSet.RelativeTimeUnits == null || $scope.timeBasedImageSet.RelativeTimeUnits < 0 || $scope.timeBasedImageSet.RelativeTimeUnits > 6) {
                        return "Relative Time Units: Must not be empty";
                    }
                    if (!$.isNumeric(relativeTime[0])) {
                        return "Relative Time: Minimum must be a number from 0 to 9";
                    }
                    if (!$.isNumeric(relativeTime[1])) {
                        return "Relative Time: Maximum must be a number from 0 to 9";
                    }
                    if (relativeTime[0] > relativeTime[1]) {
                        return "Relative Time: Maximum must be greater than or equal to Minimum";
                    }
                }
                else {
                    var abstractPriorValue = $scope.timeBasedImageSet.AbstractPriorValue;
                    if (abstractPriorValue.length != 2) {
                        return "";
                    }
                    if (!$.isNumeric(abstractPriorValue[0])) {
                        return "Abstract Prior Value: Minimum must be -1 (oldest), or 1 to 9";
                    }
                    if (!$.isNumeric(abstractPriorValue[1])) {
                        return "Abstract Prior Value: Maximum must be -1 (oldest) or 1 to 9";
                    }
                    // 2nd value (-1) is always valid
                    if (abstractPriorValue[1] == -1) {
                        return "";
                    }
                    if (abstractPriorValue[0] == -1 && abstractPriorValue[1] != -1) {
                        return "Abstract Prior Value: if Minimum is -1 (oldest), then Maximum must be -1";
                    }
                    if (abstractPriorValue[0] > abstractPriorValue[1]) {
                        return "Abstract Prior Value: Maximum must be greater than or equal to Minimum";
                    }
                }
                return errorMessage;
            };
            $scope.isFormValid = function () {
                //return $scope.item.id != undefined && $scope.item.id.length != 0 &&
                //       $scope.item.action!=undefined && $scope.item.action.length !=0;
                var error = this.getIsFormValidError();
                return error.length == 0;
            };
            $scope.isRelativeTime = function () {
                var ret = ($scope.timeBasedImageSet.ImageSetSelectorCategory == Models.ImageSetSelectorCategory.RelativeTime);
                return ret;
            };
            $scope.dropDownChanged = function () {
                if ($scope.isRelativeTime()) {
                    $scope.oldAbstractPriorValue = $scope.timeBasedImageSet.AbstractPriorValue;
                    $scope.timeBasedImageSet.AbstractPriorValue = [];
                    $scope.timeBasedImageSet.RelativeTime = $scope.oldRelativeTime;
                    $scope.timeBasedImageSet.RelativeTimeUnits = $scope.oldRelativeTimeUnits;
                }
                else {
                    $scope.oldRelativeTime = $scope.timeBasedImageSet.RelativeTime;
                    $scope.oldRelativeTimeUnits = $scope.timeBasedImageSet.RelativeTimeUnits;
                    $scope.timeBasedImageSet.RelativeTime = [];
                    $scope.timeBasedImageSet.RelativeTimeUnits = -1;
                    $scope.timeBasedImageSet.AbstractPriorValue = $scope.oldAbstractPriorValue;
                }
            };
            $scope.ok = function () {
                $modalInstance.close($scope.timeBasedImageSet);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isMinimumRelativeValid = this.isMinimumRelativeValid.bind(this);
            $scope.isMaximumRelativeValid = this.isMaximumRelativeValid.bind(this);
            $scope.isMinimumAbstractValid = this.isMinimumAbstractValid.bind(this);
            $scope.isMaximumAbstractValid = this.isMaximumAbstractValid.bind(this);
            $scope.isRelativeValid = this.isRelativeValid.bind(this);
            $scope.isAbstractValid = this.isAbstractValid.bind(this);
            $scope.getRelativeError = this.getRelativeError.bind(this);
            $scope.getAbstractError = this.getAbstractError.bind(this);
        }
        HPTimeBasedImageSetsEditorController.prototype.isMinimumRelativeValid = function () {
            if (this._$scope.isRelativeTime()) {
                var relativeTime = this._$scope.timeBasedImageSet.RelativeTime;
                if (relativeTime.length != 2) {
                    return false;
                }
                if (this._$scope.timeBasedImageSet.RelativeTimeUnits == null || this._$scope.timeBasedImageSet.RelativeTimeUnits < 0 || this._$scope.timeBasedImageSet.RelativeTimeUnits > 6) {
                    return false;
                }
                if (!$.isNumeric(relativeTime[0])) {
                    return false;
                }
                //if (!$.isNumeric(relativeTime[1])) {
                //    return "Relative Time: Maximum must be a number from 0 to 9";
                //}
                if (relativeTime[0] > relativeTime[1]) {
                    return false;
                }
            }
            return true;
        };
        HPTimeBasedImageSetsEditorController.prototype.isMaximumRelativeValid = function () {
            if (this._$scope.isRelativeTime()) {
                var relativeTime = this._$scope.timeBasedImageSet.RelativeTime;
                if (!$.isNumeric(relativeTime[1])) {
                    return false;
                }
            }
            return true;
        };
        HPTimeBasedImageSetsEditorController.prototype.isRelativeValid = function () {
            return this.isMinimumRelativeValid() && this.isMaximumRelativeValid();
        };
        HPTimeBasedImageSetsEditorController.prototype.getRelativeError = function () {
            if (this._$scope.isRelativeTime()) {
                var relativeTime = this._$scope.timeBasedImageSet.RelativeTime;
                if (relativeTime.length != 2) {
                    return "";
                }
                if (this._$scope.timeBasedImageSet.RelativeTimeUnits == null || this._$scope.timeBasedImageSet.RelativeTimeUnits < 0 || this._$scope.timeBasedImageSet.RelativeTimeUnits > 6) {
                    return "Must not be empty";
                }
                if (!$.isNumeric(relativeTime[0])) {
                    return "Must be a number from 0 to 9";
                }
                if (!$.isNumeric(relativeTime[1])) {
                    return "Maximum must be a number from 0 to 9";
                }
                if (relativeTime[0] > relativeTime[1]) {
                    return "Minimum must be less than or equal to Maximum";
                }
            }
            return "";
        };
        HPTimeBasedImageSetsEditorController.prototype.isMinimumAbstractValid = function () {
            if (this._$scope.isRelativeTime() == false) {
                var abstractPriorValue = this._$scope.timeBasedImageSet.AbstractPriorValue;
                if (abstractPriorValue.length != 2) {
                    return true;
                }
                if (!$.isNumeric(abstractPriorValue[0])) {
                    return false;
                }
                //if (!$.isNumeric(abstractPriorValue[1])) {
                //    return false;
                //}
                // 2nd value (-1) is always valid
                if (abstractPriorValue[1] == -1) {
                    return true;
                }
                if (abstractPriorValue[0] == -1 && abstractPriorValue[1] != -1) {
                    return false;
                }
                if (abstractPriorValue[0] > abstractPriorValue[1]) {
                    return false;
                }
            }
            return true;
        };
        HPTimeBasedImageSetsEditorController.prototype.isMaximumAbstractValid = function () {
            if (this._$scope.isRelativeTime() == false) {
                var abstractPriorValue = this._$scope.timeBasedImageSet.AbstractPriorValue;
                if (!$.isNumeric(abstractPriorValue[1])) {
                    return false;
                }
                if (abstractPriorValue[0] == -1 && abstractPriorValue[1] != -1) {
                    return false;
                }
            }
            return true;
        };
        HPTimeBasedImageSetsEditorController.prototype.isAbstractValid = function () {
            return this.isMinimumAbstractValid() && this.isMaximumAbstractValid();
        };
        HPTimeBasedImageSetsEditorController.prototype.getAbstractError = function () {
            if (this._$scope.isRelativeTime() == false) {
                var abstractPriorValue = this._$scope.timeBasedImageSet.AbstractPriorValue;
                if (abstractPriorValue.length != 2) {
                    return "";
                }
                if (!$.isNumeric(abstractPriorValue[0])) {
                    return "Minimum must be -1 (oldest), or 1 to 9";
                }
                if (!$.isNumeric(abstractPriorValue[1])) {
                    return "Maximum must be -1 (oldest) or 1 to 9";
                }
                // 2nd value (-1) is always valid
                if (abstractPriorValue[1] == -1) {
                    return "";
                }
                if (abstractPriorValue[0] == -1 && abstractPriorValue[1] != -1) {
                    return "If Minimum is -1 (oldest), then Maximum must be -1";
                }
                if (abstractPriorValue[0] > abstractPriorValue[1]) {
                    return "Minimum must be less than or equal to Maximum";
                }
            }
            return "";
        };
        HPTimeBasedImageSetsEditorController.$inject = ['$scope', '$modal', '$modalInstance', 'item', 'title'];
        return HPTimeBasedImageSetsEditorController;
    }());
    Controllers.HPTimeBasedImageSetsEditorController = HPTimeBasedImageSetsEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var RemoteWadoController = /** @class */ (function () {
        function RemoteWadoController($scope, $modalInstance, optionsService, $modal, authenticationService, dialogs, $translate, $timeout) {
            var __this = this;
            var saved = false;
            this._modal = $modal;
            $scope.selectedServer = null;
            $scope.wadoConfig = Models.RemoteConfig.Factory(optionsService.get(OptionNames.RemoteConfig));
            $scope.wadoConnections = new Array();
            __this.filter($scope.wadoConfig.servers, $scope.wadoConnections);
            $scope.gridOptions = {
                enableSorting: true,
                enableRowSelection: true,
                enableRowHeaderSelection: lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet,
                noUnselect: false,
                multiSelect: false,
                onRegisterApi: function (gridApi) {
                    gridApi.selection.on.rowSelectionChanged($scope, function (selectedRow) {
                        $scope.selectedServer = selectedRow.entity;
                    });
                },
                columnDefs: [
                    { name: "Friendly Name", field: "title", enableHiding: false, displayName: "Friendly Name" },
                    { name: "DicomWeb Address", field: "dicomWebRoot", enableHiding: false, displayName: "DicomWeb Address" },
                    { name: "Uri Address", field: "UriAddress", enableHiding: false, displayName: "Uri Address" },
                    { name: "Default", field: "isDefault", enableHiding: false },
                ],
                data: $scope.wadoConnections
            };
            $scope.addWadoServer = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddWadoServer.html',
                    controller: Controllers.AddWadoServerController,
                    backdrop: 'static',
                    resolve: {
                        server: function () {
                            return undefined;
                        }
                    }
                });
                modalInstance.result.then(function (server) {
                    for (var i = 0; i < $scope.wadoConfig.servers.length; i++) {
                        if (server.isDefault) {
                            $scope.wadoConfig.servers[i].isDefault = false;
                        }
                    }
                    $scope.wadoConfig.servers.push(server);
                    __this.filter($scope.wadoConfig.servers, $scope.wadoConnections); //update filtered for view connections                                     
                });
            };
            $scope.deleteWadoServer = function () {
                var result = $.grep($scope.wadoConfig.servers, function (item, index) {
                    return item.id == $scope.selectedServer.id;
                });
                if (result.length > 0) {
                    var index = $scope.wadoConfig.servers.indexOf(result[0]);
                    $scope.wadoConfig.servers.splice(index, 1);
                    $scope.selectedServer = null;
                    __this.filter($scope.wadoConfig.servers, $scope.wadoConnections); //update filtered for view connections                                                      
                }
            };
            $scope.editWadoServer = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddWadoServer.html',
                    controller: Controllers.AddWadoServerController,
                    backdrop: 'static',
                    resolve: {
                        server: function () {
                            return $scope.selectedServer;
                        }
                    }
                });
                modalInstance.result.then(function (server) {
                    var result = $.grep($scope.wadoConfig.servers, function (item, index) {
                        return item.id == server.id;
                    });
                    if (result.length > 0) {
                        var index = $scope.wadoConfig.servers.indexOf(result[0]);
                        for (var i = 0; i < $scope.wadoConfig.servers.length; i++) {
                            if (i != index && server.isDefault) {
                                $scope.wadoConfig.servers[i].isDefault = false;
                            }
                        }
                        $scope.wadoConfig.servers[index] = server;
                        __this.filter($scope.wadoConfig.servers, $scope.wadoConnections); //update filtered for view connections                                     
                    }
                });
            };
            $scope.save = function () {
                var data = {};
                var json = JSON.stringify($scope.wadoConfig);
                data[OptionNames.RemoteConfig] = json;
                optionsService.saveDefaultOptions(data).success(function () {
                    optionsService.set(OptionNames.RemoteConfig, json);
                    dialogs.notify(__this._notificationTitle, __this._saveSuccessMsg);
                    saved = true;
                }).error(function (e) {
                    dialogs.error(__this._saveFailureMsg + ": " + status);
                });
            };
            $scope.close = function () {
                $modalInstance.close(saved);
            };
            $translate('NOTIFY_WADOCONFIG_SAVE_SUCCESS').then(function (translation) {
                __this._saveSuccessMsg = translation;
            });
            $translate('NOTIFY_WADOCONFIG_SAVE_FAILURE').then(function (translation) {
                __this._saveFailureMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
        }
        RemoteWadoController.prototype.wadoConnections = function (config) {
            var result = new Models.RemoteConfig();
            result.client = config.client;
            for (var index = 0; index < config.servers.length; index++) {
                if (config.servers[index].type == 'wado') {
                    result.servers.push(config.servers[index]);
                }
            }
            return result;
        };
        RemoteWadoController.prototype.filter = function (connections, filtered) {
            if (filtered.length > 0)
                filtered.splice(0, filtered.length);
            for (var index = 0; index < connections.length; index++) {
                if (connections[index].type == 'wado') {
                    filtered.push(connections[index]);
                }
            }
        };
        RemoteWadoController.$inject = ['$scope', '$modalInstance', 'optionsService', '$modal', 'authenticationService', 'dialogs', '$translate', '$timeout'];
        return RemoteWadoController;
    }());
    Controllers.RemoteWadoController = RemoteWadoController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var LineError = /** @class */ (function () {
        function LineError(line, column, message) {
            this.line = line;
            this.column = column;
            this.message = message;
        }
        return LineError;
    }());
    var ScriptEditorController = /** @class */ (function () {
        function ScriptEditorController($scope, $modalInstance, label, text, readOnly) {
            this._interval = undefined;
            this._errorLines = new Array();
            this._firstChange = true;
            var self = this;
            $scope.label = label;
            $scope.data = {};
            $scope.data.text = text;
            $scope.readOnly = readOnly;
            $scope.editorOptions = {
                lineWrapping: false,
                mode: 'javascript',
                autofocus: true,
                lineNumbers: true,
                extraKeys: { "Ctrl-Q": function (cm) { cm.foldCode(cm.getCursor()); } },
                foldGutter: {
                    rangeFinder: new CodeMirror.fold.combine(CodeMirror.fold.brace, CodeMirror.fold.comment)
                },
                gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
                readOnly: readOnly
            };
            $scope.gridOptions = {
                rowSelection: 'single',
                suppressNoRowsOverlay: true,
                groupHeaders: true,
                columnDefs: [
                    {
                        headerName: "Errors",
                        children: [
                            {
                                headerName: "",
                                cellRenderer: Utils.countRenderer,
                                width: 29,
                                suppressSizeToFit: true,
                            },
                            {
                                headerName: "Line",
                                field: "line"
                            },
                            {
                                headerName: "Column",
                                field: "column",
                            },
                            {
                                headerName: "Description",
                                field: "message"
                            },
                        ]
                    }
                ],
                onRowSelected: function (data) {
                    this.jumpToLine(data.node.data.line - 1, data.node.data.column - 1);
                }.bind(this),
                rowData: null,
                onGridReady: function () {
                    self._gridApi = $scope.gridOptions.api;
                    self._gridApi.hideOverlay();
                    self._gridApi.sizeColumnsToFit();
                }
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.ok = function () {
                $modalInstance.close($scope.data.text);
            };
            $scope.hasErrors = function () {
                if (angular.isArray($scope.gridOptions.rowData)) {
                    return $scope.gridOptions.rowData.length > 0;
                }
                return $scope.gridOptions.rowData != null;
            };
            $scope.codemirrorLoaded = this.codeMirrorLoaded.bind(this);
        }
        ScriptEditorController.prototype.codeMirrorLoaded = function (editor) {
            this._editor = editor;
            this._editor.refresh();
            this._editor.focus();
            this._editor.getDoc().setCursor({ line: this._editor.getDoc().lineCount(), ch: 0 });
            this._editor.on('change', this.onChange.bind(this));
        };
        ScriptEditorController.prototype.onChange = function (instance, changeObj) {
            if (this._firstChange) {
                this._firstChange = false;
                instance.getDoc().markClean();
                instance.getDoc().clearHistory();
            }
            if (this._interval)
                clearTimeout(this._interval);
            this._interval = setTimeout(this.update.bind(this), 500);
        };
        ScriptEditorController.prototype.update = function () {
            var text = this._editor.getDoc().getValue();
            while (this._errorLines.length > 0) {
                this._editor.removeLineClass(this._errorLines.shift().line - 1, 'background', 'errorLine');
            }
            this._gridApi.setRowData(null);
            try {
                var result = esprima.parse(text, { tolerant: true, loc: true });
                for (var i = 0; i < result.length; i++) {
                    var error = result[i];
                    var lineNumber = error.lineNumber;
                    this._errorLines.push(new LineError(lineNumber, result.column, error.message));
                    this._editor.addLineClass(lineNumber - 1, 'background', 'errorLine');
                }
            }
            catch (error) {
                var lineNumber = error.lineNumber;
                this._errorLines.push(new LineError(lineNumber, error.column, error.message));
                this._editor.addLineClass(lineNumber - 1, 'background', 'errorLine');
            }
            this._gridApi.setRowData(this._errorLines);
        };
        ScriptEditorController.prototype.jumpToLine = function (line, column) {
            var t = this._editor.charCoords({ line: line, ch: column }, "local").top;
            var middleHeight = this._editor.getScrollerElement().offsetHeight / 2;
            this._editor.scrollTo(null, t - middleHeight - 5);
            this._editor.getDoc().setCursor({ line: line, ch: column });
            this._editor.focus();
        };
        ScriptEditorController.$inject = ['$scope', '$modalInstance', 'label', 'text', 'readOnly'];
        return ScriptEditorController;
    }());
    Controllers.ScriptEditorController = ScriptEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var PromptController = /** @class */ (function () {
        function PromptController($scope, $modalInstance, label, text) {
            $scope.label = label;
            $scope.data = {};
            $scope.data.text = text;
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.ok = function () {
                $modalInstance.close($scope.data.text);
            };
        }
        PromptController.$inject = ['$scope', '$modalInstance', 'label', 'text'];
        return PromptController;
    }());
    Controllers.PromptController = PromptController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var HSLController = /** @class */ (function () {
        function HSLController($scope, $modalInstance, optionsService, eventService, seriesManagerService) {
            $scope.ipVals = {
                hue: 0,
                saturation: 0,
                lightness: 0
            };
            function stop(event, ui) {
                var args = new Array();
                args["hue"] = $scope.ipVals.hue * 100;
                args["saturation"] = $scope.ipVals.saturation * 10;
                args["intensity"] = $scope.ipVals.lightness * 10;
                $scope.ipApi.applyIPCommand("ChangeHueSaturationIntensity", args);
            }
            function change(event, ui) {
                var args = new Array();
                args["hue"] = $scope.ipVals.hue * 100;
                args["saturation"] = $scope.ipVals.saturation * 10;
                args["intensity"] = $scope.ipVals.lightness * 10;
                $scope.ipApi.applyIPCommand("ChangeHueSaturationIntensity", args);
            }
            $scope.slider = {
                'options': {
                    stop: stop
                },
                'hueOptions': {
                    stop: stop,
                    min: -180,
                    max: 180
                }
            };
            $scope.frame = seriesManagerService.get_activeCellFrame();
            $scope.ipApi = {};
            $scope.ok = function () {
                $modalInstance.close($scope.ipVals);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.change = function () {
                change(null, null);
            };
        }
        HSLController.$inject = ['$scope', '$modalInstance', 'optionsService', 'eventService', 'seriesManagerService'];
        return HSLController;
    }());
    Controllers.HSLController = HSLController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var PrintController = /** @class */ (function () {
        function PrintController($scope, optionsService, $modalInstance) {
            $scope.exportOptions = new Models.ExportOptions();
            $scope.source = {};
            $scope.source.value = "SelectedImages";
            $scope.ok = function () {
                $scope.exportOptions.LayoutImageWidth = 0;
                $modalInstance.close({ options: $scope.exportOptions, source: $scope.source.value });
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        PrintController.$inject = ['$scope', 'optionsService', '$modalInstance'];
        return PrintController;
    }());
    Controllers.PrintController = PrintController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var RolePatientsAccessController = /** @class */ (function () {
        function RolePatientsAccessController($rootScope, $scope, patientAccessRightsService, optionsService, queryArchiveService, authenticationService, roles, $modalInstance, dialogs, $translate, uiGridConstants) {
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var timeFormat = optionsService.get(OptionNames.TimeFormat);
            var __this = this;
            $scope.gridapi = null;
            $scope.roles = roles;
            $scope.role = { name: null };
            this.scope = $scope;
            this.patientAccessRightsService = patientAccessRightsService;
            this._dialogs = dialogs;
            $scope.gridOptions = {
                enableSorting: true,
                enableRowSelection: true,
                showFooter: true,
                modifierKeysToMultiSelect: false,
                paginationPageSizes: [25, 50, 75],
                paginationPageSize: 25,
                enableFiltering: true,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                onRegisterApi: function (gridApi) {
                    $scope.gridapi = gridApi;
                    gridApi.pagination.on.paginationChanged($scope, __this.paginationChanged.bind(__this));
                    gridApi.selection.on.rowSelectionChanged($scope, __this.rowSelectionChange.bind(__this));
                    gridApi.selection.on.rowSelectionChangedBatch($scope, __this.rowSelectionChangedBatch.bind(__this));
                    __this.makeReadOnly(true);
                },
                columnDefs: [
                    { name: "Id", field: "ID", enableHiding: false },
                    { name: "Name", field: "Name", enableHiding: false },
                    { name: "Sex", field: "Sex", enableHiding: false, enableFiltering: false },
                    { name: "Birth Date", field: "BirthDate", enableHiding: false, enableFiltering: false },
                ],
                data: 'patients'
            };
            queryArchiveService.FindPatients(null).success(function (patients) {
                $scope.patients = patients;
            });
            $scope.close = function () {
                $modalInstance.close();
            };
            $scope.roleChanged = this.roleChanged.bind(this);
            $scope.applyPermissions = this.applyPermissions.bind(this);
            $translate('NOTIFY_PERMISSIONS_SAVED').then(function (translation) {
                this._saveSuccessMsg = translation;
            }.bind(this));
            $translate('NOTIFY_PERMISSIONS_FAILED').then(function (translation) {
                this._saveFailureMsg = translation;
            }.bind(this));
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this._notificationTitle = translation;
            }.bind(this));
        }
        RolePatientsAccessController.prototype.roleChanged = function (role) {
            this.scope.gridapi.selection.clearSelectedRows();
            if (role != null) {
                this.makeReadOnly(false);
                this.patientAccessRightsService.GetRoleAccess(role).then(function (result) {
                    this.grantedPermissions = [];
                    for (var i = 0; i < result.data.length; i++) {
                        this.grantedPermissions.push(result.data[i].PatientId);
                    }
                    this.updatePermissions();
                }.bind(this), function (e) {
                });
            }
            else {
                this.makeReadOnly(true);
            }
        };
        RolePatientsAccessController.prototype.applyPermissions = function () {
            this.patientAccessRightsService.GrantRolePatients(this.scope.role.name, this.grantedPermissions).then(function (data) {
                this._dialogs.notify(this._notificationTitle, this._saveSuccessMsg);
            }.bind(this), function (error) {
                this._dialogs.error(this._saveFailureMsg + ": " + error);
            }.bind(this));
        };
        RolePatientsAccessController.prototype.updatePermissions = function () {
            var rows = this.scope.gridapi.grid.rows;
            angular.forEach(rows, function (value, key) {
                var entity = value.entity;
                var permissions = $.grep(this.grantedPermissions, function (e, index) {
                    return e == entity.ID;
                });
                if (permissions.length > 0) {
                    this.scope.gridapi.selection.selectRow(entity);
                }
            }, this);
        };
        RolePatientsAccessController.prototype.paginationChanged = function (currentPage, pageSize) {
            this.updatePermissions();
        };
        RolePatientsAccessController.prototype.rowSelectionChange = function (row, event) {
            if (!angular.isDefined(event)) {
                //
                // event happen through programmatic access
                //
                return;
            }
            if (row.isSelected)
                this.addPermission(this.scope.role.name, row.entity.ID);
            else
                this.removePermission(this.scope.role.name, row.entity.ID);
        };
        RolePatientsAccessController.prototype.rowSelectionChangedBatch = function (rows, event) {
            var length = rows.length;
            for (var i = 0; i < length; i++) {
                if (rows[i].isSelected)
                    this.addPermission(this.scope.role.name, rows[i].entity.ID);
                else
                    this.removePermission(this.scope.role.name, rows[i].entity.ID);
            }
        };
        RolePatientsAccessController.prototype.addPermission = function (role, patientId) {
            var permissions = $.grep(this.grantedPermissions, function (e, index) {
                return e == patientId;
            });
            if (permissions.length == 0) {
                this.grantedPermissions.push(patientId);
            }
        };
        RolePatientsAccessController.prototype.removePermission = function (role, patientId) {
            var permissions = $.grep(this.grantedPermissions, function (e, index) {
                return e == patientId;
            });
            if (permissions.length == 1) {
                var index = this.grantedPermissions.indexOf(permissions[0]);
                this.grantedPermissions.splice(index, 1);
            }
        };
        RolePatientsAccessController.prototype.makeReadOnly = function (readonly) {
            var rows = this.scope.gridapi.core.getVisibleRows(this.scope.gridapi.grid);
            if (rows.length == 0) {
                setTimeout(function () {
                    this.makeReadOnly(readonly);
                }.bind(this), 250);
            }
            else {
                angular.forEach(rows, function (row, key) {
                    row.isSelected = false;
                    row.enableSelection = !readonly;
                }, this);
            }
        };
        RolePatientsAccessController.$inject = ['$rootScope', '$scope', 'patientAccessRightsService', 'optionsService', 'queryArchiveService', 'authenticationService', 'roles', '$modalInstance', 'dialogs', '$translate', 'uiGridConstants'];
        return RolePatientsAccessController;
    }());
    Controllers.RolePatientsAccessController = RolePatientsAccessController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UISettingsController = /** @class */ (function () {
        function UISettingsController($scope, $modalInstance) {
            $scope.edit = {};
            $scope.isEnabled = function () {
                var currentTheme = window.localStorage.getItem("leadmedicalwebviewertheme");
                var element;
                element = document.getElementById("darkThemeCheckBox");
                switch (currentTheme) {
                    case "dark":
                        element.checked = true;
                        break;
                    case "light":
                        element.checked = false;
                        break;
                    default:
                        element.checked = !element.checked;
                }
            };
            $scope.ok = function () {
                var element = document.getElementById("darkThemeCheckBox");
                var isChecked = element.checked;
                if (isChecked) {
                    window.localStorage.setItem("leadmedicalwebviewertheme", "dark");
                    var themeCSSElement = document.getElementById('theme_css');
                    themeCSSElement.href = 'css/darktheme.css';
                }
                else {
                    window.localStorage.setItem("leadmedicalwebviewertheme", "light");
                    var themeCSSElement = document.getElementById('theme_css');
                    themeCSSElement.href = 'css/theme-light.css';
                }
                $modalInstance.close('ok');
            };
        }
        UISettingsController.$inject = ['$scope', '$modalInstance'];
        return UISettingsController;
    }());
    Controllers.UISettingsController = UISettingsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Controllers;
(function (Controllers) {
    var UploadFileController = /** @class */ (function () {
        function UploadFileController($scope, $modalInstance, seriesManagerService, eventService, safeApply, objectStoreService) {
            var previousCell = null;
            $scope.enabled = true;
            //$scope.service = uploadFileService;  
            $scope.player = {};
            $scope.cancelVisiblity = false;
            $scope.progresscurrent = 0;
            $scope.totalProgressValue = 0;
            $scope.countTo = 0;
            $scope.countFrom = 0;
            $scope.totalCountTo = 0;
            $scope.text = { current: "", total: "" };
            $scope.progressBarVisiblity = false;
            $scope.browseDisabled = false;
            $scope.subProgressForTotal = 0;
            $scope.currentTotalProgress = 0;
            $scope.fileCount = 0;
            var closePending;
            var title = document.title;
            var base64ArrayBuffer = function (arrayBuffer) {
                var base64 = '';
                var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var bytes = new Uint8Array(arrayBuffer);
                var byteLength = bytes.byteLength;
                var byteRemainder = byteLength % 3;
                var mainLength = byteLength - byteRemainder;
                var a, b, c, d;
                var chunk;
                // Main loop deals with bytes in chunks of 3
                for (var i = 0; i < mainLength; i = i + 3) {
                    // Combine the three bytes into a single integer
                    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                    // Use bitmasks to extract 6-bit segments from the triplet
                    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
                    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
                    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
                    d = chunk & 63; // 63       = 2^6 - 1
                    // Convert the raw binary segments to the appropriate ASCII encoding
                    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
                }
                // Deal with the remaining bytes and padding
                if (byteRemainder == 1) {
                    chunk = bytes[mainLength];
                    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
                    // Set the 4 least significant bits to zero
                    b = (chunk & 3) << 4; // 3   = 2^2 - 1
                    base64 += encodings[a] + encodings[b] + '==';
                }
                else if (byteRemainder == 2) {
                    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
                    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
                    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
                    // Set the 2 least significant bits to zero
                    c = (chunk & 15) << 2; // 15    = 2^4 - 1
                    base64 += encodings[a] + encodings[b] + encodings[c] + '=';
                }
                return base64;
            };
            var EventDispatcher = (function () {
                function EventDispatcher() {
                    this._eventHandlers = {};
                }
                EventDispatcher.prototype.addEventListener = function (theEvent, theHandler) {
                    this._eventHandlers[theEvent] = this._eventHandlers[theEvent] || [];
                    this._eventHandlers[theEvent].push(theHandler);
                };
                EventDispatcher.prototype.clearEventListener = function (theEvent) {
                    this._eventHandlers[theEvent].clear();
                };
                EventDispatcher.prototype.checkEventListener = function (theEvent) {
                    return this._eventHandlers[theEvent].length > 0;
                };
                EventDispatcher.prototype.dispatchEvent = function (theEvent, eventData, theHandler) {
                    theHandler(theEvent, eventData);
                };
                EventDispatcher.prototype.dispatchAll = function (theEvent, eventData) {
                    var theHandlers = this._eventHandlers[theEvent];
                    if (theHandlers) {
                        for (var i = 0; i < theHandlers.length; i += 1) {
                            this.dispatchEvent(theEvent, eventData, theHandlers[i]);
                        }
                    }
                };
                return EventDispatcher;
            })();
            var uploadingFilePosition = 0;
            var uploadingFileChunkSize = 200 * 200;
            var uploadEvent = new EventDispatcher();
            var uploadFileName;
            var StartDicomUpload = function (file) {
                var reader = new FileReader();
                var __this = this;
                var d = $.Deferred();
                uploadingFilePosition = 0;
                reader.onloadend = function (evt) {
                    if (evt.target.readyState === 2) {
                        var base64String = base64ArrayBuffer(evt.target.result);
                        var frame;
                        objectStoreService.UploadDicomImage(base64String, "start", "").then(function (data) {
                            uploadFileName = data.data;
                            uploadingFilePosition = uploadingFilePosition + uploadingFileChunkSize;
                            $scope.countTo =
                                $scope.progresscurrent = (uploadingFilePosition >= file.size) ? 100 : (100 * uploadingFilePosition / file.size) >> 0;
                            $scope.subProgressForTotal = $scope.progresscurrent / $scope.fileCount;
                            $scope.totalCountTo =
                                $scope.totalProgressValue = $scope.currentTotalProgress + Math.ceil($scope.subProgressForTotal);
                            if (uploadingFilePosition >= file.size) {
                                d.resolve("success_done");
                            }
                            else
                                d.resolve("success_more");
                        });
                    }
                };
                var endByte = uploadingFilePosition + uploadingFileChunkSize;
                if (endByte > file.size) {
                    endByte = file.size;
                }
                var blob = file.slice(uploadingFilePosition, endByte);
                reader.readAsArrayBuffer(blob);
                return d.promise();
            };
            var ResumeDicomUpload = function (file) {
                var reader = new FileReader();
                var __this = this;
                var d = $.Deferred();
                reader.onloadend = function (evt) {
                    if (evt.target.readyState === 2) {
                        var base64String = base64ArrayBuffer(evt.target.result);
                        objectStoreService.UploadDicomImage(base64String, "append", uploadFileName).then(function (data) {
                            uploadingFilePosition = uploadingFilePosition + uploadingFileChunkSize;
                            $scope.countTo =
                                $scope.progresscurrent = (uploadingFilePosition >= file.size) ? 100 : (100 * uploadingFilePosition / file.size) >> 0;
                            $scope.subProgressForTotal = $scope.progresscurrent / $scope.fileCount;
                            $scope.totalCountTo =
                                $scope.totalProgressValue = $scope.currentTotalProgress + Math.ceil($scope.subProgressForTotal);
                            if (uploadingFilePosition >= file.size) {
                                d.resolve("success_done");
                            }
                            else
                                d.resolve("success_more");
                        });
                    }
                };
                var endByte = uploadingFilePosition + uploadingFileChunkSize;
                if (endByte > file.size) {
                    endByte = file.size;
                }
                var blob = file.slice(uploadingFilePosition, endByte);
                reader.readAsArrayBuffer(blob);
                return d.promise();
            };
            var UploadFile = function (files, index) {
                var file = files[index];
                var minChunkSize = 512 * 512;
                var multipier = Math.max(1, files.length / 10);
                uploadingFileChunkSize = minChunkSize * multipier;
                var uploadError = "";
                $scope.fileCount = files.length;
                $scope.progressBarVisiblity = true;
                $scope.cancelVisiblity = true;
                $scope.browseDisabled = true;
                $scope.text.current = file.name;
                var d = $.Deferred();
                uploadEvent.addEventListener("onStateChanged", function (theEvent, eventData) {
                    if (closePending) {
                        uploadEvent.clearEventListener("FileUploaded");
                        return;
                    }
                    switch (eventData) {
                        case "success_more":
                            ResumeDicomUpload(file).done(function (data) {
                                if (data === "success_more")
                                    uploadEvent.dispatchAll("onStateChanged", "success_more");
                                else
                                    uploadEvent.dispatchAll("onStateChanged", "success_done");
                            }).fail(function () {
                                alert("couldn\'t upload the file");
                            });
                            break;
                        case "success_done":
                            objectStoreService.UploadDicomImage(null, "done", uploadFileName).then(function (data) {
                                uploadEvent.clearEventListener("onStateChanged");
                                if (data.data.hasOwnProperty('FaultType') && data.data.FaultType == 'Exception') {
                                    uploadError = data.data.Message;
                                }
                                if (data.data != "success")
                                    uploadError = data.data;
                                d.resolve("file uploaded", uploadError);
                            });
                            break;
                        case "error_fail":
                            alert('Error uploading file!');
                            break;
                    }
                });
                $scope.currentTotalProgress = (100 * (index) / files.length) >> 0;
                $scope.totalCountTo =
                    $scope.totalProgressValue = $scope.currentTotalProgress + Math.ceil($scope.subProgressForTotal);
                $scope.text.total = "Uploading " + (index + 1) + " / " + files.length;
                document.title = "Uploading " + (index + 1) + " / " + files.length;
                StartDicomUpload(file).done(function (data) {
                    if (data === "success_more")
                        uploadEvent.dispatchAll("onStateChanged", "success_more");
                    else
                        uploadEvent.dispatchAll("onStateChanged", "success_done");
                });
                ;
                return d.promise();
            };
            var fileCounter;
            var startUploading = false;
            var uploadErrorMessage = "";
            var uploadErrorCount = 0;
            $scope.previous = function (files) {
                fileCounter = 0;
                closePending = false;
                startUploading = true;
                uploadErrorCount = 0;
                uploadErrorMessage = "";
                if (files.length != 0) {
                    uploadEvent.addEventListener("FileUploaded", function (theEvent, eventError) {
                        if (eventError != "") {
                            if (uploadErrorCount == 0) {
                                uploadErrorMessage = "File [" + files[fileCounter].name + "] " + eventError;
                            }
                            uploadErrorCount++;
                        }
                        fileCounter++;
                        if (closePending) {
                            uploadEvent.clearEventListener("FileUploaded");
                            return;
                        }
                        if (fileCounter >= files.length) {
                            startUploading = false;
                            uploadEvent.clearEventListener("FileUploaded");
                            $scope.progressBarVisiblity = false;
                            $scope.cancelVisiblity = false;
                            $scope.browseDisabled = false;
                            document.title = title;
                            var message = "";
                            if (uploadErrorCount > 0) {
                                message = "Total Files Uploaded: " + (fileCounter - uploadErrorCount) + " of " + fileCounter + '\n' +
                                    "Total Files Upload Failure: " + (uploadErrorCount) + " of " + fileCounter;
                            }
                            else {
                                message = "Total Files Uploaded: " + fileCounter;
                            }
                            alert(message);
                        }
                        else {
                            UploadFile(files, fileCounter).then(function (name, eventError) {
                                uploadEvent.dispatchAll("FileUploaded", eventError);
                            });
                        }
                    });
                    UploadFile(files, fileCounter).then(function (name, eventError) {
                        uploadEvent.dispatchAll("FileUploaded", eventError);
                    });
                }
            };
            $scope.close = function () {
                closePending = true;
                document.title = title;
                if (!startUploading)
                    $modalInstance.dismiss('cancel');
            };
            $scope.cancel = function () {
                closePending = true;
                $scope.progressBarVisiblity = false;
                $scope.cancelVisiblity = false;
                $scope.browseDisabled = false;
                startUploading = false;
                document.title = title;
                var inputFile = document.getElementById("inputFile");
                inputFile.value = null;
                objectStoreService.UploadDicomImage("", "cancel", "").then(function (data) {
                    alert('Canceled');
                });
            };
            eventService.subscribe(EventNames.ActiveSeriesChanged, function (event, data) {
            });
        }
        UploadFileController.$inject = ['$scope', '$modalInstance', 'seriesManagerService', 'eventService', 'safeApply', 'objectStoreService'];
        return UploadFileController;
    }());
    Controllers.UploadFileController = UploadFileController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UserPatientsAccessController = /** @class */ (function () {
        function UserPatientsAccessController($rootScope, $scope, patientAccessRightsService, optionsService, queryArchiveService, authenticationService, users, $modalInstance, dialogs, $translate, uiGridConstants, blockUI) {
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var timeFormat = optionsService.get(OptionNames.TimeFormat);
            var __this = this;
            var enableSelectionTemplate = '<div class="ui-grid-cell-contents" ng-class="{\'em\':row.enableSelection===false && row.grid.appScope.user.name!=null}" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>';
            $scope.gridapi = null;
            $scope.users = users;
            $scope.user = { name: null };
            this.scope = $scope;
            this._patientAccessRightsService = patientAccessRightsService;
            this._authenticationService = authenticationService;
            this._dialogs = dialogs;
            this.rolePatients = [];
            this._uiGridConstants = uiGridConstants;
            this._patientsBock = blockUI.instances.get('patientsBlockUI');
            $scope.gridOptions = {
                appScopeProvider: $scope,
                enableSorting: true,
                enableRowSelection: true,
                showFooter: true,
                modifierKeysToMultiSelect: false,
                paginationPageSizes: [25, 50, 75],
                paginationPageSize: 25,
                enableFiltering: true,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                onRegisterApi: function (gridApi) {
                    $scope.gridapi = gridApi;
                    gridApi.pagination.on.paginationChanged($scope, __this.paginationChanged.bind(__this));
                    gridApi.selection.on.rowSelectionChanged($scope, __this.rowSelectionChange.bind(__this));
                    gridApi.selection.on.rowSelectionChangedBatch($scope, __this.rowSelectionChangedBatch.bind(__this));
                    __this.makeReadOnly();
                },
                columnDefs: [
                    { name: "Id", field: "ID", enableHiding: false, cellTemplate: enableSelectionTemplate },
                    { name: "Name", field: "Name", enableHiding: false, cellTemplate: enableSelectionTemplate },
                    { name: "Sex", field: "Sex", enableHiding: false, enableFiltering: false, cellTemplate: enableSelectionTemplate },
                    { name: "Birth Date", field: "BirthDate", enableHiding: false, enableFiltering: false, cellTemplate: enableSelectionTemplate },
                ],
                data: 'patients'
            };
            queryArchiveService.FindPatients(null).success(function (patients) {
                $scope.patients = patients;
            });
            $scope.close = function () {
                $modalInstance.close();
            };
            $scope.userChanged = this.userChanged.bind(this);
            $scope.applyPermissions = this.applyPermissions.bind(this);
            $translate('NOTIFY_PERMISSIONS_SAVED').then(function (translation) {
                this._saveSuccessMsg = translation;
            }.bind(this));
            $translate('NOTIFY_PERMISSIONS_FAILED').then(function (translation) {
                this._saveFailureMsg = translation;
            }.bind(this));
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this._notificationTitle = translation;
            }.bind(this));
        }
        UserPatientsAccessController.prototype.userChanged = function (user) {
            var __this = this;
            this.scope.gridapi.selection.clearSelectedRows();
            if (user != null) {
                this._authenticationService.isAdmin(user).success(function (result) {
                    this.rolePatients = [];
                    if (!result) {
                        __this._authenticationService.getUserRoles(user).success(function (userRoles) {
                            if (userRoles.length > 0) {
                                __this._patientAccessRightsService.GetRolesAccess(userRoles).then(function (data) {
                                    var length = data.data.length;
                                    for (var i = 0; i < length; i++) {
                                        var patientId = data.data[i].PatientId;
                                        if (__this.rolePatients.indexOf(patientId) == -1)
                                            __this.rolePatients.push(patientId);
                                    }
                                    __this.getPermissions(user);
                                }, function (reason) {
                                    __this.getPermissions(user);
                                });
                            }
                            else
                                __this.getPermissions(user);
                        })
                            .error(function () {
                            __this.getPermissions(user);
                        });
                    }
                    else
                        __this.makeReadOnly();
                });
            }
            else {
                this.makeReadOnly();
            }
        };
        UserPatientsAccessController.prototype.getPermissions = function (user) {
            this._patientAccessRightsService.GetUserAccess(user).then(function (result) {
                this.grantedPermissions = [];
                for (var i = 0; i < result.data.length; i++) {
                    this.grantedPermissions.push(result.data[i].PatientId);
                }
                this.updateSelection();
                this.updatePermissions();
            }.bind(this), function (e) {
            });
        };
        UserPatientsAccessController.prototype.applyPermissions = function () {
            this._patientAccessRightsService.GrantUserPatients(this.scope.user.name, this.grantedPermissions).then(function (data) {
                this._dialogs.notify(this._notificationTitle, this._saveSuccessMsg);
            }.bind(this), function (error) {
                this._dialogs.error(this._saveFailureMsg + ": " + error);
            }.bind(this));
        };
        UserPatientsAccessController.prototype.updatePermissions = function () {
            var rows = this.scope.gridapi.grid.rows;
            angular.forEach(rows, function (value, key) {
                var entity = value.entity;
                var permissions = $.grep(this.grantedPermissions, function (e, index) {
                    return e == entity.ID;
                });
                if (permissions.length > 0) {
                    this.scope.gridapi.selection.selectRow(entity);
                }
            }, this);
        };
        UserPatientsAccessController.prototype.paginationChanged = function (currentPage, pageSize) {
            this.updateSelection();
            this.updatePermissions();
        };
        UserPatientsAccessController.prototype.rowSelectionChange = function (row, event) {
            if (!angular.isDefined(event)) {
                //
                // event happen through programmatic access
                //
                return;
            }
            if (row.isSelected)
                this.addPermission(this.scope.user.name, row.entity.ID);
            else
                this.removePermission(this.scope.user.name, row.entity.ID);
        };
        UserPatientsAccessController.prototype.rowSelectionChangedBatch = function (rows, event) {
            var length = rows.length;
            for (var i = 0; i < length; i++) {
                if (rows[i].isSelected)
                    this.addPermission(this.scope.user.name, rows[i].entity.ID);
                else
                    this.removePermission(this.scope.user.name, rows[i].entity.ID);
            }
        };
        UserPatientsAccessController.prototype.updateSelection = function () {
            var rows = this.scope.gridapi.core.getVisibleRows(this.scope.gridapi.grid);
            angular.forEach(rows, function (row, key) {
                var contains = this.rolePatients.indexOf(row.entity.ID) != -1;
                row.isSelected = contains;
                row.enableSelection = !contains;
            }, this);
        };
        UserPatientsAccessController.prototype.makeReadOnly = function (isAdmin) {
            var rows = this.scope.gridapi.core.getVisibleRows(this.scope.gridapi.grid);
            isAdmin = isAdmin || false;
            if (rows.length == 0 || isAdmin) {
                setTimeout(function () {
                    this.makeReadOnly();
                }.bind(this), 250);
            }
            else {
                angular.forEach(rows, function (row, key) {
                    row.isSelected = false;
                    row.enableSelection = false;
                }, this);
            }
        };
        UserPatientsAccessController.prototype.addPermission = function (user, patientId) {
            var permissions = $.grep(this.grantedPermissions, function (e, index) {
                return e == patientId;
            });
            if (permissions.length == 0) {
                this.grantedPermissions.push(patientId);
            }
        };
        UserPatientsAccessController.prototype.removePermission = function (user, patientId) {
            var permissions = $.grep(this.grantedPermissions, function (e, index) {
                return e == patientId;
            });
            if (permissions.length == 1) {
                var index = this.grantedPermissions.indexOf(permissions[0]);
                this.grantedPermissions.splice(index, 1);
            }
        };
        UserPatientsAccessController.$inject = ['$rootScope', '$scope', 'patientAccessRightsService', 'optionsService', 'queryArchiveService', 'authenticationService', 'users', '$modalInstance', 'dialogs', '$translate', 'uiGridConstants', 'blockUI'];
        return UserPatientsAccessController;
    }());
    Controllers.UserPatientsAccessController = UserPatientsAccessController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var TagChooserController = /** @class */ (function () {
        function TagChooserController($scope, $modalInstance, optionsService, $translate, dicom, selector, currentTags) {
            this._unknownString = "Unknown";
            var model = [];
            var self = this;
            this._dateFormat = optionsService.get(OptionNames.DateFormat);
            this._timeFormat = optionsService.get(OptionNames.TimeFormat);
            this._$scope = $scope;
            this._selector = selector;
            // Remove this line if want the Tag Chooser Editor to display tags that have already been selected
            currentTags = [];
            $scope.gridOptions = {
                columnDefs: [
                    {
                        headerName: "Tag",
                        field: "tag",
                        width: 150,
                        cellRenderer: {
                            renderer: 'group',
                            innerRenderer: this.innerCellRenderer.bind(this),
                            checkbox: true
                        }
                    },
                    {
                        headerName: "Name",
                        field: "name",
                        width: 250
                    },
                    {
                        headerName: "Value",
                        field: "value",
                        width: 250
                    }
                ],
                rowData: this.buildData(dicom, new Array(), currentTags),
                rowSelection: !selector ? 'multiple' : 'single',
                rowsAlreadyGrouped: true,
                suppressRowClickSelection: true,
                enableColResize: true,
                //enableSorting: true,  
                groupSelectsChildren: false,
                icons: {
                    groupExpanded: '<i class="fa fa-minus-square-o"/>',
                    groupContracted: '<i class="fa fa-plus-square-o"/>'
                },
                onGridReady: function () {
                    $scope.gridOptions.api.hideOverlay();
                    if (selector && selector.WCFSelectorAttribute && selector.WCFSelectorAttribute.length > 0) {
                        setTimeout(function () {
                            self.selectCurrentTag();
                        }, 500);
                    }
                },
                onSelectionChanged: this.selectionChanged.bind(this),
                onRowSelected: this.rowSelected.bind(this)
            };
            $scope.ok = function () {
                var nodes = $scope.gridOptions.api.getSelectedNodes();
                if (selector) {
                    var newNode = self.sequenceCheck(nodes[0]);
                    $modalInstance.close(newNode.data);
                }
                else {
                    var data = new Array();
                    for (var i = 0; i < nodes.length; i++) {
                        var newNode = self.sequenceCheck(nodes[i]);
                        // data.push(newNode.data);
                        var clonedData = Utils.myclone(newNode.data, ['children']);
                        data.push(clonedData);
                    }
                    $modalInstance.close(data);
                }
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        TagChooserController.prototype.containsCodeValue = function (itemNode) {
            if (itemNode == null)
                return false;
            for (var i = 0; i < itemNode.children.length; i++) {
                var tag1 = itemNode.children[i].data.tag;
                tag1 = tag1.replace(":", "");
                if (tag1 == DicomTag.CodeValue)
                    return true;
            }
            return false;
        };
        TagChooserController.prototype.isCodeSequence = function (node, itemNumber) {
            var d = node.data;
            var result = false;
            if (d.name.indexOf("Code Sequence") != -1)
                return true;
            if (d.vr != "SQ")
                return false;
            if (node.children.length == 0)
                return false;
            if (this.containsCodeValue(node.children[0]))
                return true;
            // If the 0th item has no children, try the selected item: item[itemNumber-1]
            var index = parseInt(itemNumber);
            if (isNaN(index))
                return false;
            // index should be 0-based
            index = index - 1;
            // If index is 0, we already checked this
            if (index == 0)
                return false;
            if (node.children.length <= index)
                return false;
            if (this.containsCodeValue(node.children[index]))
                return true;
            return false;
        };
        TagChooserController.prototype.getSelectorSequencePointer = function (node) {
            var s = "";
            while (node != null) {
                var d = node.data;
                if (d != null && d.tag != DicomTag.Item) {
                    if (s.length == 0) {
                        s = d.tag;
                    }
                    else {
                        s = d.tag + "\\" + s;
                    }
                }
                node = node.parent;
            }
            return s;
        };
        TagChooserController.prototype.getSelectorSequencePointerItems = function (node) {
            var s = "";
            while (node != null) {
                var d = node.data;
                if (d != null && d.tag == DicomTag.Item) {
                    var itemNumber = d.name.replace("Item ", ""); // "Item 3" --> "3"
                    if (s.length == 0) {
                        s = itemNumber;
                    }
                    else {
                        s = itemNumber + "\\" + s;
                    }
                }
                node = node.parent;
            }
            return s;
        };
        TagChooserController.prototype.findNodeSequenceTag = function (node) {
            if (node == null)
                return null;
            while (node.data.vr != "SQ" && node.parent != null) {
                node = node.parent;
            }
            return node;
        };
        TagChooserController.prototype.findNodeItemTag = function (node) {
            if (node == null)
                return null;
            if (node.data.vr == "SQ") {
                // User selected a sequenceTag so use the first child item
                if (node.children != null && node.children.length > 0) {
                    node = node.children[0];
                }
                else {
                    node = null;
                }
                return node;
            }
            while (node.data.tag != DicomTag.Item && node.parent != null) {
                node = node.parent;
            }
            return node;
        };
        TagChooserController.prototype.sequenceCheck = function (nodeSelected) {
            var dataSelected = nodeSelected.data;
            var nodeSequence = null;
            var nodeItem = null;
            var itemNumber = null;
            var nodeReturn = nodeSelected;
            //if (dataSelected.tag == DicomTag.Item) {
            //    // User selected a sequence item, so the parent tag is the sequence tag
            //    nodeSequence = nodeSelected.parent;
            //    nodeItem = nodeSelected;
            //    itemNumber = nodeItem.data.name.replace("Item ", "");
            //}
            //else if (dataSelected.vr == "SQ") {
            //    // User selected a sequenceTag so use the first item
            //    nodeSequence = nodeSelected;
            //    nodeItem = nodeSelected.children[0];
            //}
            //else if (nodeSelected.parent != null) {
            //    // User selected a tag that is not an item or a sequence.
            //    // If the tag has a parent then it is part of an item
            //    nodeSequence = this.findNodeSequenceTag(nodeSelected);
            //    nodeItem = this.findNodeItemTag(nodeSelected);
            //}
            //else {
            //    // User selected a tag that is not part of a sequence or sequence item
            //}
            nodeSequence = this.findNodeSequenceTag(nodeSelected);
            nodeItem = this.findNodeItemTag(nodeSelected);
            if (nodeItem != null) {
                itemNumber = nodeItem.data.name.replace("Item ", "");
            }
            // Check nodeSelected is SQ or Item
            var isCodeSequence = false;
            if (nodeSelected.data.vr == "SQ" || nodeSelected.data.tag == DicomTag.Item) {
                isCodeSequence = this.isCodeSequence(nodeSequence, itemNumber);
                nodeReturn = nodeSequence;
            }
            var nodeReturnData = nodeReturn.data;
            if (isCodeSequence) {
                nodeReturnData["isCodeSequence"] = true;
                nodeReturnData["children"] = nodeSelected.children;
            }
            else {
                delete nodeReturnData["isCodeSequence"];
                delete nodeReturnData["children"];
            }
            nodeReturnData['itemNumber'] = (itemNumber == null ? null : parseInt(itemNumber));
            if (nodeSequence != null) {
                // d['selectorSequencePointer'] = parent.data.tag;
                nodeReturnData['selectorSequencePointer'] = this.getSelectorSequencePointer(nodeItem);
                nodeReturnData['sequencePointerName'] = nodeSequence.data.name;
                nodeReturnData['selectorSequencePointerItems'] = this.getSelectorSequencePointerItems(nodeItem);
            }
            return nodeReturn;
        };
        TagChooserController.prototype.selectCurrentTag = function () {
            var self = this;
            this._$scope.gridOptions.api.forEachNode(function (node, index) {
                var nodeData = node.data;
                if (nodeData.tag == self._selector.WCFSelectorAttribute && !node.parent) {
                    self._$scope.gridOptions.api.selectNode(node);
                    self._$scope.gridOptions.api.ensureIndexVisible(index);
                }
            });
        };
        TagChooserController.prototype.innerCellRenderer = function (params) {
            if (params.data.vr == 'SQ') {
                return '&nbsp;<span><i class="fa fa-tags" style="color: blue"></i>&nbsp;' + params.data.tag + '</span>';
            }
            return '&nbsp;<span><i class="fa fa-tag" style="color: blue"></i>&nbsp;' + params.data.tag + '</span>';
        };
        TagChooserController.prototype.isValidSelectorVR = function (key, vr) {
            if (key == DicomTag.Item)
                return true;
            var valid = (vr == "AT" ||
                vr == "CS" ||
                vr == "IS" ||
                vr == "LO" ||
                vr == "LT" ||
                vr == "PN" ||
                vr == "SH" ||
                vr == "ST" ||
                vr == "UT" ||
                vr == "DS" ||
                vr == "FD" ||
                vr == "FL" ||
                vr == "UL" ||
                vr == "US" ||
                vr == "SL" ||
                vr == "SS" ||
                vr == "UI" ||
                vr == "SQ");
            return valid;
        };
        TagChooserController.prototype.buildData = function (dicom, data, currentTags) {
            for (var key in dicom) {
                var tag = key.substr(0, 4) + ":" + key.substr(4);
                var dcmData = new Models.DicomData(Utils.splitCamelCaseToString(dicom[key].keyword), tag);
                var row = new Models.DicomTagRow(dcmData);
                if (!this.isValidSelectorVR(key, dicom[key].vr)) {
                    continue;
                }
                if (!dcmData.name) {
                    dcmData.name = this._unknownString;
                }
                dcmData.vr = dicom[key].vr;
                if (dicom[key].vr == 'PN') {
                    dcmData.value = DicomHelper.getPatientNameFromTag(dicom[key]);
                }
                else if (dicom[key].vr != 'SQ') {
                    var value = DicomHelper.getConvertValue(dicom[key]);
                    if (dicom[key].vr == 'DA') {
                        if (value) {
                            var DateJS = (new Date(DicomHelper.parseDicomDate(value)));
                            value = DateJS.toString(this._dateFormat);
                        }
                    }
                    if (dicom[key].vr == 'TM') {
                        if (value) {
                            var DateJS = Date.today().at(DicomHelper.parseDicomTime(value));
                            value = DateJS.toString(this._timeFormat);
                        }
                    }
                    dcmData.value = value;
                }
                else {
                    if (dicom[key].Value && dicom[key].Value.length > 0) {
                        var length = dicom[key].Value.length;
                        row.group = true;
                        row.expanded = false;
                        for (var index = 0; index < length; index++) {
                            var dcmData = new Models.DicomData("Item " + (index + 1).toString(), "FFFEE000");
                            var itemRow = new Models.DicomTagRow(dcmData);
                            itemRow.group = true;
                            itemRow.expanded = false;
                            row.children.push(itemRow);
                            this.buildData(dicom[key].Value[index], itemRow.children, currentTags);
                        }
                    }
                }
                if ((currentTags && currentTags.length == 0) || (currentTags && currentTags.length > 0 && currentTags.indexOf(tag) == -1))
                    data.push(row);
            }
            return data;
        };
        TagChooserController.prototype.getDateTime = function () {
            var DateJS = (new Date());
            var formattedString;
            formattedString = DateJS.toString(this._dateFormat + " " + this._timeFormat);
            return formattedString;
        };
        TagChooserController.prototype.rowSelected = function (event) {
            //var nodes: Array<any> = this._$scope.gridOptions.api.getSelectedNodes();
            //for (var i = 0; i < nodes.length; i++) {
            //    var node = nodes[i];
            //}
        };
        TagChooserController.prototype.selectionChanged = function () {
            //var nodes: Array<any> = this._$scope.gridOptions.api.getSelectedNodes();
            //for (var i = 0; i < nodes.length; i++) {
            //    var node = nodes[i];
            //}
        };
        TagChooserController.$inject = ['$scope', '$modalInstance', 'optionsService', '$translate', 'dicom', 'selector', 'currentTags'];
        return TagChooserController;
    }());
    Controllers.TagChooserController = TagChooserController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var Settings3DController = /** @class */ (function () {
        function Settings3DController($scope, eventService, toolbarService, $modalInstance, optionsService, objectRetrieveService, $translate, cell) {
            this._unknownString = "Unknown";
            this.GetVolume = function (volumeType) {
                switch (volumeType) {
                    case lt.Controls.Medical.VolumeType.VRT:
                    case lt.Controls.Medical.VolumeType.MIP:
                        return "Volume";
                    case lt.Controls.Medical.VolumeType.MPR:
                        return "MPR";
                }
            };
            this._$scope = $scope;
            var model = [];
            var __this = this;
            $scope.source = new Models.Settings3DOptions();
            $scope.range = new Models.ValueRange();
            var cell3D = cell;
            $scope.range.ValueMaximum = parseInt(cell3D.information.maxValue.toString());
            $scope.range.ValueMinimum = parseInt(cell3D.information.minValue.toString());
            $scope.source.volumeType = this.GetVolume(cell.volumeType);
            $scope.source.lowResQuality = cell.volume.lowResQuality;
            $scope.source.showClippingFrame = cell.volume.enableClippingFrame;
            $scope.source.showCrossLines = cell.MPR.enableCrossLines;
            $scope.source.projectionMethod = cell.projection;
            $scope.source.showRotationCube = cell.showRotationCube;
            $scope.source.showVolumeBorder = cell.showVolumeBorder;
            $scope.source.resizeFactor = cell.resizeFactor;
            $scope.ok = function () {
                var output = {};
                output.IsoThreshold = __this._$scope.source.isoThreshold;
                output.LowResQuality = __this._$scope.source.lowResQuality;
                output.ProjectionMethod = __this._$scope.source.projectionMethod;
                output.ShowClippingFrame = __this._$scope.source.showClippingFrame;
                output.ShowMPRCrossLines = __this._$scope.source.showCrossLines;
                output.ShowRotationCube = __this._$scope.source.showRotationCube;
                output.ShowVolumeBorder = __this._$scope.source.showVolumeBorder;
                cell.resizeFactor = __this._$scope.source.resizeFactor;
                output.AxialPosition = -1;
                output.SagittalPosition = -1;
                output.CoronalPosition = -1;
                $modalInstance.close(output);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isSelectorIndexValid = this.isSelectorIndexValid.bind(this);
            $scope.getSelectorIndexError = this.getSelectorIndexError.bind(this);
            $scope.getIsoThresholdError = this.getIsoThresholdError.bind(this);
            $scope.isFormValid = function () {
                return this.isSelectorIndexValid();
            };
            $scope.getSelectorValueError = function () {
                return "error test";
            };
        }
        Settings3DController.prototype.getIsoThresholdError = function () {
            var value = this._$scope.source.isoThreshold;
            if (!$.isNumeric(value)) {
                return "invalid value, must be numerical";
            }
            if (value < this._$scope.range.ValueMinimum || value >= this._$scope.range.ValueMaximum)
                return "value must be betweren (" + this._$scope.range.ValueMinimum + ") and ( " + this._$scope.range.ValueMaximum + " )";
            return "";
        };
        Settings3DController.prototype.getSelectorIndexError = function () {
            var lowQuality = this._$scope.source.lowResQuality;
            if (!$.isNumeric(lowQuality)) {
                return "invalid value, must be numerical";
            }
            if (lowQuality < 0 || lowQuality > 1)
                return "value must be btween 0 and 1";
            return "";
        };
        Settings3DController.prototype.isSelectorIndexValid = function () {
            var value = this._$scope.source.isoThreshold;
            var lowQuality = this._$scope.source.lowResQuality;
            if (value < this._$scope.range.ValueMinimum || value >= this._$scope.range.ValueMaximum)
                return false;
            if (lowQuality < 0 || lowQuality > 1)
                return false;
            return true;
        };
        Settings3DController.$inject = ['$scope', 'eventService', 'toolbarService', '$modalInstance', 'optionsService', 'objectRetrieveService', '$translate', 'cell'];
        return Settings3DController;
    }());
    Controllers.Settings3DController = Settings3DController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var WarningController = /** @class */ (function () {
        function WarningController($scope, $modalInstance) {
            $scope.warning = {};
            $scope.warning.DontAskAgain = false;
            $scope.export = function () {
                window.localStorage.setItem("Export.DontAskAgain", $scope.warning.DontAskAgain.toString());
                $modalInstance.close('export');
            };
            $scope.cancel = function () {
                $modalInstance.dismiss("cancel");
            };
        }
        WarningController.$inject = ["$scope", "$modalInstance"];
        return WarningController;
    }());
    Controllers.WarningController = WarningController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var WindowLevelCustomController = /** @class */ (function () {
        function WindowLevelCustomController($scope, optionsService, $modalInstance, settings, currentFrame, seriesService) {
            var index;
            $scope.settings = angular.copy(settings);
            $scope.ok = function () {
                $modalInstance.close($scope.settings);
            };
            $scope.apply = function () {
                var cell = seriesService.get_activeCell();
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    var cell3D = cell;
                    cell3D.information.windowWidth = $scope.settings.width;
                    cell3D.information.windowCenter = $scope.settings.center;
                    cell3D.updateWindowLevelValues();
                }
                else {
                    var linked = cell.get_linked();
                    if (linked) {
                        seriesService.enumerateFrames(cell, function (frame, index) {
                            if (seriesService.withinVisibleRange(cell, index)) {
                                frame.setWindowLevel($scope.settings.width, $scope.settings.center);
                            }
                        });
                    }
                    else {
                        currentFrame.setWindowLevel($scope.settings.width, $scope.settings.center);
                    }
                }
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.reset = function () {
                $scope.settings.width = settings.originalWindowLevelWidth;
                $scope.settings.center = settings.originalWindowLevelCenter;
            };
        }
        WindowLevelCustomController.$inject = ['$scope', 'optionsService', '$modalInstance', 'settings', 'currentFrame', 'seriesService'];
        return WindowLevelCustomController;
    }());
    Controllers.WindowLevelCustomController = WindowLevelCustomController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var SeriesLayoutController = /** @class */ (function () {
        function SeriesLayoutController($scope, optionsService, $modalInstance, layout, templateService, dialogs, $translate, authenticationService) {
            this._notificationTitle = 'Notify';
            this._errorMessage = 'Error getting template list';
            this._$scope = $scope;
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this._notificationTitle = translation;
            }.bind(this));
            $translate('DIALOGS_TEMPLATE_ERROR_GET').then(function (translation) {
                this._errorMessage = translation;
            }.bind(this));
            $scope.ok = function () {
                $modalInstance.close($scope.layout);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isRowValid = this.isRowValid.bind(this);
            $scope.getIsRowValidError = this.getIsRowValidError.bind(this);
            $scope.isColumnValid = this.isColumnValid.bind(this);
            $scope.getIsColumnValidError = this.getIsColumnValidError.bind(this);
            $scope.isFormValid = this.isFormValid.bind(this);
            $scope.layout = {
                rows: layout.rows,
                columns: layout.columns,
                custom: null
            };
        }
        SeriesLayoutController.prototype.isRowValid = function () {
            var errorMessage = this.getIsRowValidError();
            return (errorMessage == "");
        };
        SeriesLayoutController.prototype.getIsRowValidError = function () {
            if (!this._$scope.layout)
                return "";
            if (!$.isNumeric(this._$scope.layout.rows)) {
                return "Must be numeric";
            }
            if (this._$scope.layout.rows <= 0) {
                return "Must be greater than 0";
            }
            return "";
        };
        SeriesLayoutController.prototype.isColumnValid = function () {
            var errorMessage = this.getIsColumnValidError();
            return (errorMessage == "");
        };
        SeriesLayoutController.prototype.getIsColumnValidError = function () {
            if (!this._$scope.layout)
                return "";
            if (!$.isNumeric(this._$scope.layout.columns)) {
                return "Must be numeric";
            }
            if (this._$scope.layout.columns <= 0) {
                return "Must be greater than 0";
            }
            return "";
        };
        SeriesLayoutController.prototype.isFormValid = function () {
            return this.isRowValid() && this.isColumnValid();
        };
        SeriesLayoutController.$inject = ['$scope', 'optionsService', '$modalInstance', 'layout', 'templateService', 'dialogs', '$translate', 'authenticationService'];
        return SeriesLayoutController;
    }());
    Controllers.SeriesLayoutController = SeriesLayoutController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="Scopes.ts" />
var Controllers;
(function (Controllers) {
    var TemplateEditorController = /** @class */ (function () {
        function TemplateEditorController($rootScope, $scope, templateEditorService, $location, templates, $modal, eventService, $translate, authenticationService, templateService, dialogs, optionsService, toolbarService, $timeout, $window, $idle) {
            this._newString = "New";
            this._templateString = "Template";
            this._errorTitle = "Notification";
            this._notifyTitle = "Error";
            this._updateMessage = "Template successfully updated";
            this._addMessage = "New template successfully added";
            this._toolbarKey = "BE0855F9-9BA9-4068-A7B9-AEC8D5F8FA17";
            var spacingSize = Utils.get_spacingSize();
            var unsubscribe;
            var self = this;
            var showWest = Utils.debounce(function () {
                var state = $scope.layoutApi.get_state("west");
                if (!state.isClosed) {
                    $scope.layoutApi.openPane("west");
                }
            }, 250);
            if (templates && templates.length > 0) {
                templates.sort(function (a, b) {
                    return a.Frames.length - b.Frames.length;
                });
            }
            unsubscribe = eventService.subscribe(EventNames.ToolbarCreated, function (event, data) {
                toolbarService.disable("SaveTemplate" + self._toolbarKey);
                toolbarService.enable('NewTemplate' + self._toolbarKey, function () {
                    return self.canAdd();
                });
                toolbarService.enable(['DrawTemplateBox' + self._toolbarKey, 'DeleteTemplateBox' + self._toolbarKey], function () {
                    return self.canDraw();
                });
                toolbarService.enable('DeleteTemplate' + self._toolbarKey, function () {
                    return self._authenticationService.hasPermission(PermissionNames.CanDeleteTemplates);
                });
                toolbarService.enable('RenameTemplate' + self._toolbarKey, function () {
                    return self.canDraw();
                });
                toolbarService.enable('ImportTemplates' + self._toolbarKey, function () {
                    return authenticationService.hasPermission(PermissionNames.CanImportTemplates);
                });
                toolbarService.enable('ExportTemplates' + self._toolbarKey, function () {
                    return authenticationService.hasPermission(PermissionNames.CanExportTemplates);
                });
                toolbarService.enable(['ToggleGrid' + self._toolbarKey, 'ToggleSnapToGrid' + self._toolbarKey], function () {
                    return self._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
                });
                toolbarService.enable(self._alignmentActions, function () {
                    return false;
                });
                toolbarService.press('SelectTemplateBox' + self._toolbarKey);
                unsubscribe();
                self.setToggleGridState();
                self.setToggleSnapToGridState();
            });
            eventService.subscribe(EventNames.TemplatesImported, this.templatesImported.bind(this));
            this._authenticationService = authenticationService;
            this._templateEditorService = templateEditorService;
            this._templateService = templateService;
            this._toolbarService = toolbarService;
            this._dialogs = dialogs;
            this._$window = $window;
            $scope.idleWait = optionsService.get(OptionNames.IdleWarningDuration);
            this._dateFormat = optionsService.get(OptionNames.DateFormat);
            this._timeFormat = optionsService.get(OptionNames.TimeFormat);
            templateEditorService.templateEditController = this;
            $translate('NEW').then(function (translation) {
                this.newString = translation;
            }.bind(this));
            $translate('TEMPLATE').then(function (translation) {
                this.templateString = translation;
            }.bind(this));
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this._notifyTitle = translation;
            }.bind(this));
            $translate('DIALOGS_ERROR').then(function (translation) {
                this._errorTitle = translation;
            }.bind(this));
            $translate('DIALOGS_TEMPLATE_ADDED').then(function (translation) {
                this._addMessage = translation;
            }.bind(this));
            $translate('DIALOGS_TEMPLATE_UPDATE').then(function (translation) {
                this._updateMessage = translation;
            }.bind(this));
            this._scope = $scope;
            /* Reserved for capture
             *
            this._descriptions = anatomicDescriptions; */
            this._modal = $modal;
            this._isDirty = false;
            this.initializeToolbar();
            /* Reserved for capture
             *
            this._anatomicDescriptions = "NONE";
            for (var i = 0; i < length; i++) {
                this._anatomicDescriptions += "|" + anatomicDescriptions[i].Name;
            }*/
            $scope.layoutConfig = {
                applyDemoStyles: true,
                scrollToBookmarkOnLoad: false,
                spacing_closed: spacingSize,
                spacing_open: spacingSize,
                livePaneResizing: false,
                north__size: lt.LTHelper.device == lt.LTDevice.mobile ? "auto" : "auto",
                north__resizable: false,
                north__showOverflowOnHover: true,
                west__size: lt.LTHelper.device == lt.LTDevice.tablet ? '30%' : lt.LTHelper.device == lt.LTDevice.mobile ? '60%' : '20%',
                //west__initClosed: lt.LTHelper.device == lt.LTDevice.mobile ? true : false               
                west__initClosed: false
            };
            $scope.layoutApi = {};
            $scope.editorApi = {};
            $scope.layout = {};
            $scope.templates = templates;
            $scope.editorConfig = {
                keepDrawing: true,
                editorMode: EditorMode.Select,
                editAfterDraw: false,
                onSelectedItemsChanged: this.onSelectedItemsChanged.bind(this),
                onFrameChanged: this.onFrameChanged.bind(this),
                borderSize: optionsService.get(OptionNames.TemplateBorderSize),
                borderColor: optionsService.get(OptionNames.TemplateBorderColor),
                backgroundColor: optionsService.get(OptionNames.TemplateBackgroundColor),
                foreColor: optionsService.get(OptionNames.TemplateForeColor),
                boundsNotification: optionsService.get(OptionNames.TemplateBoundsNotification)
            };
            eventService.subscribe(EventNames.CenterPaneResized, function (event, data) {
                if (data.args.element.attr('id') == "mainCenter") {
                    showWest();
                }
            });
            $scope.onSelect = this.onSelect.bind(this);
            $scope.onNewTemplate = this.onNewTemplate.bind(this);
            $scope.onCopyTemplate = this.onCopyTemplate.bind(this);
            $scope.loadTemplate = this.loadTemplate.bind(this);
            $scope.onPropertyChanged = this.onPropertyChanged.bind(this);
            $scope.onPropertyClicked = this.onPropertyClicked.bind(this);
            $scope.onNewFrame = this.onNewFrame.bind(this);
            $scope.onExitEditor = function () {
                $location.path('/');
            };
            if ($scope.templates.length > 0) {
                this.load($scope.templates[0]);
                if (angular.isDefined($scope.currentTemplate)) {
                    this._scope.cancelMove = this._scope.currentTemplate.BuiltIn;
                }
            }
            $scope.canSave = this.canSave.bind(this);
            $scope.canDraw = this.canDraw.bind(this);
            $scope.canAdd = this.canAdd.bind(this);
            this._timerId = null;
            this._optionsService = optionsService;
            $scope.$watch('windowDimensions', function (newValue, oldValue) {
                if ($scope.layoutApi) {
                    if ($scope.layoutApi.refresh) {
                        $scope.layoutApi.refresh();
                    }
                    else {
                        var self = this;
                        setTimeout(function () {
                            $scope.layoutApi.refresh();
                            $scope.layoutApi.openPane("west");
                        }, 1000);
                    }
                }
            });
            function closeModals() {
                if ($scope.warning) {
                    $scope.warning.close();
                    $scope.warning = null;
                }
                if ($scope.timedout) {
                    $scope.timedout.close();
                    $scope.timedout = null;
                }
            }
            $scope.$on('$idleStart', function () {
                $scope.warning = $modal.open({
                    templateUrl: 'warning-dialog.html',
                    windowClass: 'modal-danger'
                });
            });
            $scope.$on('$idleEnd', function () {
                closeModals();
            });
            $scope.$on('$idleTimeout', function () {
                closeModals();
                $idle.unwatch();
                authenticationService.logout();
            });
        }
        Object.defineProperty(TemplateEditorController.prototype, "currentTemplateName", {
            get: function () {
                return this._scope.currentTemplate.Name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TemplateEditorController.prototype, "currentTemplateId", {
            get: function () {
                return this._scope.currentTemplate.Id;
            },
            enumerable: false,
            configurable: true
        });
        TemplateEditorController.prototype.initializeToolbar = function () {
            var toolbar = new Models.Toolbar();
            var item;
            this._scope.toolbars = new Array();
            toolbar.name = "Template";
            this._alignmentActions = Array();
            this.addToolbarItem(toolbar, "NewTemplate", "OnNewTemplate", "New Template", "NewTemplate", "New");
            this.addToolbarItem(toolbar, "SaveTemplate", "OnSaveTemplate", "Save Template", "SaveTemplate", "Save");
            this.addToolbarItem(toolbar, "RenameSeperator", "", "", "", "", "seperator");
            this.addToolbarItem(toolbar, "RenameTemplate", "OnRenameTemplate", "Rename Template", "RenameTemplate", "Rename");
            this.addToolbarItem(toolbar, "CopyTemplate", "OnCopyTemplate", "Copy Template", "CopyTemplate", "Copy");
            this.addToolbarItem(toolbar, "DeleteTemplate", "OnDeleteTemplate", "Delete Template", "DeleteTemplate", "Delete");
            this.addToolbarItem(toolbar, "GridSeperator", "", "", "", "", "seperator");
            this.addToolbarItem(toolbar, "ConfigureGrid", "OnConfigureGrid", "Configure Grid", "Configure", "Configure");
            this.addToolbarItem(toolbar, "ToggleGrid", "OnToggleGrid", "Toggle Grid", "ToggleGrid", "Grid");
            this.addToolbarItem(toolbar, "ToggleSnapToGrid", "OnToggleSnapToGrid", "Toggle Snap to Grid", "SnapToGrid", "Snap");
            this.addToolbarItem(toolbar, "SelectSeperator", "", "", "", "", "seperator");
            this.addToolbarItem(toolbar, "SelectTemplateBox", "OnSelectBox", "Select Box", "SelectTemplateBox", "Select Box");
            this.addToolbarItem(toolbar, "DrawTemplateBox", "OnDrawBox", "Draw Box", "DrawTemplateBox", "Draw Box");
            this.addToolbarItem(toolbar, "DeleteTemplateBox", "OnDeleteBox", "Delete Box", "DeleteTemplateBox", "Delete Box");
            this.addToolbarItem(toolbar, "AlignmentSeperator", "", "", "", "", "seperator");
            this.addToolbarItem(toolbar, "AlignLeft", "OnAlignLeft", "Align Left", "AlignLeft", "Align left");
            this._alignmentActions.push("AlignLeft" + this._toolbarKey);
            this.addToolbarItem(toolbar, "AlignRight", "OnAlignRight", "Align Right", "AlignRight", "Align right");
            this._alignmentActions.push("AlignRight" + this._toolbarKey);
            this.addToolbarItem(toolbar, "AlignCenter", "OnAlignCenter", "Align Center", "AlignCenter", "Align center");
            this._alignmentActions.push("AlignCenter" + this._toolbarKey);
            this.addToolbarItem(toolbar, "AlignTop", "OnAlignTop", "Align Top", "AlignTop", "Align top");
            this._alignmentActions.push("AlignTop" + this._toolbarKey);
            this.addToolbarItem(toolbar, "AlignBottom", "OnAlignBottom", "Align Bottom", "AlignBottom", "Align bottom");
            this._alignmentActions.push("AlignBottom" + this._toolbarKey);
            this.addToolbarItem(toolbar, "AlignMiddle", "OnAlignMiddle", "Align Middle", "AlignMiddle", "Align middle");
            this._alignmentActions.push("AlignMiddle" + this._toolbarKey);
            this.addToolbarItem(toolbar, "SameWidth", "OnMakeSameWidth", "Make Same Width", "MakeSameWidth", "Same Width");
            this._alignmentActions.push("SameWidth" + this._toolbarKey);
            this.addToolbarItem(toolbar, "SameHeight", "OnMakeSameHeight", "Make Same Height", "MakeSameHeight", "Same Height");
            this._alignmentActions.push("SameHeight" + this._toolbarKey);
            this.addToolbarItem(toolbar, "SameSize", "OnMakeSameSize", "Make Same Size", "MakeSameSize", "Same Size");
            this._alignmentActions.push("SameSize" + this._toolbarKey);
            this.addToolbarItem(toolbar, "ExportSeperator", "", "", "", "", "seperator");
            this.addToolbarItem(toolbar, "ExportTemplates", "OnExportTemplates", "Export All Templates", "ExportTemplates", "Export");
            this.addToolbarItem(toolbar, "ImportTemplates", "OnImportTemplates", "Import Templates", "ImportTemplates", "Import");
            this.addToolbarItem(toolbar, "ReturnToViewer", "OnReturnToViewer", "Return to viewer", "RotateCounterClock", "Return");
            this._scope.toolbars.push(toolbar);
        };
        TemplateEditorController.prototype.addToolbarItem = function (toolbar, id, action, tooltip, cssIconClass, caption, type) {
            var item;
            item = new Models.ToolbarItem();
            item.id = id;
            item.action = action;
            item.tooltip = tooltip;
            item.cssIconClass = cssIconClass;
            item.type = type || "button";
            item.caption = caption;
            toolbar.items.push(item);
        };
        TemplateEditorController.prototype.onSelect = function () {
            this._scope.editorConfig.editorMode = EditorMode.Select;
            this._toolbarService.press('SelectTemplateBox' + this._toolbarKey);
            this._toolbarService.unpress('DrawTemplateBox' + this._toolbarKey);
        };
        TemplateEditorController.prototype.onDraw = function () {
            this._scope.editorConfig.editorMode = EditorMode.Draw;
            this._toolbarService.unpress('SelectTemplateBox' + this._toolbarKey);
            this._toolbarService.press('DrawTemplateBox' + this._toolbarKey);
        };
        TemplateEditorController.prototype.onDeleteSelectedFrames = function () {
            var frames = this._templateEditorService.selectedFrames;
            if (this._scope.currentTemplate.Frames && frames) {
                var length = frames.length;
                for (var i = 0; i < length; i++) {
                    var index = this._scope.currentTemplate.Frames.indexOf(frames[i]);
                    if (index != -1) {
                        this._scope.currentTemplate.Frames.splice(index, 1);
                    }
                }
            }
        };
        TemplateEditorController.prototype.saveTemplate = function (afterSave) {
            var __this = this;
            if (this._scope.currentTemplate.Frames.length == 0) {
                alert("Template is Empty, it will not be saved.");
                return;
            }
            if (this._isNew) {
                this._templateService.AddTemplate(this._scope.currentTemplate).then(function () {
                    if (__this._isNew) {
                        __this._isNew = false;
                        delete (__this._scope.currentTemplate).isNew;
                    }
                    __this._isDirty = false;
                    __this.checkSave();
                    if (angular.isDefined(afterSave))
                        afterSave();
                    __this._dialogs.notify(__this._notifyTitle, __this._addMessage);
                }, function (error) {
                });
            }
            else {
                this._templateService.UpdateTemplate(this._scope.currentTemplate).then(function (result) {
                    if (result.data["FaultType"]) {
                        if (result.data["Message"]) {
                            alert(result.data["Message"]);
                        }
                    }
                    else {
                        __this._isDirty = false;
                        if (angular.isDefined(afterSave))
                            afterSave();
                        __this.checkSave();
                        __this._dialogs.notify(__this._notifyTitle, __this._updateMessage);
                    }
                }, function (error) {
                });
            }
        };
        TemplateEditorController.prototype.setNewTemplateProperties = function (newTemplate) {
            this._scope.currentTemplate = newTemplate;
            (this._scope.currentTemplate).isNew = true;
            this._scope.templates.push(this._scope.currentTemplate);
            this._templateEditorService.selectedFrames = [];
            this._scope.selectedFrames = [];
            this._scope.cancelMove = false;
            this._isNew = true;
            this._isDirty = true;
            this.checkSave();
            this.setTemplateProperties();
            this._toolbarService.enable(['DrawTemplateBox' + this._toolbarKey, 'DeleteTemplateBox' + this._toolbarKey], function () {
                return this.canDraw();
            }.bind(this));
            this._toolbarService.enable(['DeleteTemplateBox' + this._toolbarKey], function () {
                return this.canDraw() && (this._selectedFrames && this._selectedFrames.length) > 0;
            }.bind(this));
            this.onSelect();
        };
        TemplateEditorController.prototype.setCloneTemplateProperties = function (newTemplate) {
            this._scope.currentTemplate = newTemplate;
            (this._scope.currentTemplate).isNew = true;
            this._scope.templates.push(this._scope.currentTemplate);
            if (this._scope.currentTemplate.Frames && this._scope.currentTemplate.Frames.length > 0) {
                this._templateEditorService.selectedFrames = [this._scope.currentTemplate.Frames[0]];
                this._scope.selectedFrames = this._templateEditorService.selectedFrames;
                this.setFrameProperties(this._scope.selectedFrames[0]);
            }
            else
                this.setTemplateProperties();
            this._toolbarService.enable(['DrawTemplateBox' + this._toolbarKey], function () {
                return this.canDraw();
            }.bind(this));
            this._originalTemplate = angular.copy(newTemplate);
            this._isNew = true;
            this._isDirty = true;
            this.checkSave();
            this.onSelect();
        };
        TemplateEditorController.prototype.onNewTemplate = function () {
            var newTemplate = new Models.Template(this._newString + ' ' + this._templateString + " " + this.getDateTime());
            this.setNewTemplateProperties(newTemplate);
        };
        TemplateEditorController.prototype.onCopyTemplate = function () {
            var clonedTemplate = new Models.Template("Copy " + /*this._templateString +*/ " " + this.getDateTime());
            var currentTemplate = this._scope.currentTemplate;
            clonedTemplate.Modality = currentTemplate.Modality;
            clonedTemplate.Comments = currentTemplate.Comments;
            clonedTemplate.AutoMatching = currentTemplate.AutoMatching;
            clonedTemplate.BuiltIn = false;
            clonedTemplate.Hidden = false;
            ;
            clonedTemplate.Availability = Models.TemplateAvailability.SeriesAndStudy;
            for (var i = 0; i < this._scope.currentTemplate.Frames.length; i++) {
                var currentFrame = currentTemplate.Frames[i];
                var newFrame = new Models.Frame(currentFrame.Position);
                newFrame.FrameNumber = currentFrame.FrameNumber;
                newFrame.SequenceNumber = currentFrame.SequenceNumber;
                newFrame.Rotation = currentFrame.Rotation;
                newFrame.ImageComments = currentFrame.ImageComments;
                newFrame.Script = currentFrame.Script;
                newFrame.Flip = currentFrame.Flip;
                newFrame.Reverse = currentFrame.Reverse;
                newFrame.Invert = currentFrame.Invert;
                newFrame.HorizontalJustification = currentFrame.HorizontalJustification;
                newFrame.VerticalJustification = currentFrame.VerticalJustification;
                newFrame.PresentationSizeMode = currentFrame.PresentationSizeMode;
                newFrame.Magnification = currentFrame.Magnification;
                clonedTemplate.Frames.push(newFrame);
            }
            this.setCloneTemplateProperties(clonedTemplate);
        };
        TemplateEditorController.prototype.canSave = function () {
            return this._isDirty;
        };
        TemplateEditorController.prototype.canDraw = function () {
            return this._scope.currentTemplate != null && !this._scope.currentTemplate.BuiltIn && this._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
        };
        TemplateEditorController.prototype.canAdd = function () {
            return this._authenticationService.hasPermission(PermissionNames.CanAddTemplates);
        };
        TemplateEditorController.prototype.loadTemplate = function (template) {
            if (this._scope.currentTemplate == template)
                return;
            if (angular.isDefined((this._scope.currentTemplate).isNew)) {
                if (this._scope.currentTemplate.Frames.length == 0) {
                    var index = this._scope.templates.indexOf(this._scope.currentTemplate);
                    this._scope.templates.splice(index, 1);
                    this.load(template);
                }
            }
            if (this._isDirty) {
                this.confirmSave(function (save) {
                    if (save) {
                        this.saveTemplate(function () {
                            if (angular.isDefined((this._scope.currentTemplate).isNew)) {
                                delete (this._scope.currentTemplate).isNew;
                            }
                            this.load(template);
                        }.bind(this));
                    }
                    else {
                        this.load(template);
                    }
                }.bind(this));
            }
            else {
                this.load(template);
            }
        };
        TemplateEditorController.prototype.deleteCurrentTemplate = function () {
            var index = this._scope.templates.indexOf(this._scope.currentTemplate);
            if (index != -1) {
                this._scope.templates.splice(index, 1);
            }
            index = index - 1;
            if (index < 0)
                index = 0;
            if (this._scope.templates.length > 0) {
                this.load(this._scope.templates[index]);
            }
        };
        TemplateEditorController.prototype.onAlignLeft = function () {
            this.getAutomation().alignLefts();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onAlignRight = function () {
            this.getAutomation().alignRights();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onAlignCenter = function () {
            this.getAutomation().alignCenters();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onAlignTop = function () {
            this.getAutomation().alignTops();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onAlignBottom = function () {
            this.getAutomation().alignBottoms();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onAlignMiddle = function () {
            this.getAutomation().alignMiddles();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onMakeSameWidth = function () {
            this.getAutomation().makeSameWidth();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onMakeSameHeight = function () {
            this.getAutomation().makeSameHeight();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onMakeSameSize = function () {
            this.getAutomation().makeSameSize();
            this._scope.editorApi.updatePositions();
        };
        TemplateEditorController.prototype.onToggleGrid = function () {
            this.getAutomation().manager.snapToGridOptions.showGrid = !this.getAutomation().manager.snapToGridOptions.showGrid;
            this.setToggleGridState();
            this.getAutomation().invalidate(lt.LeadRectD.empty);
            this._optionsService.saveUserOption(OptionNames.ShowGrid, this.getAutomation().manager.snapToGridOptions.showGrid).success(function () {
                this._optionsService.set(OptionNames.ShowGrid, this.getAutomation().manager.snapToGridOptions.showGrid);
            }.bind(this)).
                error(function (error, status) {
            });
        };
        TemplateEditorController.prototype.setToggleGridState = function () {
            if (this.getAutomation().manager.snapToGridOptions.showGrid)
                this._toolbarService.press("ToggleGrid" + this._toolbarKey);
            else
                this._toolbarService.unpress("ToggleGrid" + this._toolbarKey);
        };
        TemplateEditorController.prototype.onToggleSnapToGrid = function () {
            this.getAutomation().manager.snapToGridOptions.enableSnap = !this.getAutomation().manager.snapToGridOptions.enableSnap;
            this.setToggleSnapToGridState();
            this._optionsService.saveUserOption(OptionNames.SnapToGrid, this.getAutomation().manager.snapToGridOptions.enableSnap).success(function () {
                this._optionsService.set(OptionNames.SnapToGrid, this.getAutomation().manager.snapToGridOptions.enableSnap);
            }.bind(this)).
                error(function (error, status) {
            });
        };
        TemplateEditorController.prototype.setToggleSnapToGridState = function () {
            if (this.getAutomation().manager.snapToGridOptions.enableSnap)
                this._toolbarService.press("ToggleSnapToGrid" + this._toolbarKey);
            else
                this._toolbarService.unpress("ToggleSnapToGrid" + this._toolbarKey);
        };
        TemplateEditorController.prototype.onReturnToViewer = function () {
            if (this._isDirty) {
                this.confirmSave(function (save) {
                    if (save) {
                        this.saveTemplate(function () {
                            if (angular.isDefined((this._scope.currentTemplate).isNew)) {
                                delete (this._scope.currentTemplate).isNew;
                            }
                            this.reload();
                        }.bind(this));
                    }
                    else {
                        this.reload();
                    }
                }.bind(this));
            }
            else {
                this.reload();
            }
        };
        TemplateEditorController.prototype.reload = function () {
            sessionStorage.setItem('AuthCode', this._authenticationService.authenticationCode);
            this._$window.location.reload();
        };
        TemplateEditorController.prototype.get_GetLineSpacing = function () {
            return this.getAutomation().manager.snapToGridOptions.lineSpacing;
        };
        TemplateEditorController.prototype.get_GridLength = function () {
            return this.getAutomation().manager.snapToGridOptions.gridLength;
        };
        TemplateEditorController.prototype.set_LineSpacing = function (size) {
            if (size != this.getAutomation().manager.snapToGridOptions.lineSpacing) {
                this.getAutomation().manager.snapToGridOptions.lineSpacing = size;
                this.getAutomation().invalidate(lt.LeadRectD.empty);
            }
        };
        TemplateEditorController.prototype.set_GridLength = function (size) {
            if (size != this.getAutomation().manager.snapToGridOptions.gridLength) {
                this.getAutomation().manager.snapToGridOptions.gridLength = size;
                this.getAutomation().invalidate(lt.LeadRectD.empty);
            }
        };
        TemplateEditorController.prototype.getAutomation = function () {
            return this._scope.editorApi.getAutomation();
        };
        TemplateEditorController.prototype.load = function (template) {
            this._scope.currentTemplate = template;
            this._scope.cancelMove = this._scope.currentTemplate.BuiltIn || !this._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
            if (this._scope.currentTemplate.Frames && this._scope.currentTemplate.Frames.length > 0) {
                this._templateEditorService.selectedFrames = [this._scope.currentTemplate.Frames[0]];
                this._scope.selectedFrames = this._templateEditorService.selectedFrames;
                this.setFrameProperties(this._scope.selectedFrames[0]);
            }
            else
                this.setTemplateProperties();
            this._toolbarService.enable(['DrawTemplateBox' + this._toolbarKey], function () {
                return this.canDraw();
            }.bind(this));
            this._originalTemplate = angular.copy(template);
            this._isDirty = false;
        };
        TemplateEditorController.prototype.onSelectedItemsChanged = function (frames) {
            var canDelete = false;
            if (frames.length == 0 || frames.length > 1) {
                this.setTemplateProperties();
                if (frames.length > 1) {
                    canDelete = true;
                }
            }
            else {
                this.setFrameProperties(frames[0]);
                canDelete = true;
                if (this._scope.editorConfig.editorMode == EditorMode.Draw) {
                    this._scope.editorConfig.editorMode = EditorMode.Select;
                    this._toolbarService.press('SelectTemplateBox' + this._toolbarKey);
                    this._toolbarService.unpress('DrawTemplateBox' + this._toolbarKey);
                }
            }
            this._toolbarService.enable(['DeleteTemplateBox' + this._toolbarKey], function () {
                return this.canDraw() && canDelete;
            }.bind(this));
            this._templateEditorService.selectedFrames = frames;
            if (frames.length > 1) {
                if (this._timerId == null) {
                    this._timerId = setInterval(this.onCheckAlignment.bind(this), 500);
                }
            }
            else {
                if (this._timerId != null) {
                    clearInterval(this._timerId);
                    this._timerId = null;
                    this._toolbarService.enable(this._alignmentActions, function () {
                        return false;
                    });
                }
            }
        };
        TemplateEditorController.prototype.onCheckAlignment = function () {
            var automation = this.getAutomation();
            if (automation.currentEditObject instanceof lt.Annotations.Engine.AnnSelectionObject) {
                var selectionObject = automation.currentEditObject;
                var canEdit = !this._scope.currentTemplate.BuiltIn && this._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
                this._toolbarService.enable(this._alignmentActions, function () {
                    return selectionObject.alignmentTarget != null && canEdit;
                });
            }
        };
        TemplateEditorController.prototype.onFrameChanged = function (frame, e) {
            this._isDirty = true;
            this.checkSave();
        };
        TemplateEditorController.prototype.onPropertyClicked = function (name, value) {
            var self = this;
            if (name == "Auto Match") {
                var modalInstance = this._modal.open({
                    templateUrl: 'views/dialogs/ScriptEditor.html',
                    controller: Controllers.ScriptEditorController,
                    backdrop: 'static',
                    size: 'lg',
                    resolve: {
                        label: function () {
                            return "Script";
                        },
                        text: function () {
                            if (self._scope.currentTemplate.AutoMatching) {
                                return self._scope.currentTemplate.AutoMatching;
                            }
                            else {
                                var scrptDefault = "//following is an auto generated sample script " +
                                    "\n//template will be applied automatically if the series number matches " +
                                    "\nvar ars = dicom['00200011'];//series number tag " +
                                    "\nvar success = false; " +
                                    "\nif (ars && ars.Value && ars.Value.length > 0) { " +
                                    "\nvar _val = ars.Value[0];" +
                                    "\nsuccess = _val == 'series_number_here';//have the to-be-matched series number here " +
                                    "\n} " +
                                    "\nsuccess == true";
                                return scrptDefault; //default script
                            }
                        },
                        readOnly: function () {
                            return false;
                        },
                    }
                });
                modalInstance.result.then(function (text) {
                    var oldText = self._scope.currentTemplate.AutoMatching;
                    if (oldText != text) {
                        self._scope.currentTemplate.AutoMatching = text;
                        self._isDirty = true;
                        self.checkSave();
                        self.setTemplateProperties();
                    }
                });
            }
        };
        TemplateEditorController.prototype.onPropertyChanged = function (name, value) {
            this._isDirty = true;
            switch (name) {
                case 'Rotation':
                    this._templateEditorService.selectedFrames[0].Rotation = this.getRotationValue(value);
                    break;
                case 'Comments':
                    if (this._templateEditorService.selectedFrames.length > 0) {
                        this._templateEditorService.selectedFrames[0].ImageComments = value;
                    }
                    else {
                        this._scope.currentTemplate.Comments = value;
                    }
                    break;
                case 'Auto Match':
                    this._scope.currentTemplate.AutoMatching = value;
                    break;
                case 'Auto Match Id':
                    var scrptDefault = "//following is an auto generated sample script " +
                        "\n//template will be applied automatically if the series number matches " +
                        "\nvar ars = dicom['00200011'];//series number tag " +
                        "\nvar success = false; " +
                        "\nif (ars && ars.Value && ars.Value.length > 0) { " +
                        "\nvar _val = ars.Value[0];" +
                        "\nsuccess = _val == '" + value + "';//have the to-be-matched series number here " +
                        "\n} " +
                        "\nsuccess == true";
                    this._scope.currentTemplate.AutoMatching = scrptDefault;
                    break;
                case 'Name':
                    this._scope.currentTemplate.Name = value;
                    break;
                case 'Availability':
                    this._scope.currentTemplate.Availability = this.set_availability(value);
                    break;
                /* Reserved for capture
                 *
                case 'Description':
                    this._templateEditorService.selectedFrames[0].AnatomicDescription = this.getAnatomicDescription(value);
                    this.setFrameProperties(this._templateEditorService.selectedFrames[0]);
                    break; */
                case 'SequenceNumber':
                    this._templateEditorService.selectedFrames[0].SequenceNumber = value;
                    break;
                case 'FrameNumber':
                    this._templateEditorService.selectedFrames[0].FrameNumber = value;
                    break;
                case 'Modality':
                    this._scope.currentTemplate.Modality = this.getModalityInfo(value);
                    break;
                case 'Flip':
                    this._templateEditorService.selectedFrames[0].Flip = Utils.toBoolean(value, false);
                    break;
                case 'Reverse':
                    this._templateEditorService.selectedFrames[0].Reverse = Utils.toBoolean(value, false);
                    break;
                case 'Invert':
                    this._templateEditorService.selectedFrames[0].Invert = Utils.toBoolean(value, false);
                    break;
                case 'Horizontal Justification':
                    this._templateEditorService.selectedFrames[0].HorizontalJustification = this.set_horizontalJustification(value);
                    break;
                case 'Vertical Justification':
                    this._templateEditorService.selectedFrames[0].VerticalJustification = this.set_verticalJustification(value);
                    break;
                case 'Presentation Size Mode':
                    this._templateEditorService.selectedFrames[0].PresentationSizeMode = this.set_presentationSizeMode(value);
                    break;
                case 'Magnification':
                    this._templateEditorService.selectedFrames[0].Magnification = value;
                    break;
            }
            this.checkSave();
        };
        TemplateEditorController.prototype.onNewFrame = function (frame) {
            this._isDirty = true;
            this.checkSave();
        };
        TemplateEditorController.prototype.renameTemplate = function (newName) {
            var oldName = this._scope.currentTemplate.Name;
            this._scope.currentTemplate.Name = newName;
            this._isDirty = oldName != newName;
            if (this._isDirty) {
                this.setTemplateProperties();
            }
            this.checkSave();
        };
        TemplateEditorController.prototype.checkSave = function () {
            this._toolbarService.enable("SaveTemplate" + this._toolbarKey, function () {
                return this._isDirty;
            }.bind(this));
        };
        TemplateEditorController.prototype.setTemplateProperties = function () {
            if (this._scope.currentTemplate) {
                var items = new Array();
                var item;
                var canEdit = !this._scope.currentTemplate.BuiltIn && this._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
                item = this.addProperty("Template", "input", "", "", "", this._scope.currentTemplate.Name, "Name");
                item.enabled = canEdit;
                items.push(item);
                item = this.addProperty("Template", "input", "", "", "", this._scope.currentTemplate.CreateDate, "Created");
                item.enabled = canEdit;
                items.push(item);
                item = this.addProperty("Template", "cdrop", "", this._templateEditorService.getModalityDescriptions(), "", this.getModality(this._scope.currentTemplate.Modality), "Modality");
                item.enabled = canEdit;
                items.push(item);
                item = this.addProperty("Template", "input", "", "", "", this._scope.currentTemplate.Comments != null ? this._scope.currentTemplate.Comments : "", "Comments");
                item.enabled = canEdit;
                items.push(item);
                item = this.addProperty("Template", "cdrop", "", "Not Available|Series Only|Study Only|Series and Study", "", this.get_availability(this._scope.currentTemplate.Availability), "Availability");
                item.enabled = true; // always enabled
                items.push(item);
                item = this.addProperty("Template", "dialog", "", "", "", this._scope.currentTemplate.AutoMatching ? "script" : "(empty)", "Auto Match");
                item.enabled = true; //always enabled
                items.push(item);
                item = this.addProperty("Template", "input", "", "", "", this.parseAutoMatchId(this._scope.currentTemplate.AutoMatching), "Auto Match Id");
                item.enabled = true;
                items.push(item);
                this._scope.propertyGridItems = items;
                if (!this._scope.$$phase) {
                    this._scope.$digest();
                }
            }
        };
        TemplateEditorController.prototype.parseAutoMatchId = function (script) {
            if (!script)
                return "";
            var txt1 = "success = _val == '";
            var txt2 = "'";
            var index1 = script.indexOf(txt1);
            if (index1 == -1)
                return "";
            index1 += txt1.length;
            var index2 = script.indexOf(txt2, index1);
            if (index2 == -1 || index2 <= index1)
                return "";
            return script.slice(index1, index2);
        };
        TemplateEditorController.prototype.updateSelectedFrameProperties = function () {
            this._scope.propertyGridItems[1].value = "hello";
        };
        TemplateEditorController.prototype.setFrameProperties = function (frame) {
            var items = new Array();
            var item;
            var canEdit = !this._scope.currentTemplate.BuiltIn && this._authenticationService.hasPermission(PermissionNames.CanEditTemplates);
            frame.readOnly = this._scope.currentTemplate.BuiltIn;
            item = this.addProperty("Template Frames", "num", "", "", "", frame.SequenceNumber, "SequenceNumber");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "num", "", "", "", frame.FrameNumber, "FrameNumber");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "0\xB0|90\xB0|180\xB0|270\xB0", "", Utils.getRotation(frame.Rotation), "Rotation");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "true|false", "", frame.Flip.toString(), "Flip");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "true|false", "", frame.Reverse.toString(), "Reverse");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "true|false", "", frame.Invert.toString(), "Invert");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "Left|Center|Right", "", this.get_horizontalJustification(frame.HorizontalJustification), "Horizontal Justification");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "Top|Center|Bottom", "", this.get_verticalJustification(frame.VerticalJustification), "Vertical Justification");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "cdrop", "", "Scale To Fit|True Size|Magnify", "", this.get_presentationSizeMode(frame.PresentationSizeMode), "Presentation Size Mode");
            item.enabled = canEdit;
            items.push(item);
            item = this.addProperty("Template Frames", "num", "", "", "", frame.Magnification, "Magnification");
            item.enabled = canEdit;
            items.push(item);
            /* Reserved for capture
              *
            item = this.addProperty("Anatomic Information", "cdrop", "", this._anatomicDescriptions, "", this.getAnatomicDescriptionItem(frame, "Name", "NONE"), "Description");
            item.enabled = !this._scope.currentTemplate.BuiltIn;
            items.push(item);
   
            item = this.addProperty("Anatomic Information", "input", "", "", "", this.getLaterality(frame), "Laterality");
            item.enabled = false;
            items.push(item);
   
            item = this.addProperty("Anatomic Information", "input", "", "", "", Utils.accessProperty(frame, "AnatomicDescription.AnatomicRegionSequence.CodeMeaning"), "Region");
            item.enabled = false;
            items.push(item);
   
            item = this.addProperty("Anatomic Information", "input", "", "", "", Utils.accessProperty(frame, "AnatomicDescription.AnatomicRegionModifierSequence.CodeMeaning"), "Modifer");
            item.enabled = false;
            items.push(item);
   
            item = this.addProperty("Anatomic Information", "input", "", "", "", frame.ImageComments != null ? frame.ImageComments : "", "Comments");*/
            item = this.addProperty("Template Frames", "input", "", "", "", frame.ImageComments != null ? frame.ImageComments : "", "Comments");
            item.enabled = canEdit;
            items.push(item);
            this._scope.propertyGridItems = items;
            if (!this._scope.$$phase) {
                this._scope.$digest();
            }
        };
        TemplateEditorController.prototype.getModality = function (modalityInfo) {
            var data = modalityInfo.split('|');
            var modalities;
            var defaultModalites = this._templateEditorService.getModalities();
            if (data.length == 0)
                return modalityInfo;
            if (data.length == 1) {
                modalities = $.grep(defaultModalites, function (modality, index) {
                    return modality.classType == data[0];
                });
            }
            else {
                modalities = $.grep(defaultModalites, function (modality, index) {
                    return modality.classType == data[0] && modality.description == data[1];
                });
            }
            if (modalities.length > 0)
                return modalities[0].name + ":" + modalities[0].description;
        };
        TemplateEditorController.prototype.getModalityInfo = function (modalityDescription) {
            var data = modalityDescription.split(":");
            var defaultModalites = this._templateEditorService.getModalities();
            if (data.length == 2) {
                var modalities = $.grep(defaultModalites, function (modality, index) {
                    return modality.name == data[0] && modality.description == data[1];
                });
                if (modalities.length > 0) {
                    var info = modalities[0].classType;
                    if (modalities[0].saveDescription)
                        info += "|" + modalities[0].description;
                    return info;
                }
            }
            return "";
        };
        TemplateEditorController.prototype.addProperty = function (groupName, rowType, cssName, drpFields, isSubGroup, value, propertyName) {
            var item = new PropertyGridItem();
            item.groupName = groupName;
            item.rowType = rowType;
            item.cssName = cssName;
            item.dropFields = drpFields;
            item.isSubGroup = isSubGroup;
            item.value = value;
            item.propertyName = propertyName;
            item.enabled = true;
            return item;
        };
        TemplateEditorController.prototype.getRotationValue = function (name) {
            switch (name) {
                case '180':
                    return Models.FrameRotation.Rotate180;
                case '270':
                    return Models.FrameRotation.Rotate270;
                case '90':
                    return Models.FrameRotation.Rotate90;
            }
            return Models.FrameRotation.None;
        };
        TemplateEditorController.prototype.getAnatomicDescriptionItem = function (frame, property, defaultValue) {
            if (!frame.AnatomicDescription)
                return defaultValue;
            if (frame.AnatomicDescription[property])
                return frame.AnatomicDescription[property].toString();
            return defaultValue;
        };
        TemplateEditorController.prototype.getLaterality = function (frame) {
            if (!frame.AnatomicDescription)
                return "NONE";
            switch (frame.AnatomicDescription.Laterality) {
                case Models.Laterality.Left:
                    return "Left";
                case Models.Laterality.Right:
                    return "Right";
                case Models.Laterality.Both:
                    return "Both";
            }
            return "Unknown";
        };
        TemplateEditorController.prototype.get_horizontalJustification = function (value) {
            switch (value) {
                case Models.FrameHorizontalJustification.Left:
                    return "LEFT";
                case Models.FrameHorizontalJustification.Right:
                    return "RIGHT";
                default:
                    return "CENTER";
            }
        };
        TemplateEditorController.prototype.set_horizontalJustification = function (value) {
            switch (value) {
                case "LEFT":
                    return Models.FrameHorizontalJustification.Left;
                case "RIGHT":
                    return Models.FrameHorizontalJustification.Right;
                default:
                    return Models.FrameHorizontalJustification.Center;
            }
        };
        TemplateEditorController.prototype.get_verticalJustification = function (value) {
            switch (value) {
                case Models.FrameVerticalJustification.Top:
                    return "TOP";
                case Models.FrameVerticalJustification.Bottom:
                    return "BOTTOM";
                default:
                    return "CENTER";
            }
        };
        TemplateEditorController.prototype.set_verticalJustification = function (value) {
            switch (value) {
                case "TOP":
                    return Models.FrameVerticalJustification.Top;
                case "BOTTOM":
                    return Models.FrameVerticalJustification.Bottom;
                default:
                    return Models.FrameVerticalJustification.Center;
            }
        };
        TemplateEditorController.prototype.get_availability = function (value) {
            switch (value) {
                case Models.TemplateAvailability.None:
                    return "Not Available";
                case Models.TemplateAvailability.Series:
                    return "Series Only";
                case Models.TemplateAvailability.Study:
                    return "Study Only";
                case Models.TemplateAvailability.SeriesAndStudy:
                    return "Series and Study";
                default:
                    return "Series Only";
            }
        };
        TemplateEditorController.prototype.set_availability = function (value) {
            switch (value) {
                case "Not Available":
                    return Models.TemplateAvailability.None;
                case "Series Only":
                    return Models.TemplateAvailability.Series;
                case "Study Only":
                    return Models.TemplateAvailability.Study;
                case "Series and Study":
                    return Models.TemplateAvailability.SeriesAndStudy;
                default:
                    return Models.TemplateAvailability.Series;
            }
        };
        TemplateEditorController.prototype.get_presentationSizeMode = function (value) {
            switch (value) {
                case Models.FramePresentationSizeMode.Magnify:
                    return "Magnify";
                case Models.FramePresentationSizeMode.TrueSize:
                    return "True Size";
                default:
                    return "Scale To Fit";
            }
        };
        TemplateEditorController.prototype.set_presentationSizeMode = function (value) {
            switch (value) {
                case "Magnify":
                    return Models.FramePresentationSizeMode.Magnify;
                case "True Size":
                    return Models.FramePresentationSizeMode.TrueSize;
                default:
                    return Models.FramePresentationSizeMode.ScaleToFit;
            }
        };
        /* Reserved for capture
         *
        private getAnatomicDescription(description: string): Models.AnatomicDescription {
            var length: number = this._descriptions.length;
  
            for (var index = 0; index < length; index++) {
                if (description == this._descriptions[index].Name) {
                    return this._descriptions[index];
                }
            }
  
            return null;
        }*/
        TemplateEditorController.prototype.confirmSave = function (success) {
            var __this = this;
            var modalInstance = this._modal.open({
                templateUrl: 'views/dialogs/Confirmation.html',
                controller: Controllers.ConfirmDialogControllerScope,
                backdrop: 'static',
                resolve: {
                    data: function () {
                        return {
                            header: 'Template Changed',
                            msg: 'Do you want to save changes',
                        };
                    }
                }
            });
            modalInstance.result.then(function (btn) {
                if (btn != 'cancel') {
                    if (btn == 'no') {
                        var index = __this._scope.templates.indexOf(__this._scope.currentTemplate);
                        if (index != -1) {
                            __this._scope.templates[index] = __this._originalTemplate;
                        }
                    }
                    success(btn == 'yes');
                }
            });
        };
        TemplateEditorController.prototype.templatesImported = function (event, data) {
            var newTemplates = this.getDiff(data.args.templates, this._scope.templates);
            if (newTemplates.length > 0) {
                data.args.templates.forEach(function (template) {
                    this._scope.templates.push(template);
                }.bind(this));
                if (!angular.isDefined(this._scope.currentTemplate)) {
                    this.load(this._scope.templates[0]);
                }
            }
        };
        TemplateEditorController.prototype.getDiff = function (a, b) {
            var oldIds = {};
            b.forEach(function (template) {
                return oldIds[template.Id] = template;
            });
            return a.filter(function (box) {
                return !(box.Id in oldIds);
            });
        };
        TemplateEditorController.prototype.getDateTime = function () {
            var DateJS = (new Date());
            var formattedString;
            formattedString = DateJS.toString(this._dateFormat + " " + this._timeFormat);
            return formattedString;
        };
        TemplateEditorController.$inject = ["$rootScope", "$scope", "templateEditorService", "$location", "templates", "$modal", "eventService", "$translate", "authenticationService", "templateService", "dialogs", "optionsService", "toolbarService", "$timeout", "$window", "$idle"];
        return TemplateEditorController;
    }());
    Controllers.TemplateEditorController = TemplateEditorController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var ConfirmDialogControllerScope = /** @class */ (function () {
        function ConfirmDialogControllerScope($scope, $modalInstance, $translate, data) {
            $scope.header = (angular.isDefined(data.header)) ? data.header : $translate.instant('DIALOGS_NOTIFICATION');
            $scope.msg = (angular.isDefined(data.msg)) ? data.msg : $translate.instant('DIALOGS_NOTIFICATION_MSG');
            $scope.icon = (angular.isDefined(data.icon)) ? data.icon : 'fa fa-info';
            $scope.no = function () {
                $modalInstance.close('no');
            }; // end close
            $scope.yes = function () {
                $modalInstance.close('yes');
            }; // end yes
            $scope.cancel = function () {
                $modalInstance.dismiss("cancel");
            };
        }
        ConfirmDialogControllerScope.$inject = ["$scope", "$modalInstance", "$translate", 'data'];
        return ConfirmDialogControllerScope;
    }());
    Controllers.ConfirmDialogControllerScope = ConfirmDialogControllerScope;
})(Controllers || (Controllers = {}));
commangular.command('OnNewTemplate', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onNewTemplate();
            }
        };
    }]);
commangular.command('OnCopyTemplate', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onCopyTemplate();
            }
        };
    }]);
commangular.command('OnSaveTemplate', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.saveTemplate();
            }
        };
    }]);
commangular.command('OnRenameTemplate', ['templateEditorService', '$modal', function (templateEditorService, $modal) {
        return {
            execute: function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/Prompt.html',
                    controller: Controllers.PromptController,
                    backdrop: 'static',
                    resolve: {
                        label: function () {
                            return "Rename Template";
                        },
                        text: function () {
                            return templateEditorService.templateEditController.currentTemplateName;
                        }
                    }
                });
                modalInstance.result.then(function (newName) {
                    templateEditorService.templateEditController.renameTemplate(newName);
                });
            }
        };
    }]);
commangular.command('OnDeleteBox', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onDeleteSelectedFrames();
            }
        };
    }]);
commangular.command('OnDeleteTemplate', ['templateEditorService', 'templateService', '$translate', 'dialogs', function (templateEditorService, templateService, $translate, dialogs) {
        return {
            execute: function () {
                var id = templateEditorService.templateEditController.currentTemplateId;
                var notifyTitle = 'Notification';
                var errorTitle = 'Error';
                var confirmation = 'Confirmation';
                var confirmationMessage = 'This will delete the selected template.\nAre you sure?';
                var successMessage = 'Current template successfully deleted';
                $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                    notifyTitle = translation;
                }.bind(this));
                $translate('DIALOGS_ERROR').then(function (translation) {
                    errorTitle = translation;
                }.bind(this));
                $translate('DIALOGS_TEMPLATE_DELETE').then(function (translation) {
                    successMessage = translation;
                }.bind(this));
                $translate('DIALOGS_CONFIRMATION_TITLE').then(function (translation) {
                    confirmation = translation;
                }.bind(this));
                $translate('DIALOGS_TEMPLATE_DELETE_CONFIRMATION').then(function (translation) {
                    confirmationMessage = translation;
                }.bind(this));
                var dlg = dialogs.confirm(confirmation, confirmationMessage);
                dlg.result.then(function (btn) {
                    templateService.DeleteTemplate(id).success(function () {
                        templateEditorService.templateEditController.deleteCurrentTemplate();
                        dialogs.notify(notifyTitle, successMessage);
                    }).error(function (error) {
                        dialogs.error(notifyTitle, error);
                    });
                });
            }
        };
    }]);
commangular.command('OnSelectBox', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onSelect();
            }
        };
    }]);
commangular.command('OnDrawBox', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onDraw();
            }
        };
    }]);
commangular.command('OnExportTemplates', ['templateService', function (templateService) {
        return {
            execute: function () {
                templateService.ExportAllTemplates();
            }
        };
    }]);
commangular.command('OnImportTemplates', ['templateEditorService', '$modal', function (templateEditorService, $modal) {
        return {
            execute: function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/Upload.html',
                    controller: Controllers.UploadController,
                    backdrop: 'static'
                });
            }
        };
    }]);
commangular.command('OnAlignLeft', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignLeft();
            }
        };
    }]);
commangular.command('OnAlignRight', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignRight();
            }
        };
    }]);
commangular.command('OnAlignCenter', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignCenter();
            }
        };
    }]);
commangular.command('OnAlignTop', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignTop();
            }
        };
    }]);
commangular.command('OnAlignBottom', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignBottom();
            }
        };
    }]);
commangular.command('OnAlignMiddle', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onAlignMiddle();
            }
        };
    }]);
commangular.command('OnMakeSameWidth', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onMakeSameWidth();
            }
        };
    }]);
commangular.command('OnMakeSameHeight', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onMakeSameHeight();
            }
        };
    }]);
commangular.command('OnMakeSameSize', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onMakeSameSize();
            }
        };
    }]);
commangular.command('OnConfigureGrid', ['templateEditorService', '$modal', 'optionsService', 'authenticationService', function (templateEditorService, $modal, optionsService, authenticationService) {
        return {
            execute: function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/GridSettings.html',
                    controller: Controllers.GridSettingsController,
                    backdrop: 'static',
                    resolve: {
                        label: function () {
                            return {
                                spacing: "Line Spacing",
                                length: "Grid Length"
                            };
                        },
                        spacing: function () {
                            var spacing = optionsService.get(OptionNames.GridSpacing);
                            if (!spacing)
                                spacing = templateEditorService.templateEditController.get_GetLineSpacing();
                            return spacing;
                        },
                        length: function () {
                            var length = optionsService.get(OptionNames.GridLength);
                            if (!length)
                                length = templateEditorService.templateEditController.get_GridLength();
                            return length;
                        },
                        title: function () {
                            return "Grid Settings";
                        }
                    }
                });
                modalInstance.result.then(function (settings) {
                    var value = optionsService.get(OptionNames.GridSpacing);
                    var length = optionsService.get(OptionNames.GridLength);
                    if (value != settings.spacing) {
                        templateEditorService.templateEditController.set_LineSpacing(settings.spacing);
                        optionsService.saveUserOption(OptionNames.GridSpacing, settings.spacing).success(function () {
                            optionsService.set(OptionNames.GridSpacing, settings.spacing);
                        }).
                            error(function (error, status) {
                        });
                    }
                    if (length != settings.length) {
                        templateEditorService.templateEditController.set_GridLength(settings.length);
                        optionsService.saveUserOption(OptionNames.GridLength, settings.length).success(function () {
                            optionsService.set(OptionNames.GridLength, settings.length);
                        }).
                            error(function (error, status) {
                        });
                    }
                });
            }
        };
    }]);
commangular.command('OnToggleGrid', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onToggleGrid();
            }
        };
    }]);
commangular.command('OnToggleSnapToGrid', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onToggleSnapToGrid();
            }
        };
    }]);
commangular.command('OnReturnToViewer', ['templateEditorService', function (templateEditorService) {
        return {
            execute: function () {
                templateEditorService.templateEditController.onReturnToViewer();
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UploadController = /** @class */ (function () {
        function UploadController($scope, $modalInstance, Upload, templateService, eventService, $translate, dialogs) {
            this.notifyTitle = 'Notification';
            this.errorTitle = 'Error';
            this.successMessage = 'Templates successfully imported';
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                this.notifyTitle = translation;
            }.bind(this));
            $translate('DIALOGS_ERROR').then(function (translation) {
                this.errorTitle = translation;
            }.bind(this));
            $translate('DIALOGS_TEMPLATES_IMPORTED').then(function (translation) {
                this.successMessage = translation;
            }.bind(this));
            $scope.file = '';
            $scope.uploadFile = this.uploadFile.bind(this);
            $scope.ok = function () {
                $modalInstance.close();
            };
            $scope.close = function () {
                $modalInstance.close();
            };
            $scope.cancel = function () {
                $modalInstance.close();
            };
            this._Upload = Upload;
            this._templateService = templateService;
            this._eventService = eventService;
            this._dialogs = dialogs;
        }
        UploadController.prototype.uploadFile = function (file) {
            var __this = this;
            this._templateService.ImportTemplates(this._Upload, file)
                .success(function (data, status, headers, config) {
                if (data.length == 1 && data[0].Id == 'GetImportTemplatesError_0F649AC6-0D07-49EA-906C-413256B8A43E') {
                    var errorString = "Import Failed: " + data[0].Name;
                    __this._dialogs.error(__this.errorTitle, errorString);
                }
                else {
                    __this._eventService.publish(EventNames.TemplatesImported, { templates: data });
                    __this._dialogs.notify(__this.notifyTitle, __this.successMessage);
                }
            })
                .error(function (data, status, headers, config, aaa, bbb, ccc, ddd) {
                __this._dialogs.error(__this.errorTitle, data);
            });
        };
        UploadController.$inject = ['$scope', '$modalInstance', 'Upload', 'templateService', 'eventService', '$translate', 'dialogs'];
        return UploadController;
    }());
    Controllers.UploadController = UploadController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UpdatePasswordController = /** @class */ (function () {
        function UpdatePasswordController($scope, optionsService, authenticationService, dialogs, $translate) {
            var __this = this;
            this._authenticationService = authenticationService;
            this._dialogs = dialogs;
            $scope.curPassword = '';
            $scope.password = '';
            $scope.confirmPassword = '';
            $scope.resetPassword = $.proxy(this.resetPassword, this);
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                __this._errorTitle = translation;
            });
            this._scope = $scope;
        }
        UpdatePasswordController.prototype.resetPassword = function (curPassword, password) {
            var __this = this;
            this._authenticationService.validatePassword(password).
                success(function (result) {
                if (result.length == 0) {
                    __this._authenticationService.resetCurrentPassword(curPassword, password).
                        success(function (result) {
                        if (result) {
                            __this._dialogs.notify(__this._notifyTitle, "Password changed successfully.");
                        }
                        else {
                            __this._dialogs.error(__this._errorTitle, "Failed to change password, make sure the current password is correct.");
                        }
                    }).
                        error(function (error) {
                        __this._dialogs.error(__this._errorTitle, error);
                    });
                }
                else {
                    __this._dialogs.error(__this._errorTitle, result);
                }
            }).
                error(function (error) {
                __this._dialogs.error(__this._errorTitle, error);
            });
        };
        UpdatePasswordController.$inject = ['$scope', 'optionsService', 'authenticationService', 'dialogs', '$translate', '$timeout'];
        return UpdatePasswordController;
    }());
    Controllers.UpdatePasswordController = UpdatePasswordController;
})(Controllers || (Controllers = {}));
if (!String.prototype.format) {
    String.prototype.format = function () {
        var args = arguments;
        return this.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined'
                ? args[number]
                : match;
        });
    };
}
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var lt;
(function (lt) {
    var Annotations;
    (function (Annotations) {
        var JavaScript;
        (function (JavaScript) {
            var AutomationControlMultiContainerMode;
            (function (AutomationControlMultiContainerMode) {
                AutomationControlMultiContainerMode[AutomationControlMultiContainerMode["SinglePage"] = 0] = "SinglePage";
                AutomationControlMultiContainerMode[AutomationControlMultiContainerMode["MultiPage"] = 1] = "MultiPage"; // One container per image viewer item
            })(AutomationControlMultiContainerMode = JavaScript.AutomationControlMultiContainerMode || (JavaScript.AutomationControlMultiContainerMode = {}));
            // this version of IAnnAutomationControl contains an image viewer
            var ImageViewerAutomationControl = /** @class */ (function () {
                function ImageViewerAutomationControl() {
                    var _this = this;
                    this._multiContainerMode = AutomationControlMultiContainerMode.SinglePage;
                    this.handleGotFocus = function () {
                        _this.automationGotFocus.invoke(_this, lt.LeadEventArgs.empty);
                    };
                    this.automationPointerDown = lt.LeadEvent.create(this, "automationPointerDown"); // read-only
                    this.automationPointerMove = lt.LeadEvent.create(this, "automationPointerMove"); // read-only
                    this.automationPointerUp = lt.LeadEvent.create(this, "automationPointerUp"); // read-only
                    this.automationDoubleClick = lt.LeadEvent.create(this, "automationDoubleClick"); // read-only
                    this.automationEnabledChanged = lt.LeadEvent.create(this, "automationEnabledChanged"); // read-only
                    //Automation Focus Event Handler
                    this.automationLostFocus = lt.LeadEvent.create(this, "automationLostFocus"); // read-only
                    this.automationGotFocus = lt.LeadEvent.create(this, "automationGotFocus"); // read-only
                    // Automation items properties
                    this.automationSizeChanged = lt.LeadEvent.create(this, "automationSizeChanged"); // read-only
                    this.imageViewer_ItemChanged = function (sender, e) {
                        switch (e.get_reason()) {
                            case lt.Controls.ImageViewerItemChangedReason.url:
                            case lt.Controls.ImageViewerItemChangedReason.image:
                            case lt.Controls.ImageViewerItemChangedReason.imageChanged:
                            case lt.Controls.ImageViewerItemChangedReason.size:
                            case lt.Controls.ImageViewerItemChangedReason.transform:
                                // Let the automation know the size of item has changed
                                if (_this.automationTransformChanged != null)
                                    _this.automationTransformChanged.invoke(_this, lt.LeadEventArgs.empty);
                                if (_this.automationSizeChanged != null)
                                    _this.automationSizeChanged.invoke(_this, lt.LeadEventArgs.empty);
                                break;
                            default:
                                break;
                        }
                    };
                    this.imageViewer_ActiveItemChanged = function (sender, e) {
                        _this.syncActiveItemContainer(true);
                    };
                    this.automationObject_ActiveContainerChanged = function (sender, e) {
                        _this.syncActiveItemContainer(false);
                    };
                    this.automationTransformChanged = lt.LeadEvent.create(this, "automationTransformChanged"); // read-only
                    this.imageViewer_TransformChanged = function (sender, e) {
                        // Let the automation know
                        if (_this.automationTransformChanged != null)
                            _this.automationTransformChanged.invoke(_this, lt.LeadEventArgs.empty);
                    };
                    this.automationUseDpiChanged = lt.LeadEvent.create(this, "automationUseDpiChanged"); // read-only
                    this.imageViewer_PropertyChanged = function (sender, e) {
                        switch (e.propertyName) {
                            case "UseDpi":
                                if (_this.automationUseDpiChanged != null)
                                    _this.automationUseDpiChanged.invoke(_this, lt.LeadEventArgs.empty);
                                break;
                            default:
                                break;
                        }
                    };
                    // Turn anti aliasing on and off
                    this.automationAntiAlias = false;
                    this.renderingEngine = null;
                    this.imageViewer_PostRender = function (sender, e) {
                        // Do we have a rendering engine?
                        var renderingEngine = _this.renderingEngine;
                        if (renderingEngine == null)
                            return;
                        var runMode = false;
                        if (_this.automationObject != null && _this.automationObject.manager != null)
                            runMode = (_this.automationObject.manager.userMode == lt.Annotations.Engine.AnnUserMode.run);
                        var context = e.get_context();
                        var saveSmoothingMode = context["msImageSmoothingEnabled"];
                        try {
                            // Set the anti alias mode
                            if (_this.get_automationAntiAlias()) {
                                if (!context["msImageSmoothingEnabled"])
                                    context["msImageSmoothingEnabled"] = true;
                            }
                            else {
                                if (context["msImageSmoothingEnabled"])
                                    context["msImageSmoothingEnabled"] = false;
                            }
                            // Do we have multiple containers?
                            var container;
                            if (_this.automationGetContainersCallback != null) {
                                // Yes, get the container for this item
                                var containers = _this.automationGetContainersCallback().toArray();
                                if (containers != null) {
                                    switch (_this._multiContainerMode) {
                                        case AutomationControlMultiContainerMode.MultiPage:
                                            // Each container belong to an item
                                            for (var index = 0; index < containers.length; index++) {
                                                if (index < _this._imageViewer.get_items().get_count()) {
                                                    var container = containers[index];
                                                    var item = _this._imageViewer.get_items().get_item(index);
                                                    var containerBounds = _this.automationObject.getContainerInvalidRect(container, true);
                                                    var intersects = !containerBounds.get_isEmpty();
                                                    if (intersects || !_this._imageViewer.getItemViewBounds(item, lt.Controls.ImageViewerItemPart.item, true).isEmpty)
                                                        lt.Annotations.JavaScript.ImageViewerAutomationControl.renderContainer(e, renderingEngine, container, runMode);
                                                }
                                            }
                                            break;
                                        case AutomationControlMultiContainerMode.SinglePage:
                                        default:
                                            // All containers belong to the active item
                                            if (_this._imageViewer.activeItem != null &&
                                                !_this._imageViewer.getItemViewBounds(_this._imageViewer.activeItem, lt.Controls.ImageViewerItemPart.item, true).isEmpty) {
                                                for (var index = 0; index < containers.length; index++) {
                                                    var container = containers[index];
                                                    var containerBounds = _this.automationObject.getContainerInvalidRect(container, true);
                                                    var intersects = !containerBounds.get_isEmpty();
                                                    if (intersects)
                                                        lt.Annotations.JavaScript.ImageViewerAutomationControl.renderContainer(e, renderingEngine, container, runMode);
                                                }
                                            }
                                            break;
                                    }
                                }
                            }
                            else {
                                // Using single-containers, just render the one the user set
                                container = _this._container;
                                if (container != null)
                                    lt.Annotations.JavaScript.ImageViewerAutomationControl.renderContainer(e, renderingEngine, container, runMode);
                            }
                        }
                        finally {
                            if (context["msImageSmoothingEnabled"] !== saveSmoothingMode)
                                context["msImageSmoothingEnabled"] = saveSmoothingMode;
                        }
                    };
                    this.automationContainerIndex = -1;
                    // Data provider for the images
                    this.automationDataProvider = new lt.Annotations.Engine.AnnDataProvider(); // read-only
                }
                Object.defineProperty(ImageViewerAutomationControl.prototype, "multiContainerMode", {
                    get: function () { return this._multiContainerMode; },
                    set: function (value) { this._multiContainerMode = value; },
                    enumerable: false,
                    configurable: true
                });
                ImageViewerAutomationControl.prototype.dispose = function () { this.unHook(); };
                Object.defineProperty(ImageViewerAutomationControl.prototype, "imageViewer", {
                    get: function () { return this._imageViewer; },
                    set: function (value) {
                        if (this._imageViewer != value) {
                            this.unHook();
                            this._imageViewer = value;
                            this.hook();
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                ImageViewerAutomationControl.prototype.hook = function () {
                    if (this._imageViewer == null)
                        return;
                    // Hook to the image viewer events we need
                    this._imageViewer.add_propertyChanged(this.imageViewer_PropertyChanged);
                    this._imageViewer.add_itemChanged(this.imageViewer_ItemChanged);
                    this._imageViewer.add_activeItemChanged(this.imageViewer_ActiveItemChanged);
                    this._imageViewer.add_transformChanged(this.imageViewer_TransformChanged);
                    this._imageViewer.add_postRender(this.imageViewer_PostRender);
                    this._imageViewer.get_interactiveService().add_tap(this.handleGotFocus);
                };
                ImageViewerAutomationControl.prototype.unHook = function () {
                    if (this._imageViewer == null)
                        return;
                    // Unhook from the image viewer events
                    this._imageViewer.remove_propertyChanged(this.imageViewer_PropertyChanged);
                    this._imageViewer.remove_itemChanged(this.imageViewer_ItemChanged);
                    this._imageViewer.remove_activeItemChanged(this.imageViewer_ActiveItemChanged);
                    this._imageViewer.remove_transformChanged(this.imageViewer_TransformChanged);
                    this._imageViewer.remove_postRender(this.imageViewer_PostRender);
                    this._imageViewer.get_interactiveService().remove_tap(this.handleGotFocus);
                    if (this.automationObject != null)
                        this.automationObject.remove_activeContainerChanged(this.automationObject_ActiveContainerChanged);
                };
                ImageViewerAutomationControl.prototype.get_automationObject = function () { return this.automationObject; };
                ImageViewerAutomationControl.prototype.set_automationObject = function (value) {
                    this.automationObject = value;
                    if (this.automationObject != null)
                        this.automationObject.remove_activeContainerChanged(this.automationObject_ActiveContainerChanged);
                    this.automationObject = value;
                    if (this.automationObject != null)
                        this.automationObject.add_activeContainerChanged(this.automationObject_ActiveContainerChanged);
                };
                ImageViewerAutomationControl.prototype.add_automationPointerDown = function (value) { this.automationPointerDown.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationPointerDown = function (value) { this.automationPointerDown.remove(value); };
                ImageViewerAutomationControl.prototype.add_automationPointerMove = function (value) { this.automationPointerMove.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationPointerMove = function (value) { this.automationPointerMove.remove(value); };
                ImageViewerAutomationControl.prototype.add_automationPointerUp = function (value) { this.automationPointerUp.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationPointerUp = function (value) { this.automationPointerUp.remove(value); };
                ImageViewerAutomationControl.prototype.add_automationDoubleClick = function (value) { this.automationDoubleClick.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationDoubleClick = function (value) { this.automationDoubleClick.remove(value); };
                ImageViewerAutomationControl.prototype.onAutomationPointerDown = function (args) {
                    if (this.automationPointerDown != null) {
                        this.automationPointerDown.invoke(this, args);
                    }
                };
                ImageViewerAutomationControl.prototype.onAutomationPointerMove = function (args) {
                    if (this.automationPointerMove != null)
                        this.automationPointerMove.invoke(this, args);
                };
                ImageViewerAutomationControl.prototype.onAutomationPointerUp = function (args) {
                    if (this.automationPointerUp != null)
                        this.automationPointerUp.invoke(this, args);
                };
                ImageViewerAutomationControl.prototype.onAutomationDoubleClick = function (args) {
                    if (this.automationDoubleClick != null)
                        this.automationDoubleClick.invoke(this, args);
                };
                ImageViewerAutomationControl.prototype.get_automationDpiX = function () { return this._imageViewer != null ? this._imageViewer.get_screenDpi().get_width() : 96; };
                ImageViewerAutomationControl.prototype.get_automationDpiY = function () { return this._imageViewer != null ? this._imageViewer.get_screenDpi().get_height() : 96; };
                ImageViewerAutomationControl.prototype.get_automationScaleFactor = function () { return 1; };
                ;
                ImageViewerAutomationControl.prototype.get_automationRotateAngle = function () { return 0; };
                ;
                ImageViewerAutomationControl.prototype.get_isAutomationEventsHooked = function () { return false; };
                ;
                ImageViewerAutomationControl.prototype.set_isAutomationEventsHooked = function (value) { };
                ;
                ImageViewerAutomationControl.prototype.get_automationEnabled = function () { return true; };
                ImageViewerAutomationControl.prototype.add_automationEnabledChanged = function (value) { this.automationEnabledChanged.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationEnabledChanged = function (value) { this.automationEnabledChanged.remove(value); };
                ImageViewerAutomationControl.prototype.onEnabledChanged = function (e) {
                    if (this.automationEnabledChanged != null)
                        this.automationEnabledChanged.invoke(this, lt.LeadEventArgs.empty);
                };
                ImageViewerAutomationControl.prototype.add_automationLostFocus = function (value) { this.automationLostFocus.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationLostFocus = function (value) { this.automationLostFocus.remove(value); };
                ImageViewerAutomationControl.prototype.add_automationGotFocus = function (value) { this.automationGotFocus.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationGotFocus = function (value) { this.automationGotFocus.remove(value); };
                ImageViewerAutomationControl.prototype.add_automationSizeChanged = function (value) { this.automationSizeChanged.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationSizeChanged = function (value) { this.automationSizeChanged.remove(value); };
                ImageViewerAutomationControl.prototype.syncActiveItemContainer = function (fromViewer) {
                    // Ensure that both the image viewer and automation active "item" is the same
                    if (this.automationObject == null || this._imageViewer == null)
                        return;
                    var itemsCount = this._imageViewer.get_items().get_count();
                    var containersCount = this.automationObject.get_containers().get_count();
                    if (itemsCount == 0 || itemsCount != containersCount)
                        return;
                    var imageViewerIndex = this._imageViewer.get_items().indexOf(this._imageViewer.get_activeItem());
                    var containerIndex = -1;
                    if (this.automationObject.get_activeContainer() != null)
                        containerIndex = this.automationObject.get_containers().indexOf(this.automationObject.get_activeContainer());
                    if (imageViewerIndex != containerIndex) {
                        if (fromViewer) {
                            if (imageViewerIndex != -1)
                                this.automationObject.set_activeContainer(this.automationObject.get_containers().get_item(imageViewerIndex));
                        }
                        else {
                            if (containerIndex != -1)
                                this._imageViewer.set_activeItem(this._imageViewer.get_items().get_item(containerIndex));
                        }
                    }
                };
                ImageViewerAutomationControl.prototype.getItemForCurrentContainer = function () {
                    if (this._imageViewer == null)
                        return null;
                    // Multiple container support?
                    if (this.automationContainerIndex != -1) {
                        // Yes, get the item
                        switch (this._multiContainerMode) {
                            case AutomationControlMultiContainerMode.MultiPage:
                                // One container for each item
                                // Sanity check
                                if (this.automationContainerIndex >= 0 && this.automationContainerIndex < this._imageViewer.get_items().get_count())
                                    return this._imageViewer.get_items().get_item(this.automationContainerIndex);
                                return null;
                            case AutomationControlMultiContainerMode.SinglePage:
                            default:
                                // All containers belong to the first item
                                return this._imageViewer.activeItem;
                        }
                    }
                    else {
                        // No, active item
                        return this._imageViewer.activeItem;
                    }
                };
                ImageViewerAutomationControl.prototype.getCurrentContainer = function () {
                    if (this.automationObject != null && this.automationContainerIndex != -1)
                        return this.automationObject.get_containers().get_item(this.automationContainerIndex);
                    return null;
                };
                ImageViewerAutomationControl.prototype.get_automationTransform = function () {
                    var item = this.getItemForCurrentContainer();
                    var container = this.getCurrentContainer();
                    if (item != null) {
                        return this._imageViewer.getItemImageTransformWithDpi(item, false);
                    }
                    else
                        return lt.LeadMatrix.identity;
                };
                ImageViewerAutomationControl.prototype.add_automationTransformChanged = function (value) { this.automationTransformChanged.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationTransformChanged = function (value) { this.automationTransformChanged.remove(value); };
                ImageViewerAutomationControl.prototype.get_automationUseDpi = function () { return this._imageViewer != null && this._imageViewer.get_useDpi(); };
                ImageViewerAutomationControl.prototype.add_automationUseDpiChanged = function (value) { this.automationUseDpiChanged.add(value); };
                ImageViewerAutomationControl.prototype.remove_automationUseDpiChanged = function (value) { this.automationUseDpiChanged.remove(value); };
                ImageViewerAutomationControl.prototype.get_automationXResolution = function () {
                    var item = this.getItemForCurrentContainer();
                    if (item != null)
                        return item.get_resolution().get_width();
                    else
                        return 96.0;
                };
                ImageViewerAutomationControl.prototype.get_automationYResolution = function () {
                    var item = this.getItemForCurrentContainer();
                    if (item != null)
                        return item.get_resolution().get_height();
                    else
                        return 96.0;
                };
                // Rendering
                ImageViewerAutomationControl.prototype.automationInvalidate = function (rc) {
                    // Invalidate the viewer
                    if (this._imageViewer != null) {
                        this._imageViewer.invalidate(rc);
                    }
                };
                ImageViewerAutomationControl.prototype.get_automationAntiAlias = function () { return this.automationAntiAlias; };
                ImageViewerAutomationControl.prototype.set_automationAntiAlias = function (value) {
                    this.automationAntiAlias = value;
                    if (this._imageViewer) {
                        this._imageViewer.invalidate(lt.LeadRectD.empty);
                    }
                };
                ImageViewerAutomationControl.prototype.get_renderingEngine = function () { return this.renderingEngine; };
                ImageViewerAutomationControl.prototype.set_renderingEngine = function (value) { this.renderingEngine = value; };
                ImageViewerAutomationControl.renderContainer = function (e, renderingEngine, container, runMode) {
                    // Attach to the current container and context.
                    var context = e.get_context();
                    var clipRectangle = e.get_clipRectangle();
                    // Render the annotatirons
                    renderingEngine.attach(container, context);
                    try {
                        // Convert the clip rectangle to annotation coordinates
                        var annClipRect = container.mapper.rectToContainerCoordinates(clipRectangle);
                        renderingEngine.render(annClipRect, runMode);
                    }
                    finally {
                        renderingEngine.detach();
                    }
                };
                ImageViewerAutomationControl.prototype.get_automationGetContainersCallback = function () { return this.automationGetContainersCallback; };
                ImageViewerAutomationControl.prototype.set_automationGetContainersCallback = function (value) { this.automationGetContainersCallback = value; };
                ImageViewerAutomationControl.prototype.get_automationContainerIndex = function () { return this.automationContainerIndex; };
                ImageViewerAutomationControl.prototype.set_automationContainerIndex = function (value) { this.automationContainerIndex = value; };
                ImageViewerAutomationControl.prototype.automationAttach = function (container) { this._container = container; };
                ImageViewerAutomationControl.prototype.automationDetach = function () { this._container = null; };
                ImageViewerAutomationControl.prototype.get_automationDataProvider = function () { return this.automationDataProvider; };
                ImageViewerAutomationControl.prototype.set_automationDataProvider = function (value) { this.automationDataProvider = value; };
                ImageViewerAutomationControl.prototype.get_automationScrollOffset = function () {
                    return this._imageViewer != null ? this._imageViewer.get_scrollOffset() : lt.LeadPointD.create(0, 0);
                };
                return ImageViewerAutomationControl;
            }());
            JavaScript.ImageViewerAutomationControl = ImageViewerAutomationControl;
        })(JavaScript = Annotations.JavaScript || (Annotations.JavaScript = {}));
    })(Annotations = lt.Annotations || (lt.Annotations = {}));
})(lt || (lt = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../lib/angular/angular.d.ts" />
/// <reference path="../lib/angular/angular-route.d.ts" />
// <reference path="../Scripts/Controllers/MedicalWebViewerController.ts" />
// <reference path="../Scripts/Controllers/LoginController.ts" />
// <reference path="../Scripts/ExternalCommand/SharedPropertiesService.ts" />
// <reference path="../Scripts/services/OptionsService.ts" />
// <reference path="../Scripts/services/ToolbarService.ts" />
// <reference path="../Scripts/controllers/MedicalWebViewerController.ts" />
// <reference path="../Scripts/externalCommand/SharedPropertiesService.ts" />
// <reference path="../Scripts/services/AuditLogService.ts" />
// <reference path="../Scripts/controllers/TemplateEditorController.ts" />
agGrid.initialiseAgGridWithAngular1(angular);
//
// Register all of the required modules for the application.
//
var app = angular.module("MedicalWebViewer", ['controllers', 'services', 'directives', 'filters', 'ui.bootstrap', 'ngAnimate', 'ngRoute', 'angular-loading-bar',
    'ngIdle', 'blockUI', 'colorpicker.module', 'dialogs.main', 'ngSanitize', 'pascalprecht.translate', 'commangular', 'cfp.hotkeys', 'ui.slider',
    'ui.grid', 'ui.grid.selection', 'ui.grid.expandable', 'ui.grid.autoResize', 'ui.grid.pinning', 'ui.grid.autoResize', 'ui.grid.pagination', 'agGrid',
    'ngFileUpload', 'ui.codemirror', 'angularNumberPicker', 'multiStepForm', 'isteven-multi-select', 'ngPatternRestrict']);
var controllers = angular.module('controllers', []);
var services = angular.module('services', []);
var directives = angular.module('directives', []);
var filters = angular.module('filters', []);
var providers = angular.module('providers', []);
var commangularProvider;
var _jsFileCorePath = "Scripts/LEADTOOLS/Leadtools.ImageProcessing.Core.js";
var _jsFileCoreColorPath = "Scripts/LEADTOOLS/Leadtools.ImageProcessing.Color.js";
app.config(["app.config", "$routeProvider", "$locationProvider", "cfpLoadingBarProvider", "$idleProvider", "blockUIConfigProvider", "dialogsProvider", "$translateProvider", "$commangularProvider", "$httpProvider", "$keepaliveProvider", "$controllerProvider",
    function (config, $routeProvider, $locationProvider, cfpLoadingBarProvider, $idleProvider, blockUIConfigProvider, dialogsProvider, $translateProvider, $commangularProvider, $httpProvider, $keepaliveProvider, $controllerProvider) {
        cfpLoadingBarProvider.includeSpinner = false;
        commangularProvider = $commangularProvider;
        $controllerProvider.allowGlobals();
        $httpProvider.interceptors.push('authInterceptor');
        function initIdleProvider(optionsService, $idle, $keepalive) {
            var enableIdleTimer = optionsService.get(OptionNames.EnableIdleTimeout);
            //
            // This initialize the idle timer. Idle timer provide by:
            // http://hackedbychinese.github.io/ng-idle/
            //
            if (enableIdleTimer) {
                $idleProvider.idleDuration(optionsService.get(OptionNames.IdleTimeout));
                $idleProvider.warningDuration(optionsService.get(OptionNames.IdleWarningDuration));
                $idle.watch();
            }
            $keepaliveProvider.http('HeartBeat.html');
            $keepalive.start();
            if (config.runAsEval) {
                lt.RasterSupport.setLicenseUri("https://demo.leadtools.com/licenses/js/LEADTOOLSEVAL.txt", "EVAL", function () {
                    if (!lt.RasterSupport.kernelExpired) {
                        lt.LTHelper.log("LEADTOOLS client license set successfully");
                    }
                    else {
                        var msg = "No LEADTOOLS License\n\nYour license file is missing, invalid or expired. LEADTOOLS will not function. Please contact LEAD Sales for information on obtaining a valid license.";
                        alert(msg);
                    }
                });
            }
            else {
                lt.RasterSupport.setLicenseUri(null, null, function () {
                    if (!lt.RasterSupport.kernelExpired) {
                        lt.LTHelper.log("License was set successfully");
                    }
                    else {
                        var msg = "No license was found!\n\nYour license file is missing, invalid or expired. This web application will not function.";
                        alert(msg);
                        $.removeCookie("User", { path: '/' });
                        $.removeCookie("Pass", { path: '/' });
                        window.location.reload();
                    }
                });
            }
        }
        //
        // Register the toolbar commands.
        //
        function registerCommands(toolbarService) {
            if (commangularProvider) {
                var commands = toolbarService.getCommands();
                //
                // Register commands provided by the toolbar.json that is stored in the options table
                //
                angular.forEach(commands, function (value, key) {
                    commangularProvider.mapTo(value)
                        .asSequence()
                        .add(value);
                });
            }
            function registerCommand(action) {
                commangularProvider.mapTo(action)
                    .asSequence()
                    .add(action);
            }
            //
            // Register any additional commands that will be used but not provided by the toolbar json
            //
            registerCommand('Compare');
            registerCommand('OnNewTemplate');
            registerCommand('OnCopyTemplate');
            registerCommand('OnSaveTemplate');
            registerCommand('OnRenameTemplate');
            registerCommand('OnDeleteTemplate');
            registerCommand('OnConfigureGrid');
            registerCommand('OnToggleGrid');
            registerCommand('OnToggleSnapToGrid');
            registerCommand('OnSelectBox');
            registerCommand('OnDrawBox');
            registerCommand('OnDeleteBox');
            registerCommand('OnExportTemplates');
            registerCommand('OnImportTemplates');
            registerCommand('OnAlignLeft');
            registerCommand('OnAlignRight');
            registerCommand('OnAlignCenter');
            registerCommand('OnAlignTop');
            registerCommand('OnAlignBottom');
            registerCommand('OnAlignMiddle');
            registerCommand('OnMakeSameWidth');
            registerCommand('OnMakeSameHeight');
            registerCommand('OnMakeSameSize');
            registerCommand('OnReturnToViewer');
        }
        //
        // Configures the routes for this application
        // https://code.angularjs.org/1.3.9/docs/api/ngRoute/provider/$routeProvider
        //
        $routeProvider.when('/', {
            templateUrl: 'views/medicalviewer.html',
            controller: Controllers.MedicalWebViewerController,
            caseInsensitiveMatch: true,
            resolve: {
                getOptions: ["$q", "sharedPropertiesService", "optionsService", "$http", "$idle", "toolbarService", "auditLogService", "$keepalive", function ($q, sharedPropertiesService, optionsService, $http, $idle, toolbarService, auditLogService, $keepalive) {
                        var deferred = $q.defer();
                        //
                        // Get the user options
                        //
                        optionsService.GetUserOptions(function (options) {
                            initIdleProvider(optionsService, $idle, $keepalive);
                            registerCommands(toolbarService);
                            auditLogService.log_launch();
                            deferred.resolve(options);
                        }, function (data, status, headers, config) {
                            initIdleProvider(optionsService, $idle, $keepalive);
                            deferred.resolve(null);
                        });
                        return deferred.promise;
                    }]
            }
        })
            .when('/login', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                deferredQ: ["$q", function ($q) {
                        return $q;
                    }],
                getOptions: ["$q", "sharedPropertiesService", "optionsService", "$http", "$idle", "toolbarService", "auditLogService", "$keepalive", function ($q, sharedPropertiesService, optionsService, $http, $idle, toolbarService, auditLogService, $keepalive) {
                        var deferred = $q.defer();
                        //
                        // Get the user options - only sign-in required options - no auth cookie yet
                        //
                        optionsService.GetUserOptions(function (options) {
                            deferred.resolve(options);
                        }, function (data, status, headers, config) {
                            deferred.resolve(null);
                        });
                        return deferred.promise;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", function ($q, authenticationService, eventService) {
                        LogUtils.DebugLog("--- $routeProvider [/login]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            var user = $.cookie("User");
                            var pass = $.cookie("Pass");
                            var token = sessionStorage.getItem('AuthCode');
                            //
                            // If the authentication was unsuccessful the application will remain on the login screen
                            //
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                deferred.resolve(false);
                            });
                            //
                            // If authentication was successful that application will continue.
                            //
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                deferred.resolve(true);
                            });
                            if (token != null && token.length > 0) {
                                sessionStorage.removeItem('AuthCode');
                                authenticationService.getAuthenticationInfo(token, "").success(function (authenticationInfoResult) {
                                    var result = authenticationInfoResult;
                                    //
                                    // This is only possible if the user has selected the Remember Me option on the login screen
                                    //
                                    document.getElementById('verionNumberFooter').innerHTML = "";
                                    authenticationService.autologin(result.UserName, token);
                                    return deferred.promise;
                                }).error(function (error) {
                                    LogUtils.DebugLog("getAuthenticationInfo error");
                                });
                            }
                            else {
                                if ((user && user.length > 0) && (pass && pass.length > 0)) {
                                    authenticationService.login(user, pass, false);
                                    return deferred.promise;
                                }
                            }
                        }
                    }]
            }
        })
            .when('/login/autologin/:externalControlPort/:token*', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                deferredQ: ["$q", function ($q) {
                        return $q;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", "sharedPropertiesService", "$route", function ($q, authenticationService, eventService, sharedPropertiesService, $route) {
                        LogUtils.DebugLog("--- $routeProvider [/login/autologin]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            var user = $.cookie("User");
                            var pass = $.cookie("Pass");
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                sharedPropertiesService.SetExternalControlMode(false);
                                deferred.resolve(false);
                            });
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                sharedPropertiesService.SetExternalControlMode(true);
                                deferred.resolve(true);
                            });
                            LogUtils.DebugLog("   calling getAuthenticationInfo: ");
                            LogUtils.DebugLog("   $route.current.params.token: " + $route.current.params.token);
                            var myAuthenticationInfoResult;
                            authenticationService.getAuthenticationInfo($route.current.params.token, "").success(function (authenticationInfoResult) {
                                myAuthenticationInfoResult = authenticationInfoResult;
                                sharedPropertiesService.SetToken($route.current.params.token);
                                var externalControlPort = Number($route.current.params.externalControlPort);
                                sharedPropertiesService.SetPort(externalControlPort);
                                sharedPropertiesService.SetPolling(externalControlPort != 0);
                                authenticationService.autologin(myAuthenticationInfoResult.UserName, $route.current.params.token);
                                return deferred.promise;
                            }).error(function (error) {
                                LogUtils.DebugLog("getAuthenticationInfo error");
                            });
                        }
                    }]
            }
        })
            .when('/login/automate/:token*', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                deferredQ: ["$q", function ($q) {
                        return $q;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", "sharedPropertiesService", "$route", function ($q, authenticationService, eventService, sharedPropertiesService, $route) {
                        LogUtils.DebugLog("--- $routeProvider [/automate]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                sharedPropertiesService.SetAutoMode(false);
                                deferred.resolve(false);
                            });
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                sharedPropertiesService.SetAutoMode(true);
                                deferred.resolve(true);
                            });
                            LogUtils.DebugLog("   calling getAuthenticationInfo: ");
                            LogUtils.DebugLog("   $route.current.params.token: " + $route.current.params.token);
                            var myAuthenticationInfoResult;
                            authenticationService.getAuthenticationInfo($route.current.params.token, "").success(function (authenticationInfoResult) {
                                myAuthenticationInfoResult = authenticationInfoResult;
                                sharedPropertiesService.SetToken($route.current.params.token);
                                sharedPropertiesService.SetPolling(true);
                                authenticationService.autologin(myAuthenticationInfoResult.UserName, $route.current.params.token);
                                return deferred.promise;
                            }).error(function (error) {
                                LogUtils.DebugLog("getAuthenticationInfo error");
                            });
                        }
                    }]
            }
        })
            .when('/login/auto/:protocol/:token*', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                deferredQ: ["$q", function ($q) {
                        return $q;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", "sharedPropertiesService", "$route",
                    function ($q, authenticationService, eventService, sharedPropertiesService, $route) {
                        LogUtils.DebugLog("--- $routeProvider [/automate-v2.0]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                sharedPropertiesService.SetAutoMode(false);
                                deferred.resolve(false);
                            });
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                sharedPropertiesService.SetAutoMode(true);
                                deferred.resolve(true);
                            });
                            LogUtils.DebugLog("   calling tempAuthenticate: ");
                            LogUtils.DebugLog("   $route.current.params.protocol: " + $route.current.params.protocol);
                            LogUtils.DebugLog("   $route.current.params.token: " + $route.current.params.token);
                            authenticationService.isTempAuthentication = true;
                        }
                    }]
            }
        })
            .when('/login/autoExternal/:protocol/:token*', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                deferredQ: ["$q", function ($q) {
                        return $q;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", "sharedPropertiesService", "$route",
                    function ($q, authenticationService, eventService, sharedPropertiesService, $route) {
                        LogUtils.DebugLog("--- $routeProvider [/automate-v2.0]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                sharedPropertiesService.SetAutoMode(false);
                                deferred.resolve(false);
                            });
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                sharedPropertiesService.SetAutoMode(true);
                                deferred.resolve(true);
                            });
                            LogUtils.DebugLog("   calling tempAuthenticate: ");
                            LogUtils.DebugLog("   $route.current.params.protocol: " + $route.current.params.protocol);
                            LogUtils.DebugLog("   $route.current.params.token: " + $route.current.params.token);
                            authenticationService.isExternalAuthentication = true;
                        }
                    }]
            }
        })
            .when('/login/implicit/:protocol/:token*', {
            templateUrl: 'views/login.html',
            caseInsensitiveMatch: true,
            controller: Controllers.LoginController,
            resolve: {
                linkToken: ["$route", function ($route) {
                        return $route.current.params.token;
                    }],
                linkProtocol: ["$route", function ($route) {
                        return $route.current.params.protocol;
                    }],
                sharedProperties: ["sharedPropertiesService", function (sharedPropertiesService) {
                        return sharedPropertiesService;
                    }],
                q: ["$q", function ($q) {
                        return $q;
                    }],
                loggedIn: ["$q", "authenticationService", "eventService", "sharedPropertiesService", "$route", function ($q, authenticationService, eventService, sharedPropertiesService, $route) {
                        LogUtils.DebugLog("--- $routeProvider [/automate-v2.0]");
                        if (!authenticationService.isAuthenticated()) {
                            var deferred = $q.defer();
                            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                                sharedPropertiesService.SetAutoMode(false);
                                deferred.resolve(false);
                            });
                            eventService.subscribe("AuthenticationService/AuthenticationSuccess", function (event, data) {
                                sharedPropertiesService.SetAutoMode(true);
                                deferred.resolve(true);
                            });
                            LogUtils.DebugLog("   calling implicitAuthenticate: ");
                            LogUtils.DebugLog("   $route.current.params.protocol: " + $route.current.params.protocol);
                            LogUtils.DebugLog("   $route.current.params.token: " + $route.current.params.token);
                            var myAuthenticationInfoResult;
                            authenticationService.implicitAuthenticate($route.current.params.token, $route.current.params.protocol).success(function (authenticationInfoResult) {
                                myAuthenticationInfoResult = authenticationInfoResult;
                                sharedPropertiesService.SetToken(authenticationInfoResult.Cookie);
                                authenticationService.autologin(myAuthenticationInfoResult.UserName, authenticationInfoResult.Cookie);
                                return deferred.promise;
                            })
                                .error(function (error) {
                                LogUtils.DebugLog("implicitAuthenticate error");
                                if (error)
                                    if (error.Message)
                                        alert(error.Message);
                                    else
                                        alert(error);
                                sharedPropertiesService.SetAutoMode(false);
                                deferred.resolve(false);
                                $.removeCookie("User", { path: '/' });
                                $.removeCookie("Pass", { path: '/' });
                                sessionStorage.removeItem('AuthCode');
                                window.location.href = window.location.href.split("/#")[0];
                            });
                        }
                    }]
            }
        })
            .when('/templateEditor', {
            templateUrl: 'views/TemplateEditorView.html',
            controller: Controllers.TemplateEditorController,
            caseInsensitiveMatch: true,
            resolve: {
                templates: ["$q", "templateService", "optionsService", function ($q, templateService, optionsService) {
                        var deferred = $q.defer();
                        templateService.GetAllTemplates().success(function (data) {
                            deferred.resolve(data);
                        }).error(function () {
                            deferred.resolve(null);
                        });
                        return deferred.promise;
                    }]
            }
        })
            .otherwise({
            //retirectTo: '/' 
            redirectTo: function (params, currentPath) {
                var newPath = '/login';
                LogUtils.DebugLog("--- $routeProvider [otherwise]: " + currentPath + "--> " + newPath);
                return newPath;
            }
        });
        // $locationProvider.html5Mode(true).hashPrefix('!');
        blockUIConfigProvider.autoBlock(false);
        blockUIConfigProvider.delay(0);
        blockUIConfigProvider.message('Please wait...');
        dialogsProvider.useBackdrop('static');
        dialogsProvider.useEscClose(false);
        dialogsProvider.useCopy(false);
        dialogsProvider.setSize('sm');
        $translateProvider.useStaticFilesLoader({
            prefix: 'languages/',
            suffix: '.json'
        });
        $translateProvider.preferredLanguage('en-US');
    }]);
app.factory('safeApply', [function ($rootScope) {
        return function ($scope, fn) {
            var phase = $scope.$root.$$phase;
            if (phase == '$apply' || phase == '$digest') {
                if (fn) {
                    $scope.$eval(fn);
                }
            }
            else {
                if (fn) {
                    $scope.$apply(fn);
                }
                else {
                    $scope.$apply();
                }
            }
        };
    }]);
//
// Create an interceptor that will test to see if the user's session has expired.  If it has the user will be automatically
// logged out of the application
// https://docs.angularjs.org/api/ng/service/$http
//
app.factory('authInterceptor', ['$q', '$injector', function ($q, $injector) {
        var authInterceptor = {
            response: function (response) {
                if (response.headers()['content-type'] === "application/xml; charset=utf-8") {
                    if (response.data.FaultType && response.data.Message) {
                        if (response.data.FaultType === 'ServiceAuthenticationException' && response.data.Message === 'Timed-out') {
                            var authenticationService = $injector.get('authenticationService');
                            alert("Your session with the server has been timed-out.");
                            authenticationService.logout();
                        }
                    }
                }
                return response;
            }
        };
        return authInterceptor;
    }]);
app.factory('dataCache', function () {
    var cache = {};
    cache.data = {};
    cache.add = function (key, data) {
        cache[key] = data;
    };
    return cache;
});
function addPreload(fileName) {
    var fileref = document.createElement("link");
    fileref.setAttribute("rel", "preload");
    fileref.setAttribute("as", "style");
    fileref.setAttribute("href", fileName);
    if (typeof fileref != "undefined") {
        document.getElementsByTagName("head")[0].appendChild(fileref);
    }
}
function addCss(fileName) {
    var fileref = document.createElement("link");
    fileref.setAttribute("rel", "stylesheet");
    fileref.setAttribute("type", "text/css");
    fileref.setAttribute("href", fileName);
    if (typeof fileref != "undefined") {
        document.getElementsByTagName("head")[0].appendChild(fileref);
    }
}
function loadCss() {
    if (lt.LTHelper.device == lt.LTDevice.mobile) {
        addCss("css/m.toolbar.css");
        addPreload("css/toolbarSVG.css");
        addCss("css/toolbarSVG.css");
        addCss("css/m.app.css");
    }
    else {
        addCss("css/toolbar.css");
        addPreload("css/toolbarSVG.css");
        addCss("css/toolbarSVG.css");
    }
    if (lt.LTHelper.device == lt.LTDevice.tablet) {
        var style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = '.ui-jqgrid tr.jqgrow td {height: 55px;}';
        document.getElementsByTagName('head')[0].appendChild(style);
    }
}
app.run(['$rootScope', '$location', 'authenticationService', 'sharedPropertiesService', '$window', 'app.config', 'dialogs', 'optionsService', '$templateCache', function ($rootScope, $location, authenticationService, sharedPropertiesService, $window, config, dialogs, optionsService, $templateCache) {
        var mainView = document.getElementById('mainView');
        var currentTheme = window.localStorage.getItem("leadmedicalwebviewertheme");
        switch (currentTheme) {
            case "dark":
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/darktheme.css';
                //element.checked = true;
                break;
            case "light":
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/theme-light.css';
                //element.checked = false;
                break;
            default:
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/darktheme.css';
            //element.checked = !element.checked;
        }
        $rootScope.Title = config.title;
        $rootScope.windowDimensions = { width: $window.outerWidth, height: $window.outerHeight };
        angular.element($window).bind('resize', function () {
            mainView.style.height = window.innerHeight + "px";
            $rootScope.windowDimensions = { width: $window.outerWidth, height: $window.outerHeight };
            $rootScope.$apply('windowDimensions');
        });
        loadCss();
        mainView.style.height = window.innerHeight + "px";
        $rootScope.$on('$locationChangeStart', function (event, next, current) {
            LogUtils.DebugLog("*** $locationChangeStart: " + "next: " + next + ",  current: " + current);
            var pathLogin = "/login";
            var currentPath = $location.path();
            var pathContainsLogin = (currentPath.indexOf(pathLogin) > -1);
            if (!authenticationService.isAuthenticated() && !pathContainsLogin) {
                LogUtils.DebugLog("*** changing $location.path()-->" + pathLogin);
                $location.path(pathLogin);
            }
            else {
                if (authenticationService.isAuthenticated()) {
                    if (next.indexOf(pathLogin) != -1 && $rootScope.previousPath == "/") {
                        if (!confirm("Navigating back will automatically log you out.  Would you like to continue?")) {
                            event.preventDefault();
                        }
                        else {
                            authenticationService.logout();
                        }
                    }
                }
            }
        });
        $rootScope.$on('$locationChangeSuccess', function (event) {
            $rootScope.previousPath = $location.path();
        });
        $rootScope.$on('$viewContentLoaded', function () {
            var tabView = document.getElementById('ltTabWrapper');
            if (tabView) {
                tabView.style.width = '100%';
            }
        });
        // 
        // Solution for typeahead not working correctly in angular 1.3. 
        // http://stackoverflow.com/questions/25180433/angular-bootstrap-typeahead-doesnt-respond-to-clicks-or-arrow-keys
        //
        $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen()\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
            "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{match.id}}\">\n" +
            "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
            "    </li>\n" +
            "</ul>");
        $templateCache.put("ui-grid/expandableTopRowHeader", "<div />");
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
/// <reference path="../app.ts" />
var EditorMode;
(function (EditorMode) {
    EditorMode.Select = 0;
    EditorMode.Draw = 1;
})(EditorMode || (EditorMode = {}));
var TemplateEditor;
(function (TemplateEditor) {
    var Config = /** @class */ (function () {
        function Config() {
            this.editAfterDraw = false;
            this.editorMode = EditorMode.Draw;
            this.backgroundColor = 'lightgray';
            this.borderColor = 'red';
            this.borderSize = 0;
            this.onSelectedItemsChanged = null;
            this.boundsNotification = true;
            this.foreColor = "white";
        }
        return Config;
    }());
    TemplateEditor.Config = Config;
})(TemplateEditor || (TemplateEditor = {}));
directives.directive('templateEditor', ["eventService", "$rootScope", "$timeout", "templateEditorService", "$modal", "optionsService", function (eventService, $rootScope, $timeout, templateEditorService, $modal, optionsService) {
        return {
            restrict: 'A',
            require: 'ngModel',
            scope: {
                editorApi: "=?",
                config: "=",
                selectedItems: "=",
                cancelMove: "=",
                onNewFrame: "&",
            },
            link: function (scope, elem, attr, ngModel) {
                var options = new lt.Controls.ImageViewerCreateOptions($(elem)[0]);
                var viewer = new lt.Controls.ImageViewer(options);
                var renderingEngine = new lt.Annotations.Rendering.AnnHtml5RenderingEngine();
                var manager = lt.Annotations.Automation.AnnAutomationManager.create(renderingEngine);
                var automationControl = new lt.Annotations.JavaScript.ImageViewerAutomationControl();
                var automationInteractiveMode = new lt.Annotations.JavaScript.AutomationInteractiveMode();
                var automation = new lt.Annotations.Automation.AnnAutomation(manager, automationControl);
                var configOptions = new TemplateEditor.Config();
                var dcmLayoutRect = {
                    left: 0,
                    top: 1,
                    width: 1,
                    height: -1
                };
                var debouncedPosition = Utils.debounce(positionFrames, 350);
                var automationHelper;
                templateEditorService.automation = automation;
                scope.config = $.extend(configOptions, scope.config);
                viewer.items.get_item(0).imageSize = lt.LeadSizeD.create(1, 1);
                createAutomationObjects(manager);
                setThumbPreferences(manager.renderingEngine.renderers);
                automationControl.imageViewer = viewer;
                automationInteractiveMode.automationControl = automationControl;
                viewer.defaultInteractiveMode = automationInteractiveMode;
                automation.add_currentDesignerChanged(onCurrentDesignerChanged);
                automation.add_beforeObjectChanged(onBeforeObjectChanged);
                automation.add_afterObjectChanged(onAfterObjectChanged);
                automation.add_selectedObjectsChanged(onSelectedObjectsChanged);
                automation.add_draw(onTextDraw);
                automation.add_editText(onEditText);
                setEditorMode();
                automation.active = true;
                manager.editObjectAfterDraw = scope.config.editAfterDraw;
                manager.restrictDesigners = true;
                manager.snapToGridOptions.showGrid = true;
                manager.snapToGridOptions.enableSnap = true;
                manager.enableObjectsAlignment = true;
                initializeGrid();
                automationHelper = new lt.Annotations.JavaScript.AutomationManagerHelper(manager, '');
                lt.Annotations.Engine.Utils.checkModifierKey = lt.Annotations.JavaScript.AutomationManagerHelper.checkModifierKey;
                manager.multiSelectModifierKey = lt.Annotations.Engine.AnnKeys.control;
                $(elem).resize(function () {
                    resizeView();
                    $timeout(function () {
                        resizeView();
                    }, 800);
                });
                scope.editorApi = scope.editorApi || {};
                scope.cancelMove = scope.cancelMove || false;
                scope.editorApi.resize = function () {
                    resizeView();
                    $timeout(function () {
                        resizeView();
                    }, 800);
                };
                scope.editorApi.getAutomation = function () {
                    return automation;
                };
                scope.editorApi.updatePositions = function () {
                    var selectionObject = automation.container.selectionObject;
                    var selectCount = selectionObject.selectedObjects.count;
                    for (var x = 0; x < selectCount; x++) {
                        var stamp = (selectionObject.selectedObjects.item(x));
                        var frame = findFrame(stamp.tag);
                        if (frame) {
                            var position = getPosition(stamp.rect);
                            frame.Position = position;
                            scope.config.onFrameChanged(frame, lt.Annotations.Automation.AnnAfterObjectChangedEventArgs.empty);
                        }
                    }
                };
                scope.$watch(function () {
                    return ngModel.$modelValue;
                }, onModelChanged, true);
                scope.$watch('config', function (newValue, oldValue) {
                    if (angular.isDefined(oldValue)) {
                        var differences = Utils.diff(newValue, oldValue);
                        if (differences.changed != "equal") {
                            getChanges(differences.value);
                        }
                    }
                }, true);
                scope.$watch('selectedItems', function (newValue, oldValue) {
                    if (angular.isDefined(newValue) && newValue != null) {
                        var length = newValue.length;
                        var selectedObjects = new lt.Annotations.Engine.AnnObjectCollection();
                        for (var i = 0; i < length; i++) {
                            var stamp = findAnnotationItem(newValue[i].Id);
                            if (stamp != null) {
                                selectedObjects.add(stamp);
                            }
                        }
                        if (selectedObjects.count > 0) {
                            automation.selectObjects(selectedObjects);
                        }
                    }
                });
                function initializeGrid() {
                    var value = optionsService.get(OptionNames.SnapToGrid);
                    if (value != undefined) {
                        manager.snapToGridOptions.enableSnap = value;
                    }
                    value = optionsService.get(OptionNames.ShowGrid);
                    if (value != undefined) {
                        manager.snapToGridOptions.showGrid = value;
                    }
                    value = optionsService.get(OptionNames.GridLength);
                    if (value) {
                        manager.snapToGridOptions.gridLength = parseInt(value);
                    }
                    value = optionsService.get(OptionNames.GridSpacing);
                    if (value) {
                        manager.snapToGridOptions.lineSpacing = parseInt(value);
                    }
                }
                function getChanges(changes) {
                    for (var key in changes) {
                        if (changes.hasOwnProperty(key)) {
                            if (changes[key].changed != "equal") {
                                switch (key) {
                                    case 'editorMode':
                                        setEditorMode();
                                        break;
                                    case 'editAfterDraw':
                                        manager.editObjectAfterDraw = scope.config.editAfterDraw;
                                        break;
                                }
                            }
                        }
                    }
                }
                function setEditorMode() {
                    automation.defaultCurrentObjectId = scope.config.editorMode == EditorMode.Draw ? lt.Annotations.Engine.AnnObject.textObjectId : lt.Annotations.Engine.AnnObject.selectObjectId;
                    manager.currentObjectId = automation.defaultCurrentObjectId;
                }
                function getAnnPicture(url) {
                    var picture = null;
                    if (url) {
                        picture = new lt.Annotations.Engine.AnnPicture(url);
                        return picture;
                    }
                    return picture;
                }
                function onModelChanged(newValue, oldValue) {
                    if (!newValue)
                        return;
                    newValue.forEach(function (frame, index) {
                        if (!angular.isDefined(frame.isWatching) || !frame.isWatching['Rotation']) {
                            frame.watch('Rotation', onRotationChanged);
                            //(<any>frame).watch('SequenceNumber', onSequenceNumberChanged); 
                            frame.watch('FrameNumber', onFrameNumberChanged);
                        }
                    });
                    removeFrames(getDiff(oldValue, newValue));
                    if (newValue instanceof Array) {
                        positionFrames(newValue);
                    }
                }
                function onRotationChanged(frame, name, oldValue, newValue) {
                    var stamp = findAnnotationItem(frame.Id);
                    if (stamp.labels["rotation"]) {
                        stamp.labels["rotation"].text = getRotation(newValue);
                    }
                    automation.invalidateObject(stamp);
                    return newValue;
                }
                function getRotation(value) {
                    if (value == Models.FrameRotation.None)
                        return '';
                    return Utils.getRotation(value);
                }
                //function onSequenceNumberChanged(frame: Models.Frame, name: string, oldValue: any, newValue: any) {
                //    var stamp: lt.Annotations.Engine.AnnTextObject = findAnnotationItem(frame.Id);
                //    updateFrameNumber(stamp, frame.FrameNumber, newValue);            
                //    return newValue;
                //}
                function onFrameNumberChanged(frame, name, oldValue, newValue) {
                    var stamp = findAnnotationItem(frame.Id);
                    updateFrameNumber(stamp, newValue, frame.SequenceNumber);
                    return newValue;
                }
                function updateFrameNumber(stamp, frame, sequence) {
                    var label = stamp.labels['frameNumber'];
                    if (angular.isDefined(label)) {
                        /* Reserved for capture
                        *
                        label.text = frame + ", Sequence: " + sequence;*/
                        label.text = frame.toString();
                        automation.invalidateObject(stamp);
                    }
                }
                function getDiff(a, b) {
                    var oldIds = {};
                    b.forEach(function (box) {
                        return oldIds[box.Id] = box;
                    });
                    return a.filter(function (box) {
                        return !(box.Id in oldIds);
                    });
                }
                function removeFrames(frames) {
                    frames.forEach(function (box, index) {
                        var id = box.Id;
                        var stamp = findAnnotationItem(id);
                        if (stamp != null) {
                            automation.container.children.remove(stamp);
                        }
                        box.unwatch('Rotation');
                        box.unwatch('SequenceNumber');
                    });
                    if (frames.length > 0) {
                        automation.container.selectionObject.selectedObjects.clear();
                        automation.invalidateContainer(automation.container);
                    }
                }
                function findAnnotationItem(id) {
                    var stamps = automation.container.children.toArray().filter(function (value, index) {
                        return value.tag == id;
                    });
                    if (stamps.length > 0) {
                        return stamps[0];
                    }
                    return null;
                }
                function findFrame(id) {
                    var frames = ngModel.$modelValue.filter(function (value, index) {
                        return value.Id == id;
                    });
                    if (frames.length > 0) {
                        return frames[0];
                    }
                    return null;
                }
                function positionFrames(frames) {
                    frames.forEach(function (box, index) {
                        positionFrame(box);
                    });
                    automation.invalidate(lt.LeadRectD.empty);
                }
                function positionFrame(frame) {
                    var rect = computeRectangle(frame.Position);
                    var stamp = null;
                    var objects = automation.container.children.toArray();
                    var foundObjects;
                    foundObjects = objects.filter(function (object, index) {
                        return object.tag == frame.Id;
                    });
                    if (foundObjects.length > 0) {
                        stamp = foundObjects[0];
                    }
                    else {
                        stamp = manager.objects.get_item(1).objectTemplate.clone();
                        stamp.tag = frame.Id;
                        if (frame.FrameNumber == -1)
                            frame.FrameNumber = getFrameNumber();
                        if (frame.SequenceNumber == -1)
                            frame.SequenceNumber = getSequenceNumber();
                        stamp.text = frame.Script;
                        automation.container.children.add(stamp);
                    }
                    if (stamp != null) {
                        stamp.set_rect(rect);
                        if (!stamp.labels["frameNumber"]) {
                            setLabel(stamp, frame);
                        }
                        if ((scope.selectedItems != null && scope.selectedItems.length == 1 && scope.selectedItems[0].Id == frame.Id) && !stamp.isSelected) {
                            automation.selectObject(stamp);
                        }
                    }
                }
                function setLabel(stamp, box) {
                    var label;
                    var height;
                    label = new lt.Annotations.Engine.AnnLabel();
                    /* Reserved for capture
                    *
                    label.text = box.FrameNumber + ", Sequence: " + box.SequenceNumber;*/
                    label.text = box.FrameNumber.toString();
                    label.foreground = lt.Annotations.Engine.AnnSolidColorBrush.create(scope.config.foreColor);
                    label.isVisible = true;
                    label.restrictionMode = lt.Annotations.Engine.AnnLabelRestriction.restrictToObjectBounds;
                    height = renderingEngine.measureString(label.text, label.font).height;
                    label.originalPosition = lt.LeadPointD.create(0, height);
                    label.positionMode = lt.Annotations.Engine.AnnLabelPositionMode.relativeToObject;
                    stamp.labels["frameNumber"] = label;
                    label = new lt.Annotations.Engine.AnnLabel();
                    /* Reserved for capture
                    *
                    label.text = box.FrameNumber + ", Sequence: " + box.SequenceNumber;*/
                    label.text = getRotation(box.Rotation);
                    label.foreground = lt.Annotations.Engine.AnnSolidColorBrush.create(scope.config.foreColor);
                    label.isVisible = true;
                    label.restrictionMode = lt.Annotations.Engine.AnnLabelRestriction.restrictToObjectBounds;
                    label.originalPosition = lt.LeadPointD.create(0, stamp.bounds.height - height);
                    label.positionMode = lt.Annotations.Engine.AnnLabelPositionMode.relativeToObject;
                    stamp.labels["rotation"] = label;
                }
                function computeRectangle(position) {
                    var xpos1, xpos2, ypos1, ypos2;
                    var point;
                    var rect = lt.LeadRectD.create(0, 0, automation.container.size.width, automation.container.size.height);
                    point = Utils.transformRectangle(dcmLayoutRect, rect, position.leftTop);
                    xpos1 = point.x;
                    ypos1 = point.y;
                    point = Utils.transformRectangle(dcmLayoutRect, rect, position.rightBottom);
                    xpos2 = point.x;
                    ypos2 = point.y;
                    return lt.LeadRectD.create(xpos1, ypos1, xpos2 - xpos1, Math.abs(ypos2 - ypos1));
                }
                function resizeView() {
                    var container = automation.container;
                    var size = lt.LeadSizeD.create($(elem).width(), $(elem).height());
                    viewer.onSizeChanged();
                    if (container != null) {
                        container.size = container.mapper.sizeToContainerCoordinates(size);
                    }
                    if (angular.isDefined(ngModel.$modelValue)) {
                        debouncedPosition(ngModel.$modelValue);
                    }
                }
                function createAutomationObjects(automationManager) {
                    var automationObjects = automationManager.get_objects();
                    var automationObject = null;
                    automationObject = new lt.Annotations.Automation.AnnAutomationObject();
                    automationObject.set_id(lt.Annotations.Engine.AnnObject.selectObjectId);
                    automationObject.set_name("Select");
                    automationObject.set_drawDesignerType(lt.Annotations.Designers.AnnRectangleDrawDesigner);
                    automationObject.set_editDesignerType(lt.Annotations.Designers.AnnSelectionEditDesigner);
                    automationObject.set_runDesignerType(null);
                    var selectionObject = new lt.Annotations.Engine.AnnSelectionObject();
                    selectionObject.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create("darkgreen"), lt.LeadLengthD.create(2)));
                    automationObject.set_objectTemplate(selectionObject);
                    automationObjects.add(automationObject);
                    automationObject = new lt.Annotations.Automation.AnnAutomationObject();
                    automationObject.set_id(lt.Annotations.Engine.AnnObject.textObjectId);
                    automationObject.set_name("Text");
                    automationObject.set_drawDesignerType(lt.Annotations.Designers.AnnRectangleDrawDesigner);
                    automationObject.set_editDesignerType(lt.Annotations.Designers.AnnTextEditDesigner);
                    automationObject.set_runDesignerType(lt.Annotations.Designers.AnnRunDesigner);
                    automationObject.useRotateThumbs = false;
                    //
                    // Create the object template for it, use the default stroke and fill
                    //
                    var textObject = new lt.Annotations.Engine.AnnTextObject();
                    textObject.fill = lt.Annotations.Engine.AnnSolidColorBrush.create(scope.config.backgroundColor);
                    textObject.text = "";
                    textObject.stroke = lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create(scope.config.borderColor), lt.LeadLengthD.create(scope.config.borderSize));
                    automationObject.set_objectTemplate(textObject);
                    automationObjects.add(automationObject);
                }
                function setThumbPreferences(renderers) {
                    var bigThumbSize = 80 * 2;
                    var smallThumbSize = 80;
                    var locationThumbStyle = new lt.Annotations.Rendering.AnnRectangleThumbStyle();
                    var rotateCenterThumbStyle = new lt.Annotations.Rendering.AnnEllipseThumbStyle();
                    var rotateGripperThumbStyle = new lt.Annotations.Rendering.AnnEllipseThumbStyle();
                    if (lt.LTHelper.device == lt.LTDevice.desktop) {
                        locationThumbStyle.set_size(lt.LeadSizeD.create(smallThumbSize, smallThumbSize));
                    }
                    else {
                        locationThumbStyle.set_size(lt.LeadSizeD.create(bigThumbSize, bigThumbSize));
                    }
                    locationThumbStyle.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create('black'), lt.LeadLengthD.create(1)));
                    locationThumbStyle.set_fill(lt.Annotations.Engine.AnnSolidColorBrush.create('rgba(173, 216, 230, 1)'));
                    rotateCenterThumbStyle.isVisible = false;
                    rotateGripperThumbStyle.isVisible = false;
                    for (var $key2 in renderers) {
                        var item = { key: $key2, value: renderers[$key2] };
                        var renderer = item.value;
                        renderer.set_locationsThumbStyle(locationThumbStyle);
                        renderer.set_rotateCenterThumbStyle(rotateCenterThumbStyle);
                        renderer.set_rotateGripperThumbStyle(rotateGripperThumbStyle);
                    }
                }
                function onCurrentDesignerChanged(sender, e) {
                    if (automation.currentDesigner instanceof lt.Annotations.Designers.AnnTextEditDesigner) {
                        var editDesigner = (automation.currentDesigner);
                        editDesigner.add_edit(onTextEdit);
                    }
                }
                function onTextEdit(sender, e) {
                    if (e.object instanceof lt.Annotations.Engine.AnnTextObject) {
                        var stamp = e.object;
                        if (e.operation == lt.Annotations.Engine.AnnEditDesignerOperation.move && e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.start && scope.cancelMove) {
                            e.cancel = true;
                            return;
                        }
                        if (e.operation == lt.Annotations.Engine.AnnEditDesignerOperation.moveThumb && e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.working) {
                            if (stamp.labels["rotation"]) {
                                var height = renderingEngine.measureString(stamp.labels["rotation"].text, stamp.labels["rotation"].font).height;
                                stamp.labels["rotation"].originalPosition = lt.LeadPointD.create(0, stamp.bounds.bottom - height);
                            }
                        }
                        if (e.operation == lt.Annotations.Engine.AnnEditDesignerOperation.move && e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.working) {
                            var bounds = stamp.bounds;
                            var x, y;
                            x = bounds.left;
                            y = bounds.top;
                            if (bounds.width > 0) {
                                //
                                // Change rectangle if the object is about to go out of bounds                            
                                //
                                if (scope.config.boundsNotification) {
                                    if (x < 0 || y < 0 || ((automation.container.size.height - bounds.bottom) < 0) || ((automation.container.size.width - bounds.right) < 0)) {
                                        stamp.stroke.strokeThickness = lt.LeadLengthD.create(3);
                                        stamp.stroke.strokeDashArray = [5, 5, 2, 5];
                                        function doAnts() {
                                            if (stamp.stroke.strokeDashArray != null) {
                                                var offset = stamp.stroke.strokeDashOffset;
                                                if (offset > 100) {
                                                    offset = 0;
                                                }
                                                stamp.stroke.strokeDashOffset = offset + 1;
                                                automation.invalidateObject(stamp);
                                                setTimeout(function () {
                                                    doAnts();
                                                }, 10);
                                            }
                                        }
                                        doAnts();
                                    }
                                    else {
                                        if (stamp.stroke.strokeDashArray != null) {
                                            stamp.stroke.strokeThickness = lt.LeadLengthD.create(scope.config.borderSize);
                                            stamp.stroke.strokeDashArray = null;
                                        }
                                    }
                                }
                            }
                        }
                        if ((e.operation == lt.Annotations.Engine.AnnEditDesignerOperation.move || e.operation == lt.Annotations.Engine.AnnEditDesignerOperation.moveThumb)
                            && e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.end) {
                            updatePosition(stamp);
                            if (scope.config.boundsNotification && stamp.stroke.strokeDashArray != null) {
                                stamp.stroke.strokeThickness = lt.LeadLengthD.create(scope.config.borderSize);
                                stamp.stroke.strokeDashArray = null;
                            }
                        }
                    }
                }
                function onTextDraw(sender, e) {
                    if (e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.end && (e.object instanceof lt.Annotations.Engine.AnnTextObject)) {
                        var stamp = e.object;
                        //
                        // If the user id is null then we do not have an Image Box for this annotation stamp.  Need to create one.
                        //
                        if (stamp.tag == null) {
                            var position = getPosition(stamp.rect);
                            var box = new Models.Frame(position);
                            stamp.tag = box.Id;
                            stamp.text = optionsService.get(OptionNames.DefaultScript);
                            box.FrameNumber = getFrameNumber();
                            box.SequenceNumber = getSequenceNumber();
                            setLabel(stamp, box);
                            ngModel.$modelValue.push(box);
                            scope.onNewFrame({ frame: box });
                        }
                    }
                }
                function onEditText(sender, e) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/ScriptEditor.html',
                        controller: Controllers.ScriptEditorController,
                        backdrop: 'static',
                        size: 'lg',
                        resolve: {
                            label: function () {
                                return "Script";
                            },
                            text: function () {
                                return e.textObject.text;
                            },
                            readOnly: function () {
                                var frame = findFrame(e.textObject.tag);
                                return frame.readOnly;
                            },
                        }
                    });
                    modalInstance.result.then(function (text) {
                        var oldText = e.textObject.text;
                        if (oldText != text) {
                            e.get_textObject().set_text(text);
                            automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                            if (scope.config.onFrameChanged) {
                                var frame = findFrame(e.textObject.tag);
                                frame.Script = text;
                                scope.config.onFrameChanged(frame, null);
                            }
                        }
                    });
                }
                function moveCaretToEnd(element) {
                    if (typeof element.selectionStart == "number") {
                        element.selectionStart = element.selectionEnd = element.value.length;
                    }
                    else if (typeof (element["createTextRange"]) != "undefined") {
                        element.focus();
                        var range = element["createTextRange"];
                        range.collapse(false);
                        range.select();
                    }
                }
                function automation_GotFocus(sender, e, id) {
                    var parent = viewer.get_foreCanvas().parentNode;
                    var child = document.getElementById(id);
                    if (child) {
                        child.userData.set_text(child.value);
                        parent.removeChild(child);
                        automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                    }
                }
                function onBeforeObjectChanged(sender, e) {
                    if (e.changeType == lt.Annotations.Automation.AnnObjectChangedType.deleted) {
                        for (var i = 0; i < e.objects.count; i++) {
                            var stamp = e.objects.get_item(i);
                            var imageBox = ngModel.$modelValue.filter(function (box) {
                                return box.Id == stamp.tag;
                            });
                            // 
                            // Remove imagebox since the stamp object has been deleted
                            //
                            if (imageBox.length > 0) {
                                ngModel.$modelValue.splice(ngModel.$modelValue.indexOf(imageBox[0]), 1);
                            }
                        }
                    }
                }
                function onAfterObjectChanged(sender, e) {
                    var count = e.objects.count;
                    if (e.changeType == lt.Annotations.Automation.AnnObjectChangedType.picture) {
                        automation.invalidate(lt.LeadRectD.empty);
                    }
                    for (var i = 0; i < count; i++) {
                        if (e.objects.item(i) instanceof lt.Annotations.Engine.AnnSelectionObject) {
                            var selectionObject = (e.objects.item(i));
                            var selectCount = selectionObject.selectedObjects.count;
                            for (var x = 0; x < selectCount; x++) {
                                var stamp = (selectionObject.selectedObjects.item(x));
                                var frame = findFrame(stamp.tag);
                                if (frame) {
                                    var position = getPosition(stamp.rect);
                                    frame.Position = position;
                                    scope.config.onFrameChanged(frame, e);
                                }
                            }
                        }
                        else {
                            if (scope.config.onFrameChanged) {
                                var stamp = (e.objects.item(i));
                                var frame = findFrame(stamp.tag);
                                if (frame) {
                                    scope.config.onFrameChanged(frame, e);
                                }
                            }
                        }
                    }
                }
                function onSelectedObjectsChanged(sender, e) {
                    var selectedItems = automation.container.get_selectionObject().get_selectedObjects();
                    if (selectedItems.count > 0 && scope.config.onSelectedItemsChanged) {
                        var boxes = new Array();
                        for (var i = 0; i < selectedItems.count; i++) {
                            var stamp = (selectedItems.item(i));
                            var box = findFrame(stamp.tag);
                            boxes.push(box);
                        }
                        scope.config.onSelectedItemsChanged(boxes);
                        return;
                    }
                    scope.selectedItems = null;
                    if (scope.config.onSelectedItemsChanged) {
                        scope.config.onSelectedItemsChanged(new Array());
                    }
                }
                function updatePosition(stamp) {
                    var foundObjects = ngModel.$modelValue.filter(function (object, index) {
                        return stamp.tag == object.Id;
                    });
                    if (foundObjects.length > 0) {
                        var frame = foundObjects[0];
                        frame.Position = getPosition(stamp.rect);
                    }
                }
                function getPosition(rect) {
                    var position = new Models.FramePosition();
                    position.leftTop = new lt.LeadPointD();
                    position.leftTop.x = rect.left / automation.container.size.width;
                    position.leftTop.y = 1 - (rect.top / automation.container.size.height);
                    position.rightBottom = new lt.LeadPointD();
                    position.rightBottom.x = position.leftTop.x + rect.width / automation.container.size.width;
                    position.rightBottom.y = position.leftTop.y - rect.height / automation.container.size.height;
                    return position;
                }
                function getFrameNumber() {
                    var sortedList = getSortedList("FrameNumber");
                    return getNextNumber(sortedList);
                }
                function getSequenceNumber() {
                    var sortedList = getSortedList("SequenceNumber");
                    return getNextNumber(sortedList);
                }
                function getSortedList(property) {
                    var list = new Array();
                    for (var i = 0; i < ngModel.$modelValue.length; i++) {
                        var box = ngModel.$modelValue[i];
                        if (box[property] == -1)
                            continue;
                        list.push(box[property]);
                    }
                    return list.sort(function (a, b) {
                        if (a > b) {
                            return 1;
                        }
                        if (a < b) {
                            return -1;
                        }
                        return 0;
                    });
                }
                function getNextNumber(sequence) {
                    var nextSquence = function formula(n) { return n + 1; };
                    var i = 0;
                    for (; i < sequence.length; i++) {
                        var x = nextSquence(i);
                        if (sequence[i] != x) {
                            sequence.splice(i, 0, x); // insert x here
                            sequence.length = 10; // chop of rest
                            return x;
                        }
                    }
                    return i + 1;
                }
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
// <reference path="../app.ts" />
var SharedPropertiesService = /** @class */ (function () {
    function SharedPropertiesService() {
        this._autoMode = false;
        this._externalControlMode = false;
        this._authenticationToken = '';
        this._port = 0;
        this._polling = true;
    }
    SharedPropertiesService.prototype.GetExternalControlMode = function () {
        return this._externalControlMode;
    };
    SharedPropertiesService.prototype.SetExternalControlMode = function (externalControlMode) {
        this._externalControlMode = externalControlMode;
    };
    SharedPropertiesService.prototype.GetAutoMode = function () {
        return this._autoMode;
    };
    SharedPropertiesService.prototype.SetAutoMode = function (autoMode) {
        this._autoMode = autoMode;
    };
    SharedPropertiesService.prototype.GetToken = function () {
        return this._authenticationToken;
    };
    SharedPropertiesService.prototype.SetToken = function (token) {
        this._authenticationToken = token;
    };
    SharedPropertiesService.prototype.GetPort = function () {
        return this._port;
    };
    SharedPropertiesService.prototype.SetPort = function (port) {
        this._port = port;
    };
    SharedPropertiesService.prototype.GetPolling = function () {
        return this._polling;
    };
    SharedPropertiesService.prototype.SetPolling = function (polling) {
        this._polling = polling;
    };
    return SharedPropertiesService;
}());
services.service('sharedPropertiesService', SharedPropertiesService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../lib/angular/angular.d.ts" />
/// <reference path="../lib/datejs.d.ts" />
/// <reference path="Services/OptionsService.ts" />
var HttpStatus;
(function (HttpStatus) {
    HttpStatus.ACCEPTED = 202;
    HttpStatus.BAD_GATEWAY = 502;
    HttpStatus.BAD_REQUEST = 400;
    HttpStatus.CONFLICT = 409;
    HttpStatus.CONTINUE = 100;
    HttpStatus.CREATED = 201;
    HttpStatus.EXPECTATION_FAILED = 417;
    HttpStatus.FORBIDDEN = 403;
    HttpStatus.GATEWAY_TIMEOUT = 504;
    HttpStatus.GONE = 410;
    HttpStatus.HTTP_VERSION_NOT_SUPPORTED = 505;
    HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE = 419;
    HttpStatus.INSUFFICIENT_STORAGE = 507;
    HttpStatus.INTERNAL_SERVER_ERROR = 500;
    HttpStatus.LENGTH_REQUIRED = 411;
    HttpStatus.LOCKED = 423;
    HttpStatus.METHOD_FAILURE = 420;
    HttpStatus.METHOD_NOT_ALLOWED = 405;
    HttpStatus.MOVED_PERMANENTLY = 301;
    HttpStatus.MOVED_TEMPORARILY = 302;
    HttpStatus.MULTI_STATUS = 207;
    HttpStatus.MULTIPLE_CHOICES = 300;
    HttpStatus.NO_CONTENT = 204;
    HttpStatus.NON_AUTHORITATIVE_INFORMATION = 203;
    HttpStatus.NOT_ACCEPTABLE = 406;
    HttpStatus.NOT_FOUND = 404;
    HttpStatus.NOT_IMPLEMENTED = 501;
    HttpStatus.NOT_MODIFIED = 304;
    HttpStatus.OK = 200;
    HttpStatus.PARTIAL_CONTENT = 206;
    HttpStatus.PAYMENT_REQUIRED = 402;
    HttpStatus.PRECONDITION_FAILED = 412;
    HttpStatus.PROCESSING = 102;
    HttpStatus.PROXY_AUTHENTICATION_REQUIRED = 407;
    HttpStatus.REQUEST_TIMEOUT = 408;
    HttpStatus.REQUEST_TOO_LONG = 413;
    HttpStatus.REQUEST_URI_TOO_LONG = 414;
    HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    HttpStatus.RESET_CONTENT = 205;
    HttpStatus.SEE_OTHER = 303;
    HttpStatus.SERVICE_UNAVAILABLE = 503;
    HttpStatus.SWITCHING_PROTOCOLS = 101;
    HttpStatus.TEMPORARY_REDIRECT = 307;
    HttpStatus.UNAUTHORIZED = 401;
    HttpStatus.UNPROCESSABLE_ENTITY = 422;
    HttpStatus.UNSUPPORTED_MEDIA_TYPE = 415;
    HttpStatus.USE_PROXY = 305;
})(HttpStatus || (HttpStatus = {}));
var Dictionary = /** @class */ (function () {
    function Dictionary() {
        this._dictionary = Object.create(null);
    }
    Dictionary.prototype.setData = function (key, value) {
        this._dictionary[key] = value;
    };
    Dictionary.prototype.getData = function (key) {
        return this._dictionary[key];
    };
    Dictionary.prototype.containsKey = function (key) {
        return this._dictionary.hasOwnProperty(key);
    };
    Dictionary.prototype.removeData = function (key) {
        delete this._dictionary[key];
    };
    return Dictionary;
}());
var Utils = /** @class */ (function () {
    function Utils() {
    }
    Utils.disposeCanvas = function (canvas) {
        var context = canvas.getContext('2d');
        canvas.width = 1;
        canvas.height = 1;
        canvas.style.width = "1px";
        canvas.style.height = "1px";
        context.clearRect(0, 0, canvas.width, canvas.height);
    };
    Utils.StartLoading = function (cell, loadingDiv) {
        loadingDiv = document.createElement("div");
        loadingDiv.id = 'loader';
        loadingDiv.className = 'loader' + cell.div.id;
        loadingDiv.style.width = "50px";
        loadingDiv.style.height = "50px";
        cell.div.appendChild(loadingDiv);
    };
    Utils.EndLoading = function (cell, loadingDiv) {
        loadingDiv = cell.div.getElementsByClassName('loader' + cell.div.id)[0];
        if (loadingDiv != null) {
            cell.div.removeChild(loadingDiv);
            loadingDiv.id = '';
        }
    };
    Utils.combineString = function (referencedSeries, sep) {
        var index = 0;
        var length = referencedSeries.length;
        var output = "";
        for (index = 0; index < length; index++) {
            if (index == length - 1)
                output += referencedSeries[index];
            else
                output += referencedSeries[index] + sep;
        }
        return output;
    };
    Utils.containsSTLData = function (json) {
        if (!json)
            return false;
        // the dicom standard way.
        var classUID = DicomHelper.getDicomTagValue(json, DicomTag.SOPClassUID);
        if (classUID == "1.2.840.10008.5.1.4.1.1.104.3") {
            return true;
        }
        // the non-standard lead way, which is storing the STL in a private tag.
        if (json["00271000"])
            return true;
        return false;
    };
    Utils.initProcessingScreen = function (text, show) {
        var processingScreen = document.getElementById("processingScreen");
        if (!processingScreen)
            return;
        // set the div to full screen first.
        processingScreen.style.top = "0px";
        processingScreen.style.left = "0px";
        processingScreen.style.width = "100%";
        processingScreen.style.height = "100%";
        processingScreen.style.visibility = show ? "visible" : "hidden";
        if (show) {
            processingScreen.innerHTML = "<div class='processingText'> " + text + " <div class='dot-flashing' style='top:0px; left:45%'> </div></div>";
        }
        else
            processingScreen.innerHTML = "";
    };
    Utils.ShowProcessingScreen = function (text, show, delay) {
        if (delay == 0)
            Utils.initProcessingScreen(text, show);
        else {
            // after a set amount of time specified by 'delay', show/hide the processing window.
            window.setTimeout(function () {
                Utils.initProcessingScreen(text, show);
            }, delay);
        }
    };
    Utils.ForceStopProcessingScreen = function (text, delay) {
        Utils._showCounter = 0;
        Utils.ShowProcessingScreen(text, false, delay);
    };
    Utils.ResizeProcessingScreen = function (left, top, width, height) {
        var processingScreen = document.getElementById("processingScreen");
        if (!processingScreen)
            return;
        if (top != -1) {
            processingScreen.style.top = top + "px";
            processingScreen.style.height = (processingScreen.clientHeight - top) + "px";
        }
        if (left != -1) {
            processingScreen.style.left = left + "px";
            processingScreen.style.width = (processingScreen.clientWidth - left) + "px";
        }
        if (width != -1)
            processingScreen.style.width = width + "px";
        if (height != -1)
            processingScreen.style.height = height + "px";
    };
    Utils.prepareDataForSeriesDisplay = function (data, series, patientInfo) {
        var index = 0;
        var length = data.length;
        var sd = null;
        for (index = 0; index < length; index++) {
            sd = data[index];
            if (sd.Boxes) {
                sd.CompleteMRTI = true;
                sd.Date = sd.SeriesDate + " " + sd.SeriesTime;
                sd.Description = sd.SeriesDescription;
                sd.InstanceUID = sd.SeriesInstanceUID;
                sd.Number = sd.InstanceNumber;
                sd.Modality = "PR";
                sd.NumberOfRelatedInstances = sd.Boxes.length;
                sd.NumericalDate = Utils.getSortableDate(sd.Date);
                sd.Patient = JSON.parse(JSON.stringify(patientInfo));
                sd.SopInstanceUIDs = null;
            }
        }
    };
    Utils.disposeAutomation = function (automation) {
        if (automation == null)
            return;
        automation.get_container().get_children().clear();
        automation.detach();
    };
    Utils.clearAllShutter = function (frame, annotationColor) {
        var automation = frame.parentCell.automation;
        var annotations = frame.shutter.objects;
        var index = 0;
        var length = annotations.count;
        var container = frame.container;
        if (annotationColor) {
            for (index = 0; index < length; index++) {
                var annObject = annotations.get_item(index);
                annObject.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create(annotationColor), lt.LeadLengthD.create(2)));
            }
        }
        frame.get_shutter().get_objects().clear();
        automation.automationControl.automationInvalidate(lt.LeadRectD.empty);
    };
    Utils.filterStructredDisplayItems = function (structredDisplay, series) {
        if (!structredDisplay.Series)
            return false;
        var length = structredDisplay.Series.length;
        var index = 0;
        var list = [];
        var sdItem;
        var filteredList = [];
        var sdSeriesLength;
        var sdSeriesIndex;
        var instanceUID;
        sdSeriesIndex = 0;
        sdSeriesLength = series.length;
        for (sdSeriesIndex = 0; sdSeriesIndex < sdSeriesLength; sdSeriesIndex++) {
            instanceUID = series[sdSeriesIndex].InstanceUID;
            for (index = length - 1; index >= 0; index--) {
                sdItem = structredDisplay.Series[index];
                if (instanceUID == sdItem.SeriesInstanceUID) {
                    filteredList.add(sdItem);
                }
            }
        }
        structredDisplay.Series = filteredList;
        return false;
    };
    Utils.findUIDInStructuredDisplay = function (structuredDisplay, uid) {
        if (!structuredDisplay)
            return;
        var length = structuredDisplay.length;
        var index = 0;
        var list = [];
        var sd;
        var sdSeriesLength;
        var sdSeriesIndex;
        for (index = 0; index < length; index++) {
            sd = structuredDisplay[index];
            if (!sd.Series)
                continue;
            sdSeriesLength = sd.Series.length;
            for (sdSeriesIndex = 0; sdSeriesIndex < sdSeriesLength; sdSeriesIndex++) {
                if (sd.Series[sdSeriesIndex].SeriesInstanceUID == uid)
                    return true;
            }
        }
        return false;
    };
    Utils.filterOutStructuredDisplay = function (localStructuredDisplay, series) {
        if (!series)
            return;
        if (!localStructuredDisplay)
            return;
        var length = localStructuredDisplay.length;
        var index = 0;
        var sd;
        for (index = length - 1; index >= 0; index--) {
            sd = localStructuredDisplay[index];
            if (!this.filterStructredDisplayItems(sd, series)) {
                if (sd.Series.length == 0) {
                    localStructuredDisplay.removeAt(index);
                }
            }
        }
    };
    Utils.findSeriesNotUsedByStructuredDisplay = function (result, structuredDisplay, series, addSD) {
        if (!series)
            return;
        if (!structuredDisplay)
            return;
        var length = series.length;
        var index = 0;
        var uid;
        for (index = 0; index < length; index++) {
            uid = series[index].InstanceUID;
            if (!this.findUIDInStructuredDisplay(structuredDisplay, uid))
                result.add(series[index]);
        }
        if (addSD) {
            length = structuredDisplay.length;
            for (index = 0; index < length; index++) {
                result.add(structuredDisplay[index]);
            }
        }
    };
    Utils.getSortableDate = function (date) {
        var sep = date.indexOf(' ');
        var pureDate = date.substring(0, sep);
        var time = date.substring(sep + 1, date.lastIndexOf(' '));
        var firstIndex = pureDate.indexOf('/');
        var lastIndex = pureDate.lastIndexOf('/');
        var year = pureDate.substring(lastIndex + 1, date.length);
        var day = pureDate.substring(firstIndex + 1, lastIndex);
        var month = pureDate.substring(0, firstIndex);
        if (year.trim() == "")
            return "";
        var hours = 0;
        var minutes = "00";
        var seconds = "00";
        var timeArray = time.split(':');
        if (timeArray.length > 0)
            hours = parseInt(timeArray[0]);
        if (timeArray.length > 1)
            minutes = timeArray[1];
        if (timeArray.length > 2)
            seconds = timeArray[2];
        if (hours == 12)
            hours = 0;
        var pmAm = date.substring(date.lastIndexOf(" ") + 1, date.length);
        if (pmAm.toLowerCase().trim() == 'pm')
            hours += 12;
        return year + "" + month + "" + day + "" + hours + "" + minutes + "" + seconds;
    };
    Utils.toBoolean = function (str, defaultValue) {
        if (str == undefined)
            return defaultValue;
        str = str.toString().toLowerCase();
        if (str == 'true' || str == 'yes' || str == 'y' || str == 'on' || str == '+') {
            return (true);
        }
        else if (str == 'false' || str == 'no' || str == 'n' || str == 'off' || str == '-') {
            return (false);
        }
        else {
            return (defaultValue);
        }
    };
    Utils.get_thumbnailUrl = function (entity) {
        if (!entity)
            return '';
        var injector = angular.element(document.getElementById('app')).injector();
        var optionsService = injector.get('optionsService');
        var authService = injector.get('authenticationService');
        var config = injector.get('app.config');
        if (optionsService.get(OptionNames.ShowSearchThumbnails)) {
            var imageUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
            imageUrl += '/GetSeriesThumbnail?';
            imageUrl += 'auth=' + encodeURIComponent(authService.authenticationCode);
            imageUrl += '&study=' + entity.StudyInstanceUID;
            imageUrl += '&series=' + entity.InstanceUID;
            imageUrl += '&cx=' + optionsService.get(OptionNames.SeriesThumbnailWidth);
            imageUrl += '&cy=' + optionsService.get(OptionNames.SeriesThumbnailHeight);
            if (entity.Modality == "PR") {
                imageUrl = "images/SD.jpg";
            }
            return imageUrl;
        }
        return '';
    };
    Utils.nameFormatter = function (cellValue) {
        if (cellValue)
            return cellValue.replace(/\^/g, ', ').toUpperCase();
        else
            return cellValue;
    };
    Utils.dateFormatter = function (cellValue, newFormat) {
        var DateJS = Date;
        var parsedDate = DateJS.parse(cellValue);
        if (parsedDate == null) {
            if (angular.isDefined(cellValue) && cellValue != null && cellValue.length == 0)
                return cellValue;
            parsedDate = new Date(cellValue);
        }
        // if parsed date is null, just used the passed cell value; otherwise,
        // transform the date to desired format
        var formattedDate = parsedDate ? parsedDate.toString(newFormat) : cellValue;
        return formattedDate;
    };
    Utils.countRenderer = function (evt) {
        return evt.rowIndex + 1 + Utils.countRenderer_StartIndex;
    };
    Utils.hyperlinkCountRenderer = function (evt) {
        return "<a href='javascript:void(0)' ng-click='onViewStudy(data)'> " + (evt.rowIndex + 1).toString() + "</a>";
    };
    Utils.hyperlinkPatientIdRenderer = function (evt) {
        return "<a href='javascript:void(0)' ng-click='onViewStudy(data)' title='View Study'> " + evt.data.Patient.ID + "</a>";
    };
    Utils.has_mrtiRenderer = function (evt) {
        var span = document.createElement('span');
        var text = document.createTextNode(evt.rowIndex + 1);
        span.appendChild(text);
        if (!evt.data.CompleteMRTI) {
            span.style.fontWeight = 'bold';
            span.style.color = 'red';
        }
        return span;
    };
    Utils.clearMrti = function (api, rowData, seriesInstanceUID) {
        var updatedNodes = [];
        api.forEachNode(function (node) {
            var data = node.data;
            if (data.InstanceUID == seriesInstanceUID) {
                data.CompleteMRTI = true;
                updatedNodes.push(node);
            }
        });
        api.refreshRows(updatedNodes);
    };
    Utils.GetDateLength = function (text) {
        if (!this.canvas)
            this.canvas = document.createElement('canvas');
        var ctx = this.canvas.getContext("2d");
        ctx.font = "14px Arial";
        return ctx.measureText(text).width + 10;
    };
    Utils.dateRendererMultiLines = function (evt) {
        var injector = angular.element(document.getElementById('app')).injector();
        var optionsService = injector.get('optionsService');
        var dateFormat = optionsService.get(OptionNames.DateFormat);
        var timeFormat = optionsService.get(OptionNames.TimeFormat);
        var unformmated = Utils.dateRenderer(evt);
        var sep = unformmated.indexOf(" ");
        var date = unformmated.substring(0, sep);
        var time = unformmated.substring(sep + 1, unformmated.length);
        return "<span style='font-family: arial; font-size: 100%;'>" + date + "</span> <br> <span style='font-family: arial; font-size: 80%;'>" + time + "</span>";
    };
    Utils.sortableDateRenderer = function (evt) {
        var injector = angular.element(document.getElementById('app')).injector();
        var str = evt.value;
        if (str.trim() == "")
            return "";
        var timeArray = str.split('_', 20);
        var timeFormat = "AM";
        var hours = parseInt(timeArray[3]);
        if (hours == 0)
            hours = 12;
        if (hours > 12) {
            hours -= 12;
            timeFormat = "PM";
        }
        return timeArray[1] + "/" + timeArray[2] + "/" + timeArray[0] + " " + hours + ":" + timeArray[4] + ":" + timeArray[5] + " " + timeFormat;
    };
    Utils.dateRenderer = function (evt) {
        var injector = angular.element(document.getElementById('app')).injector();
        var optionsService = injector.get('optionsService');
        var dateFormat = optionsService.get(OptionNames.DateFormat);
        var timeFormat = optionsService.get(OptionNames.TimeFormat);
        return Utils.dateFormatter(evt.value, dateFormat + ' ' + timeFormat);
    };
    Utils.thumbnailRenderer = function (evt) {
        var eContainer = document.createElement("span");
        var image = document.createElement("img");
        image.src = Utils.get_thumbnailUrl(evt.data);
        image.style.maxWidth = "100%";
        image.style.maxHeight = "100%";
        image.style.display = "block";
        image.style.margin = "0 auto";
        eContainer.appendChild(image);
        return eContainer;
    };
    Utils.mrtiRenderer = function (evt) {
        if (!evt.data.CompleteMRTI) {
            var eContainer = document.createElement("i");
            var span = document.createElement("span");
            var id = UUID.generate();
            eContainer.style.maxWidth = "100%";
            eContainer.style.maxHeight = "100%";
            eContainer.style.display = "block";
            eContainer.style.margin = "0 auto";
            eContainer.style.verticalAlign = "middle";
            evt.data.element = eContainer;
            $(eContainer).attr('id', id);
            evt.data.mrtiCell = id;
            $(eContainer).addClass("fa fa-hourglass fa-fw");
            return eContainer;
        }
        return null;
    };
    Utils.createButton = function (eContainer) {
        var button = document.createElement("button");
        $(button).addClass("btn btn-default");
        button.appendChild(eContainer);
        return button;
    };
    Utils.dateComparator = function (date1, date2) {
        var d1;
        var d2;
        if (!date1 && !date2)
            return 0;
        if (!date1)
            return -1;
        if (!date2)
            return 1;
        d1 = new Date(date1);
        d2 = new Date(date2);
        return d1 - d2;
    };
    Utils.patientIDComparator = function (date1, date2) {
        var d1;
        var d2;
        if (!date1 && !date2)
            return 0;
        if (!date1)
            return -1;
        if (!date2)
            return 1;
        d1 = new Date(date1);
        d2 = new Date(date2);
        return d1 - d2;
    };
    Utils.createLeadRect = function (left, top, right, bottom) {
        return lt.LeadRectD.create(left, top, Math.abs(right - left), Math.abs(bottom - top));
    };
    Utils.clone = function (src) {
        return Utils.myclone(src, null);
    };
    Utils.myclone = function (src, excludedItems) {
        function mixin(dest, source, copyFunc) {
            var name, s, i, empty = {};
            for (name in source) {
                var found = false;
                var index = 0;
                var length = excludedItems == null ? 0 : excludedItems.length;
                for (index = 0; index < length; index++) {
                    if (name == excludedItems[index])
                        found = true;
                }
                // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
                // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
                // don't overwrite it with the toString() method that source inherited from Object.prototype
                if (!found) {
                    s = source[name];
                    if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                        dest[name] = copyFunc ? copyFunc(s, excludedItems) : s;
                    }
                }
            }
            return dest;
        }
        if (!src || typeof src != "object" || Object.prototype.toString.call(src) === "[object Function]") {
            // null, undefined, any non-object, or function
            return src; // anything
        }
        if (src.nodeType && "cloneNode" in src) {
            // DOM Node
            return src.cloneNode(true); // Node
        }
        if (src instanceof Date) {
            // Date
            return new Date(src.getTime()); // Date
        }
        if (src instanceof RegExp) {
            // RegExp
            return new RegExp(src); // RegExp
        }
        var r, i, l;
        if (src instanceof Array) {
            // array
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
                if (i in src) {
                    r.push(Utils.myclone(src[i], excludedItems));
                }
            }
            // we don't clone functions for performance reasons
            //		}else if(d.isFunction(src)){
            //			// function
            //			r = function(){ return src.apply(this, arguments); };
        }
        else {
            // generic objects
            r = src.constructor ? new src.constructor() : {};
        }
        return mixin(r, src, Utils.myclone);
    };
    Utils.get_httpStatusText = function (statusCode) {
        if (this.statusCodes == null) {
            this.statusCodes = {};
            this.statusCodes[HttpStatus.ACCEPTED] = "Accepted";
            this.statusCodes[HttpStatus.BAD_GATEWAY] = "Bad Gateway";
            this.statusCodes[HttpStatus.BAD_REQUEST] = "Bad Request";
            this.statusCodes[HttpStatus.CONFLICT] = "Conflict";
            this.statusCodes[HttpStatus.CONTINUE] = "Continue";
            this.statusCodes[HttpStatus.CREATED] = "Created";
            this.statusCodes[HttpStatus.EXPECTATION_FAILED] = "Expectation Failed";
            this.statusCodes[HttpStatus.FORBIDDEN] = "Forbidden";
            this.statusCodes[HttpStatus.GATEWAY_TIMEOUT] = "Gateway Timeout";
            this.statusCodes[HttpStatus.GONE] = "Gone";
            this.statusCodes[HttpStatus.HTTP_VERSION_NOT_SUPPORTED] = "HTTP Version Not Supported";
            this.statusCodes[HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE] = "Insufficient Space on Resource";
            this.statusCodes[HttpStatus.INSUFFICIENT_STORAGE] = "Insufficient Storage";
            this.statusCodes[HttpStatus.INTERNAL_SERVER_ERROR] = "Server Error";
            this.statusCodes[HttpStatus.LENGTH_REQUIRED] = "Length Required";
            this.statusCodes[HttpStatus.LOCKED] = "Locked";
            this.statusCodes[HttpStatus.METHOD_FAILURE] = "Method Failure";
            this.statusCodes[HttpStatus.METHOD_NOT_ALLOWED] = "Method Not Allowed";
            this.statusCodes[HttpStatus.MOVED_PERMANENTLY] = "Moved Permanently";
            this.statusCodes[HttpStatus.MOVED_TEMPORARILY] = "Moved Temporarily";
            this.statusCodes[HttpStatus.MULTI_STATUS] = "Multi-Status";
            this.statusCodes[HttpStatus.MULTIPLE_CHOICES] = "Multiple Choices";
            this.statusCodes[HttpStatus.NO_CONTENT] = "No Content";
            this.statusCodes[HttpStatus.NON_AUTHORITATIVE_INFORMATION] = "Non Authoritative Information";
            this.statusCodes[HttpStatus.NOT_ACCEPTABLE] = "Not Acceptable";
            this.statusCodes[HttpStatus.NOT_FOUND] = "Not Found";
            this.statusCodes[HttpStatus.NOT_IMPLEMENTED] = "Not Implemented";
            this.statusCodes[HttpStatus.NOT_MODIFIED] = "Not Modified";
            this.statusCodes[HttpStatus.OK] = "OK";
            this.statusCodes[HttpStatus.PARTIAL_CONTENT] = "Partial Content";
            this.statusCodes[HttpStatus.PAYMENT_REQUIRED] = "Payment Required";
            this.statusCodes[HttpStatus.PRECONDITION_FAILED] = "Precondition Failed";
            this.statusCodes[HttpStatus.PROCESSING] = "Processing";
            this.statusCodes[HttpStatus.PROXY_AUTHENTICATION_REQUIRED] = "Proxy Authentication Required";
            this.statusCodes[HttpStatus.REQUEST_TIMEOUT] = "Request Timeout";
            this.statusCodes[HttpStatus.REQUEST_TOO_LONG] = "Request Entity Too Large";
            this.statusCodes[HttpStatus.REQUEST_URI_TOO_LONG] = "Request-URI Too Long";
            this.statusCodes[HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE] = "Requested Range Not Satisfiable";
            this.statusCodes[HttpStatus.RESET_CONTENT] = "Reset Content";
            this.statusCodes[HttpStatus.SEE_OTHER] = "See Other";
            this.statusCodes[HttpStatus.SERVICE_UNAVAILABLE] = "Service Unavailable";
            this.statusCodes[HttpStatus.SWITCHING_PROTOCOLS] = "Switching Protocols";
            this.statusCodes[HttpStatus.TEMPORARY_REDIRECT] = "Temporary Redirect";
            this.statusCodes[HttpStatus.UNAUTHORIZED] = "Unauthorized";
            this.statusCodes[HttpStatus.UNPROCESSABLE_ENTITY] = "Unprocessable Entity";
            this.statusCodes[HttpStatus.UNSUPPORTED_MEDIA_TYPE] = "Unsupported Media Type";
            this.statusCodes[HttpStatus.USE_PROXY] = "Use Proxy";
        }
        if (this.statusCodes.hasOwnProperty(statusCode)) {
            return this.statusCodes[statusCode];
        }
        else {
            throw "Status code does not exist: " + statusCode;
        }
    };
    Utils.get_splitterSize = function () {
        var ua = navigator.userAgent.toLowerCase();
        if (lt.LTHelper.device == lt.LTDevice.tablet || ((ua.indexOf("tablet pc") > -1) && ua.indexOf("windows nt 10.0") == -1)) {
            return 21;
        }
        if (lt.LTHelper.device == lt.LTDevice.mobile) {
            return 27;
        }
        return 7;
    };
    Utils.get_spacingSize = function () {
        return this.isTabletOrMobile() ? 10 : 6;
    };
    Utils.isTabletOrMobile = function () {
        return lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet;
    };
    Utils.isNumber = function (event, element) {
        if (event) {
            var max_chars = element.getAttribute("max") ? element.getAttribute("max").length : null;
            var charCode = (event.which) ? event.which : event.keyCode;
            if (charCode != 190 && charCode != 189 && charCode != 109 && charCode > 31 &&
                (charCode < 48 || charCode > 57) &&
                (charCode < 96 || charCode > 105) &&
                (charCode < 37 || charCode > 40) &&
                charCode != 110 && charCode != 8 && charCode != 46) {
                return false;
            }
            if (max_chars && element.value.length >= max_chars && charCode > 47) {
                return false;
            }
            else {
                return true;
            }
        }
    };
    Utils.debounce = function (func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow)
                func.apply(context, args);
        };
    };
    Utils.transformRectangle = function (from, to, src) {
        var dst = new lt.LeadPointD();
        dst.x = (((src.x - from.left) / from.width) * to.width) + to.left;
        dst.y = (((src.y - from.top) / from.height) * to.height) + to.top;
        return dst;
    };
    Utils.diff = function (a, b) {
        if (a === b) {
            return {
                changed: 'equal',
                value: a
            };
        }
        var diff = {};
        var equal = true;
        var keys = Object.keys(a);
        for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            if (b.hasOwnProperty(key)) {
                if (a[key] === b[key]) {
                    diff[key] = {
                        changed: 'equal',
                        value: a[key]
                    };
                }
                else {
                    var typeA = typeof a[key];
                    var typeB = typeof b[key];
                    if (a[key] && b[key] && (typeA == 'object' || typeA == 'function') && (typeB == 'object' || typeB == 'function')) {
                        var valueDiff = Utils.diff(a[key], b[key]);
                        if (valueDiff.changed == 'equal') {
                            diff[key] = {
                                changed: 'equal',
                                value: a[key]
                            };
                        }
                        else {
                            equal = false;
                            diff[key] = valueDiff;
                        }
                    }
                    else {
                        equal = false;
                        diff[key] = {
                            changed: 'primitive change',
                            removed: a[key],
                            added: b[key]
                        };
                    }
                }
            }
            else {
                equal = false;
                diff[key] = {
                    changed: 'removed',
                    value: a[key]
                };
            }
        }
        keys = Object.keys(b);
        for (i = 0, length = keys.length; i < length; i++) {
            key = keys[i];
            if (!a.hasOwnProperty(key)) {
                equal = false;
                diff[key] = {
                    changed: 'added',
                    value: b[key]
                };
            }
        }
        if (equal) {
            return {
                value: a,
                changed: 'equal'
            };
        }
        else {
            return {
                changed: 'object change',
                value: diff
            };
        }
    };
    Utils.accessProperty = function (object, keys, array) {
        array = array || keys.split('.');
        if (array.length > 1) {
            var item = array.shift();
            if (object[item] == null)
                return null;
            if (!angular.isDefined(object[item]))
                return undefined;
            return this.accessProperty(object[item], null, array);
        }
        else {
            return object[array.toString()] || undefined;
        }
    };
    Utils.roundNumber = function (n, decimalPlaces) {
        return parseFloat(n.toFixed(decimalPlaces));
    };
    Utils.getPosition = function (rect, width, height) {
        var position = new Models.FramePosition();
        position.leftTop = new lt.LeadPointD();
        position.leftTop.x = rect.left / width;
        position.leftTop.y = 1 - (rect.top / height);
        position.rightBottom = new lt.LeadPointD();
        position.rightBottom.x = position.leftTop.x + rect.width / width;
        position.rightBottom.y = position.leftTop.y - rect.height / height;
        return position;
    };
    Utils.getRotation = function (rotation) {
        switch (rotation) {
            case Models.FrameRotation.Rotate180:
                return '180\xB0';
            case Models.FrameRotation.Rotate270:
                return '270\xB0';
            case Models.FrameRotation.Rotate90:
                return '90\xB0';
        }
        return '0\xB0';
    };
    Utils.resetSeriesArrangement = function (medicalViewer, layout) {
        var cellLength = Math.min(layout.length, medicalViewer.layout.get_items().get_count());
        for (var index = 0; index < cellLength; index++) {
            medicalViewer.layout.get_items().get_item(index).set_position(index);
        }
        var length = medicalViewer.get_emptyDivs().get_items().get_count();
        for (index = 0; index < length; index++) {
            medicalViewer.get_emptyDivs().get_items().get_item(index).set_position(index + cellLength);
        }
    };
    Utils.rearrangeSeries = function (medicalViewer, layout) {
        medicalViewer.layout.beginUpdate();
        var length = medicalViewer.get_emptyDivs().get_items().get_count();
        for (var index = 0; index < length; index++) {
            var positionIndex = medicalViewer.get_emptyDivs().get_items().get_item(index).get_position();
            medicalViewer.get_emptyDivs().get_items().get_item(index).set_bounds(Utils.createLeadRect(layout[positionIndex][0], layout[positionIndex][1], layout[positionIndex][2], layout[positionIndex][3]));
            medicalViewer.get_emptyDivs().get_items().get_item(index).onSizeChanged();
        }
        length = Math.min(layout.length, medicalViewer.layout.get_items().get_count());
        for (var index = 0; index < length; index++) {
            var positionIndex = medicalViewer.layout.get_items().get_item(index).get_position();
            medicalViewer.layout.get_items().get_item(index).set_bounds(Utils.createLeadRect(layout[positionIndex][0], layout[positionIndex][1], layout[positionIndex][2], layout[positionIndex][3]));
            medicalViewer.layout.get_items().get_item(index).onSizeChanged();
        }
        length = medicalViewer.layout.get_items().get_count();
        for (; index < length; index++) {
            medicalViewer.layout.get_items().get_item(index).set_bounds(Utils.createLeadRect(0, 0, 0, 0));
        }
        medicalViewer.layout.endUpdate();
    };
    Utils.get_seriesLayout = function (cell) {
        var injector = angular.element(document.getElementById('app')).injector();
        var seriesManagerService = injector.get('seriesManagerService');
        var layout = seriesManagerService.get_layout(cell.seriesInstanceUID, cell.divID);
        if (layout && layout.Boxes.length > 0) {
            var imageViewer = cell.imageViewer;
            var length = imageViewer.items.count;
            var items = imageViewer.get_items();
            var frames = cell.frames;
            var framesMapping = cell.framesMappingIndex;
            layout = new Models.Layout();
            for (var index = 0; index < length; index++) {
                var templateFrame = items.item(index);
                var subCell = (items.get_item(index));
                if (templateFrame) {
                    var cellFrame;
                    if (framesMapping && framesMapping[index] != -1)
                        cellFrame = frames.item(framesMapping[index]);
                    else
                        cellFrame = frames.item(index);
                    if (cellFrame.Instance) {
                        var box = new Models.ImageBox(cellFrame.Instance.SOPInstanceUID);
                        var bounds = subCell.bounds;
                        box.Position = new Models.FramePosition(bounds.topLeft, bounds.bottomRight);
                        layout.Boxes.push(box);
                    }
                }
            }
        }
        return layout;
    };
    Utils.createViewerLayout = function (cell, template, update) {
        var framesMapping = {};
        var length = template.Frames.length;
        var imageViewer = cell.imageViewer;
        var injector = angular.element(document.getElementById('app')).injector();
        var optionsService = injector.get('optionsService');
        var backColor = optionsService.get(OptionNames.EmptyCellBackgroundColor);
        template.Frames.sort(function (frameA, frameB) {
            return frameA.SequenceNumber - frameB.SequenceNumber;
        });
        update = angular.isDefined(update) ? update : true;
        imageViewer.beginUpdate();
        try {
            cell.set_arrangement(1);
            cell.framesMappingIndex = new Array();
            cell.updateSubCellCount(length);
            cell.templateId = template.Id;
            for (var index = 0; index < length; index++) {
                var rect;
                var subCell = (imageViewer.get_items().get_item(index));
                var oldAttach = subCell.set_attachedFrame;
                rect = Utils.createLeadRect(template.Frames[index].Position.leftTop.x, 1 - template.Frames[index].Position.leftTop.y, template.Frames[index].Position.rightBottom.x, 1 - template.Frames[index].Position.rightBottom.y);
                subCell.set_bounds(rect);
                subCell.backColor = backColor;
                if (subCell.attachedFrame) {
                    subCell.attachedFrame = null;
                }
                subCell.templateFrame = template.Frames[index];
                framesMapping[index] = -1;
                delete subCell["isMapped"];
                subCell.add_frameAttached(function (sender, e) {
                    if (e.frame) {
                        if (e.subCell.templateFrame) {
                            var templateFrame = e.subCell.templateFrame;
                            Utils.rotateFrame(e.frame, templateFrame);
                            if (templateFrame.Flip && !e.frame.flipped)
                                e.frame.flipped = templateFrame.Flip;
                            if (templateFrame.Reverse && !e.frame.reversed)
                                e.frame.reversed = templateFrame.Reverse;
                            if (e.frame.mrtiInfo) {
                                if (templateFrame.Invert && !e.frame.inverted)
                                    e.frame.inverted = templateFrame.Invert;
                            }
                            Utils.subCell_setPresentationMode(e.subCell);
                        }
                    }
                });
            }
            if (update) {
                cell.framesMappingIndex = framesMapping;
            }
        }
        finally {
            if (update) {
                imageViewer.endUpdate();
                cell.onSizeChanged();
            }
        }
    };
    Utils.subCell_setPresentationMode = function (subCell) {
        if (subCell.templateFrame) {
            var templateFrame = subCell.templateFrame;
            if (templateFrame.PresentationSizeMode == Models.FramePresentationSizeMode.ScaleToFit) {
                subCell.attachedFrame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.fit, 1);
            }
            else if (templateFrame.PresentationSizeMode == Models.FramePresentationSizeMode.TrueSize) {
                subCell.attachedFrame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.trueSize, 1);
            }
            else if (templateFrame.PresentationSizeMode == Models.FramePresentationSizeMode.Magnify) {
                if (templateFrame.Magnification != 1) {
                    subCell.attachedFrame.zoom(subCell.attachedFrame.get_scaleMode(), subCell.attachedFrame.get_scale() * templateFrame.Magnification);
                }
            }
        }
    };
    Utils.rotateFrame = function (frame, templateFrame) {
        if (templateFrame.Rotation != Models.FrameRotation.None) {
            var angle = 0;
            switch (templateFrame.Rotation) {
                case Models.FrameRotation.Rotate90:
                    angle = 90;
                    break;
                case Models.FrameRotation.Rotate180:
                    angle = 180;
                    break;
                case Models.FrameRotation.Rotate270:
                    angle = 270;
                    break;
            }
            if (angle != 0) {
                var rotation = frame.get_rotateAngle();
                if (rotation != angle) {
                    frame.set_rotateAngle(rotation + angle);
                }
            }
        }
    };
    Utils.isInstanceOfSOP = function (layoutFrame /*: Models.Frame*/, metaData, sopInstanceUID, instanceNumber) {
        if (!layoutFrame)
            return false;
        if (layoutFrame.Script) {
            var defaultScript = "var dicom = JSON.parse(dicomJSON);";
            var interpreterInitialize = function (interpreter, scope) {
                var wrapper = function (text) {
                    text = text ? text.toString() : '';
                    return interpreter.createPrimitive(alert(text));
                };
                interpreter.setProperty(scope, 'alert', interpreter.createNativeFunction(wrapper));
                interpreter.setProperty(scope, 'dicomJSON', interpreter.createPrimitive(JSON.stringify(metaData)));
            };
            try {
                var interpreter = new Interpreter(defaultScript + layoutFrame.Script, interpreterInitialize);
                interpreter.run();
                return interpreter.value ? interpreter.value.toBoolean() : false;
            }
            catch (exception) {
                console.log(exception);
            }
        }
        else {
            if (layoutFrame.referencedSOPInstanceUID) {
                if (layoutFrame.referencedSOPInstanceUID[0]) {
                    return layoutFrame.referencedSOPInstanceUID[0] == sopInstanceUID;
                }
            }
        }
        return instanceNumber == layoutFrame.FrameNumber;
    };
    Utils.isInstanceInFrame = function (layoutFrame, cellFrame) {
        if (layoutFrame.Script) {
            var defaultScript = "var dicom = JSON.parse(dicomJSON);";
            var interpreterInitialize = function (interpreter, scope) {
                var wrapper = function (text) {
                    text = text ? text.toString() : '';
                    return interpreter.createPrimitive(alert(text));
                };
                interpreter.setProperty(scope, 'alert', interpreter.createNativeFunction(wrapper));
                interpreter.setProperty(scope, 'dicomJSON', interpreter.createPrimitive(JSON.stringify(cellFrame.metadata)));
            };
            try {
                var interpreter = new Interpreter(defaultScript + layoutFrame.Script, interpreterInitialize);
                interpreter.run();
                return interpreter.value ? interpreter.value.toBoolean() : false;
            }
            catch (exception) {
                console.log(exception);
            }
        }
        return cellFrame.instanceNumber == layoutFrame.FrameNumber;
    };
    Utils.executeScript = function (script, json) {
        if (script) {
            var defaultScript = "var dicom = JSON.parse(dicomJSON);";
            var interpreterInitialize = function (interpreter, scope) {
                var wrapper = function (text) {
                    text = text ? text.toString() : '';
                    return interpreter.createPrimitive(alert(text));
                };
                interpreter.setProperty(scope, 'alert', interpreter.createNativeFunction(wrapper));
                interpreter.setProperty(scope, 'dicomJSON', interpreter.createPrimitive(json));
            };
            try {
                var interpreter = new Interpreter(defaultScript + script, interpreterInitialize);
                interpreter.run();
                return interpreter.value ? interpreter.value.toBoolean() : false;
            }
            catch (exception) {
                console.log(exception);
            }
        }
        return false;
    };
    Utils.findFirst = function (arr, callback, context) {
        var el;
        for (var i = 0, l = arr.length; i < l; i++) {
            el = arr[i];
            if (callback.call(context, el, i, arr)) {
                return el;
            }
        }
        return null; //to return null and not undefined
    };
    Utils.findAll = function (arr, callback, context) {
        var el = new Array();
        if (!arr)
            return el;
        for (var i = 0, l = arr.length; i < l; i++) {
            if (callback.call(context, arr[i], i, arr)) {
                el.push(arr[i]);
            }
        }
        return el;
    };
    Utils.insert = function (value, index, string) {
        var ind = index < 0 ? this.length + index : index;
        return value.substring(0, ind) + string + value.substring(ind);
    };
    ;
    Utils.longToDicomTag = function (value) {
        var dicomString;
        dicomString = "00000000" + value.toString(16);
        var dicomStringLength = dicomString.length;
        dicomString = dicomString.substring(dicomStringLength - 8, dicomStringLength);
        dicomString = this.insert(dicomString, 4, ":");
        return dicomString;
    };
    Utils.isValidNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    };
    Utils.get_Modalities = function () {
        var modalities = new Array();
        modalities.push({ name: "CR", description: "Computed Radiography" });
        modalities.push({ name: "CT", description: "Computed Tomography" });
        modalities.push({ name: "MR", description: "Magnetic Resonance" });
        modalities.push({ name: "NM", description: "Nuclear Medicine" });
        modalities.push({ name: "US", description: "Ultrasound" });
        modalities.push({ name: "OT", description: "Other" });
        modalities.push({ name: "BI", description: "Biomagnetic imaging" });
        modalities.push({ name: "DG", description: "Diaphanography" });
        modalities.push({ name: "ES", description: "Endoscopy" });
        modalities.push({ name: "LS", description: "Laser surface scan" });
        modalities.push({ name: "PT", description: "Positron emission tomography (PET)" });
        modalities.push({ name: "RG", description: "Radiographic imaging (conventional film/screen)" });
        modalities.push({ name: "TG", description: "Thermography" });
        modalities.push({ name: "XA", description: "X-Ray Angiographyy" });
        modalities.push({ name: "RF", description: "Radio Fluoroscopy" });
        modalities.push({ name: "DX", description: "Digital Radiography" });
        modalities.push({ name: "MG", description: "Mammography" });
        modalities.push({ name: "IO", description: "Intra-oral Radiography" });
        modalities.push({ name: "PX", description: "Panoramic X-Ray" });
        modalities.push({ name: "GM", description: "General Microscopy" });
        modalities.push({ name: "SM", description: "Slide Microscopy" });
        modalities.push({ name: "XC", description: "External-camera Photography" });
        return modalities;
    };
    Utils.is_equal = function (v1, v2) {
        if (typeof (v1) !== typeof (v2)) {
            return false;
        }
        if (typeof (v1) === "function") {
            return v1.toString() === v2.toString();
        }
        if (v1 instanceof Object && v2 instanceof Object) {
            if (Utils.count_props(v1) !== Utils.count_props(v2)) {
                return false;
            }
            var r = true;
            for (var k in v1) {
                r = Utils.is_equal(v1[k], v2[k]);
                if (!r) {
                    return false;
                }
            }
            return true;
        }
        else {
            return v1 === v2;
        }
    };
    Utils.count_props = function (obj) {
        var count = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                count++;
            }
        }
        return count;
    };
    Utils.splitCamelCaseToString = function (s) {
        if (!s)
            return '';
        return s.replace(/(^[a-z]+)|[0-9]+|[A-Z][a-z]+|[A-Z]+(?=[A-Z][a-z]|[0-9])/g, function (match, first) {
            if (first)
                match = match[0].toUpperCase() + match.substr(1);
            return match + ' ';
        }).trim();
    };
    Utils.Contains = function (values, testValue) {
        for (var i = 0; i < values.length; i++) {
            if (values[i].id == testValue.id)
                return true;
        }
        return false;
    };
    Utils.RemoveDuplicates = function (mainList, pruneList) {
        var returnList = new Array();
        for (var i = 0; i < pruneList.length; i++) {
            if (!Utils.Contains(mainList, pruneList[i])) {
                returnList.push(pruneList[i]);
            }
        }
        return returnList;
    };
    Utils.GetNumericPrefix = function (n) {
        if (n == 1)
            return "1st";
        if (n == 2)
            return "2nd";
        if (n == 3)
            return "3rd";
        return (n.toString() + "th");
    };
    Utils.isArrayNumeric = function (numbersArray) {
        var numeric = false;
        for (var i = 0; i < numbersArray.length; i++) {
            if ($.isNumeric(numbersArray[i]) == false)
                return false;
        }
        return true;
    };
    // lengthToCheck = 0: means determine number of items in array
    Utils.verifyNumeric = function (selectorValue, lengthToCheck) {
        // Split into an array and remove the empty values
        var selectorValues = selectorValue.split("\\", 5).filter(function (el) { return el.length != 0; });
        var errorMessage = "";
        if (lengthToCheck == 0) {
            lengthToCheck = selectorValues.length;
        }
        if (!Utils.isArrayNumeric(selectorValues)) {
            if (lengthToCheck > 1)
                errorMessage = "Values must be numeric. (Example: 1\\3)";
            else
                errorMessage = "Value must be numeric";
        }
        return errorMessage;
    };
    Utils.isNumericVr = function (vr) {
        var isNumeric = false;
        switch (vr) {
            case "DS": // decimal string
            case "FL": // floating point single
            case "FD": // floating point double
            case "IS": // integer string
            case "SL": // signed long
            case "SS": // signed short
            case "UL": // unsigned long
            case "US": // unsgined short
                isNumeric = true;
                break;
        }
        return isNumeric;
    };
    Utils.isStringEmpty = function (s) {
        if (s == null)
            return true;
        if (s.trim().length == 0) {
            return true;
        }
    };
    Utils.verifySelectorCount = function (selectorValue, requiredCount) {
        var selectorValues = selectorValue.split("\\", 5).filter(function (el) { return el.length != 0; });
        var separatorCount = selectorValue.split("\\", 5).length - 1;
        var selectorValueCount = selectorValues.length;
        var errorMessage = "";
        // means at least one value
        if (requiredCount == 0) {
            if (selectorValueCount == 0)
                errorMessage = "Must have at least one value.";
        }
        else if (selectorValueCount != requiredCount || separatorCount != (requiredCount - 1)) {
            if (requiredCount == 2)
                errorMessage = "Must have exactly two values. (Example: 1\\3)";
            else if (requiredCount == 1)
                errorMessage = "Must have exactly one value.";
            else
                errorMessage = "Must have exactly " + requiredCount.toString() + " values.";
        }
        return errorMessage;
    };
    Utils.SortData = function (inputData) {
        var index = 0;
        var length = inputData.length;
        var sortArray = [];
        for (index = 0; index < length; index++) {
            sortArray[index] = inputData[index];
            sortArray[index].NumericalDate = Utils.getSortableDate(sortArray[index].Date);
        }
        var newest = 1;
        var newestIndex = 0;
        var sortIndex = 0;
        for (index = 0; index < length; index++) {
            newest = 1;
            newestIndex = 0;
            sortIndex = 0;
            for (sortIndex = 0; sortIndex < sortArray.length; sortIndex++) {
                if (sortArray[sortIndex].NumericalDate > newest) {
                    newest = sortArray[sortIndex].NumericalDate;
                    newestIndex = sortIndex;
                }
            }
            inputData[index] = sortArray[newestIndex];
            sortArray.splice(newestIndex, 1);
        }
    };
    Utils.statusCodes = null;
    Utils.canvas = null;
    Utils.debug_counter = 0;
    Utils.debug_timer = 0;
    Utils._showCounter = 0;
    Utils.countRenderer_StartIndex = 0;
    Utils.countit = 0;
    return Utils;
}());
var functionCache = {};
//
// Function to substitute string template with object properties.
// Property substitution should be defined in the string as <%=property%>.  Nested
//   properties also work: <%=object.property%>.
//
$.tmplParse = function (str, data) {
    // Figure out if we're getting a template, or if we need to
    // load the template - and be sure to cache the result.
    var fn = !/\W/.test(str) ?
        functionCache[str] = functionCache[str] ||
            $.template(str) :
        // Generate a reusable function that will serve as a template
        // generator (and which will be cached).
        new Function("obj", "var p=[],print=function(){p.push.apply(p,arguments);};" +
            // Introduce the data as local variables using with(){}
            "with(obj){p.push('" +
            // Convert the template into pure JavaScript
            str
                .replace(/[\r\t\n]/g, " ")
                .split("<%").join("\t")
                .replace(/((^|%>)[^\t]*)'/g, "$1\r")
                .replace(/\t=(.*?)%>/g, "',$1,'")
                .split("\t").join("');")
                .split("%>").join("p.push('")
                .split("\r").join("\\'")
            + "');}return p.join('');");
    // Provide some basic currying to the user
    return data ? fn(data) : fn;
};
function AssociativeArray() {
    var _instance = this;
    this.Size = function () {
        var size = 0, key;
        for (key in _instance) {
            if (key == "Size") {
                continue;
            }
            else if (_instance.hasOwnProperty(key) && _instance[key] != null) {
                size++;
            }
        }
        return size;
    };
}
/*
* object.watch polyfill
*
* 2012-04-03
*
* By Eli Grey, http://eligrey.com
* Public Domain.
* NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
*/
// object.watch
if (!Object.prototype.watch) {
    Object.defineProperty(Object.prototype, "watch", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: function (prop, handler) {
            var oldval = this[prop], newval = oldval, getter = function () {
                return newval;
            }, setter = function (val) {
                oldval = newval;
                return newval = handler.call(this, this, prop, oldval, val);
            };
            if (delete this[prop]) {
                Object.defineProperty(this, prop, {
                    get: getter,
                    set: setter,
                    enumerable: true,
                    configurable: true
                });
            }
            if (!this.isWatching) {
                this.isWatching = {};
            }
            this.isWatching[prop] = true;
        }
    });
}
// object.unwatch
if (!Object.prototype.unwatch) {
    Object.defineProperty(Object.prototype, "unwatch", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: function (prop, newVal) {
            var val = this[prop];
            if (this.isWatching) {
                delete this.isWatching[prop];
            }
            delete this[prop]; // remove accessors
            if (newVal == undefined)
                newVal = val;
            this[prop] = newVal;
        }
    });
}
var DragDrop;
(function (DragDrop) {
    var MSEventsHelper = /** @class */ (function () {
        function MSEventsHelper() {
        }
        MSEventsHelper.MSEventsHelper = function () {
            var isWinPhone = lt.LTHelper.OS == lt.LTOS.windows && lt.LTHelper.device == lt.LTDevice.mobile;
            if (window.navigator.userAgent.toLocaleLowerCase().indexOf("windows nt 6.2") != -1 || isWinPhone || MSEventsHelper.msPointerEnabled) {
                MSEventsHelper.pointerDown = "MSPointerDown";
                MSEventsHelper.pointerUp = "MSPointerUp";
                MSEventsHelper.pointerCancel = "MSPointerCancel";
                MSEventsHelper.pointerMove = "MSPointerMove";
            }
            else {
                //for Windows 8.1 and above
                MSEventsHelper.pointerDown = "pointerdown";
                MSEventsHelper.pointerUp = "pointerup";
                MSEventsHelper.pointerCancel = "pointercancel";
                MSEventsHelper.pointerMove = "pointermove";
            }
        };
        MSEventsHelper.msPointerEnabled = lt.LTHelper.msPointerEnabled;
        MSEventsHelper.ctor = MSEventsHelper.MSEventsHelper();
        return MSEventsHelper;
    }());
    var DragDropEvent = /** @class */ (function () {
        function DragDropEvent() {
        }
        return DragDropEvent;
    }());
    var DragDropHelper = /** @class */ (function () {
        function DragDropHelper() {
        }
        DragDropHelper.fillEvent = function (e, lastLocation) {
            var ev = e;
            // init
            var ddEvent = {
                x: 0,
                y: 0,
                isTouchEvent: false
            };
            if (e.type === MSEventsHelper.pointerDown || e.type === MSEventsHelper.pointerMove || e.type === MSEventsHelper.pointerUp || e.type === MSEventsHelper.pointerCancel) {
                ddEvent.isTouchEvent = true;
                ddEvent.x = parseInt(ev.pageX, 10);
                ddEvent.y = parseInt(ev.pageY, 10);
                if (e.type === MSEventsHelper.pointerDown) {
                    if ("preventMouseEvent" in ev)
                        (ev.preventMouseEvent());
                    if ("preventManipulation" in ev)
                        (ev.preventManipulation());
                }
            }
            else if (e.type === "MSGestureChange" || e.type === "MSGestureEnd") {
                return null;
            }
            else if (e.type === "touchstart" || e.type === "touchmove" || e.type === "touchend" || e.type === "touchcancel") {
                ddEvent.isTouchEvent = true;
                // Get number of touches
                var useChangedTouches = "changedTouches" in ev;
                var touchCount = 0;
                if (useChangedTouches)
                    touchCount = ev.changedTouches.length;
                else
                    touchCount = ev.touches.length;
                touchCount = Math.min(lt.LTHelper.supportsMultiTouch ? 2 : 1, touchCount);
                if (touchCount === 0) {
                    // Touch cancel or touch end, get the last position
                    ddEvent.x = lastLocation.x;
                    ddEvent.y = lastLocation.y;
                }
                else if (useChangedTouches) {
                    ddEvent.x = ev.changedTouches[0].pageX;
                    ddEvent.y = ev.changedTouches[0].pageY;
                }
                else {
                    ddEvent.x = ev.touches[0].pageX;
                    ddEvent.y = ev.touches[0].pageY;
                }
            }
            else {
                // Mouse
                ddEvent.isTouchEvent = false;
                ddEvent.x = parseInt(ev.pageX, 10);
                ddEvent.y = parseInt(ev.pageY, 10);
            }
            return ddEvent;
        };
        DragDropHelper.startListening = function (element, cb, msPointerEnabled) {
            MSEventsHelper.msPointerEnabled = msPointerEnabled;
            // IE 10, hook to the pointer events
            if (msPointerEnabled) {
                element.addEventListener(MSEventsHelper.pointerDown, cb.onDown, false);
                element.addEventListener(MSEventsHelper.pointerMove, cb.onMove, false);
                element.addEventListener(MSEventsHelper.pointerUp, cb.onUp, false);
                element.addEventListener(MSEventsHelper.pointerCancel, cb.onUp, false);
            }
            // We must disable the default gesture handling for touch screens using Edge
            if (lt.LTHelper.browser == lt.LTBrowser.edge || lt.LTHelper.browser == lt.LTBrowser.internetExplorer) {
                element.style["touchAction"] = "none";
                element.style["msTouchAction"] = "none";
                element.style["touch-action"] = "none";
                element.style["-ms-touch-action"] = "none";
            }
            // For devices that aren't msPointer-related
            if (lt.LTHelper.supportsTouch && !msPointerEnabled) {
                element.addEventListener("touchstart", cb.onDown, false);
                element.addEventListener("touchmove", cb.onMove, false);
                element.addEventListener("touchend", cb.onUp, false);
                element.addEventListener("touchcancel", cb.onUp, false);
            }
            // Else if mouse, do the mouse events
            if (lt.LTHelper.supportsMouse) {
                if (!msPointerEnabled) {
                    element.addEventListener("mousedown", cb.onDown, false);
                    document.addEventListener("mouseup", cb.onUp, false);
                }
            }
            element.addEventListener("dragstart", cb.onDragStart, false);
            element.addEventListener("dragend", cb.onDragEnd, false);
        };
        DragDropHelper.stopListening = function (element, cb, msPointerEnabled) {
            // IE 10, unhook from the pointer events
            if (msPointerEnabled) {
                element.removeEventListener(MSEventsHelper.pointerDown, cb.onDown, false);
                element.removeEventListener(MSEventsHelper.pointerMove, cb.onMove, false);
                element.removeEventListener(MSEventsHelper.pointerUp, cb.onUp, false);
                element.removeEventListener(MSEventsHelper.pointerCancel, cb.onUp, false);
            }
            if (lt.LTHelper.supportsTouch && !msPointerEnabled) {
                element.removeEventListener("touchstart", cb.onDown, false);
                element.removeEventListener("touchmove", cb.onMove, false);
                element.removeEventListener("touchend", cb.onUp, false);
                element.removeEventListener("touchcancel", cb.onUp, false);
            }
            // We must disable the default gesture handling for touch screens using edge
            if (lt.LTHelper.browser == lt.LTBrowser.edge && msPointerEnabled) {
                element.style["touchAction"] = "";
            }
            if (lt.LTHelper.supportsMouse) {
                if (!msPointerEnabled) {
                    element.removeEventListener("mousedown", cb.onDown, false);
                }
            }
            element.removeEventListener("dragstart", cb.onDragStart, false);
            element.removeEventListener("dragend", cb.onDragEnd, false);
        };
        return DragDropHelper;
    }());
    var DragDropState = /** @class */ (function () {
        function DragDropState() {
            this.isDragging = false;
            this.element = null;
            this.location = lt.LeadPointD.empty;
            this.placeholders = null;
            this.targetsHit = [];
        }
        return DragDropState;
    }());
    var DragDropBinding = /** @class */ (function () {
        function DragDropBinding(options) {
            // Check for inputs
            if (!options)
                throw "No options provided";
            if (!options.sources || options.sources.length == 0)
                throw "No array of element sources provided";
            // Should stay the same once this is created
            this._msPointerEnabled = lt.LTHelper.msPointerEnabled;
            if (lt.LTHelper.browser === lt.LTBrowser.edge) {
                // Edge is too funky about its touch support
                this._msPointerEnabled = false;
            }
            // Make a copy
            this._options = options;
            // Initialize the state
            this._state = new DragDropState();
        }
        DragDropBinding.prototype.start = function () {
            var _this = this;
            var callbacks = [];
            // Create a callback set for each element
            this._options.sources.forEach(function (element, index) {
                var callbackSet = _this.setCallbacks(element);
                callbacks.push(callbackSet);
                DragDropHelper.startListening(element, callbackSet, _this._msPointerEnabled);
            });
            this._callbacks = callbacks;
        };
        DragDropBinding.prototype.addTargets = function (targetElements) {
            var _this = this;
            if (!targetElements)
                throw "targetElements cannot be null";
            if (!targetElements.length)
                throw "targetElements must be an array";
            targetElements.forEach(function (targetToAdd) {
                if (_this._options.targets.indexOf(targetToAdd) === -1)
                    _this._options.targets.push(targetToAdd);
            });
        };
        DragDropBinding.prototype.removeTargets = function (targetElements) {
            if (!targetElements)
                throw "targetElements cannot be null";
            if (!targetElements.length)
                throw "targetElements must be an array";
            var newTargets = [];
            var newTargetsHit = [];
            for (var targetsIndex = 0, targetsToRemove = targetElements.length; targetsIndex < this._options.targets.length && targetsToRemove > 0; targetsIndex++) {
                var target = this._options.targets[targetsIndex];
                if (targetElements.indexOf(target) === -1) {
                    // This target is not to be removed
                    newTargets.push(target);
                    if (this._state.targetsHit.indexOf(target) !== -1) {
                        // This target should remain hit
                        newTargetsHit.push(target);
                    }
                }
                else {
                    // Remove class
                    $(target).removeClass(this._options.hitTargetClassName);
                }
            }
            this._options.targets = newTargets;
            this._state.targetsHit = newTargetsHit;
        };
        DragDropBinding.prototype.dispose = function () {
            var _this = this;
            this._options.sources.forEach(function (element, index) {
                DragDropHelper.stopListening(element, _this._callbacks[index], _this._msPointerEnabled);
            });
            this._callbacks = null;
            this._state = null;
        };
        DragDropBinding.prototype.HitTestItem = function (state, options, e, highlight) {
            var elements = new Array();
            var dEvent = DragDropHelper.fillEvent(e, state.location);
            var controller = options.tabService.get_tabData(options.viewerTab.id, TabDataKeys.ViewController);
            var viewer = controller.getViewer();
            var position = $("#" + viewer.divId).offset();
            var targetPoint = lt.LeadPointD.create(dEvent.x - position.left, dEvent.y - position.top);
            if (viewer != null) {
                var item;
                viewer.layout.highlightedItems.clear();
                viewer.emptyDivs.highlightedItems.clear();
                for (var i = 0; i < viewer.layout.items.count; i++) {
                    item = viewer.layout.items.get_item(i);
                    if (item.displayRectangle.contains(targetPoint.x, targetPoint.y)) {
                        $(item.div).data('cell', item);
                        elements.push(item.div);
                        if (highlight)
                            viewer.layout.highlightedItems.add(item);
                    }
                }
                for (var i = 0; i < viewer.emptyDivs.items.count; i++) {
                    item = viewer.emptyDivs.items.get_item(i);
                    if (item.displayRectangle.contains(targetPoint.x, targetPoint.y)) {
                        $(item.div).data('emptyDiv', item);
                        elements.push(item.div);
                        if (highlight)
                            viewer.emptyDivs.highlightedItems.add(item);
                    }
                }
            }
            return elements;
        };
        DragDropBinding.prototype.setCallbacks = function (element) {
            var _this = this;
            // init
            var callbacks = {
                onDown: null,
                onMove: null,
                onUp: null,
                onDragStart: null,
                onDragEnd: null
            };
            var dragDrop = this;
            var state = this._state;
            var options = this._options;
            // OnDown
            callbacks.onDown = function (e) {
                document.addEventListener("mousemove", dragDrop._callbacks[0].onMove, false);
                document.addEventListener("drag", dragDrop._callbacks[0].onMove, false);
                e.preventDefault();
                var dEvent = DragDropHelper.fillEvent(e, state.location);
                // If dragging already, return
                if (state.isDragging)
                    return;
                else
                    state.isDragging = true;
                // Set our state
                state.element = element;
                state.location = lt.LeadPointD.create(dEvent.x, dEvent.y);
                if (options.onMouseDown) {
                    options.onMouseDown(dragDrop, state.element);
                }
                // Create copies of the sources and anchors
                state.placeholders = [];
                (options.sources.concat(options.anchors)).forEach(function (el) {
                    var $el = $(el);
                    var position = $el.position();
                    var offset = $el.offset(); /// AM added
                    var pos = lt.LeadPointD.create(position.left, position.top);
                    var size = lt.LeadSizeD.create($el.outerWidth(), $el.outerHeight());
                    // Make the placeholder
                    var $placeHolder;
                    if (el instanceof HTMLImageElement) {
                        var canvas = document.createElement("canvas");
                        canvas.width = size.width;
                        canvas.height = size.height;
                        var context = canvas.getContext("2d");
                        context.drawImage(el, 0, 0, canvas.width, canvas.height);
                        $placeHolder = $(canvas);
                    }
                    else {
                        $placeHolder = $(document.createElement("div"));
                    }
                    $placeHolder.addClass(options.placeHolderClassName);
                    var elementCSS = {
                        position: $el.css("position"),
                        display: $el.css("display"),
                        top: parseInt($el.css("top"), 10),
                        left: parseInt($el.css("left"), 10)
                    };
                    $placeHolder.css({
                        position: elementCSS.position,
                        display: elementCSS.display,
                        //top: elementCSS.top === 0 ? pos.y : elementCSS.top,
                        //left: elementCSS.left === 0 ? pos.x : elementCSS.left,
                        width: size.width,
                        height: size.height,
                        "z-index": 100
                    });
                    $placeHolder.get(0).innerHTML = el.innerHTML;
                    $placeHolder.data("dragdrop", elementCSS);
                    $placeHolder.data("dragdropbase", el);
                    $placeHolder.insertAfter(el);
                    state.placeholders.push($placeHolder);
                    // Dim ourselves
                    $el.detach();
                    $(document.body).append($el);
                    $el.css({
                        position: "fixed",
                        top: offset.top,
                        left: offset.left,
                        width: size.width,
                        height: size.height,
                        opacity: .5,
                        "z-index": 20000,
                        "-webkit-transform": "translateZ(10px)",
                        "-moz-transform": "translateZ(10px)",
                        "-o-transform": "translateZ(10px)",
                        "transform": "translateZ(10px)"
                    });
                });
            };
            // OnMove
            callbacks.onMove = function (e) {
                e.preventDefault();
                var dEvent = DragDropHelper.fillEvent(e, state.location);
                // If not dragging, return
                if (!state.isDragging)
                    return;
                var delta = lt.LeadPointD.create(dEvent.x - state.location.x, dEvent.y - state.location.y);
                state.location = lt.LeadPointD.create(dEvent.x, dEvent.y);
                var elements = _this.HitTestItem(state, options, e, true);
                // Move the sources and anchors
                (options.sources.concat(options.anchors)).forEach(function (el) {
                    var $el = $(el);
                    var position = $el.position(); // AM Added
                    var outerPos = lt.LeadPointD.create(position.left - parseInt($el.css("margin-left"), 10), position.top - parseInt($el.css("margin-top"), 10));
                    var size = lt.LeadSizeD.create($el.outerWidth(), $el.outerHeight());
                    // Move ourselves
                    $el.css({
                        top: outerPos.y + delta.y,
                        left: outerPos.x + delta.x,
                    });
                });
                // Check if we hit a target
                var targetsHit = [];
                options.targets.forEach(function (targetElement) {
                    var $targetEl = $(targetElement);
                    var position = $targetEl.offset();
                    var pos = lt.LeadPointD.create(position.left, position.top);
                    var size = lt.LeadSizeD.create($targetEl.outerWidth(), $targetEl.outerHeight());
                    //console.log('event: ', dEvent);
                    //console.log('target: ', position);
                    if ((dEvent.x > pos.x && dEvent.x < (pos.x + size.width)) && (dEvent.y > pos.y && dEvent.y < (pos.y + size.height))) {
                        $targetEl.addClass(options.hitTargetClassName);
                        targetsHit.push(targetElement);
                    }
                    else {
                        $targetEl.removeClass(options.hitTargetClassName);
                    }
                });
                // See if we should call the callback for a target hit
                if (targetsHit.length > 0) {
                    // Check to see if same ones are hit, if this is the case don't call function again
                    if (targetsHit.length !== state.targetsHit.length) {
                        if (options.onTargetHit) {
                            options.onTargetHit(dragDrop, state.element, targetsHit);
                        }
                    }
                    else {
                        if (!targetsHit.every(function (targetHit) {
                            return state.targetsHit.indexOf(targetHit) !== -1;
                        })) {
                            options.onTargetHit(dragDrop, state.element, targetsHit);
                        }
                    }
                }
                state.targetsHit = targetsHit;
            };
            // OnUp
            callbacks.onUp = function (e) {
                var elements = new Array();
                document.removeEventListener("mousemove", dragDrop._callbacks[0].onMove, false);
                document.removeEventListener("drag", dragDrop._callbacks[0].onMove, false);
                e.preventDefault();
                var dEvent = DragDropHelper.fillEvent(e, state.location);
                if (!options.viewerTab)
                    return;
                if (!state.isDragging)
                    return;
                elements = _this.HitTestItem(state, options, e, false);
                // Remove the copies of the sources and anchors
                state.placeholders.forEach(function ($placeHolder) {
                    var elementCSS = $placeHolder.data("dragdrop");
                    var realElement = $placeHolder.data("dragdropbase");
                    var $el = $(realElement);
                    $el.detach();
                    $el.insertAfter($placeHolder);
                    $placeHolder.remove();
                    // Return to original form
                    $el.css({
                        opacity: 1,
                        "z-index": 0,
                        "-webkit-transform": "",
                        "-moz-transform": "",
                        "-o-transform": "",
                        "transform": ""
                    });
                    $el.css(elementCSS);
                });
                // See if we should call the callback for a target hit on up
                //if (state.targetsHit.length > 0) {
                //    options.onTargetUp(dragDrop, state.element, state.targetsHit);
                // }
                if (elements.length != 0) {
                    options.onTargetUp(dragDrop, state.element, elements);
                }
                state.element = null;
                state.isDragging = false;
                state.placeholders = null;
                state.location = lt.LeadPointD.empty;
                state.targetsHit = [];
                // Clear targets 
                options.targets.forEach(function (targetElement) {
                    $(targetElement).removeClass(options.hitTargetClassName);
                });
            };
            // OnDragStart
            callbacks.onDragStart = callbacks.onDown;
            // OnDragEnd
            callbacks.onDragEnd = callbacks.onUp;
            return callbacks;
        };
        return DragDropBinding;
    }());
    DragDrop.DragDropBinding = DragDropBinding;
})(DragDrop || (DragDrop = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../Scripts/Utils.ts" />
/// <reference path="AuthenticationService.ts" />
var OptionNames;
(function (OptionNames) {
    OptionNames.CaptureInfoTextRectFillColor = "CaptureInfoTextRectFillColor";
    OptionNames.CaptureInfoTextColor = "CaptureInfoTextColor";
    OptionNames.EmptyCellBackgroundColor = "EmptyCellBackgroundColor";
    OptionNames.ShowPacsQuery = "ShowPacsQuery";
    OptionNames.BlockWhileLoading = "BlockWhileLoading";
    OptionNames.EnablePatientIdAutoComplete = "EnablePatientIdAutoComplete";
    OptionNames.EnablePatientNameAutoComplete = "EnablePatientNameAutoComplete";
    OptionNames.Toolbar = "Toolbar";
    OptionNames.DisabledToolbarItems = "DisabledToolbarItems";
    OptionNames.DateFormat = "DateFormat";
    OptionNames.TimeFormat = "TimeFormat";
    OptionNames.SeriesThumbnailWidth = "SeriesThumbnailWidth";
    OptionNames.SeriesThumbnailHeight = "SeriesThumbnailHeight";
    OptionNames.ShowSearchThumbnails = "ShowSearchThumbnails";
    OptionNames.DerivedSeriesDescriptionText = "DerivedSeriesDescriptionText";
    OptionNames.Derived3DSeriesDescriptionText = "Derived3DSeriesDescriptionText";
    OptionNames.DerivedPanoramicSeriesDescriptionText = "DerivedPanoramicSeriesDescriptionText";
    OptionNames.EnableSeriesNumberEdit = "EnableSeriesNumberEdit";
    OptionNames.EnableProtocolNameEdit = "EnableProtocolNameEdit";
    OptionNames.EnableAuditLog = "EnableAuditLog";
    OptionNames.LogUserActivity = "LogUserActivity";
    OptionNames.LogUserSecurity = "LogUserSecurity";
    OptionNames.LogSettingChanges = "LogSettingChanges";
    OptionNames.LogSecuritySettingChanges = "LogSecuritySettingChanges";
    OptionNames.PatientIdMask = "PatientIdMask";
    OptionNames.IssuerOfPatientID = "IssuerOfPatientID";
    OptionNames.AutoStartCapture = "AutoStartCapture";
    OptionNames.ConfirmWorklistSelection = "ConfirmWorklistSelection";
    OptionNames.AllowOnlyWorklistQuery = "AllowOnlyWorklistQuery";
    OptionNames.EnableModalityWorklistQuery = "EnableModalityWorklistQuery";
    OptionNames.TimelinePosition = "TimelinePosition";
    OptionNames.SelectedBorderColor = "SelectedBorderColor";
    OptionNames.UnSelectedBorderColor = "UnSelectedBorderColor";
    OptionNames.SelectedSubCellBorderColor = "SelectedSubCellBorderColor";
    OptionNames.ViewerMode = "ViewerMode";
    OptionNames.SinglePatientMode = "SinglePatientMode";
    OptionNames.EnableIdleTimeout = "EnableIdleTimeout";
    OptionNames.IdleTimeout = "IdleTimeout";
    OptionNames.IdleWarningDuration = "IdleWarningDuration";
    OptionNames.SingleSeriesMode = "SingleSeriesMode";
    OptionNames.ShowFrameBorder = "ShowFrameBorder";
    OptionNames.OverlaySettings = "OverlaySettings";
    OptionNames.Toolbars = "Toolbars";
    OptionNames.AnnotationStrokeColor = "AnnotationStrokeColor";
    OptionNames.AnnotationTextColor = "AnnotationTextColor";
    OptionNames.AnnotationHiliteColor = "AnnotationHiliteColor";
    OptionNames.CalibrateUsingDpi = "CalibrateUsingDpi";
    OptionNames.AllRulersSameCalibration = "AllRulersSameCalibration";
    OptionNames.DefaultSeriesRowCount = "DefaultSeriesRowCount";
    OptionNames.DefaultSeriesColumnCount = "DefaultSeriesColumnCount";
    OptionNames.HideOverlays = "HideOverlays";
    OptionNames.RemoteConfig = "RemoteConfig";
    OptionNames.MaxStudyResults = "MaxStudyResults";
    OptionNames.MaxSeriesResults = "MaxSeriesResults";
    OptionNames.MaxPatientResults = "MaxPatientResults";
    OptionNames.SearchOtherPatientIds = "SearchOtherPatientIds";
    OptionNames.SearchStructuredDisplay = "SearchStructuredDisplay";
    OptionNames.EnablePatientRestriction = "EnablePatientRestriction";
    OptionNames.TemplateBorderColor = "TemplateBorderColor";
    OptionNames.TemplateBackgroundColor = "TemplateBackgroundColor";
    OptionNames.TemplateBorderSize = "TemplateBorderSize";
    OptionNames.TemplateBoundsNotification = "TemplateBoundsNotification";
    OptionNames.TemplateForeColor = "TemplateForeColor";
    OptionNames.DefaultScript = "DefaultScript";
    OptionNames.GridSpacing = "GridSpacing";
    OptionNames.GridLength = "GridLength";
    OptionNames.SnapToGrid = "SnapToGrid";
    OptionNames.ShowGrid = "ShowGrid";
    OptionNames.CustomStudyLayout = "CustomStudyLayout";
    OptionNames.AutoLoadHangingProtocol = "AutoLoadHangingProtocol";
    OptionNames.LazyLoadingThreshold = "LazyLoadingThreshold";
    OptionNames.LazyLoadingMobileThreshold = "LazyLoadingMobileThreshold";
    OptionNames.LazyLoadingBuffer = "LazyLoadingBuffer";
    OptionNames.HideCustomLayouts = "HideCustomLayouts";
    OptionNames.ShowStudyTimeLine = "ShowStudyTimeLine";
    OptionNames.LinkImages = "LinkImages";
    OptionNames.SplitSeries = "SplitSeries";
    OptionNames.StackSingleFrames = "StackSingleFrames";
    OptionNames.UseMedicoreLogo = "UseMedicoreLogo";
    OptionNames.BackgroundSize = "BackgroundSize";
    OptionNames.SDBackgroundSize = "SDBackgroundSize";
    OptionNames.TwoFactorsAuthenticationMessage = "TwoFactorsAuthenticationMessage";
    OptionNames.SearchPageSize = "SearchPageSize";
    OptionNames.MPRRenderSide = "MprRenderSide";
    OptionNames.RenderingMethod = "RenderingMethod";
    OptionNames.PrintSize = "PrintSize";
    OptionNames.PrintLayout = "PrintLayout";
    OptionNames.PrintName = "PrintName";
    OptionNames.EnableOkta = "EnableOktaSignIn";
    OptionNames.EnableShibboleth = "EnableShibbolethSignIn";
    OptionNames.EnableCaching = "EnableCaching";
    OptionNames.TextBackgroundColor = "TextBackground";
    OptionNames.TextColor = "TextColor";
    OptionNames.BackgroundColor = "BackgroundColor";
    OptionNames.PdfBackgroundColor = "PdfBackgroundColor";
})(OptionNames || (OptionNames = {}));
var OptionsService = /** @class */ (function () {
    function OptionsService(config, authService, $http, $location, eventService) {
        this._httpService = $http;
        this._eventService = eventService;
        this._authenticationService = authService;
        this._optionsServiceUrl = config.urls.serviceUrl + config.urls.optionsServiceName;
        this.InitializeOptions();
    }
    OptionsService.prototype.InitializeOptions = function () {
        this._objectDictionary = {};
        this.set(OptionNames.CaptureInfoTextColor, "#000000");
        this.set(OptionNames.CaptureInfoTextRectFillColor, "#DCDCDC");
        this.set(OptionNames.EmptyCellBackgroundColor, "#0F0F0F");
        this.set(OptionNames.DerivedSeriesDescriptionText, "(D)");
        this.set(OptionNames.DerivedPanoramicSeriesDescriptionText, "(Derived Panoramic)");
        this.set(OptionNames.Derived3DSeriesDescriptionText, "(Derived 3D)");
        this.set(OptionNames.ShowSearchThumbnails, false);
        this.set(OptionNames.SeriesThumbnailWidth, "50");
        this.set(OptionNames.SeriesThumbnailHeight, "50");
        this.set(OptionNames.EnableAuditLog, true);
        this.set(OptionNames.LogUserActivity, false);
        this.set(OptionNames.LogUserSecurity, false);
        this.set(OptionNames.LogSettingChanges, false);
        this.set(OptionNames.LogSecuritySettingChanges, false);
        this.set(OptionNames.PatientIdMask, "");
        this.set(OptionNames.IssuerOfPatientID, "");
        this.set(OptionNames.AutoStartCapture, true);
        this.set(OptionNames.ConfirmWorklistSelection, false);
        this.set(OptionNames.AllowOnlyWorklistQuery, false);
        this.set(OptionNames.EnableModalityWorklistQuery, false);
        this.set(OptionNames.TimelinePosition, "left");
        this.set(OptionNames.SelectedBorderColor, "#FF0000");
        this.set(OptionNames.UnSelectedBorderColor, "#000000");
        this.set(OptionNames.SelectedSubCellBorderColor, "#000000");
        this.set(OptionNames.ViewerMode, "Study View");
        this.set(OptionNames.SinglePatientMode, false);
        this.set(OptionNames.EnableIdleTimeout, true);
        this.set(OptionNames.IdleTimeout, 30);
        this.set(OptionNames.IdleWarningDuration, 30);
        this.set(OptionNames.SingleSeriesMode, false);
        this.set(OptionNames.ShowFrameBorder, true);
        this.set(OptionNames.AnnotationStrokeColor, "#FF0000");
        this.set(OptionNames.AnnotationTextColor, "#FF0000");
        this.set(OptionNames.AnnotationHiliteColor, "#FFFF00");
        this.set(OptionNames.CalibrateUsingDpi, false);
        this.set(OptionNames.AllRulersSameCalibration, true);
        this.set(OptionNames.DefaultSeriesRowCount, 2);
        this.set(OptionNames.DefaultSeriesColumnCount, 2);
        this.set(OptionNames.DateFormat, "MM/d/yyyy");
        this.set(OptionNames.TimeFormat, " hh:mm:ss tt");
        this.set(OptionNames.RemoteConfig, "");
        this.set(OptionNames.MaxStudyResults, 0);
        this.set(OptionNames.MaxSeriesResults, 0);
        this.set(OptionNames.MaxPatientResults, 0);
        this.set(OptionNames.SearchOtherPatientIds, false);
        this.set(OptionNames.SearchStructuredDisplay, false);
        this.set(OptionNames.EnablePatientIdAutoComplete, false);
        this.set(OptionNames.EnablePatientNameAutoComplete, false);
        this.set(OptionNames.EnablePatientRestriction, false);
        this.set(OptionNames.TemplateBackgroundColor, "#000000");
        this.set(OptionNames.TemplateBorderColor, "#FF0000");
        this.set(OptionNames.TemplateBorderSize, 2);
        this.set(OptionNames.TemplateBoundsNotification, true);
        this.set(OptionNames.TemplateForeColor, "#FFFFFF");
        this.set(OptionNames.DefaultScript, "true;");
        this.set(OptionNames.LazyLoadingThreshold, 100);
        this.set(OptionNames.LazyLoadingMobileThreshold, 25);
        this.set(OptionNames.LazyLoadingBuffer, 5);
        this.set(OptionNames.StackSingleFrames, true);
        this.set(OptionNames.BackgroundSize, 640);
        this.set(OptionNames.SDBackgroundSize, 256);
        this.set(OptionNames.ShowStudyTimeLine, false);
        this.set(OptionNames.LinkImages, true);
        this.set(OptionNames.SearchPageSize, 25);
        this.set(OptionNames.MPRRenderSide, "Server Side");
        this.set(OptionNames.RenderingMethod, "Hardware Software");
        this.set(OptionNames.EnableOkta, false);
        this.set(OptionNames.EnableShibboleth, false);
        this.set(OptionNames.EnableCaching, false);
        this.set(OptionNames.PrintSize, 1024);
        this.set(OptionNames.PrintLayout, true);
        this.set(OptionNames.PrintName, "<SeriesInstanceUID>");
        this.set(OptionNames.BackgroundColor, "#050505");
        this.set(OptionNames.TextColor, "#000000");
        this.set(OptionNames.TextBackgroundColor, "#FFFFFF");
        this.set(OptionNames.PdfBackgroundColor, "#FFFFFF");
        this.set(OptionNames.TwoFactorsAuthenticationMessage, "Web Viewer Link for \"<PatientName>\"\nPatient ID: <PatientID>\n\nPlease click on the link below:\n\n<urlInterfaceLink>");
    };
    OptionsService.prototype.isSeriesView = function () {
        return this._objectDictionary[OptionNames.ViewerMode] == "Series View";
    };
    OptionsService.prototype.set = function (key, val) {
        this._objectDictionary[key] = val;
    };
    OptionsService.prototype.get = function (key) {
        return this._objectDictionary[key];
    };
    OptionsService.prototype.has = function (key) {
        return this._objectDictionary.hasOwnProperty(key);
    };
    OptionsService.prototype.should = function (key) {
        return this.has(key) && this.get(key) == true;
    };
    OptionsService.prototype.GetUserOptions = function (success, error) {
        var currentTheme = window.localStorage.getItem("leadmedicalwebviewertheme");
        switch (currentTheme) {
            case "dark":
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/darktheme.css';
                //element.checked = true;
                break;
            case "light":
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/theme-light.css';
                //element.checked = false;
                break;
            default:
                var themeCSSElement = document.getElementById('theme_css');
                themeCSSElement.href = 'css/darktheme.css';
            //element.checked = !element.checked;
        }
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode);
        var __this = this;
        return this._httpService.get(this._optionsServiceUrl + "/GetUserOptions?" + parameter + "&r=" + Date.now()).success(function (options) {
            //
            // Create properties with the option names
            //
            $.each(options, function (key, value) {
                if (value && value.Key) { //old wcf service
                    __this._objectDictionary[value.Key] = Utils.toBoolean(value.Value, value.Value);
                }
                else {
                    __this._objectDictionary[key] = Utils.toBoolean(value, value);
                }
            });
            //#Shibboleth : always disable shibboleth, remove this line to enable functionality
            __this.set(OptionNames.EnableShibboleth, false);
            if (__this._authenticationService.user) {
                __this._authenticationService.getUserRoles(__this._authenticationService.user).success(function (result) {
                    var role = result[0];
                    var toolbarName = "main";
                    __this.getRoleOption(role, OptionNames.Toolbar + "_" + toolbarName).success(function (data) {
                        if (data && data.length > 0) {
                            //data = data.replace(/(\r\n|\n|\r|\t|\\)/gm, "");
                            //items = JSON.parse(data).items;
                            var key = OptionNames.Toolbar + "_" + toolbarName;
                            __this._objectDictionary[key] = Utils.toBoolean(key, data);
                            __this.getRoleOption(role, OptionNames.DisabledToolbarItems + "_" + toolbarName).success(function (disabledItems) {
                                if (disabledItems && disabledItems.length > 0) {
                                    //disabledItems = disabledItems.replace(/(\r\n|\n|\r|\t|\\)/gm, "");
                                    //items = JSON.parse(data).items;
                                    var key = OptionNames.DisabledToolbarItems + "_" + toolbarName;
                                    __this._objectDictionary[key] = Utils.toBoolean(key, disabledItems);
                                    success(options);
                                }
                                else {
                                    success(options);
                                }
                            }).error(function (data, status, headers, config) { error(data, status, headers, config); });
                        }
                        else {
                            success(options);
                        }
                    }).error(function (data, status, headers, config) { error(data, status, headers, config); });
                }).error(function (data, status, headers, config) { error(data, status, headers, config); });
            }
            else {
                success(options);
            }
        }).error(function (data, status, headers, config) { error(data, status, headers, config); });
    };
    ;
    OptionsService.prototype.dictionaryToWCFArray = function (obj) {
        var data = [];
        for (var key in obj) {
            data.push({ Key: key, Value: obj[key] });
        }
        return data;
    };
    OptionsService.prototype.saveDefaultOptions = function (defaultOptions) {
        var data = this.dictionaryToWCFArray(defaultOptions);
        var postData = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: data
        };
        return this._httpService.post(this._optionsServiceUrl + "/SaveDefaultOptions", JSON.stringify(postData));
    };
    OptionsService.prototype.saveRoleOptions = function (role, options) {
        var data = this.dictionaryToWCFArray(options);
        var postData = {
            authenticationCookie: this._authenticationService.authenticationCode,
            role: role,
            options: data
        };
        return this._httpService.post(this._optionsServiceUrl + "/SaveRoleOptions", JSON.stringify(postData));
    };
    OptionsService.prototype.getRoleOption = function (role, option) {
        var postData = {
            authenticationCookie: this._authenticationService.authenticationCode,
            role: role,
            optionName: option
        };
        return this._httpService.post(this._optionsServiceUrl + "/GetRoleOption", JSON.stringify(postData));
    };
    OptionsService.prototype.saveUserOption = function (name, value) {
        var postData = {
            authenticationCookie: this._authenticationService.authenticationCode,
            optionName: name,
            optionValue: value
        };
        return this._httpService.post(this._optionsServiceUrl + "/SaveUserOption", JSON.stringify(postData));
    };
    OptionsService.$inject = ['app.config', 'authenticationService', '$http', '$location', 'eventService'];
    return OptionsService;
}());
services.service('optionsService', OptionsService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.cookie.d.ts" />
/// <reference path="../app.ts" />
/// <reference path="OptionsService.ts" />
/// <reference path="../Utils.ts" />
var PermissionNames;
(function (PermissionNames) {
    PermissionNames.CanChangeServerSettings = "CanChangeServerSettings";
    PermissionNames.CanDeleteFromDatabase = "CanDeleteFromDatabase";
    PermissionNames.CanEmptyDatabase = "CanEmptyDatabase";
    PermissionNames.CanCalibrateMonitor = "CanCalibrateMonitor";
    PermissionNames.CanDeleteAnnotations = "CanDeleteAnnotations";
    PermissionNames.CanDeleteDownloadInfo = "CanDeleteDownloadInfo";
    PermissionNames.CanDownloadImages = "CanDownloadImages";
    PermissionNames.CanManageAccessRight = "CanManageAccessRight";
    PermissionNames.CanManageRoles = "CanManageRoles";
    PermissionNames.CanManageUsers = "CanManageUsers";
    PermissionNames.CanQuery = "CanQuery";
    PermissionNames.CanQueryPACS = "CanQueryPACS";
    PermissionNames.CanRetrieve = "CanRetrieve";
    PermissionNames.CanStore = "CanStore";
    PermissionNames.CanStoreAnnotations = "CanStoreAnnotations";
    PermissionNames.CanViewAnnotations = "CanViewAnnotations";
    PermissionNames.CanExport = "CanExport";
    PermissionNames.CanManageRemotePACS = "CanManageRemotePACS";
    PermissionNames.CanEditTemplates = "CanEditTemplates";
    PermissionNames.CanDeleteTemplates = "CanDeleteTemplates";
    PermissionNames.CanModifyBuiltInTemplates = "CanModifyBuiltInTemplates";
    PermissionNames.CanAddTemplates = "CanAddTemplates";
    PermissionNames.CanViewTemplates = "CanViewTemplates";
    PermissionNames.CanImportTemplates = "CanImportTemplates";
    PermissionNames.CanExportTemplates = "CanExportTemplates";
    PermissionNames.CanSaveStructuredDisplay = "CanSaveStructuredDisplay";
    PermissionNames.CanSaveHangingProtocol = "CanSaveHangingProtocol";
    PermissionNames.CanDeleteCache = "CanDeleteCache";
    PermissionNames.CanSharePatients = "CanSharePatients";
})(PermissionNames || (PermissionNames = {}));
var UserCredentials = /** @class */ (function () {
    function UserCredentials() {
    }
    Object.defineProperty(UserCredentials.prototype, "userName", {
        get: function () {
            return this._userName;
        },
        set: function (value) {
            this._userName = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserCredentials.prototype, "password", {
        get: function () {
            return this._password;
        },
        set: function (value) {
            this._password = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserCredentials.prototype, "userData", {
        get: function () {
            return this._userData;
        },
        set: function (value) {
            this._userData = value;
        },
        enumerable: false,
        configurable: true
    });
    return UserCredentials;
}());
var CookieOptions = /** @class */ (function () {
    function CookieOptions() {
    }
    return CookieOptions;
}());
var AuthenticationService = /** @class */ (function () {
    function AuthenticationService(config, $http, $location, eventService, $window) {
        this._httpService = $http;
        this._eventService = eventService;
        this._locationService = $location;
        this._window = $window;
        this._isTempAuthentication = false;
        this._isExternalAuthentication = false;
        this.authenticationCode = "";
        this.authenticationMessage = "";
        this._authUrl = config.urls.serviceUrl + config.urls.authenticationServiceName;
        this._permissions = {};
    }
    Object.defineProperty(AuthenticationService.prototype, "permissions", {
        get: function () {
            return this._permissions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AuthenticationService.prototype, "isTempAuthentication", {
        get: function () {
            return this._isTempAuthentication;
        },
        set: function (value) {
            this._isTempAuthentication = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AuthenticationService.prototype, "isExternalAuthentication", {
        get: function () {
            return this._isExternalAuthentication;
        },
        set: function (value) {
            this._isExternalAuthentication = value;
        },
        enumerable: false,
        configurable: true
    });
    AuthenticationService.prototype.isAuthenticated = function () {
        return this.authenticationCode.length > 0;
    };
    Object.defineProperty(AuthenticationService.prototype, "authenticationMessage", {
        get: function () {
            return this._authenticationMessage;
        },
        set: function (value) {
            this._authenticationMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AuthenticationService.prototype, "authenticationCode", {
        get: function () {
            return this._authenticationCode;
        },
        set: function (value) {
            this._authenticationCode = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AuthenticationService.prototype, "user", {
        get: function () {
            return this._user;
        },
        enumerable: false,
        configurable: true
    });
    AuthenticationService.prototype.refreshPermissions = function () {
        var d = $.Deferred();
        var __this = this;
        var username = __this.user;
        __this._permissions.isAdmin = false;
        __this._permissions = {};
        __this.getUserPermissions(username).error(function (e, x) {
            __this.authenticationMessage = e.Message;
            __this._eventService.publish("AuthenticationService/AuthenticationFailed", e.Message);
            d.resolve("refreshPermissions_fail");
        }).success(function (permissions) {
            var length = permissions.length;
            for (var i = 0; i < length; i++) {
                var permission = permissions[i];
                var index = permission.indexOf(".");
                if (index != -1) {
                    permission = permission.substr(index + 1);
                }
                __this._permissions[permission] = true;
            }
            __this.isAdmin(username).error(function () {
                __this._permissions.isAdmin = false;
            }).success(function (result) {
                __this._permissions.isAdmin = result;
            });
            d.resolve("refreshPermissions_success");
        });
        return d.promise();
    };
    AuthenticationService.prototype.login = function (username, password, rememberMe) {
        var __this = this;
        if (!username)
            username = "";
        if (!password)
            password = "";
        return this._httpService.post(this._authUrl + "/AuthenticateUser", { userName: username, password: password, userData: '' })
            .error(function (e, status) {
            var message = "";
            if ((typeof e === 'string') && e.length == 0) {
                message = __this.authenticationMessage = "HTTP Error (" + status + "): " + Utils.get_httpStatusText(status);
            }
            else {
                if (e) {
                    if (e.hasOwnProperty('ExceptionMessage')) {
                        message = __this.authenticationMessage = e.ExceptionMessage;
                    }
                    else if (e.hasOwnProperty('Message')) {
                        message = __this.authenticationMessage = e.Message;
                    }
                    else {
                        // this is not an exception, this is a whole HTML page, so we are opening a new window to display it.
                        var newtab = window.open("", "_blank");
                        if (newtab) {
                            newtab.focus();
                            newtab.document.write(e);
                            newtab.focus();
                        }
                        message = "Error";
                    }
                }
                else {
                    message = 'Web service is down';
                }
            }
            __this._eventService.publish("AuthenticationService/AuthenticationFailed", message);
        })
            .then(function (data) {
            if (data.status != HttpStatus.OK) {
                if (data.statusText)
                    __this.authenticationMessage = data.statusText;
                else
                    __this.authenticationMessage = "Unknown error: " + data.status;
                __this._eventService.publish("AuthenticationService/AuthenticationFailed", data.statusText);
            }
            else if (data.data.Message) {
                __this.authenticationMessage = data.data.Message;
                __this._eventService.publish("AuthenticationService/AuthenticationFailed", data.data.Message);
            }
            else {
                if (rememberMe) {
                    var date = new Date();
                    var options = new CookieOptions();
                    date.setMonth(date.getMonth() + 1);
                    options.expires = date;
                    options.path = "/";
                    $.cookie("User", username, options);
                    $.cookie("Pass", password, options);
                }
                document.getElementById('verionNumberFooter').innerHTML = "";
                __this._user = username;
                __this.authenticationCode = data.data.toString();
                __this._permissions.isAdmin = false;
                __this.getUserPermissions(username).error(function (e, x) {
                    __this.authenticationMessage = e.Message;
                    __this._eventService.publish("AuthenticationService/AuthenticationFailed", e.Message);
                }).success(function (permissions) {
                    var length = permissions.length;
                    for (var i = 0; i < length; i++) {
                        var permission = permissions[i];
                        var index = permission.indexOf(".");
                        if (index != -1) {
                            permission = permission.substr(index + 1);
                        }
                        __this._permissions[permission] = true;
                    }
                    __this.isAdmin(username).error(function () {
                        __this._permissions.isAdmin = false;
                    }).success(function (result) {
                        __this._permissions.isAdmin = result;
                        __this._eventService.publish("AuthenticationService/AuthenticationSuccess", data);
                        __this._locationService.path("/");
                    });
                });
            }
        });
    };
    AuthenticationService.prototype.autologin = function (username, authenticationToken) {
        var __this = this;
        __this._user = username;
        __this.authenticationCode = authenticationToken;
        __this._permissions.isAdmin = false;
        __this.getUserPermissions(username).error(function (e, x) {
            __this.authenticationMessage = e.Message;
            __this._eventService.publish("AuthenticationService/AuthenticationFailed", e.Message);
        }).success(function (permissions) {
            var length = permissions.length;
            for (var i = 0; i < length; i++) {
                var permission = permissions[i];
                var index = permission.indexOf(".");
                if (index != -1) {
                    permission = permission.substr(index + 1);
                }
                __this._permissions[permission] = true;
            }
            __this.isAdmin(username).error(function () {
                __this._permissions.isAdmin = false;
            }).success(function (result) {
                __this._permissions.isAdmin = result;
                __this._eventService.publish("AuthenticationService/AuthenticationSuccess", null /*data*/);
                __this._locationService.path("/");
            });
        });
    };
    AuthenticationService.prototype.getAuthenticationInfo = function (authenticationCookie, userData) {
        var parameters = {
            authenticationCookie: authenticationCookie,
            calibration: userData
        };
        return this._httpService.post(this._authUrl + "/GetAuthenticationInfo", JSON.stringify(parameters));
    };
    AuthenticationService.prototype.sendPatientURLVerification = function (linkProtocol, linkToken) {
        var data = {
            authenticationCookie: this._authenticationCode,
            linkProtocol: linkProtocol,
            linkToken: linkToken
        };
        return this._httpService.post(this._authUrl + "/SendPatientURLVerification", JSON.stringify(data));
    };
    AuthenticationService.prototype.verifyURLCode = function (url, key) {
        var data = {
            authenticationCookie: this._authenticationCode,
            url: url,
            key: key
        };
        return this._httpService.post(this._authUrl + "/VerifyURLCode", JSON.stringify(data));
    };
    AuthenticationService.prototype.getPatientURL = function (patientID, email, phoneNumber, miniToolbar, flags, requireAuthentication) {
        var data = {
            authenticationCookie: this._authenticationCode,
            userName: this._user,
            patientID: patientID,
            email: email,
            phoneNumber: phoneNumber,
            miniToolbar: miniToolbar,
            flags: flags,
            requireAuthentication: requireAuthentication
        };
        return this._httpService.post(this._authUrl + "/GetPatientURL", JSON.stringify(data));
    };
    AuthenticationService.prototype.sendPatientURLAsEmail = function (patientID, seriesInstanceUID, email, phoneNumber, miniToolbar, mailTitle, mailBody, isSD, requireAuthentication) {
        var data = {
            authenticationCookie: this._authenticationCode,
            userName: this._user,
            patientID: patientID,
            seriesInstanceUID: seriesInstanceUID,
            email: email,
            phoneNumber: phoneNumber,
            miniToolbar: miniToolbar,
            mailTitle: mailTitle,
            mailBody: mailBody,
            flags: (isSD ? 1 : 0),
            requireAuthentication: requireAuthentication
        };
        return this._httpService.post(this._authUrl + "/SendPatientURL", JSON.stringify(data));
    };
    AuthenticationService.prototype.tempAuthenticate = function (cookie, protocol, key) {
        var parameters = {
            authenticationCookie: this._authenticationCode,
            cookie: cookie,
            protocol: protocol,
            key: key
        };
        return this._httpService.post(this._authUrl + "/tempAuthenticate", JSON.stringify(parameters));
    };
    AuthenticationService.prototype.externalAuthenticate = function (cookie, protocol) {
        var parameters = {
            authenticationCookie: this._authenticationCode,
            cookie: cookie,
            protocol: protocol
        };
        return this._httpService.post(this._authUrl + "/ExternalAuthenticate", JSON.stringify(parameters));
    };
    AuthenticationService.prototype.implicitAuthenticate = function (cookie, protocol) {
        var parameters = {
            cookie: cookie,
            protocol: protocol
        };
        return this._httpService.post(this._authUrl + "/ImplicitAuthenticate", JSON.stringify(parameters));
    };
    AuthenticationService.prototype.logout = function () {
        var user = this.user;
        var code = this._authenticationCode;
        $.removeCookie("User", { path: '/' });
        $.removeCookie("Pass", { path: '/' });
        this._user = "";
        this._authenticationCode = "";
        this._eventService.publish(EventNames.Logout, { user: user, authenticationCode: code });
        //this._locationService.path("/login"); 
        this._window.location.reload();
    };
    AuthenticationService.prototype.logoutError = function (err) {
        var user = this.user;
        var code = this._authenticationCode;
        $.removeCookie("User", { path: '/' });
        $.removeCookie("Pass", { path: '/' });
        this._user = "";
        this._authenticationCode = "";
        this._eventService.publish(EventNames.Logout, { user: user, authenticationCode: code });
        //this._locationService.path("/login"); 
        this._window.location.reload();
        if (err) {
            alert(err);
        }
    };
    AuthenticationService.prototype.getUserPermissions = function (userName) {
        return this._httpService.get(this._authUrl + "/GetUserPermissions?" + "name=" + userName + "&rnd=" + new Date().getTime());
    };
    AuthenticationService.prototype.isAdmin = function (userName) {
        var dataArgs = "auth=" + encodeURIComponent(this._authenticationCode) + "&userName=" + userName;
        return this._httpService.get(this._authUrl + "/IsAdmin?" + dataArgs + "&r=" + Date.now());
    };
    AuthenticationService.prototype.getRolesNames = function () {
        return this._httpService.post(this._authUrl + "/GetRolesNames", null);
    };
    AuthenticationService.prototype.hasPermission = function (permission) {
        if (this._permissions) {
            return this.permissions[permission] || this.permissions.isAdmin;
        }
        return false;
    };
    AuthenticationService.prototype.createUser = function (username, password, userType) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            userName: username,
            password: password,
            userType: userType
        };
        return this._httpService.post(this._authUrl + "/CreateUser", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.createRole = function (role, description) {
        var Role = {
            AssignedPermissions: null,
            Description: description,
            Name: role,
        };
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            role: Role
        };
        return this._httpService.post(this._authUrl + "/CreateRole", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.getRoles = function () {
        var dataArgs = {
            authenticationCookie: this._authenticationCode
        };
        return this._httpService.post(this._authUrl + "/GetRoles", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.deleteRole = function (role) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            roleName: role
        };
        return this._httpService.post(this._authUrl + "/DeleteRole", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.getPermissions = function () {
        var dataArgs = {
            authenticationCookie: this._authenticationCode
        };
        return this._httpService.post(this._authUrl + "/GetPermissions", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.updateRolePermissions = function (role, permissions) {
        var Role = {
            AssignedPermissions: permissions,
            Description: null,
            Name: role
        };
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            role: Role
        };
        return this._httpService.post(this._authUrl + "/UpdateRolePermissions", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.getAllUsers = function () {
        var dataArgs = "auth=" + encodeURIComponent(this._authenticationCode) + "&rnd=" + new Date().getTime();
        return this._httpService.get(this._authUrl + "/GetAllUsers?" + dataArgs);
    };
    AuthenticationService.prototype.deleteUser = function (username, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            userName: username,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/DeleteUser", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.resetPassword = function (username, password, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            userName: username,
            newPassword: password,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/ResetPassword", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.resetCurrentPassword = function (curPassword, password) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            userName: "",
            oldPassword: curPassword,
            newPassword: password
        };
        return this._httpService.post(this._authUrl + "/ChangePassword", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.validatePassword = function (password, userdata) {
        var dataArgs = {
            password: password,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/ValidatePassword", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.getUserRoles = function (username, userdata) {
        var dataArgs = {
            username: username,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/GetUserRoles" + "?rnd=" + new Date().getTime(), JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.grantRole = function (username, role, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            username: username,
            role: role,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/GrantRole", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.denyRole = function (username, role, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            username: username,
            role: role,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/DenyRole", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.grantPermission = function (username, permission, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            username: username,
            permission: permission,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/GrantPermission", JSON.stringify(dataArgs));
    };
    AuthenticationService.prototype.denyPermission = function (username, permission, userdata) {
        var dataArgs = {
            authenticationCookie: this._authenticationCode,
            username: username,
            permission: permission,
            userData: userdata
        };
        return this._httpService.post(this._authUrl + "/DenyPermission", JSON.stringify(dataArgs));
    };
    AuthenticationService.$inject = ['app.config', '$http', '$location', 'eventService', '$window'];
    return AuthenticationService;
}());
services.service('authenticationService', AuthenticationService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var QueryArchiveService = /** @class */ (function () {
    function QueryArchiveService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._queryLocalUrl = config.urls.serviceUrl + config.urls.queryLocalServiceName;
        if (config.urls.threeDserviceUrl) {
            this._threedLocalUrl = config.urls.threeDserviceUrl + config.urls.threeDServiceName;
        }
        else {
            this._threedLocalUrl = config.urls.serviceUrl + config.urls.threeDServiceName;
        }
        this._currentPatientSeriesArray = [];
    }
    QueryArchiveService.prototype.get_CurrentPatientSeries = function (patientID) {
        return this._currentPatientSeriesArray[patientID];
    };
    QueryArchiveService.prototype.set_CurrentPatientSeries = function (patientID, patientSeries) {
        this._currentPatientSeriesArray[patientID] = patientSeries;
        this._currentPatientSeriesArray[patientID].LoadedBoxes = 0;
    };
    QueryArchiveService.prototype.get_PatientSeriesData = function (seriesInstanceUID) {
        var data = this._currentPatientSeriesArray;
        var item;
        var index;
        var patientData = null;
        Object.keys(data).forEach(function (key) {
            item = data[key];
            length = item.length;
            for (index = 0; index < length; index++) {
                if (item[index].InstanceUID == seriesInstanceUID) {
                    patientData = item[index];
                }
            }
        });
        return patientData;
    };
    QueryArchiveService.prototype.get_PatientData = function (seriesInstanceUID) {
        var data = this._currentPatientSeriesArray;
        var item;
        var index;
        var patientData = null;
        Object.keys(data).forEach(function (key) {
            item = data[key];
            length = item.length;
            for (index = 0; index < length; index++) {
                if (item[index].InstanceUID == seriesInstanceUID) {
                    patientData = item;
                }
            }
        });
        return patientData;
    };
    QueryArchiveService.prototype.FindPatients = function (queryParams, maxQueryResults) {
        var max = maxQueryResults || '0';
        if (max == "0")
            max = "10000";
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            extraOptions: { UserData: parseInt(max) }
        };
        return this._http.post(this._queryLocalUrl + "/FindPatients", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindPatientsRange = function (queryParams, from, to, maxQueryResults) {
        var max = maxQueryResults || '0';
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            extraOptions: { UserData: parseInt(max), From: from, To: to }
        };
        return this._http.post(this._queryLocalUrl + "/FindPatients", JSON.stringify(data));
    };
    QueryArchiveService.prototype.UploadDicomImage = function (buffer, start) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            dicomData: buffer,
            createFile: start
        };
        return this._http.post(this._queryLocalUrl + "/UploadDicomImage", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindStudies = function (queryParams, maxQueryResults) {
        var max = maxQueryResults || '0';
        // we wont allow more than 10000 because the database might be gigantic, and that will lead to a very long wait time.
        if (max == '0')
            max = '10000';
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            extraOptions: { UserData: parseInt(max) }
        };
        return this._http.post(this._queryLocalUrl + "/FindStudies", JSON.stringify(data));
    };
    QueryArchiveService.prototype.isDate = function (key) {
        if (key.toLowerCase().indexOf("date") != -1)
            return true;
        if (key.toLowerCase().indexOf("time") != -1)
            return true;
        return false;
    };
    QueryArchiveService.prototype.FindSeries = function (queryParams, maxQueryResults) {
        var max = maxQueryResults || '0';
        // we wont allow more than 10000 because the database might be gigantic, and that will lead to a very long wait time.
        if (max == '0')
            max = '10000';
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            extraOptions: { UserData: parseInt(max) }
        };
        var _this = this;
        return this._http.post(this._queryLocalUrl + "/FindSeries", JSON.stringify(data, function (key, value) {
            if (typeof value == 'string' && _this.isDate(key)) {
                var date = new Date(value);
                if (date != 'Invalid Date') {
                    return date.toUTCString();
                }
            }
            return value;
        }));
    };
    QueryArchiveService.prototype.FindPresentationState = function (referencedSeries) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&series=" + referencedSeries;
        return this._http.get(this._queryLocalUrl + "/FindPresentationState?" + parameter);
    };
    QueryArchiveService.prototype.KeepAlive = function (id) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id
        };
        return this._http.post(this._threedLocalUrl + "/KeepAlive", JSON.stringify(data));
    };
    QueryArchiveService.prototype.Start3DObject = function (queryParams, id, renderingMethod, stackInstanceUID) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            id: id,
            renderingType: renderingMethod,
            extraOptions: { UserData2: stackInstanceUID }
        };
        return this._http.post(this._threedLocalUrl + "/Create3DObject", JSON.stringify(data));
    };
    QueryArchiveService.prototype.GetSliceURL = function (url) {
        return this._threedLocalUrl + "/Get3DSlice?auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&url=" + url + "&fileName=";
    };
    QueryArchiveService.prototype.Generate3DSlice = function (id, widthCurve, heightCurve, info) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id,
            widthCurve: widthCurve,
            heightCurve: heightCurve,
            polygonInfo: info,
        };
        return this._http.post(this._threedLocalUrl + "/Generate3DSlice", JSON.stringify(data));
    };
    QueryArchiveService.prototype.CheckProgress = function (id) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id
        };
        return this._http.post(this._threedLocalUrl + "/CheckProgress", JSON.stringify(data));
    };
    QueryArchiveService.prototype.Get3DSettings = function (settings, id) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id,
            options: settings,
        };
        return this._http.post(this._threedLocalUrl + "/Get3DSettings", JSON.stringify(data));
    };
    QueryArchiveService.prototype.Update3DSettings = function (settings, id) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id,
            options: settings,
        };
        return this._http.post(this._threedLocalUrl + "/Update3DSettings", JSON.stringify(data));
    };
    QueryArchiveService.prototype.Get3DImage = function () {
        return this._threedLocalUrl + "/Get3DImage?auth=" + encodeURIComponent(this._authenticationService.authenticationCode);
    };
    QueryArchiveService.prototype.GetPanoramic3DImage = function () {
        return this._threedLocalUrl + "/GetPanoramicImage?auth=" + encodeURIComponent(this._authenticationService.authenticationCode);
    };
    QueryArchiveService.prototype.Close3DImage = function (id) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            id: id,
        };
        return this._http.post(this._threedLocalUrl + "/End3DObject", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindSeriesArrayInstances = function (seriesArray) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            series: seriesArray,
            extraOptions: { UserData2: null }
        };
        return this._http.post(this._queryLocalUrl + "/FindArrayInstances", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindInstancesForCT = function (queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
        };
        return this._http.post(this._queryLocalUrl + "/FindInstancesForCT", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindInstances = function (queryParams, stackInstanceUID) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            extraOptions: { UserData2: stackInstanceUID }
        };
        return this._http.post(this._queryLocalUrl + "/FindInstances", JSON.stringify(data));
    };
    QueryArchiveService.prototype.ElectStudyTimeLineInstances = function (queryParams, userData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            userData: userData || null
        };
        return this._http.post(this._queryLocalUrl + "/ElectStudyTimeLineInstances", JSON.stringify(data));
    };
    QueryArchiveService.prototype.FindHangingProtocols = function (studyInstanceUID, userData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            studyInstanceUID: studyInstanceUID,
            userData: userData || null
        };
        return this._http.post(this._queryLocalUrl + "/FindHangingProtocols", JSON.stringify(data));
    };
    QueryArchiveService.prototype.AutoComplete = function (key, term) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&key=" + key + "&term=" + term;
        ;
        var __this = this;
        return this._http.get(this._queryLocalUrl + "/AutoComplete?" + parameter, { cache: false });
    };
    QueryArchiveService.$inject = ['app.config', 'authenticationService', '$http'];
    return QueryArchiveService;
}());
services.service('queryArchiveService', QueryArchiveService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var ObjectRetrieveService = /** @class */ (function () {
    function ObjectRetrieveService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._retrieveLocalUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
        if (config.urls.threeDserviceUrl) {
            this._threedLocalUrl = config.urls.threeDserviceUrl + config.urls.threeDServiceName;
        }
        else {
            this._threedLocalUrl = config.urls.serviceUrl + config.urls.threeDServiceName;
        }
    }
    ObjectRetrieveService.prototype.GetImageUrl = function (frame, maxWidth, maxHeight) {
        var maxSize = "";
        if (maxWidth && maxHeight) {
            maxSize = '&cx=' + maxWidth + '&cy=' + maxHeight;
        }
        return this._retrieveLocalUrl + '/GetImage?auth=' + encodeURIComponent(this._authenticationService.authenticationCode) + '&instance=' + frame.Instance.SOPInstanceUID + '&frame=' + frame.FrameNumber + '&bp=0&qf=0&mime=image/jpeg' + maxSize;
    };
    ObjectRetrieveService.prototype.GetSTLData = function (seriesInstanceUID) {
        var parameter;
        var callUrl;
        parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&seriesInstanceUID=" + seriesInstanceUID;
        return this._retrieveLocalUrl + "/GetSTLData?" + parameter;
    };
    ObjectRetrieveService.prototype.GetDicomImageDataAsPngURL = function (studyInstanceUID, seriesInstanceUID, sopInstanceUID, frameNumber, userData, functions) {
        var data = userData;
        var parameter;
        var callUrl;
        data.functions = functions || null;
        parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&study=" + studyInstanceUID + "&series=" + seriesInstanceUID + "&instance=" + sopInstanceUID + "&frame=" + frameNumber + "&data=" + JSON.stringify(data);
        callUrl = this._retrieveLocalUrl + "/GetDicomImageDataAsPNG" + "?" + parameter;
        return callUrl;
    };
    ObjectRetrieveService.prototype.GetMPRFrame = function (id, mprType, index) {
        return this._threedLocalUrl + "/GetMPRImage?" + "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&id=" + id + "&mprType=" + mprType + "&index=" + index;
    };
    ObjectRetrieveService.prototype.GetImageUrlPreprocessed = function (frame, maxWidth, maxHeight, functions, random) {
        var data = {};
        var maxSize = "";
        var addRandom = "";
        if (maxWidth && maxHeight) {
            maxSize = '&cx=' + maxWidth + '&cy=' + maxHeight;
        }
        if (random) {
            addRandom = '&r=' + Date.now();
        }
        data.width = 0;
        data.height = 0;
        data.functions = functions;
        return this._retrieveLocalUrl + '/GetImage?auth=' + encodeURIComponent(this._authenticationService.authenticationCode) + '&instance=' + frame.Instance.SOPInstanceUID + '&frame=' + frame.FrameNumber + maxSize + "&data=" + JSON.stringify(data) + addRandom;
    };
    ObjectRetrieveService.prototype.GetSeriesLayout = function (seriesInstanceUID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&seriesinstanceUID=" + seriesInstanceUID + "&data=" + userData + '&r=' + Date.now();
        return this._http.get(this._retrieveLocalUrl + "/GetSeriesLayout?" + parameter);
    };
    ObjectRetrieveService.prototype.GetPatientStructuredDisplay = function (patientID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&patientID=" + patientID + "&data=" + userData + '&r=' + Date.now();
        return this._http.get(this._retrieveLocalUrl + "/GetPatientStructuredDisplay?" + parameter);
    };
    ObjectRetrieveService.prototype.GetStudyLayout = function (studyInstanceUID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&studyInstanceUID=" + studyInstanceUID + "&data=" + userData + '&r=' + Date.now();
        return this._http.get(this._retrieveLocalUrl + "/GetStudyLayout?" + parameter);
    };
    ObjectRetrieveService.prototype.GetPresentationInfo = function (seriesInstanceUID) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&series=" + seriesInstanceUID;
        return this._http.get(this._retrieveLocalUrl + "/GetPresentationInfo?" + parameter);
    };
    ObjectRetrieveService.prototype.GetDicomJSON = function (studyInstanceUID, seriesInstanceUID, sopInstanceUID) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&study=" + studyInstanceUID + "&series=" + seriesInstanceUID + "&instance=" + sopInstanceUID;
        return this._http.get(this._retrieveLocalUrl + "/GetDicomJSON?" + parameter, { headers: { 'Content-Type': 'application/json' } });
    };
    ObjectRetrieveService.prototype.UploadAnnotations = function (annotationData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            data: annotationData
        };
        return this._http.post(this._retrieveLocalUrl + "/UploadAnnotations", JSON.stringify(data));
    };
    ObjectRetrieveService.prototype.DownloadImageUrl = function (frame, annFileName, maxWidth, maxHeight, xDpi, yDpi, userData) {
        var q = "&bp=0&qf=0";
        var maxSize = "";
        if (maxWidth && maxHeight) {
            maxSize = '&cx=' + maxWidth + '&cy=' + maxHeight;
        }
        else {
            maxSize = '&cx=0&cy=0';
        }
        userData = userData == undefined ? "" : userData;
        return this._retrieveLocalUrl + '/DownloadImage?auth=' + encodeURIComponent(this._authenticationService.authenticationCode) + '&instance=' + frame.Instance.SOPInstanceUID + '&frame=' + frame.FrameNumber + q + maxSize + '&annotationFileName=' + encodeURIComponent(annFileName) + '&xDpi=' + xDpi + '&yDpi=' + yDpi + '&data=' + userData;
    };
    ObjectRetrieveService.prototype.GetPresentationAnnotations = function (sopInstanceUID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&instance=" + sopInstanceUID + "&data=" + userData;
        return this._http.get(this._retrieveLocalUrl + "/GetPresentationAnnotations?" + parameter, { headers: { 'Content-Type': 'application/xml' } });
    };
    ObjectRetrieveService.prototype.GetMappedPresentationAnnotations = function (sopInstanceUID, userData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            sopInstanceUID: sopInstanceUID,
            userData: userData
        };
        return this._http.post(this._retrieveLocalUrl + "/GetMappedPresentationAnnotations", JSON.stringify(data));
    };
    ObjectRetrieveService.prototype.GetAudioGroupsCount = function (sopInstanceUID) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            sopInstanceUID: sopInstanceUID
        };
        return this._http.post(this._retrieveLocalUrl + "/GetAudioGroupsCount", JSON.stringify(data));
    };
    ObjectRetrieveService.prototype.GetSeriesStacks = function (seriesInstanceUID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&seriesinstanceUID=" + seriesInstanceUID + "&data=" + userData;
        return this._http.get(this._retrieveLocalUrl + "/GetSeriesStacks?" + parameter);
    };
    ObjectRetrieveService.prototype.GetHangingProtocol = function (sopInstanceUID, userData) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&instance=" + sopInstanceUID + "&data=" + userData + '&r=' + Date.now();
        return this._http.get(this._retrieveLocalUrl + "/GetHangingProtocol?" + parameter);
    };
    ObjectRetrieveService.prototype.GetHangingProtocolInstances = function (sopInstanceUID, patientId, studyInstanceUID, studyDateMostRecent, userData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            hangingProtocolSOP: sopInstanceUID,
            patientID: patientId,
            studyInstanceUID: studyInstanceUID,
            studyDateMostRecent: studyDateMostRecent,
            userData: userData
        };
        return this._http.post(this._retrieveLocalUrl + "/GetHangingProtocolInstances", JSON.stringify(data));
    };
    ObjectRetrieveService.prototype.BuildAudioUrl = function (sopInstanceUID, groupIndex, mime) {
        return this._retrieveLocalUrl + '/GetAudio?auth=' + encodeURIComponent(this._authenticationService.authenticationCode) + '&instance=' + sopInstanceUID + '&group=' + groupIndex + '&mime=' + encodeURIComponent(mime);
    };
    ObjectRetrieveService.prototype.ClearCache = function () {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode
        };
        return this._http.post(this._retrieveLocalUrl + "/ClearCache", JSON.stringify(data));
    };
    ObjectRetrieveService.$inject = ['app.config', 'authenticationService', '$http'];
    return ObjectRetrieveService;
}());
services.service('objectRetrieveService', ObjectRetrieveService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var ObjectStoreService = /** @class */ (function () {
    function ObjectStoreService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._storeLocalUrl = config.urls.serviceUrl + config.urls.objectStoreLocalServiceName;
    }
    ObjectStoreService.prototype.UploadDicomImage = function (buffer, uploadStatus, uploadedFileName) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            dicomData: buffer,
            status: uploadStatus,
            fileName: uploadedFileName
        };
        return this._http.post(this._storeLocalUrl + "/UploadDicomImage", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreSecondaryCapture = function (encodedCapture, originalSOPId, seriesNumber, seriesDescription, protocolName) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            EncodedCapture: encodedCapture,
            OriginalSOPInstance: originalSOPId,
            SeriesNumber: seriesNumber,
            SeriesDescription: seriesDescription,
            ProtocolName: protocolName
        };
        return this._http.post(this._storeLocalUrl + "/StoreSecondaryCapture", JSON.stringify(data));
    };
    ObjectStoreService.prototype.DeleteAnnotations = function (sopInstanceUID, userdata) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            sopInstanceUID: sopInstanceUID,
            userData: userdata || null
        };
        return this._http.post(this._storeLocalUrl + "/DeletePresentationState", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreDerivedSeries = function (seriesInstanceUID, derivedSeriesNumber, derivedSeriesDescription, derivedProtocol, rowSpacing, columnSpacing) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUID: seriesInstanceUID,
            seriesNumber: derivedSeriesNumber,
            seriesDescription: derivedSeriesDescription,
            protocolName: derivedProtocol,
            rowSpacings: JSON.stringify(rowSpacing),
            columnSpacings: JSON.stringify(columnSpacing)
        };
        return this._http.post(this._storeLocalUrl + "/StoreDerived", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreStructuredDisplay = function (seriesInstanceUID, derivedSeriesNumber, derivedSeriesDescription, derivedProtocol, sopInstanceUIDs, rowSpacing, columnSpacing) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUID: seriesInstanceUID,
            seriesNumber: derivedSeriesNumber,
            seriesDescription: derivedSeriesDescription,
            protocolName: derivedProtocol,
            sopInstanceUIDs: JSON.stringify(sopInstanceUIDs),
            rowSpacings: JSON.stringify(rowSpacing),
            columnSpacings: JSON.stringify(columnSpacing)
        };
        return this._http.post(this._storeLocalUrl + "/StoreStructuredDisplayDerived", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreAnnotations = function (seriesInstanceUID, annotationData, description, userdata, useRulerCalibrationScale) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUID: seriesInstanceUID,
            annotationData: annotationData,
            description: description,
            userData: userdata || null,
            useRulerCalibrationScale: useRulerCalibrationScale
        };
        return this._http.post(this._storeLocalUrl + "/StoreAnnotations", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreStudyLayout = function (studyInstanceUID, studyLayout, userdata) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            studyInstanceUID: studyInstanceUID,
            studyLayout: studyLayout,
            userData: userdata || null
        };
        return this._http.post(this._storeLocalUrl + "/StoreStudyLayout", JSON.stringify(data, function (key, value) {
            if (value instanceof lt.LeadPointD) {
                var x = Utils.roundNumber(value.x, 7);
                var y = Utils.roundNumber(value.y, 7);
                //
                // lt.LeadPointD is serializing as {_x, _y}.  Need to change to {x, y}.
                //
                return { x: x, y: y };
            }
            return value;
        }));
    };
    ObjectStoreService.prototype.DeleteStudyLayout = function (studyInstanceUID, userdata) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            studyInstanceUID: studyInstanceUID,
            userData: userdata || null
        };
        return this._http.post(this._storeLocalUrl + "/DeleteStudyLayout", JSON.stringify(data));
    };
    ObjectStoreService.prototype.StoreHangingProtocol = function (hangingProtocol, userdata) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            hangingProtocol: hangingProtocol,
            userData: userdata || null
        };
        return this._http.post(this._storeLocalUrl + "/StoreHangingProtocol", JSON.stringify(data, function (key, value) {
            if (value instanceof lt.LeadPointD) {
                var x = Utils.roundNumber(value.x, 7);
                var y = Utils.roundNumber(value.y, 7);
                //
                // lt.LeadPointD is serializing as {_x, _y}.  Need to change to {x, y}.
                //
                return { x: x, y: y };
            }
            else if (key == 'WCFHangingProtocolCreationDateTime') {
                var date = new Date(value);
                if (date != 'Invalid Date') {
                    return date.toUTCString();
                }
            }
            return value;
        }));
    };
    ObjectStoreService.$inject = ['app.config', 'authenticationService', '$http'];
    return ObjectStoreService;
}());
services.service('objectStoreService', ObjectStoreService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../app.ts" />
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
var PatientService = /** @class */ (function () {
    function PatientService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._patientServiceUrl = config.urls.serviceUrl + config.urls.patientServiceName;
    }
    // AddPatient
    // : JQueryXHR 
    //{
    //var dataArgs = {
    //    authenticationCookie: this.AuthenticationProxy.GetAuthenticationCookie(),
    //    info: patientInfo,
    //    userData: null
    //};
    //return super.DoPostGeneralCall("AddPatient", dataArgs, errorHandler, successHandler);
    //}
    PatientService.prototype.AddPatient = function (patientInfo) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            info: patientInfo,
            userData: null
        };
        return this._http.post(this._patientServiceUrl + "/AddPatient", JSON.stringify(data));
    };
    PatientService.prototype.UpdatePatient = function (patientInfo) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            info: patientInfo,
            extraOptions: null
        };
        return this._http.post(this._patientServiceUrl + "/UpdatePatient", JSON.stringify(data));
        // return super.DoPostGeneralCall("UpdatePatient", dataArgs, errorHandler, successHandler);
    };
    PatientService.prototype.DeletePatient = function (patientId) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            patientId: patientId,
            extraOptions: null
        };
        return this._http.post(this._patientServiceUrl + "/DeletePatient", JSON.stringify(data));
        // return super.DoPostGeneralCall("DeletePatient", dataArgs, errorHandler, successHandler);
    };
    PatientService.$inject = ['app.config', 'authenticationService', '$http'];
    return PatientService;
}());
;
var PatientInfo = /** @class */ (function () {
    function PatientInfo(patientId, name, birthDate, sex, comments, ethnicGroup) {
        this.PatientId = patientId;
        this.Name = name;
        this.BirthDate = birthDate;
        this.Sex = sex;
        this.Comments = comments;
        this.EthnicGroup = ethnicGroup;
    }
    return PatientInfo;
}());
var PersonName = /** @class */ (function () {
    function PersonName() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.First = "";
        this.Last = "";
        this.Middle = "";
        this.Prefix = "";
        this.Suffix = "";
        if (args.length >= 1)
            this.Last = args[0];
        if (args.length >= 2)
            this.First = args[1];
        if (args.length >= 3)
            this.Middle = args[2];
        if (args.length >= 4)
            this.Prefix = args[3];
        if (args.length >= 5)
            this.Suffix = args[4];
        this.sep = "^";
    }
    PersonName.prototype.getDicomName = function () {
        var dicomName = this.Last.trim() + this.sep + this.First.trim() + this.sep + this.Middle.trim() + this.sep + this.Prefix.trim() + this.sep + this.Suffix.trim();
        return dicomName;
    };
    PersonName.getPersonName = function (dicomName) {
        var personName = new PersonName();
        var nameParts = dicomName.split('^');
        if (nameParts.length >= 1)
            personName.Last = nameParts[0];
        if (nameParts.length >= 2)
            personName.First = nameParts[1];
        if (nameParts.length >= 3)
            personName.Middle = nameParts[2];
        if (nameParts.length >= 4)
            personName.Prefix = nameParts[3];
        if (nameParts.length >= 5)
            personName.Suffix = nameParts[4];
        return personName;
    };
    return PersonName;
}());
services.service('patientService', PatientService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var WebViewerCommandNames;
(function (WebViewerCommandNames) {
    WebViewerCommandNames.LOAD_SERIES = "LoadSeriesCommand";
    WebViewerCommandNames.LOAD_SERIES_EXT = "LoadSeriesCommandExt";
    WebViewerCommandNames.LOAD_STRUCTURED_DISPLAY_EXT = "LoadStructuredDisplayCommandExt";
    WebViewerCommandNames.SET_SERIES_VIEWER_MODE = "SetSeriesViewerModeCommand";
    WebViewerCommandNames.ALIVE = "ALIVE";
    WebViewerCommandNames.SUBSCRIBE = "SubscribeToEventsCommand";
})(WebViewerCommandNames || (WebViewerCommandNames = {}));
;
var WebViewerMessage = /** @class */ (function () {
    function WebViewerMessage() {
        this._params = [];
    }
    WebViewerMessage.prototype.get_Command = function () {
        return this._cmd;
    };
    WebViewerMessage.prototype.get_Params = function () {
        return this._params;
    };
    WebViewerMessage.prototype.Parse = function (msgData) {
        var commandParams = msgData.split("?");
        if (commandParams.length === 2) {
            this._cmd = commandParams[0];
            this._params = WebViewerMessage.ParseQueryString(msgData);
        }
    };
    WebViewerMessage.SendCommand = function (cmd, receiver, url) {
        receiver.postMessage(cmd.toString(), url);
    };
    WebViewerMessage.ParseQueryString = function (url) {
        var query = url.split("?");
        var queryParams = [];
        if (query && query.length == 2) {
            query = query[1].split("&");
        }
        else {
            return queryParams;
        }
        if (query.length == 1 && query[0] === "") {
            return queryParams;
        }
        var length = query.length;
        while (length--) {
            var keyValue = query[length].split("=");
            var key = decodeURIComponent(keyValue[0]);
            var value = decodeURIComponent(keyValue[1]);
            if (key && key.length) {
                queryParams[key] = value;
            }
        }
        return queryParams;
    };
    return WebViewerMessage;
}());
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Models;
(function (Models) {
    var PatientQueryOptions = /** @class */ (function () {
        function PatientQueryOptions() {
        }
        return PatientQueryOptions;
    }());
    Models.PatientQueryOptions = PatientQueryOptions;
    var StudyQueryOptions = /** @class */ (function () {
        function StudyQueryOptions() {
        }
        return StudyQueryOptions;
    }());
    Models.StudyQueryOptions = StudyQueryOptions;
    var SeriesQueryOptions = /** @class */ (function () {
        function SeriesQueryOptions() {
        }
        return SeriesQueryOptions;
    }());
    Models.SeriesQueryOptions = SeriesQueryOptions;
    var QueryOptions = /** @class */ (function () {
        function QueryOptions() {
            this.PatientsOptions = new PatientQueryOptions();
            this.StudiesOptions = new StudyQueryOptions();
            this.SeriesOptions = new SeriesQueryOptions();
        }
        return QueryOptions;
    }());
    Models.QueryOptions = QueryOptions;
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../Services/QueryArchiveService.ts" />
/// <reference path="../Services/ObjectRetrieveService.ts" />
/// <reference path="../Services/ObjectStoreService.ts" />
/// <reference path="../Services/PatientService.ts" />
/// <reference path="WebViewerCommands.ts" />
/// <reference path="../Controllers/Scopes.ts" />
/// <reference path="../Models/QueryOptions.ts" />
var WebViewerCommandHandlerService = /** @class */ (function () {
    function WebViewerCommandHandlerService(authenticationService, webViewerAuthenticationToken, viewerWindow) {
        var injector = angular.element(document.getElementById('app')).injector();
        this._queryArchiveService = injector.get('queryArchiveService');
        this._objectRetrieveService = injector.get('objectRetrieveService');
        this._objectStoreService = injector.get('objectStoreService');
        this._patientService = injector.get('patientService');
        this._optionsService = injector.get('optionsService');
        this._authenticationToken = webViewerAuthenticationToken;
        this._authenticationService = authenticationService;
        this._authenticationService.authenticationCode = webViewerAuthenticationToken;
        this._viewerWindow = viewerWindow;
    }
    WebViewerCommandHandlerService.prototype.SendCommand = function (cmd, receiver, url) {
        receiver.postMessage(JSON.stringify(cmd), url);
    };
    WebViewerCommandHandlerService.prototype.Authenticate = function (userName, password, errorHandler, successHandler) {
        var serviceUrl = "http://" + location.host + "/MedicalViewerServiceWcf20/AuthenticationService.svc/AuthenticateUser";
        var parameters = { userName: userName, password: password, userData: null };
        return $.ajax({
            type: "POST",
            contentType: "application/json",
            url: serviceUrl,
            data: JSON.stringify(parameters),
            error: errorHandler,
            success: successHandler
        });
    };
    WebViewerCommandHandlerService.prototype.LogOut = function () {
        this._authenticationService.logout();
        this.Close();
    };
    WebViewerCommandHandlerService.prototype.LogOutError = function (err) {
        this._authenticationService.logoutError(err);
        this.Close();
    };
    WebViewerCommandHandlerService.prototype.Close = function () {
        if (this._viewerWindow === window) {
            var win = window.open("", "_self");
            win.close();
        }
        else if (this._viewerWindow) {
            this._viewerWindow.close();
        }
    };
    WebViewerCommandHandlerService.prototype.isDental = function () {
        return this._optionsService.isSeriesView();
    };
    WebViewerCommandHandlerService.prototype.FindPatient = function (patientID, findPatientOptions, errorHandler, successHandler) {
        var __this = this;
        var options = new Models.QueryOptions();
        options.PatientsOptions.PatientID = patientID;
        options.PatientsOptions.PatientName = "";
        options.StudiesOptions.AccessionNumber = "";
        options.StudiesOptions.ReferDoctorName = "";
        options.StudiesOptions.ModalitiesInStudy = new Array();
        if (findPatientOptions === "All") {
            this._queryArchiveService.FindPatients(options).then(successHandler, errorHandler);
        }
        else {
            var maxStudies = this._optionsService.get(OptionNames.MaxStudyResults);
            this._queryArchiveService.FindStudies(options, maxStudies).then(function (e) {
                __this.onSearchStudiesError(e);
                errorHandler(e);
            }, $.proxy(successHandler, this));
        }
    };
    WebViewerCommandHandlerService.prototype.FindPatientFromSeries = function (seriesInstanceUID, findPatientOptions, errorHandler, successHandler) {
        var __this = this;
        var queryParams = new Models.QueryOptions();
        queryParams.SeriesOptions.SeriesInstanceUID = seriesInstanceUID;
        if (findPatientOptions === "All") {
            this._queryArchiveService.FindPatients(queryParams).then(successHandler, errorHandler);
        }
        else {
            var maxStudies = this._optionsService.get(OptionNames.MaxStudyResults);
            this._queryArchiveService.FindStudies(queryParams, maxStudies).then(function (e) {
                __this.onSearchStudiesError(e);
                errorHandler(e);
            }, $.proxy(successHandler, this));
        }
    };
    WebViewerCommandHandlerService.prototype.UpdatePatient = function (patientInfo, errorHandler, successHandler) {
        var __this = this;
        this._patientService.UpdatePatient(patientInfo).then(successHandler, function (e) {
            __this.onUpdatePatientError(e);
            errorHandler(e);
        });
    };
    WebViewerCommandHandlerService.prototype.DeletePatient = function (patientId, errorHandler, successHandler) {
        var __this = this;
        this._patientService.DeletePatient(patientId).then(successHandler, function (e) {
            __this.onDeletePatientError(e);
            errorHandler(e);
        });
    };
    WebViewerCommandHandlerService.prototype.AddPatient = function (patientInfo, errorHandler, successHandler) {
        var __this = this;
        this._patientService.AddPatient(patientInfo).then(successHandler, function (e) {
            __this.onAddPatientError(e);
            errorHandler(e);
        });
    };
    WebViewerCommandHandlerService.prototype.onSearchStudiesSuccess = function (studies) {
        LogUtils.DebugLog(studies);
    };
    WebViewerCommandHandlerService.prototype.onSearchStudiesError = function (/*xhr,*/ textStatus /*, ex*/) {
        LogUtils.DebugLog("Failed to find series: " + textStatus);
    };
    WebViewerCommandHandlerService.prototype.onUpdatePatientError = function (textStatus) {
        LogUtils.DebugLog("Failed to update patient: " + textStatus);
    };
    WebViewerCommandHandlerService.prototype.onDeletePatientError = function (textStatus) {
        LogUtils.DebugLog("Failed to delete patient: " + textStatus);
    };
    WebViewerCommandHandlerService.prototype.onAddPatientError = function (textStatus) {
        LogUtils.DebugLog("Failed to add patient: " + textStatus);
    };
    WebViewerCommandHandlerService.prototype.onAuthenticationError = function (xhr, status, ex) {
        alert("failed to authenticate user: " + ex);
    };
    WebViewerCommandHandlerService.prototype.onAuthenticationSuccess = function (authentication) {
        alert("authentication success");
        this._authenticationToken = authentication;
    };
    WebViewerCommandHandlerService.prototype.onFindStudiesError = function (xhr, status, ex) {
        alert("Failed to query for studies: " + ex);
    };
    WebViewerCommandHandlerService.FilterPresentationState = function (series) {
        var removedPresentationStateInstanceUIDs = [];
        var length = series.length;
        while (length--) {
            if (series[length].Modality == "PR") {
                var prSeries = series.splice(length, 1);
                prSeries = prSeries[0];
                removedPresentationStateInstanceUIDs.push(prSeries.InstanceUID);
            }
        }
        return removedPresentationStateInstanceUIDs;
    };
    WebViewerCommandHandlerService.prototype.FilterSeriesInstances = function (instances, seriesInstanceUIDs) {
        var length = instances.length;
        while (length--) {
            if (seriesInstanceUIDs.indexOf(instances[length].SeriesInstanceUID) != -1) {
                instances.splice(length, 1);
            }
        }
    };
    WebViewerCommandHandlerService.prototype.FindStructuredDisplay = function (patientID, errorHandler, successHandler) {
        this._objectRetrieveService.GetPatientStructuredDisplay(patientID).then(function (sdResult) {
            if (successHandler !== null) {
                successHandler(sdResult);
            }
        });
    };
    WebViewerCommandHandlerService.prototype.FindSeriesExt = function (patientID, studyInstanceUID, seriesInstanceUID, errorHandler, successHandler) {
        var queryOptions = new Models.QueryOptions();
        var maxSeries = this._optionsService.get(OptionNames.MaxStudyResults);
        queryOptions.PatientsOptions.PatientID = patientID;
        queryOptions.StudiesOptions.StudyInstanceUID = studyInstanceUID;
        queryOptions.SeriesOptions.SeriesInstanceUID = seriesInstanceUID;
        var _this = this;
        this._objectRetrieveService.GetPatientStructuredDisplay(patientID).then(function (sdResult) {
            var _sdResults = sdResult;
            _this._queryArchiveService.FindSeries(queryOptions, maxSeries)
                .then(function (series) {
                //Filter out the presentation state instances
                WebViewerCommandHandlerService.FilterPresentationState(series.data);
                if (successHandler !== null) {
                    successHandler(series, _sdResults);
                }
            }, errorHandler);
        });
    };
    WebViewerCommandHandlerService.prototype.GetInstanceImageURL = function (sopInstanceUID, successHandler) {
        var frame = {};
        frame.FrameNumber = 1;
        frame.Instance = {};
        frame.Instance.SOPInstanceUID = sopInstanceUID;
        var url = this._objectRetrieveService.GetImageUrl(frame, 1024, 1024);
        if (successHandler != null) {
            successHandler(url);
        }
    };
    WebViewerCommandHandlerService.prototype.ShowStructuredDisplayExt = function (seriesArray, seriesInstance, completed, style) {
        var loadSeriesCommandExt = {};
        loadSeriesCommandExt.name = WebViewerCommandNames.LOAD_STRUCTURED_DISPLAY_EXT;
        loadSeriesCommandExt.seriesArray = JSON.stringify(seriesArray);
        loadSeriesCommandExt.seriesSelected = JSON.stringify(seriesInstance);
        loadSeriesCommandExt.style = style;
        this.SendCommand(loadSeriesCommandExt, this._viewerWindow, "*");
        if (completed != null) {
            completed();
        }
    };
    WebViewerCommandHandlerService.prototype.ShowSeriesInstanceExt = function (seriesArray, seriesInstance, completed, style) {
        var loadSeriesCommandExt = {};
        loadSeriesCommandExt.name = WebViewerCommandNames.LOAD_SERIES_EXT;
        loadSeriesCommandExt.seriesArray = JSON.stringify(seriesArray);
        loadSeriesCommandExt.seriesSelected = JSON.stringify(seriesInstance);
        loadSeriesCommandExt.style = style;
        this.SendCommand(loadSeriesCommandExt, this._viewerWindow, "*");
        if (completed != null) {
            completed();
        }
    };
    WebViewerCommandHandlerService.prototype.SetSeriesViewerMode = function (seriesViewerMode) {
        //var setSeriesViewerModeCommand = new SetSeriesViewerModeCommand(seriesViewerMode);
        //SendCommand(setSeriesViewerModeCommand, webViewerControllerInstance.ViewerWindow, "*");
    };
    WebViewerCommandHandlerService.$inject = ["authenticationService", "webViewerAuthenticationToken", "viewerWindow"];
    return WebViewerCommandHandlerService;
}());
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
// ExternalCommands.ts
/// <reference path="SharedPropertiesService.ts" />
/// <reference path="WebViewerCommandHandlerService.ts" />
/*jshint eqnull:true */
/*jslint plusplus: true */
/*jslint white: true */
/*global describe:true*/
/*jslint newcap: true*/
/*jslint nomen: true*/
/*jshint onevar: false */
/*global window : false */
/*global WebViewerCommandHandlerService : false */
/*global setTimeout : false */
/*global DebugLog : false */
/*global ParseQueryString : false */
/*global location : false */
var ExternalCommandNames;
(function (ExternalCommandNames) {
    ExternalCommandNames.LogOut = "LogOut";
    ExternalCommandNames.Close = "Close";
    ExternalCommandNames.FindPatient = "FindPatient";
    ExternalCommandNames.FindPatients = "FindPatient";
    ExternalCommandNames.ShowPatient = "ShowPatient";
    ExternalCommandNames.ShowStudy = "ShowStudy";
    ExternalCommandNames.ShowSeries = "ShowSeries";
    ExternalCommandNames.ShowInstance = "ShowInstance";
    ExternalCommandNames.GetCurrentPatient = "GetCurrentPatient";
    ExternalCommandNames.SearchImage = "SearchImage";
    ExternalCommandNames.GetImage = "GetImage";
    ExternalCommandNames.AddPatient = "AddPatient";
    ExternalCommandNames.DeletePatient = "DeletePatient";
    ExternalCommandNames.UpdatePatient = "UpdatePatient";
    ExternalCommandNames.EndAssociation = "EndAssociation";
    ExternalCommandNames.AddUser = "AddUser";
    ExternalCommandNames.UpdateUser = "UpdateUser";
    ExternalCommandNames.DeleteUser = "DeleteUser";
})(ExternalCommandNames || (ExternalCommandNames = {}));
;
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var TabTypes;
(function (TabTypes) {
    TabTypes.None = -1;
    TabTypes.Search = 0;
    TabTypes.Viewer = 1;
    TabTypes.UserQueue = 2;
    TabTypes.Compare = 3;
})(TabTypes || (TabTypes = {}));
var Models;
(function (Models) {
    var Tab = /** @class */ (function () {
        function Tab(id) {
            this._id = id;
            this.title = "";
            this.templateUrl = "";
            this.controller = "";
            this.active = false;
            this._type = TabTypes.None;
            this._canDelete = false;
            this._data = {};
            this._visible = true;
            this._itemCount = 0;
            this._engineDictionary = {};
        }
        Object.defineProperty(Tab.prototype, "showStudyTimeLine", {
            get: function () {
                return this._showStudyTimeLine;
            },
            set: function (value) {
                this._showStudyTimeLine = value;
            },
            enumerable: false,
            configurable: true
        });
        Tab.prototype.handle_engine3DData = function (sender, args, frame, queryArchiveService, query, id, sopInstanceUID, optionsService) {
            var engine = sender;
            var renderingMethod = optionsService.get(OptionNames.RenderingMethod);
            renderingMethod = (renderingMethod.indexOf("Hardware") != -1) ? 0 : 1;
            switch (args.type) {
                case lt.Controls.Medical.Requested3DDataType.none:
                    var json = JSON.parse(args.JSON);
                    var widthCurve = json['widthCurve'];
                    var heightCurve = json['heightCurve'];
                    var polygonInfo = JSON.stringify(json['polygonInfo']);
                    queryArchiveService.Generate3DSlice(id, widthCurve, heightCurve, polygonInfo).then(function (data) {
                        frame.URI = queryArchiveService.GetSliceURL(data.data);
                    });
                    break;
                case lt.Controls.Medical.Requested3DDataType.create3DObject:
                    queryArchiveService.Start3DObject(query, id, renderingMethod, sopInstanceUID).then(function (data) {
                        if (data.data != "Success") {
                            engine.errorMessage = data.data.Message ? data.data.Message : data.data;
                            engine.status = lt.Controls.Medical.Object3DStatus.error;
                        }
                    });
                    break;
                case lt.Controls.Medical.Requested3DDataType.creationProgress:
                    queryArchiveService.CheckProgress(id).then(function (data) {
                        if (isNaN(data.data)) {
                            engine.errorMessage = data.data.Message ? data.data.Message : data.data;
                            engine.status = lt.Controls.Medical.Object3DStatus.error;
                        }
                        else {
                            if (engine.progress != 100) {
                                engine.progress = parseInt(data.data);
                            }
                        }
                    });
                    break;
                case lt.Controls.Medical.Requested3DDataType.keepServerObjectAlive:
                    queryArchiveService.KeepAlive(id);
                    break;
                case lt.Controls.Medical.Requested3DDataType.delete3DObject:
                    queryArchiveService.Close3DImage(id);
                    break;
            }
        };
        ;
        Tab.prototype.DeleteUnusedengine = function (viewer) {
            var items = viewer.layout.get_items();
            var index = 0;
            var length = items.get_count();
            var currentCell;
            var engineID;
            var unusedEngineList = {};
            for (var item in this._engineDictionary)
                unusedEngineList[item] = this._engineDictionary[item];
            for (index = 0; index < length; index++) {
                currentCell = items.get_item(index);
                engineID = this.getRealId(currentCell.divID);
                // this is the original cell, skip it, cause the enigne hasn't proven that's been used yet.
                if (currentCell.divID == engineID)
                    continue;
                // remove the item from the unsed list, since it's used by this cell.
                delete unusedEngineList[engineID];
            }
            for (var item in unusedEngineList) {
                var engine = this._engineDictionary[item];
                engine.end();
                delete this._engineDictionary[item];
            }
        };
        Tab.prototype.fillVolumeInfo = function (cell) {
            if (!cell)
                return;
            if (!cell.frames || (cell.frames.count < 2))
                return;
            var firstFrame = cell.frames.get_item(0);
            var lastFrame = cell.frames.get_item(cell.frames.count - 1);
            var width = firstFrame.width;
            var height = firstFrame.height;
            var rowspacing = firstFrame.rowSpacing;
            var colSpacing = firstFrame.columnSpacing;
            var firstPosition = lt.Controls.Medical.LeadPoint3D.create(firstFrame.imagePosition[0], firstFrame.imagePosition[1], firstFrame.imagePosition[2]);
            var lastPostion = lt.Controls.Medical.LeadPoint3D.create(lastFrame.imagePosition[0], lastFrame.imagePosition[1], lastFrame.imagePosition[2]);
            var orientation = firstFrame.imageOrientation;
            return new lt.Controls.Medical.Volume3DInformation(orientation, firstPosition, lastPostion, rowspacing, colSpacing, width, height);
        };
        Tab.prototype.AddnewEngine = function (cell, id, queryArchiveService, query, sopInstanceUID, optionsService) {
            var engineID = this.getRealId(id);
            var __this = this;
            if (!this._engineDictionary[engineID]) {
                var engine = new lt.Controls.Medical.Object3DEngine(engineID);
                engine.info = this.fillVolumeInfo(cell);
                this._engineDictionary[engineID] = engine;
                engine.add_request3DData(function (sender, args) {
                    __this.handle_engine3DData(sender, args, args.frame, queryArchiveService, query, engineID, sopInstanceUID, optionsService);
                });
            }
            return this._engineDictionary[engineID];
        };
        ;
        Tab.prototype.getRealId = function (fullID) {
            var index = fullID.indexOf('_');
            var stripEngineID = (index == -1 ? fullID : fullID.substr(0, index));
            return stripEngineID;
        };
        Object.defineProperty(Tab.prototype, "engineDictionary", {
            //public RemoveEngineIfUnused(engineID: string): any {
            //    engineID = this.getRealId(engineID);
            //    if (this._engineDictionary[engineID]) {
            //        this._engineDictionary[engineID] = new lt.Controls.Medical.Object3DEngine(engineID);
            //    }
            //    return this._engineDictionary[engineID];
            //};
            get: function () {
                return this._engineDictionary;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (value) {
                this._title = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "templateUrl", {
            get: function () {
                return this._templateUrl;
            },
            set: function (value) {
                this._templateUrl = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "controller", {
            get: function () {
                return this._controller;
            },
            set: function (value) {
                this._controller = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (value) {
                this._active = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (value) {
                this._type = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "canDelete", {
            get: function () {
                return this._canDelete;
            },
            set: function (value) {
                this._canDelete = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "data", {
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                this._visible = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "itemCount", {
            get: function () {
                return this._itemCount;
            },
            set: function (value) {
                this._itemCount = value;
            },
            enumerable: false,
            configurable: true
        });
        return Tab;
    }());
    Models.Tab = Tab;
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../Scripts/models/Tab.ts" />
var TabDataKeys;
(function (TabDataKeys) {
    TabDataKeys.Linked = "Linked";
    TabDataKeys.TagToggle = "TagToggle";
    TabDataKeys.ViewController = "ViewController";
    TabDataKeys.PatientId = "PatientId";
    TabDataKeys.CompareInstances = "CompareInstances";
    TabDataKeys.AnnotationVisiblity = "AnnotationVisiblity";
    TabDataKeys.LaunchingStudy = "LaunchingStudy";
    TabDataKeys.searchViewerController = "SearchViewerController";
})(TabDataKeys || (TabDataKeys = {}));
;
var TabService = /** @class */ (function () {
    function TabService() {
        this._activeTab = -1;
        this._tabs = new Array();
        this._activeTab = 0;
        this._tabDictionary = new Dictionary();
    }
    Object.defineProperty(TabService.prototype, "activeTab", {
        get: function () {
            return this._activeTab;
        },
        set: function (index) {
            var tab = this._tabs[index];
            if (tab != null) {
                tab.active = true;
                this._activeTab = index;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TabService.prototype, "tabs", {
        get: function () {
            return this._tabs;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TabService.prototype, "selectedTab", {
        get: function () {
            if (this.activeTab != -1) {
                return this.get_allTabs()[this._activeTab];
            }
        },
        enumerable: false,
        configurable: true
    });
    TabService.prototype.add_tab = function (id, title, template, controller, type) {
        var tab = new Models.Tab(id);
        var tabType = type || TabTypes.None;
        tab.title = title;
        tab.templateUrl = template;
        tab.controller = controller;
        tab.type = tabType;
        tab.itemCount = 0;
        tab.showStudyTimeLine = false;
        this._tabDictionary.setData(tab.id, new Dictionary());
        this._tabs.push(tab);
        this.set_tabData(id, TabDataKeys.TagToggle, true);
        return tab;
    };
    TabService.prototype.find_tab = function (id) {
        var foundTab;
        $.each(this._tabs, function (index, tab) {
            if (tab.id == id) {
                foundTab = tab;
                return false;
            }
        });
        return foundTab;
    };
    TabService.prototype.select_tab = function (id) {
        var tab = this.find_tab(id);
        if (tab != null) {
            tab.active = true;
            this._activeTab = this._tabs.indexOf(tab);
        }
    };
    TabService.prototype.get_allTabs = function () {
        return this._tabs;
    };
    TabService.prototype.delete_tab = function (id) {
        var tab = this.find_tab(id);
        if (tab != null) {
            var index = this._tabs.indexOf(tab);
            this._tabs.splice(index, 1);
            this._tabDictionary.removeData(id);
        }
    };
    TabService.prototype.find_tabsByType = function (type) {
        var tabs = new Array();
        $.each(this._tabs, function (index, tab) {
            if (tab.type == type) {
                tabs.push(tab);
            }
        });
        return tabs;
    };
    TabService.prototype.set_tabData = function (id, key, data) {
        var tab = this.find_tab(id);
        if (tab != null) {
            var tabData = this._tabDictionary.getData(id);
            if (tabData)
                tabData.setData(key, data);
        }
    };
    TabService.prototype.get_tabData = function (id, key) {
        var tab = this.find_tab(id);
        if (tab != null) {
            var tabData = this._tabDictionary.getData(id);
            if (tabData)
                return tabData.getData(key);
        }
        return undefined;
    };
    TabService.prototype.findTabByKey = function (key, value) {
        var keyTab = null;
        var __this = this;
        $.each(this._tabs, function (index, tab) {
            var tabData = __this._tabDictionary.getData(tab.id);
            if (tabData) {
                if (tabData.getData(key) == value) {
                    keyTab = tab;
                    return false;
                }
            }
        });
        return keyTab;
    };
    TabService.prototype.getActiveViewer = function () {
        if (this.activeTab != -1) {
            var tab = this.get_allTabs()[this.activeTab];
            var controller = this.get_tabData(tab.id, TabDataKeys.ViewController);
            if (controller) {
                return controller.getViewer();
            }
        }
        return undefined;
    };
    TabService.prototype.getWindowLayout = function () {
        if (this.activeTab != -1) {
            var tab = this.get_allTabs()[this.activeTab];
            var controller = this.get_tabData(tab.id, TabDataKeys.ViewController);
            if (controller) {
                var viewer = controller.getViewer();
                var viewerElement = document.getElementById(viewer.divId);
                if (viewerElement.parentElement != null) {
                    if (viewerElement.parentElement.parentElement != null) {
                        return viewerElement.parentElement.parentElement.parentElement;
                    }
                }
            }
            else
                return undefined;
        }
        return undefined;
    };
    return TabService;
}());
services.service('tabService', TabService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
// ExternalWEebViewercontrollerProxy.js
/// <reference path="SharedPropertiesService.ts" />
/// <reference path="ExternalCommands.ts" />
/// <reference path="WebViewerCommandHandlerService.ts" />
/// <reference path="WebViewerMessageReceiver.ts" />
/*jshint eqnull:true */
/*jslint plusplus: true */
/*jslint white: true */
/*global describe:true*/
/*jslint newcap: true*/
/*jslint nomen: true*/
/*jshint onevar: false */
/*global window : false */
/*global WebViewerCommandHandlerService : false */
/*global setTimeout : false */
/*global DebugLog : false */
/*global ParseQueryString : false */
/*global location : false */
var LogUtils;
(function (LogUtils) {
    function DebugLog(s) {
        console.log(s);
    }
    LogUtils.DebugLog = DebugLog;
})(LogUtils || (LogUtils = {}));
var GenericActionStatus;
(function (GenericActionStatus) {
    GenericActionStatus.Success = "Success";
    GenericActionStatus.Failed = "failed";
})(GenericActionStatus || (GenericActionStatus = {}));
;
var ExternalCommandHandlerService = /** @class */ (function () {
    function ExternalCommandHandlerService(sharedPropertiesService, authenticationService, tabService) {
        this._externalControlEnabled = false;
        this._externalControlPort = 0;
        this._webViewerAuthenticationToken = null;
        this._externalControlAssociationToken = null;
        this._controller = null;
        this._shouldStopPolling = false;
        this._sharedPropertiesService = sharedPropertiesService;
        this._authenticationService = authenticationService;
        this._tabService = tabService;
    }
    ExternalCommandHandlerService.prototype.onUpdatePatientError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("UpdatePatientError: " + textStatus);
        this.notifyActionStatus(ExternalCommandNames.UpdatePatient, xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onDeletePatientError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("DeletePatientError: " + textStatus);
        this.notifyActionStatus(ExternalCommandNames.DeletePatient, xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onAddPatientError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("AddPatientError: " + textStatus);
        this.notifyActionStatus(ExternalCommandNames.AddPatient, xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onShowSeriesError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("FindSeriesExtError: " + textStatus);
        this.notifyActionStatus(ExternalCommandNames.ShowSeries, xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onFindPatientError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("FindPatienError: " + textStatus);
        this.notifyActionStatus(ExternalCommandNames.FindPatient, xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onFindPatientFromSeriesError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("onFindPatientFromSeriesError: " + textStatus);
        this.notifyActionStatus("FindPatientFromSeries", xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.onReceivePatientNameError = function (xhr, textStatus, ex) {
        LogUtils.DebugLog("ReceivePatientNameError: " + textStatus);
        this.notifyActionStatus("ReceivePatientName", xhr.statusText);
    };
    ExternalCommandHandlerService.prototype.encodeDate = function (date) {
        var encodedDate = date.replace(/\//g, '.');
        encodedDate = encodedDate.replace(/\:/g, '!');
        encodedDate = encodedDate.replace(/\ /g, '_');
        return encodedDate;
    };
    ExternalCommandHandlerService.prototype.sendImageInfo = function (sopInstanceUID, encodedDate, imageType, comment, toothGroups) {
        var request = this.GetExternalControlServiceRoot() + "ReceiveImageInfo/true" + "/" + sopInstanceUID + "/" + encodedDate + "/" + imageType + "/" + comment + "/" + toothGroups + "/" + this._externalControlAssociationToken;
        LogUtils.DebugLog(request);
        this.NoCacheAjax_GET(request, function () {
            LogUtils.DebugLog("Image Info Sent");
        }, $.proxy(this.onHandleRequestError, this));
    };
    ExternalCommandHandlerService.prototype.notifyImageSearchNoneFound = function () {
        var request = this.GetExternalControlServiceRoot() + 'ReceiveImageInfo/false/e/e/e/e/e/' + this._externalControlAssociationToken;
        LogUtils.DebugLog(request);
        this.NoCacheAjax_GET(request, function () {
            LogUtils.DebugLog("Notified no image info found");
        }, $.proxy(this.onHandleRequestError, this));
    };
    ExternalCommandHandlerService.prototype.notifyActionStatus = function (commandName, commandResult) {
        if (this._externalControlEnabled === true) {
            var request = this.GetExternalControlServiceRoot() + 'ReceiveGenericActionStatus/' + commandResult + '/' + this._externalControlAssociationToken;
            LogUtils.DebugLog(request);
            this.NoCacheAjax_GET(request, function () {
                LogUtils.DebugLog("Action status notification sent- status: " + commandResult);
            }, function () {
                LogUtils.DebugLog("notifyActionStatus Failed");
            });
        }
        else {
            var info = {
                "externalControlAssociationToken": this._externalControlAssociationToken,
                "commandName": commandName,
                "commandResult": commandResult
            };
            var s = JSON.stringify(info);
            // window.parent.postMessage(s, '*');
            if (window.opener != null) {
                window.opener.postMessage(s, '*');
            }
        }
    };
    ExternalCommandHandlerService.prototype.LogoutNotify = function (reason) {
        if (this._externalControlEnabled === true) {
            var request = this.GetExternalControlServiceRoot() + 'LogoutNotify/' + reason;
            this.NoCacheAjax_GET(request, {}, {});
        }
        else {
            this.notifyActionStatus(ExternalCommandNames.LogOut, reason);
        }
    };
    ExternalCommandHandlerService.prototype.IsExternalControlEnabled = function () {
        return this._externalControlEnabled;
    };
    ExternalCommandHandlerService.prototype.Initialize = function () {
        var shouldRequest;
        var polling;
        var token;
        var shouldRequest;
        shouldRequest = this._sharedPropertiesService.GetExternalControlMode();
        polling = this._sharedPropertiesService.GetPolling();
        //console.log("polling: ", polling);
        token = this._sharedPropertiesService.GetToken();
        if (token != '') {
            this._webViewerAuthenticationToken = token;
        }
        if (shouldRequest) {
            this._externalControlPort = this._sharedPropertiesService.GetPort();
            this._shouldStopPolling = !polling;
            if (polling) {
                this.EstablishExternalControl();
            }
            else {
                this._controller = new WebViewerCommandHandlerService(this._authenticationService, this._webViewerAuthenticationToken, window);
            }
        }
        else {
            this._externalControlEnabled = false;
            LogUtils.DebugLog("Normal Mode");
        }
    };
    ExternalCommandHandlerService.prototype.GetExternalControlServiceRoot = function () {
        return "http://localhost:" + this._externalControlPort + "/ExternalCommandQueueService/";
    };
    ExternalCommandHandlerService.prototype.EstablishExternalControl = function () {
        LogUtils.DebugLog("Establishing External Control...");
        this.NoCacheAjax_GET(this.GetExternalControlServiceRoot() + "RequestExternalControl", $.proxy(this.onRequestExternalControlSuccess, this), $.proxy(this.onHandleRequestError, this));
    };
    ExternalCommandHandlerService.prototype.onRequestExternalControlSuccess = function (data) {
        var _externalControlAssociationStatus = data;
        if (_externalControlAssociationStatus.Accepted) {
            this._externalControlEnabled = true;
            this._externalControlAssociationToken = _externalControlAssociationStatus.Token;
            LogUtils.DebugLog("External Control Established - token: " + this._externalControlAssociationToken);
            this.NoCacheAjax_GET(this.GetExternalControlServiceRoot() + "GetViewerAuthenticationToken/" + this._externalControlAssociationToken, $.proxy(this.onGetViewerAuthenticationTokenSuccess, this), $.proxy(this.onHandleRequestError, this));
        }
        else {
            LogUtils.DebugLog("External Control Request Denied");
        }
    };
    ExternalCommandHandlerService.prototype.onGetViewerAuthenticationTokenSuccess = function (data) {
        this._webViewerAuthenticationToken = data;
        this._controller = new WebViewerCommandHandlerService(this._authenticationService, this._webViewerAuthenticationToken, window);
        this.PollForCommands();
    };
    ExternalCommandHandlerService.prototype.onHandleRequestError = function (jqXHR, textStatus, errorThrown) {
        this._externalControlEnabled = false;
        LogUtils.DebugLog("External Control Error: " + textStatus + " - " + errorThrown);
    };
    ExternalCommandHandlerService.prototype.NoCacheAjaxParams_POST = function (serviceUrl, params, successFunction, errorFunction) {
        var s = JSON.stringify(params);
        $.ajax({
            url: serviceUrl,
            crossDomain: false,
            type: "POST",
            data: s,
            contentType: "application/json",
            dataType: "json",
            cache: false,
            success: successFunction,
            error: errorFunction
        });
    };
    ExternalCommandHandlerService.prototype.NoCacheAjax_GET = function (url, successFunction, errorFunction) {
        $.ajax({
            url: url,
            crossDomain: true,
            type: 'GET',
            dataType: "json",
            cache: false,
            success: successFunction,
            error: errorFunction
        });
    };
    ExternalCommandHandlerService.prototype.NoCacheAjax_POST = function (url, args, successFunction) {
        var s = JSON.stringify(args);
        $.ajax({
            url: url,
            crossDomain: true,
            type: "POST",
            dataType: "json",
            contentType: "application/json",
            cache: false,
            data: JSON.stringify(args),
            success: successFunction
        });
    };
    ExternalCommandHandlerService.prototype.PollForCommands = function () {
        if (this._shouldStopPolling) {
            return;
        }
        var request = this.GetExternalControlServiceRoot() + 'HasCommands/' + this._externalControlAssociationToken;
        this.NoCacheAjax_GET(request, $.proxy(this.HasCommandsRequestSuccess, this), $.proxy(this.onHandleRequestError, this));
    };
    ExternalCommandHandlerService.prototype.HasCommandsRequestSuccess = function (data) {
        var hasCommands = data;
        if (hasCommands) {
            var request = this.GetExternalControlServiceRoot() + 'GetCommands/' + this._externalControlAssociationToken;
            LogUtils.DebugLog(request);
            this.NoCacheAjax_GET(request, $.proxy(this.onGetCommandsRequestSuccess, this), $.proxy(this.onHandleRequestError, this));
        }
        else {
            setTimeout($.proxy(this.PollForCommands, this), 500);
        }
    };
    ExternalCommandHandlerService.prototype.onGetCommandsRequestSuccess = function (data) {
        var commands = data;
        for (var i = 0; i < commands.length; ++i) {
            this.ProcessCommand(commands[i]);
        }
        this.PollForCommands();
    };
    ExternalCommandHandlerService.prototype.GetInvalidArgumentsErrorString = function (functionName) {
        return functionName + ": Invalid Arguments";
    };
    ExternalCommandHandlerService.prototype.MyReceivePatientInfo = function (commandName, studies) {
        var localThis = this;
        var study = studies[0], name = null, birthDate = null, comments = null, patientId = null, sex = null, ethnicGroup = null, url = null, patientInfo = null, info = null;
        if (study.hasOwnProperty("Patient")) {
            name = study.Patient.Name;
            birthDate = study.Patient.BirthDate;
            comments = study.Patient.Comments;
            patientId = study.Patient.ID;
            sex = study.Patient.Sex;
            ethnicGroup = study.Patient.EthnicGroup;
        }
        else {
            if (study.hasOwnProperty("Name")) {
                name = study.Name;
            }
            if (study.hasOwnProperty("BirthDate")) {
                birthDate = study.BirthDate;
            }
            if (study.hasOwnProperty("Comments")) {
                comments = study.Comments;
            }
            if (study.hasOwnProperty("ID")) {
                patientId = study.ID;
            }
            if (study.hasOwnProperty("Sex")) {
                sex = study.Sex;
            }
            if (study.hasOwnProperty("EthnicGroup")) {
                ethnicGroup = study.EthnicGroup;
            }
        }
        if (name != null) {
            patientInfo = {
                "PatientId": patientId,
                "Name": name,
                "BirthDate": birthDate,
                "Sex": sex,
                "EthnicGroup": ethnicGroup,
                "Comments": comments
            },
                info = {
                    "externalControlAssociationToken": this._externalControlAssociationToken,
                    "patientInfo": patientInfo
                },
                url = null;
            if (this._externalControlEnabled === true) {
                url = this.GetExternalControlServiceRoot() + 'ReceivePatientInfo';
                this.NoCacheAjaxParams_POST(url, info, function (data, textStatus, xhr) {
                    LogUtils.DebugLog("Patient Name sent");
                    localThis.notifyActionStatus(commandName, GenericActionStatus.Success);
                }, function (xhr, textStatus, ex) {
                    LogUtils.DebugLog("ReceivePatientInfo: Error");
                    localThis.onReceivePatientNameError(xhr, textStatus, ex);
                });
            }
            else {
                info.commandName = commandName;
                info.commandResult = GenericActionStatus.Success;
                var s = JSON.stringify(info);
                window.opener.postMessage(s, '*');
            }
        }
        else {
            this.notifyActionStatus(commandName, GenericActionStatus.Success);
        }
    };
    ExternalCommandHandlerService.prototype.ProcessCommand = function (command) {
        var __this = this;
        var errorMessage = null, options = null, patientID = null, patientInfo = null, style = null;
        if (command.Name === ExternalCommandNames.LogOut) {
            __this._controller.LogOut();
        }
        else if (command.Name === ExternalCommandNames.Close) {
            __this._controller.Close();
        }
        else if (command.Name === ExternalCommandNames.FindPatient) {
            patientID = command.Args[0];
            options = command.Args[1];
            __this._controller.FindPatient(patientID, options, this.onFindPatientError, function (studies) {
                if (studies.data.length > 0) {
                    __this.MyReceivePatientInfo(command.Name, studies.data);
                }
                else {
                    __this.notifyActionStatus(command.Name, "PatientId does not exist: " + patientID);
                }
            });
        }
        else if (command.Name === ExternalCommandNames.ShowPatient) {
            if (command.Args == null || (command.Args.length !== 1 && command.Args.length !== 2)) {
                errorMessage = __this.GetInvalidArgumentsErrorString(command.Name);
                LogUtils.DebugLog(errorMessage);
                __this.notifyActionStatus(command.Name, errorMessage);
                return;
            }
            patientID = command.Args[0];
            if (command.Args.length === 2) {
                style = command.Args[1];
            }
            __this._controller.FindSeriesExt(patientID, null, null, __this.onFindPatientError, function (series) {
                for (var i = 0; i < series.data.length; i++) {
                    var instanceData = series.data[i];
                    __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, style);
                    if (__this._controller.isDental() && series.data.length > 1)
                        break;
                }
                __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
            });
        }
        else if (command.Name === ExternalCommandNames.ShowStudy) {
            if (command.Args == null || command.Args.length !== 1) {
                errorMessage = __this.GetInvalidArgumentsErrorString(command.Name);
                LogUtils.DebugLog(errorMessage);
                __this.notifyActionStatus(command.Name, errorMessage);
                return;
            }
            var studyInstanceUID = command.Args[0];
            __this._controller.FindSeriesExt(null, studyInstanceUID, null, __this.onFindPatientError, function (series) {
                for (var i = 0; i < series.data.length; i++) {
                    var instanceData = series.data[i];
                    __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, null);
                }
                __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
            });
        }
        else if (command.Name === ExternalCommandNames.ShowSeries) {
            if (command.Args == null || command.Args.length !== 1) {
                errorMessage = __this.GetInvalidArgumentsErrorString(command.Name);
                LogUtils.DebugLog(errorMessage);
                __this.notifyActionStatus(command.Name, errorMessage);
                return;
            }
            var seriesInstanceUID = command.Args[0];
            __this._controller.FindSeriesExt(null, null, seriesInstanceUID, __this.onShowSeriesError, function (series) {
                var instanceData = series.data[0];
                __this._controller.ShowSeriesInstanceExt(series.data, instanceData, function () {
                    __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
                }, null);
            });
        }
        else if (command.Name === ExternalCommandNames.GetCurrentPatient) {
            options = "All";
            var controller = null;
            var medicalViewer = null;
            var selectedItem = null;
            var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
            if (tab == null) {
                __this.notifyActionStatus(command.Name, "There are no loaded instances.");
                return;
            }
            controller = this._tabService.get_tabData(tab.id, TabDataKeys.ViewController);
            if (controller != null) {
                medicalViewer = controller.getViewer();
            }
            if (medicalViewer != null) {
                selectedItem = medicalViewer.layout.get_selectedItems().get_item(0);
            }
            if (selectedItem == null) {
                __this.notifyActionStatus(command.Name, "There are no selected instances.");
                return;
            }
            var seriesInstanceUid = selectedItem.get_seriesInstanceUID();
            __this._controller.FindPatientFromSeries(seriesInstanceUid, options, __this.onFindPatientFromSeriesError, function (studies) {
                if (studies.data.length > 0) {
                    __this.MyReceivePatientInfo(command.Name, studies.data);
                }
                else {
                    __this.notifyActionStatus(command.Name, "Current patient does not exist");
                }
            });
        }
        else if (command.Name === ExternalCommandNames.GetImage) {
            var sopInstanceUID = command.Args[0];
            if (sopInstanceUID === "") {
                var request = __this.GetExternalControlServiceRoot() + 'ReceiveImageURL?url=' + encodeURIComponent("") + "&token=" + this._externalControlAssociationToken;
                LogUtils.DebugLog(request);
                __this.NoCacheAjax_POST(request, null, function () {
                    LogUtils.DebugLog("Empty Image URL Sent");
                });
            }
            else {
                __this._controller.GetInstanceImageURL(sopInstanceUID, function (url) {
                    if (__this._externalControlEnabled === true) {
                        var request = __this.GetExternalControlServiceRoot() + 'ReceiveImageURL?url=' + encodeURIComponent(url) + "&token=" + __this._externalControlAssociationToken;
                        LogUtils.DebugLog(request);
                        __this.NoCacheAjax_POST(request, null, function () {
                            LogUtils.DebugLog("Image URL Sent");
                        });
                    }
                    else {
                        var info = {
                            "externalControlAssociationToken": __this._externalControlAssociationToken,
                            "url": url,
                            "sopInstanceUID": sopInstanceUID,
                            "commandName": command.Name,
                            "commandResult": GenericActionStatus.Success,
                        };
                        var s = JSON.stringify(info);
                        window.opener.postMessage(s, '*');
                    }
                });
            }
        }
        else if (command.Name === ExternalCommandNames.AddPatient) {
            if (command.Args == null /*|| command.Args.length != 11*/) {
                errorMessage = __this.GetInvalidArgumentsErrorString(command.Name);
                LogUtils.DebugLog(errorMessage);
                __this.notifyActionStatus(command.Name, errorMessage);
                return;
            }
            patientInfo = {};
            patientInfo.PatientId = command.Args[0];
            patientInfo.Name = command.Args[1];
            patientInfo.Sex = command.Args[2];
            patientInfo.BirthDate = command.Args[3];
            patientInfo.EthnicGroup = command.Args[4];
            patientInfo.Comments = command.Args[5];
            __this._controller.AddPatient(patientInfo, __this.onAddPatientError, function (data) {
                var patientAdded = data.data;
                if (patientAdded) {
                    __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
                }
                else {
                    __this.notifyActionStatus(command.Name, "PatientId Already Exists: " + patientInfo.PatientId);
                }
            });
        }
        else if (command.Name === ExternalCommandNames.DeletePatient) {
            if (command.Args == null || command.Args.length !== 1) {
                errorMessage = __this.GetInvalidArgumentsErrorString(command.Name);
                LogUtils.DebugLog(errorMessage);
                __this.notifyActionStatus(command.Name, errorMessage);
                return;
            }
            patientID = command.Args[0];
            options = "All";
            __this._controller.FindPatient(patientID, options, __this.onFindPatientError, function (studies) {
                if (studies.data.length > 0) {
                    __this._controller.DeletePatient(patientID, __this.onDeletePatientError, function (isSuccess) {
                        if (isSuccess) {
                            __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
                        }
                        else {
                            __this.notifyActionStatus(command.Name, "Failed to delete patient: " + patientID);
                        }
                    });
                }
                else {
                    __this.notifyActionStatus(command.Name, "PatientId does not exist: " + patientID);
                }
            });
        }
        else if (command.Name === ExternalCommandNames.UpdatePatient) {
            patientInfo = {};
            patientInfo.PatientId = command.Args[0];
            patientInfo.Name = command.Args[1];
            patientInfo.Sex = command.Args[2];
            patientInfo.BirthDate = command.Args[3];
            patientInfo.EthnicGroup = command.Args[4];
            patientInfo.Comments = command.Args[5];
            __this._controller.UpdatePatient(patientInfo, __this.onUpdatePatientError, function (data) {
                __this.notifyActionStatus(command.Name, GenericActionStatus.Success);
            });
        }
        else if (command.Name === ExternalCommandNames.EndAssociation) {
            __this._shouldStopPolling = true;
        }
    };
    ExternalCommandHandlerService.$inject = ['sharedPropertiesService', 'authenticationService', 'tabService'];
    return ExternalCommandHandlerService;
}());
services.service('externalCommandHandlerService', ExternalCommandHandlerService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
/// <reference path="../../Scripts/models/Tab.ts" />
/// <reference path="../../Scripts/Services/TabService.ts" />
/// <reference path="ExternalCommands.ts" />
/// <reference path="ExternalCommandHandlerService.ts" />
/// <reference path="WebViewerCommands.ts" />
var ViewerMessageRecieverModule;
(function (ViewerMessageRecieverModule) {
    var CommandClass = /** @class */ (function () {
        function CommandClass() {
        }
        return CommandClass;
    }());
    ViewerMessageRecieverModule.CommandClass = CommandClass;
    if (typeof window.onload != 'function') {
        window.onload = function () {
            initialize();
        };
    }
    else {
        var oldOnLoad = window.onload;
        window.onload = function () {
            oldOnLoad();
            initialize();
        };
    }
    var _messageReceiver;
    function initialize() {
        _messageReceiver = new WebViewerMessageReceiver();
        if (window.opener) {
            window.opener.window.postMessage(WebViewerCommandNames.ALIVE, "*");
        }
    }
    var WebViewerMessageReceiver = /** @class */ (function () {
        function WebViewerMessageReceiver() {
            LogUtils.DebugLog("WebViewerMessageReceiver Constructor called");
            window.onmessage = this.onMessageReceived;
            var injector = angular.element(document.getElementById('app')).injector();
            WebViewerMessageReceiver._eventService = injector.get('eventService');
            WebViewerMessageReceiver._dataService = injector.get('dataService');
            WebViewerMessageReceiver._externalCommandHandlerService = injector.get('externalCommandHandlerService');
            WebViewerMessageReceiver._seriesManagerService = injector.get('seriesManagerService');
        }
        // Create a command to pass on to ExternalWebViewerDControllerProxy.ProcessCommand
        WebViewerMessageReceiver.CreateCommand = function (commandName) {
            var myArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                myArgs[_i - 1] = arguments[_i];
            }
            var command = new CommandClass();
            command.Args = [];
            if (arguments.length == 0) {
                return command;
            }
            command.Name = commandName;
            for (var i = 0; i < myArgs.length; i++) {
                command.Args[i] = myArgs[i];
            }
            return command;
        };
        WebViewerMessageReceiver.prototype.onMessageReceived = function (args) {
            var cmd = JSON.parse(args.data);
            var message = new WebViewerMessage();
            message.Parse(args.data);
            switch (cmd.name) {
                case ExternalCommandNames.ShowPatient:
                case ExternalCommandNames.ShowStudy:
                case ExternalCommandNames.ShowSeries:
                case ExternalCommandNames.ShowInstance:
                case ExternalCommandNames.GetImage:
                    {
                        var command;
                        command = WebViewerMessageReceiver.CreateCommand(cmd.name, cmd.arg1);
                        WebViewerMessageReceiver._externalCommandHandlerService.ProcessCommand(command);
                    }
                    break;
                case ExternalCommandNames.GetCurrentPatient:
                    {
                        var command;
                        command = WebViewerMessageReceiver.CreateCommand(cmd.name);
                        WebViewerMessageReceiver._externalCommandHandlerService.ProcessCommand(command);
                    }
                    break;
                case WebViewerCommandNames.LOAD_SERIES_EXT:
                    {
                        var seriesArray = JSON.parse(cmd.seriesArray);
                        var seriesSelected = JSON.parse(cmd.seriesSelected);
                        var style = cmd.style;
                        WebViewerMessageReceiver.seriesLoaderExt(seriesArray, seriesSelected, style);
                    }
                    ;
                    break;
                case WebViewerCommandNames.LOAD_STRUCTURED_DISPLAY_EXT:
                    {
                        var seriesArray = JSON.parse(cmd.seriesArray);
                        var seriesSelected = JSON.parse(cmd.seriesSelected);
                        var style = cmd.style;
                        WebViewerMessageReceiver.seriesLoaderExt(seriesArray, seriesSelected, style);
                    }
                    ;
                    break;
                case WebViewerCommandNames.SET_SERIES_VIEWER_MODE:
                    {
                        var params = message.get_Params();
                        SetSeriesViewerMode(cmd.args.mode, -1);
                    }
                    break;
                case WebViewerCommandNames.SUBSCRIBE:
                    {
                        WebViewerMessageReceiver.EventsDispatcher(args.source, message);
                    }
                    break;
                default:
                    alert("Unknown message received");
            }
        };
        WebViewerMessageReceiver.seriesLoaderExt = function (seriesArray, seriesInstance, style) {
            WebViewerMessageReceiver._dataService.set_Series(seriesArray);
            WebViewerMessageReceiver._seriesManagerService.currentLoadingSeries = seriesInstance;
            WebViewerMessageReceiver._seriesManagerService.currentPatientSeries = seriesArray;
            if (style) {
                WebViewerMessageReceiver._eventService.publish(EventNames.LoadSelectedSeries, { study: seriesArray, data: seriesInstance, style: style });
            }
            else {
                WebViewerMessageReceiver._eventService.publish(EventNames.SeriesSelected, { study: seriesArray, series: seriesInstance, style: style });
            }
        };
        WebViewerMessageReceiver.EventsDispatcher = function (receiver, message) {
            var params = message.get_Params();
            var loadSeries = params[SubscribeToEventsCmdParams.PARAM_LoadSeries];
            var presentationStateCreated = params[SubscribeToEventsCmdParams.PARAM_PresentationStateCreated];
            var presentationStateDeleted = params[SubscribeToEventsCmdParams.PARAM_PresentationStateDeleted];
            var derivedImageCreated = params[SubscribeToEventsCmdParams.PARAM_DerivedImageCreated];
            var imageExported = params[SubscribeToEventsCmdParams.PARAM_ImageExported];
            if (loadSeries) {
                EventBroker.add_seriesLoaded(onSeriesLoaded);
            }
            if (presentationStateCreated) {
                EventBroker.add_presentationStateCreated(onPresentationStateCreated);
            }
            if (presentationStateDeleted) {
                EventBroker.add_presentationStateDeleted(onPresentationStateDeleted);
            }
            if (derivedImageCreated) {
                EventBroker.add_derivedImageCreated(onDerivedImageCreated);
            }
            if (imageExported) {
                EventBroker.add_imageExported(onImageExported);
            }
            function onSeriesLoaded(args, seriesInstanceUID) {
                receiver.postMessage("Series Loaded: Series UID=" + seriesInstanceUID, "*");
            }
            function onPresentationStateCreated(args, annId) {
                receiver.postMessage("Presentation State Created: SOP UID=" + annId.SOPInstanceUID, "*");
            }
            function onPresentationStateDeleted(args, annId) {
                receiver.postMessage("Presentation State Deleted: SOP UID=" + annId.SOPInstanceUID, "*");
            }
            function onDerivedImageCreated(args, sopInstance) {
                receiver.postMessage("Derived Image Created: SOP UID=" + sopInstance, "*");
            }
            function onImageExported(args, sopInstance) {
                receiver.postMessage("Image Exported: SOP UID=" + sopInstance, "*");
            }
        };
        return WebViewerMessageReceiver;
    }());
    ViewerMessageRecieverModule.WebViewerMessageReceiver = WebViewerMessageReceiver;
})(ViewerMessageRecieverModule || (ViewerMessageRecieverModule = {})); // Module
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
// ExternalWEebViewercontrollerProxy.js
/// <reference path="SharedPropertiesService.ts" />
/// <reference path="ExternalCommands.ts" />
/// <reference path="WebViewerCommandHandlerService.ts" />
/// <reference path="WebViewerMessageReceiver.ts" />
/*jshint eqnull:true */
/*jslint plusplus: true */
/*jslint white: true */
/*global describe:true*/
/*jslint newcap: true*/
/*jslint nomen: true*/
/*jshint onevar: false */
/*global window : false */
/*global WebViewerCommandHandlerService : false */
/*global setTimeout : false */
/*global DebugLog : false */
/*global ParseQueryString : false */
/*global location : false */
var AutoService = /** @class */ (function () {
    function AutoService(sharedPropertiesService, authenticationService, tabService, config) {
        this._automationEnabled = false;
        this._webViewerAuthenticationToken = null;
        this._controller = null;
        this._shouldStopPolling = false;
        this._sharedPropertiesService = sharedPropertiesService;
        this._authenticationService = authenticationService;
        this._tabService = tabService;
        this._autoServiceUrl = config.urls.serviceUrl + config.urls.autoServiceName;
    }
    AutoService.prototype.reportCmdError = function (cmdId, msg) {
        if (this._automationEnabled) {
            var request = this._autoServiceUrl + '/ReportCommandStatus?' +
                'token=' + encodeURIComponent(this._webViewerAuthenticationToken) +
                '&cmdid=' + encodeURIComponent(cmdId) +
                '&status=' + encodeURIComponent(AutoService.cmdStatus.failed) +
                '&message=' + encodeURIComponent(msg);
            this.GETVoid(request);
        }
    };
    AutoService.prototype.reportCmdSuccess = function (cmdId) {
        if (this._automationEnabled) {
            var request = this._autoServiceUrl + '/ReportCommandStatus?' +
                'token=' + encodeURIComponent(this._webViewerAuthenticationToken) +
                '&cmdid=' + encodeURIComponent(cmdId) +
                '&status=' + encodeURIComponent(AutoService.cmdStatus.succeeded) +
                '&message=null';
            this.GETVoid(request);
        }
    };
    AutoService.prototype.Initialize = function () {
        if (this._sharedPropertiesService.GetAutoMode()) {
            this._automationEnabled = true;
            this._webViewerAuthenticationToken = this._sharedPropertiesService.GetToken();
            this._shouldStopPolling = !this._sharedPropertiesService.GetPolling();
            this._controller = new WebViewerCommandHandlerService(this._authenticationService, this._webViewerAuthenticationToken, window);
            this.CheckAutomation();
        }
        else {
            this._automationEnabled = false;
            LogUtils.DebugLog("Normal Mode");
        }
    };
    AutoService.prototype.LogoutNotify = function (reason) {
        if (this._automationEnabled) {
            var request = this._autoServiceUrl + '/Logout?' +
                'token=' + encodeURIComponent(this._webViewerAuthenticationToken) +
                '&reason=' + encodeURIComponent(reason);
            this.GETVoid(request);
        }
    };
    AutoService.prototype.onHandleRequestError = function (jqXHR, textStatus, errorThrown) {
        this._automationEnabled = false;
        LogUtils.DebugLog("External Control Error: " + textStatus + " - " + errorThrown);
    };
    AutoService.prototype.GET = function (url, successFunction, errorFunction) {
        $.ajax({
            url: url,
            crossDomain: true,
            type: 'GET',
            dataType: "json",
            cache: false,
            success: successFunction,
            error: errorFunction
        });
    };
    AutoService.prototype.GETVoid = function (url) {
        $.ajax({
            url: url,
            crossDomain: true,
            type: 'GET',
            dataType: "json",
            cache: false
        });
    };
    AutoService.prototype.CheckAutomation = function () {
        var request = this._autoServiceUrl + '/IsAutomated?' + 'token=' + encodeURIComponent(this._webViewerAuthenticationToken);
        LogUtils.DebugLog(request);
        this.GET(request, $.proxy(this.onCheckAutomationSuccess, this), $.proxy(this.onHandleRequestError, this));
        this.PollForCommands();
    };
    AutoService.prototype.onCheckAutomationSuccess = function (enabled) {
        if (enabled) {
            this.PollForCommands();
        }
    };
    AutoService.prototype.PollForCommands = function () {
        if (this._shouldStopPolling) {
            return;
        }
        var request = this._autoServiceUrl + '/GetAndRemoveCommands?' + 'token=' + encodeURIComponent(this._webViewerAuthenticationToken);
        LogUtils.DebugLog(request);
        this.GET(request, $.proxy(this.onGetCommandsRequestSuccess, this), $.proxy(this.onHandleRequestError, this));
    };
    AutoService.prototype.onGetCommandsRequestSuccess = function (commands) {
        var idle = true;
        if (commands) {
            for (var i = 0; i < commands.length; ++i) {
                idle = false;
                this.ProcessCommand(commands[i]);
            }
        }
        if (idle) {
            setTimeout($.proxy(this.PollForCommands, this), 5000);
        }
        else {
            setTimeout($.proxy(this.PollForCommands, this), 500);
        }
    };
    AutoService.prototype.GetInvalidArgumentsErrorString = function (functionName) {
        return functionName + ": Invalid Arguments";
    };
    AutoService.prototype.findAndLoadSeries = function (command, oldsdResult) {
        var commandId = command.Item1;
        var commandName = command.Item2;
        var commandParam = JSON.parse(command.Item3);
        var patientID = commandParam.patientID;
        var style = commandParam.style;
        var seriesInstanceUID = commandParam.seriesInstanceUID;
        var found = false;
        var __this = this;
        __this._controller.FindSeriesExt(patientID, null, null, function (xhr, textStatus, ex) { __this.reportCmdError(commandId, xhr.statusText); __this._controller.LogOut(); }, function (series, sdResult) {
            var dental = __this._controller.isDental();
            if (series == null || series.data.length == 0) {
                alert("Patient doesn't have any series to display");
                return;
            }
            if (series.data.length == 0) {
                __this.reportCmdError(commandId, "This patient does not currently have any images stored");
                __this._controller.LogOutError("This patient does not currently have any images stored");
                return;
            }
            else {
                if (sdResult) {
                    Utils.prepareDataForSeriesDisplay(sdResult.data, series.data[0], series.data[0].Patient);
                    for (var i = 0; i < sdResult.data.length; i++) {
                        var instanceData = sdResult.data[i];
                        if ((!seriesInstanceUID) || (instanceData.SeriesInstanceUID == seriesInstanceUID)) {
                            __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, style);
                            found = true;
                            break;
                        }
                    }
                }
                for (var i = 0; i < series.data.length; i++) {
                    var instanceData = series.data[i];
                    if ((!seriesInstanceUID) || (instanceData.InstanceUID == seriesInstanceUID)) {
                        __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, style);
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    for (var i = 0; i < series.data.length; i++) {
                        var instanceData = series.data[i];
                        __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, style);
                        if (dental)
                            break;
                    }
                }
            }
            __this.reportCmdSuccess(commandId);
        });
    };
    AutoService.prototype.ProcessCommand = function (command) {
        var __this = this;
        var errorMessage = null, options = null, patientID = null, patientInfo = null, style = null;
        var commandId = command.Item1;
        var commandName = command.Item2;
        var commandParam = JSON.parse(command.Item3);
        console.log(command);
        if (commandName === ExternalCommandNames.LogOut) {
            __this._controller.LogOut();
        }
        else if (commandName === ExternalCommandNames.Close) {
            __this._controller.Close();
        }
        else if (commandName === ExternalCommandNames.ShowPatient) {
            if (!commandParam) {
                errorMessage = __this.GetInvalidArgumentsErrorString(commandName);
                LogUtils.DebugLog(errorMessage);
                __this.reportCmdError(commandId, errorMessage);
                __this._controller.LogOut();
                return;
            }
            patientID = commandParam.patientID;
            style = commandParam.style;
            seriesInstanceUID = commandParam.seriesInstanceUID;
            if (commandParam.isStructuredDisplay) {
                __this._controller.FindStructuredDisplay(patientID, null, function (sdResult) { __this.findAndLoadSeries(command, sdResult); });
            }
            else
                this.findAndLoadSeries(command, null);
        }
        else if (commandName === ExternalCommandNames.ShowStudy) {
            if (command.Args == null || command.Args.length !== 1) {
                errorMessage = __this.GetInvalidArgumentsErrorString(commandName);
                LogUtils.DebugLog(errorMessage);
                __this.reportCmdError(commandId, errorMessage);
                return;
            }
            var studyInstanceUID = command.Args[0];
            __this._controller.FindSeriesExt(null, studyInstanceUID, null, function (xhr, textStatus, ex) { __this.reportCmdError(commandId, xhr.statusText); }, function (series) {
                for (var i = 0; i < series.data.length; i++) {
                    var instanceData = series.data[i];
                    __this._controller.ShowSeriesInstanceExt(series.data, instanceData, null, null);
                }
                __this.reportCmdSuccess(commandId);
            });
        }
        else if (commandName === ExternalCommandNames.ShowSeries) {
            if (command.Args == null || command.Args.length !== 1) {
                errorMessage = __this.GetInvalidArgumentsErrorString(commandName);
                LogUtils.DebugLog(errorMessage);
                __this.reportCmdError(commandId, errorMessage);
                return;
            }
            var seriesInstanceUID = command.Args[0];
            __this._controller.FindSeriesExt(null, null, seriesInstanceUID, function (xhr, textStatus, ex) { __this.reportCmdError(commandId, xhr.statusText); }, function (series) {
                var instanceData = series.data[0];
                __this._controller.ShowSeriesInstanceExt(series.data, instanceData, function () {
                    __this.reportCmdSuccess(commandId);
                }, null);
            });
        }
        else if (commandName === ExternalCommandNames.EndAssociation) {
            __this._shouldStopPolling = true;
        }
    };
    AutoService.$inject = ['sharedPropertiesService', 'authenticationService', 'tabService', 'app.config'];
    AutoService.cmdStatus = { succeeded: "Succeeded", failed: "Failed" };
    return AutoService;
}());
services.service('autoService', AutoService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../lib/LEADTOOLS/Leadtools.Controls.Medical.d.ts" />
var ModalityItem = /** @class */ (function () {
    function ModalityItem(metadata, modality) {
        this.metadata = metadata;
        this.Modality = modality;
        this.AnatomicRegionSequence = new Array();
        this.ProcedureCodeSequence = new Array();
        this.ReasonForRequestedProcedureCodeSequence = new Array();
    }
    return ModalityItem;
}());
var HangingProtocolHelper = /** @class */ (function () {
    function HangingProtocolHelper() {
    }
    HangingProtocolHelper.get_HangingProtocol = function (viewer, primaryCell, metadata) {
        var hp = new Models.HangingProtocol();
        var injector = angular.element(document.getElementById('app')).injector();
        var authenticationService = injector.get('authenticationService');
        var modalities = HangingProtocolHelper.get_ModalityItemsInView(viewer);
        var studyDescription = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyDescription);
        var selectedModality = DicomHelper.getDicomTagValue(metadata, DicomTag.Modality);
        // Hanging Protocol Name (Mandatory)       
        if (studyDescription == null)
            hp.HangingProtocolName = selectedModality;
        else
            hp.HangingProtocolName = (selectedModality + " " + studyDescription).substring(0, 16);
        // Hanging Protocol Description (Mandatory)
        hp.HangingProtocolDescription = studyDescription;
        if (hp.HangingProtocolDescription == null)
            hp.HangingProtocolDescription = hp.HangingProtocolName;
        // Hanging Protocol Level (Mandatory)
        hp.HangingProtocolLevel = Models.HangingProtocolLevel.Site;
        // Hanging Protocol Creator (Mandatory)
        hp.HangingProtocolCreator = authenticationService.user;
        // Hanging Protocol Creation DateTime (Mandatory)
        hp.WCFHangingProtocolCreationDateTime = new Date();
        // Hanging Protocol Definition Sequence (Mandatory)
        for (var i = 0; i < modalities.length; i++) {
            var hpd = new Models.HangingProtocolDefinition();
            // Modality (Conditional)
            hpd.Modality = modalities[i].Modality;
            // 
            hpd.StudyDescription = modalities[i].StudyDescription;
            // Procedure Code Sequence (Mandatory)
            hpd.ProcedureCodeSequence = modalities[i].ProcedureCodeSequence;
            // Anatomic Region Sequence (Conditional)
            hpd.AnatomicRegionSequence = modalities[i].AnatomicRegionSequence;
            // Laterality (Conditional)
            // Reason for Requested Procedure Code Sequence (Mandatory)
            hpd.ReasonForRequestedProcedureCodeSequence = modalities[i].ReasonForRequestedProcedureCodeSequence;
            //
            hpd.BodyPartExamined = modalities[i].BodyPartExamined;
            //
            hpd.ProtocolName = modalities[i].ProtocolName;
            hpd["metadata"] = modalities[i].metadata;
            hp.HangingProtocolDefinitionSequence.push(hpd);
        }
        // Hanging Protocol User Identification Code Sequence (Mandatory)
        hp.HangingProtocolUserIdentificationCodeSequence = new Array();
        // Hanging Protocol User Group Name (Optional)
        // xxx
        // Source Hanging Protocol Sequence (Optional)
        // xxx
        // Number of Priors Referenced (Mandatory)
        hp.NumberOfPriorsReferenced = 0;
        // Image Sets Sequence (Mandatory)
        this.get_ImageSets(viewer, primaryCell, hp);
        // Number of Screens (Mandatory)
        hp.NumberOfScreens = 1;
        // Nominal Screen Definition Sequence (Mandatory)
        this.setNominalScreenDefinitionSequence(hp);
        // Display Sets Sequence (Mandatory)
        // constructor
        // Partial Data Display Handling (Mandatory)
        hp.PartialDataDisplayHandling = Models.PartialDataDisplayHandling.MaintainLayout;
        // Synchronized Scrolling Sequence (Optional)
        // assigned in get_ImageSets
        // Navigation Indicator Sequence (Optional)
        // assigned in get_ImageSets
        // LEAD specific
        if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
            hp.Rows = viewer.gridLayout.rows;
            hp.Columns = viewer.gridLayout.columns;
        }
        return hp;
    };
    HangingProtocolHelper.ConvertToHorizontalAlignmentType = function (frameHorizontalJustication) {
        var horizontalAlignmentType = lt.Controls.Medical.HorizontalAlignmentType.middle;
        switch (frameHorizontalJustication) {
            case Models.FrameHorizontalJustification.Center:
                horizontalAlignmentType = lt.Controls.Medical.HorizontalAlignmentType.middle;
                break;
            case Models.FrameHorizontalJustification.Left:
                horizontalAlignmentType = lt.Controls.Medical.HorizontalAlignmentType.left;
                break;
            case Models.FrameHorizontalJustification.Right:
                horizontalAlignmentType = lt.Controls.Medical.HorizontalAlignmentType.right;
                break;
        }
        return horizontalAlignmentType;
    };
    HangingProtocolHelper.ConvertToFrameHorizontalJustication = function (horizontalAlignmentType) {
        var frameHorizontalJustication = Models.FrameHorizontalJustification.Center;
        switch (horizontalAlignmentType) {
            case lt.Controls.Medical.HorizontalAlignmentType.middle:
                frameHorizontalJustication = Models.FrameHorizontalJustification.Center;
                break;
            case lt.Controls.Medical.HorizontalAlignmentType.left:
                frameHorizontalJustication = Models.FrameHorizontalJustification.Left;
                break;
            case lt.Controls.Medical.HorizontalAlignmentType.right:
                frameHorizontalJustication = Models.FrameHorizontalJustification.Right;
                break;
        }
        return frameHorizontalJustication;
    };
    HangingProtocolHelper.ConvertToVerticalAlignmentType = function (frameVerticalJustication) {
        var horizontalAlignmentType = lt.Controls.Medical.VerticalAlignmentType.middle;
        switch (frameVerticalJustication) {
            case Models.FrameVerticalJustification.Center:
                horizontalAlignmentType = lt.Controls.Medical.VerticalAlignmentType.middle;
                break;
            case Models.FrameVerticalJustification.Bottom:
                horizontalAlignmentType = lt.Controls.Medical.VerticalAlignmentType.bottom;
                break;
            case Models.FrameVerticalJustification.Top:
                horizontalAlignmentType = lt.Controls.Medical.VerticalAlignmentType.top;
                break;
        }
        return horizontalAlignmentType;
    };
    HangingProtocolHelper.ConvertToFrameVerticalJustication = function (horizontalAlignmentType) {
        var frameVerticalJustication = Models.FrameVerticalJustification.Center;
        switch (horizontalAlignmentType) {
            case lt.Controls.Medical.VerticalAlignmentType.middle:
                frameVerticalJustication = Models.FrameVerticalJustification.Center;
                break;
            case lt.Controls.Medical.VerticalAlignmentType.top:
                frameVerticalJustication = Models.FrameVerticalJustification.Top;
                break;
            case lt.Controls.Medical.VerticalAlignmentType.bottom:
                frameVerticalJustication = Models.FrameVerticalJustification.Bottom;
                break;
        }
        return frameVerticalJustication;
    };
    //public static GetCellMprTypeName(mprType: lt.Controls.Medical.CellMPRType) : string {
    //    var ret: string = "";
    //    switch (mprType) {
    //        case lt.Controls.Medical.CellMPRType.axial:
    //            ret = "Axial";
    //            break;
    //        case lt.Controls.Medical.CellMPRType.sagittal:
    //            ret = "Sagittal";
    //            break;
    //        case lt.Controls.Medical.CellMPRType.coronal:
    //            ret = "Coronal";
    //            break;
    //        case lt.Controls.Medical.CellMPRType.none:
    //            ret = "";
    //            break;
    //    }
    //    return ret;
    //}
    HangingProtocolHelper.GetCellMprTypeSelectorValue = function (mprType) {
        var ret = "";
        switch (mprType) {
            case lt.Controls.Medical.CellMPRType.axial:
                ret = "TRANSVERSE";
                break;
            case lt.Controls.Medical.CellMPRType.sagittal:
                ret = "SAGITTAL";
                break;
            case lt.Controls.Medical.CellMPRType.coronal:
                ret = "CORONAL";
                break;
            case lt.Controls.Medical.CellMPRType.none:
                ret = "";
                break;
        }
        return ret;
    };
    HangingProtocolHelper.getTimeBasedImageSetLabel = function (prefix, imageSetName) {
        var result = imageSetName.replace("Image Set", "");
        result = result.trim();
        result = prefix + " " + result;
        return result;
    };
    HangingProtocolHelper.get_ImageSets = function (viewer, primaryCell, hp) {
        var count = viewer.layout.items.count;
        // var imageSetNumber: number = 0;
        var displaySetNumber = 1;
        var imageBoxNumber = 1;
        var sets = {};
        var modalitySplit = HangingProtocolHelper.split_cells(viewer);
        var pixelSpacing = 1.0;
        for (var i = 0; i < count; i++) {
            var cell = viewer.layout.items.item(i);
            if (cell.frames.count > 0) {
                var firstFrame = cell.frames.item(0);
                var activeFrame = HangingProtocolHelper.get_activeFrame(cell);
                var metadata = firstFrame["metadata"];
                if (metadata != null) {
                    pixelSpacing = DicomHelper.getDicomTagValue(metadata, DicomTag.PixelSpacing);
                }
                var parentDisplaySet = Utils.findFirst(hp.DisplaySets, function (item) {
                    var parentCell = item['cell'];
                    if (parentCell) {
                        return parentCell.derivatives.contains(cell);
                    }
                    return false;
                });
                if (parentDisplaySet) {
                    // *************************************
                    // MPR -- generated (reformatted) stacks
                    // *************************************
                    var displaySet = new Models.DisplaySet();
                    // Display Set Number (Mandatory)
                    displaySet.DisplaySetNumber = displaySetNumber;
                    // Display Set Label (Optional)
                    displaySet.DisplaySetLabel = "Display Set " + displaySetNumber;
                    // Display Set Presentation Group (Mandatory)
                    displaySet.DisplaySetPresentationGroup = 1;
                    // Image Set Number (Mandatory)
                    displaySet.ImageSetNumber = parentDisplaySet.ImageSetNumber;
                    // Image Boxes Sequence (Mandatory)
                    var box = HangingProtocolHelper.get_cellImageBox(cell, imageBoxNumber);
                    displaySet.Boxes.push(box);
                    // Filter Operations Sequence (Mandatory)
                    this.setFilterOperationsMpr(displaySet, cell);
                    // Sorting Operations Sequence (Mandatory)
                    this.setSortingOperationsMpr(displaySet, cell);
                    // Blending Operation Type (Optional)
                    // xxx
                    // Reformatting Operation Type (Optiona)
                    this.setReformattingOptions(displaySet, cell, pixelSpacing);
                    // 3D Rendering Type (Conditional)
                    // Display Set Patient Orientation (Optional)
                    this.setDisplaySetPatientOrientation(activeFrame, displaySet);
                    // Display Set Horizontal Justification (Optional)
                    displaySet.DisplaySetHorizontalJustification = this.ConvertToFrameHorizontalJustication(activeFrame.horizontalAlignment);
                    // Display Set Vertical Justification (Optional)        
                    displaySet.DisplaySetVerticalJustification = this.ConvertToFrameVerticalJustication(activeFrame.verticalAlignment);
                    // VOI Type (Optional)
                    displaySet.VoiType = this.get_voiType(cell);
                    // Pseudo-Color Type (Optional)
                    // xxx
                    // Pseudo-Color Palette Instance Reference Sequence (Conditional)
                    // xxx
                    // Show Grayscale Inverted (Optional)
                    // xxx
                    // Show Image True Size Flag (Optional)
                    // xxx
                    // Show Graphic Annotation Flag (Optional)
                    // xxx
                    // Show Patient Demographics Flag (Optional)
                    // xxx
                    // Show Acquisition Techniques Flag (Optional)
                    // xxx
                    // Display Set Presentation Group Description (Optional)
                    // xxx
                    // displaySet["CombinedName"] = displaySet.DisplaySetLabel + " - " + "MPR Reformatted " + this.GetCellMprTypeName(cell.mprType); //+ imageSet.Name;
                    displaySet['cell'] = cell;
                    imageBoxNumber++;
                    displaySetNumber++;
                    hp.DisplaySets.push(displaySet);
                }
                else {
                    if (metadata) {
                        var imageSet;
                        var imageSetSelector;
                        var modality = DicomHelper.getDicomTagValue(metadata, DicomTag.Modality);
                        var bodyPart = DicomHelper.getDicomTagValue(metadata, DicomTag.BodyPartExamined);
                        var studyDescription;
                        var box = HangingProtocolHelper.get_cellImageBox(cell, imageBoxNumber);
                        var setKey;
                        var studyInstanceUid = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyInstanceUID);
                        if (!bodyPart) {
                            bodyPart = "";
                        }
                        if (bodyPart.length == 0) {
                            studyDescription = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyDescription);
                        }
                        if (!studyDescription)
                            studyDescription = "";
                        var ignoreStudyTime = true;
                        var studyDateString = DicomHelper.getStudyDateTimeString(metadata, ignoreStudyTime, true);
                        var studyDate = DicomHelper.getStudyDateTime(metadata, ignoreStudyTime);
                        var sopClass = DicomHelper.getDicomTagValue(metadata, DicomTag.SOPClassUID);
                        // Test for encapsulated PDF
                        var isPdf = false;
                        if (sopClass == "1.2.840.10008.5.1.4.1.1.104.1")
                            isPdf = true;
                        // setKey = modality + bodyPart + studyDescription;//  + studyDateString;
                        // setKey = modality + "|" + sopClass + "|" + bodyPart + "|" + studyDescription; // + "|" + studyInstanceUid;//  + studyDateString;
                        // setKey = modality + "|" + sopClass + "|" + bodyPart;
                        setKey = modality + "|" + sopClass;
                        if (!sets[setKey]) {
                            imageSet = new Models.ImageSet();
                            imageSet['metadata'] = metadata;
                            sets[setKey] = imageSet;
                            imageSet.Name = modality;
                            if (isPdf)
                                imageSet.Name = imageSet.Name + " PDF";
                            if (bodyPart.length > 0) {
                                imageSet.Name = imageSet.Name + " [" + bodyPart + "]";
                            }
                            imageSet.Name = imageSet.Name + /* studyDateString + */ " Image Set "; // + imageSetNumber;
                            // imageSetNumber++;
                            hp.ImageSetsSequence.push(imageSet);
                        }
                        else {
                            imageSet = sets[setKey];
                        }
                        if (imageSet.ImageSetSelectorSequence.length == 0) {
                            imageSetSelector = new Models.ImageSetSelector();
                            imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.NoMatch;
                            imageSetSelector.WCFSelectorAttribute = Utils.insert(DicomTag.Modality, 4, ":");
                            imageSetSelector.SelectorValueNumber = 1;
                            imageSetSelector.SelectorValue = modality;
                            imageSetSelector.SelectorName = 'Modality';
                            imageSet.ImageSetSelectorSequence.push(imageSetSelector);
                            if (sopClass.length != 0) {
                                imageSetSelector = new Models.ImageSetSelector();
                                imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.NoMatch;
                                imageSetSelector.WCFSelectorAttribute = Utils.insert(DicomTag.SOPClassUID, 4, ":");
                                imageSetSelector.SelectorValueNumber = 1;
                                imageSetSelector.SelectorValue = sopClass;
                                imageSetSelector.SelectorName = 'SOP Class UID';
                                imageSet.ImageSetSelectorSequence.push(imageSetSelector);
                            }
                        }
                        // Add the following items as MATCH (match if not present)
                        imageSet.UpdateImageSelectorItem(metadata, DicomTag.BodyPartExamined, "Body Part Examined");
                        imageSet.UpdateImageSelectorItem(metadata, DicomTag.Laterality, "Laterality");
                        imageSet.UpdateImageSelectorItem(metadata, DicomTag.ProtocolName, "Protocol Name");
                        imageSet.UpdateImageSelectorItem(metadata, DicomTag.StudyDescription, "Study Description");
                        imageSet.UpdateImageSelectorItem(metadata, DicomTag.ImageLaterality, "Image Laterality");
                        //if (bodyPart.length != 0) {
                        //    imageSetSelector = new Models.ImageSetSelector();
                        //    imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.Match;
                        //    imageSetSelector.WCFSelectorAttribute = Utils.insert(DicomTag.BodyPartExamined, 4, ":");
                        //    imageSetSelector.SelectorValueNumber = 1;
                        //    imageSetSelector.SelectorValue = bodyPart;
                        //    imageSetSelector.SelectorName = 'Body Part Examined';
                        //    imageSet.ImageSetSelectorSequence.push(imageSetSelector);
                        //}
                        //// (10.27.2016 -- Xxxx) put this back
                        //if (studyDescription.length > 0) {
                        //    imageSetSelector = new Models.ImageSetSelector();
                        //    imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.NoMatch;
                        //    imageSetSelector.WCFSelectorAttribute = Utils.insert(DicomTag.StudyDescription, 4, ":");
                        //    imageSetSelector.SelectorValueNumber = 1;
                        //    imageSetSelector.SelectorValue = studyDescription;
                        //    imageSetSelector.SelectorName = 'Study Description';
                        //    imageSet.ImageSetSelectorSequence.push(imageSetSelector);
                        //}
                        // remove this code
                        //var imageLaterality: string = DicomHelper.getDicomTagValue(metadata, DicomTag.ImageLaterality);
                        //if (imageLaterality.length > 0) {
                        //    imageSetSelector = new Models.ImageSetSelector();
                        //    imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.NoMatch;
                        //    imageSetSelector.WCFSelectorAttribute = Utils.insert(DicomTag.ImageLaterality, 4, ":");
                        //    imageSetSelector.SelectorValueNumber = 1;
                        //    imageSetSelector.SelectorValue = imageLaterality;
                        //    imageSetSelector.SelectorName = 'Image Laterality ';
                        //    imageSet.ImageSetSelectorSequence.push(imageSetSelector);
                        //}
                        // if (!modalitySplit[setKey] || modalitySplit[setKey].length == 1 || modalitySplit[setKey].indexOf(cell) == 0)
                        // if (imageSet.TimeBasedImageSetsSequence.length == 0) {
                        var currentImageSetNumber = imageSet.FindTimeBasedImageSetNumber(studyDate);
                        if (currentImageSetNumber == 0) {
                            currentImageSetNumber = hp.getNextImageSetNumber();
                            currentImageSetNumber = imageSet.AddTimeBasedImageSet(studyDate, currentImageSetNumber);
                        }
                        //else {
                        //    alert("Image Set not getting added");
                        //}
                        // This is the priors code, which we are currently not using
                        // 
                        //else
                        //{
                        //    var prior = modalitySplit[setKey].indexOf(cell);
                        //    var injector: ng.auto.IInjectorService = angular.element(document.getElementById('app')).injector();
                        //    var dataService: DataService = injector.get('dataService');
                        //    var series: Array<any> = dataService.get_allSeries();
                        //    var found = Utils.findFirst(series, function (item) {
                        //        return item.InstanceUID == cell.seriesInstanceUID;
                        //    });
                        //    if (found) {
                        //        prior = 1 + series.indexOf(found);
                        //    }
                        //    tmImageSetSelector.ImageSetLabel = "Prior " + modality + " " + bodyPart;
                        //    tmImageSetSelector.ImageSetNumber = ++imageSetNumber;
                        //    tmImageSetSelector.ImageSetSelectorCategory = Models.ImageSetSelectorCategory.AbstractPrior;
                        //    tmImageSetSelector.AbstractPriorValue.push(prior);
                        //    tmImageSetSelector.AbstractPriorValue.push(prior);
                        //    imageSet.TimeBasedImageSetsSequence.push(tmImageSetSelector);
                        //    hp.NumberOfPriorsReferenced += 1;
                        //}
                        var displaySet = new Models.DisplaySet();
                        if (activeFrame) {
                            displaySet['metadata'] = activeFrame['metadata'];
                        }
                        // Display Set Number (Mandatory)
                        displaySet.DisplaySetNumber = displaySetNumber;
                        // Display Set Label (Optional)
                        displaySet.DisplaySetLabel = "Display Set " + displaySetNumber;
                        // Display Set Presentation Group (Mandatory)
                        displaySet.DisplaySetPresentationGroup = 1;
                        // Image Set Number (Mandatory)
                        displaySet.ImageSetNumber = currentImageSetNumber; //imageSet.TimeBasedImageSetsSequence[0].ImageSetNumber; // tmImageSetSelector.ImageSetNumber;
                        // Image Boxes Sequence (Mandatory)                        
                        displaySet.Boxes.push(box);
                        // Filter Operations Sequence (Mandatory)
                        HangingProtocolHelper.checkFilterOperations(displaySet);
                        // Sorting Operations Sequence (Mandatory)
                        HangingProtocolHelper.checkSortingOperations(displaySet, cell);
                        // Blending Operation Type (Optional)
                        // xxx
                        // Reformatting Operation Type (Optional)
                        //if (cell.derivatives.count > 0) { // <== means MPR original cell (i.e. not derived MPR cell)
                        // Do not write the reformatting options for the MPR original cell -- only the derived MPR cells
                        // Note that the three display sets that correspond to the MPR all reference the same image set!
                        // this.setReformattingOptions(displaySet, cell, pixelSpacing);
                        //}   
                        // 3D Rendering Type (Conditional)
                        // xxx
                        // Display Set Patient Orientation (Optional)
                        this.setDisplaySetPatientOrientation(activeFrame, displaySet);
                        // Display Set Horizontal Justification (Optional)
                        displaySet.DisplaySetHorizontalJustification = this.ConvertToFrameHorizontalJustication(activeFrame.horizontalAlignment);
                        // Display Set Vertical Justification (Optional)
                        displaySet.DisplaySetVerticalJustification = this.ConvertToFrameVerticalJustication(activeFrame.verticalAlignment);
                        // VOI Type (Optional)
                        displaySet.VoiType = this.get_voiType(cell);
                        // Pseudo-Color Type (Optional)
                        // xxx
                        // Pseudo-Color Palette Instance Reference Sequence (Conditional)
                        // xxx
                        // Show Grayscale Inverted (Optional)
                        displaySet.ShowGrayscaleInverted = this.get_invertedFlag(cell);
                        // Show Image True Size Flag (Optional)
                        displaySet.ShowImageTrueSizeFlag = this.get_showImageTrueSize(cell);
                        // Show Graphic Annotation Flag (Optional)
                        displaySet.ShowGraphicAnnotationFlag = this.get_annotationFlag(cell);
                        // Show Patient Demographics Flag (Optional)
                        displaySet.ShowPatientDemographicsFlag = cell.overlayTextVisible;
                        // Show Acquisition Techniques Flag (Optional)
                        // xxx
                        // Display Set Presentation Group Description (Optional)
                        // xxx
                        var notUsed = hp.getTimeBasedImageSetLabel(displaySet.ImageSetNumber);
                        // displaySet["CombinedName"] = displaySet.DisplaySetLabel + " - " + imageSet.Name;
                        displaySet['cell'] = cell;
                        imageBoxNumber++;
                        displaySetNumber++;
                        hp.DisplaySets.push(displaySet);
                    }
                }
            }
        }
        //*******************************************
        // Code to update the Priors
        for (var i = 0; i < hp.ImageSetsSequence.length; i++) {
            hp.ImageSetsSequence[i].TimeBasedImageSetsSequence.sort(function (a, b) {
                return (-1) * a.StudyDateTime.compareTo(b.StudyDateTime);
            });
            // Update current and Priors information (TimeBasedImageSetsSequence)
            for (var index = 0; index < hp.ImageSetsSequence[i].TimeBasedImageSetsSequence.length; index++) {
                var timeBasedImageSet = hp.ImageSetsSequence[i].TimeBasedImageSetsSequence[index];
                if (index == 0) { // <== Most current
                    // Image Set Selector Category (Mandatory)
                    timeBasedImageSet.ImageSetSelectorCategory = Models.ImageSetSelectorCategory.RelativeTime;
                    // Relative Time (Conditional)
                    timeBasedImageSet.RelativeTime.push(0);
                    timeBasedImageSet.RelativeTime.push(0);
                    // Relative Time Units (Conditional)
                    timeBasedImageSet.RelativeTimeUnits = Models.RelativeTimeUnits.Minutes;
                    // Image Set Label (Optional)                   
                    timeBasedImageSet.ImageSetLabel = this.getTimeBasedImageSetLabel("Current", hp.ImageSetsSequence[i].Name);
                }
                else { // <== Prior(s)
                    // Image Set Selector Category (Mandatory)
                    timeBasedImageSet.ImageSetSelectorCategory = Models.ImageSetSelectorCategory.AbstractPrior;
                    // Abstract Prior Value (Conditional)
                    timeBasedImageSet.AbstractPriorValue.push(index);
                    timeBasedImageSet.AbstractPriorValue.push(index);
                    // Image Set Label (Optional)
                    var priorPrefix = Utils.GetNumericPrefix(index);
                    // timeBasedImageSet.ImageSetLabel = priorPrefix + " Prior " + modality + " " + bodyPart;
                    timeBasedImageSet.ImageSetLabel = this.getTimeBasedImageSetLabel(priorPrefix + " Prior", hp.ImageSetsSequence[i].Name);
                }
            }
        }
        hp.updateDisplaySetCombinedName();
        // Number of Priors Referenced (Mandatory)
        hp.NumberOfPriorsReferenced = hp.getNumberOfPriorsReferenced();
        hp.updateImageSetSelectorValues();
        //*******************************************
        this.setReferenceLine(viewer, hp);
        this.setSynchronizedScrolling(viewer, hp);
        this.setSynchronizedScrollingMprDerived(viewer, hp);
        count = viewer.emptyDivs.items.count;
        for (var i = 0; i < count; i++) {
            var emptyCell = viewer.emptyDivs.items.item(i);
            var displaySet = new Models.DisplaySet();
            // Display Set Number (Mandatory)
            displaySet.DisplaySetNumber = displaySetNumber++;
            // Display Set Label (Optional)
            displaySet.DisplaySetLabel = "Display Set " + displaySet.DisplaySetNumber;
            // Display Set Presentation Group (Mandatory)
            // xxx
            // Image Set Number (Mandatory)      
            displaySet.ImageSetNumber = -1;
            // Image Boxes Sequence (Mandatory)
            var box = HangingProtocolHelper.get_emptyCellImageBox(emptyCell, imageBoxNumber++);
            displaySet.Boxes.push(box);
            hp.DisplaySets.push(displaySet);
            // Filter Operations Sequence (Mandatory)
            // xxx
            // Sorting Operations Sequence (Mandatory)
            // xxx
            // Blending Operation Type (Optional)
            // xxx
            // Reformatting Operation Type (Optional)
            // xxx
            // 3D Rendering Type (Conditional)
            // xxx
            // Display Set Patient Orientation (Optional)
            displaySet.DisplaySetPatientOrientation = null;
            // Display Set Horizontal Justification (Optional)
            // xxx
            // Display Set Vertical Justification (Optional)
            // xxx
            // VOI Type (Optional)
            // xxx
            // Pseudo-Color Type (Optional)
            // xxx
            // Pseudo-Color Palette Instance Reference Sequence (Conditional)
            // xxx
            // Show Grayscale Inverted (Optional)
            displaySet.ShowGrayscaleInverted = this.get_invertedFlag(cell);
            // Show Image True Size Flag (Optional)
            displaySet.ShowImageTrueSizeFlag = this.get_showImageTrueSize(cell);
            // Show Graphic Annotation Flag (Optional)
            // xxx
            // Show Patient Demographics Flag (Optional)
            // xxx
            // Show Acquisition Techniques Flag (Optional)
            // xxx
            // Display Set Presentation Group Description (Optional)
            // xxx
        }
    };
    HangingProtocolHelper.get_activeFrame = function (cell) {
        if (cell) {
            var injector = angular.element(document.getElementById('app')).injector();
            var seriesManagerService = injector.get('seriesManagerService');
            var index = seriesManagerService.get_activeSubCellIndex(cell);
            return (cell.imageViewer.items.get_item(index)).attachedFrame;
        }
        return null;
    };
    HangingProtocolHelper.get_allValues = function (cell, field) {
        var returnValue = null;
        var count = cell.frames.count;
        // get first value
        var frame = cell.frames.get_item(0);
        if (frame.hasOwnProperty(field)) {
            returnValue = frame[field];
        }
        if (returnValue == null)
            return null;
        // All frames must have same returnValue to return returnValue
        // Otherwise, return null
        for (var i = 1; i < count; i++) {
            var frame = cell.frames.get_item(i);
            if (!frame.hasOwnProperty(field)) {
                return null;
            }
            if (returnValue != frame[field]) {
                return null;
            }
        }
        return returnValue;
    };
    HangingProtocolHelper.get_voiType = function (cell) {
        var voiType = null;
        var voiTypeItem = this.get_allValues(cell, 'currentCustomWindowlevel');
        if (voiTypeItem != null) {
            if (voiTypeItem.hasOwnProperty('VoiType')) {
                voiType = voiTypeItem["VoiType"];
            }
        }
        return voiType == Models.VoiType.Undefined ? null : voiType;
    };
    HangingProtocolHelper.get_invertedFlag = function (cell) {
        var inverted = this.get_allValues(cell, '_inverted');
        return inverted;
    };
    HangingProtocolHelper.get_showImageTrueSize = function (cell) {
        var imageTrueSize = this.get_allValues(cell, '_sizeMode');
        return imageTrueSize == lt.Controls.Medical.MedicalViewerSizeMode.trueSize ? true : null;
    };
    HangingProtocolHelper.get_annotationFlag = function (cell) {
        var automation = cell.automation;
        return automation.activeContainer.isVisible;
    };
    HangingProtocolHelper.setReformattingOptions = function (displaySet, cell, pixelSpacing) {
        displaySet.ReformattingOperationType = Models.ReformattingOperationType.Mpr;
        displaySet.ReformattingThickness = 1.0; // MedicalViewer does not currently return this value so default
        displaySet.ReformattingInterval = pixelSpacing;
        displaySet.ReformattingOperationInitialViewDirection = cell.mprType;
    };
    HangingProtocolHelper.checkFilterOperations = function (displaySet) {
        var metadata = displaySet['metadata'];
        var imageTypes = DicomHelper.get_allValues(metadata, DicomTag.ImageType);
        var value;
        var filterOperation;
        // Check if non-image DICOM Dataset (like encapsulated PDF)  
        // If non-image, add SOPClassUID
        var isImage = DicomHelper.IsDicomImage(metadata);
        if (!isImage) {
            value = DicomHelper.getDicomTagValue(metadata, DicomTag.SOPClassUID);
            if (value) {
                filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.SOPClassUID, 1, value);
                filterOperation.SelectorName = 'SOP Class UID';
                filterOperation.SelectorAttributeVr = "UI";
                displaySet.FilterOperationsSequence.push(filterOperation);
            }
            //value = DicomHelper.getDicomTagValue(metadata, DicomTag.DocumentTitle);
            //if (value) {
            //    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.DocumentTitle, 1, value);
            //    filterOperation.SelectorName = 'Document Title';
            //    filterOperation.SelectorAttributeVr = "ST";
            //    displaySet.FilterOperationsSequence.push(filterOperation);
            //}
        }
        // Value 3 of Image Type (0008,0008)
        if (imageTypes.length >= 3) {
            // Check if 3rd value contains only white space
            var onlyWhitespace = ($.trim(imageTypes[2]).length === 0);
            if (!onlyWhitespace) {
                filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ImageType, 3, imageTypes[2]);
                filterOperation.SelectorName = 'Image Type';
                filterOperation.SelectorAttributeVr = "CS";
                displaySet.FilterOperationsSequence.push(filterOperation);
            }
            else {
                // Check if 4th value contains only white space
                onlyWhitespace = ($.trim(imageTypes[3]).length === 0);
                if (!onlyWhitespace) {
                    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ImageType, 4, imageTypes[3]);
                    filterOperation.SelectorName = 'Image Type';
                    filterOperation.SelectorAttributeVr = "CS";
                    displaySet.FilterOperationsSequence.push(filterOperation);
                }
            }
        }
        // Anatomic Region Sequence (0008,2218)
        // Pixel Presentation (0008, 9205)
        // Volume Based Calculation Technique (0008,9207)
        // Acquisition Contrast (0008,9209)
        // Contrast/Bolus Agent (0018,0010)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.ContrastBolusAgent);
        if (value && (typeof value != "string" || (typeof value == "string" && value.length > 0))) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ContrastBolusAgent, 1, value);
            filterOperation.SelectorName = 'Contrast/Bolus Agent';
            filterOperation.SelectorAttributeVr = "LO";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Body Part Examined (0018, 0015)
        // Scanning Sequence (0018,0020)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.ScanningSequence);
        if (value && (typeof value != "string" || (typeof value == "string" && value.length > 0))) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ScanningSequence, 1, value);
            filterOperation.SelectorName = 'Scanning Sequence';
            filterOperation.SelectorAttributeVr = "CS";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Intervention Drug Start Time (0018,0035)
        // Echo Time (0018,0081)
        //value = DicomHelper.getDicomTagValue(metadata, DicomTag.EchoTime);
        //if (value && (typeof value != "string" || (typeof value == "string" && value.length > 0))) {
        //    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.EchoTime, 1, value);
        //    filterOperation.SelectorName = 'Echo Time';
        //    filterOperation.SelectorAttributeVr = "DS";
        //    displaySet.FilterOperationsSequence.push(filterOperation);
        //}
        // Echo Number(s) (0018,0086)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.EchoNumber);
        if (value) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.EchoNumber, 1, value);
            filterOperation.SelectorName = 'Echo Numbers';
            filterOperation.SelectorAttributeVr = "IS";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Protocol Name (0018,1030)
        if (!value) {
            value = DicomHelper.getDicomTagValue(metadata, DicomTag.ProtocolName);
            if (value && (typeof value != "string" || (typeof value == "string" && value.length > 0))) {
                filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ProtocolName, 1, value);
                filterOperation.SelectorName = 'Protocol Name';
                filterOperation.SelectorAttributeVr = "LO";
                displaySet.FilterOperationsSequence.push(filterOperation);
            }
        }
        // Contrast/Bolus Start Time (0018,1042)
        // Contrast/Bolus Stop Time (0018,1043)
        // Trigger Time (0018,1060)
        // Image Trigger Delay (0018,1067)
        // Radiopharmaceutical Start Time (0018,1072)
        // Radiopharmaceutical Stop Time (0018,1073)
        // Trigger Window (0018,1094)
        // View Position (0018,5101)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.ViewPosition);
        if (value) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ViewPosition, 1, value);
            filterOperation.SelectorName = 'View Position';
            filterOperation.SelectorAttributeVr = "CS";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Echo Pulse Sequence (0018,9008)
        // Phase Contrast (0018,9014)
        // Effective Echo Time (0018,9082)
        // Laterality (0020,0060)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.Laterality);
        if (value) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.Laterality, 1, value);
            filterOperation.SelectorName = 'Laterality';
            filterOperation.SelectorAttributeVr = "CS";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Image Laterality (0020,0062)
        value = DicomHelper.getDicomTagValue(metadata, DicomTag.ImageLaterality);
        if (value) {
            filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.ImageLaterality, 1, value);
            filterOperation.SelectorName = 'Image Laterality';
            filterOperation.SelectorAttributeVr = "CS";
            displaySet.FilterOperationsSequence.push(filterOperation);
        }
        // Slice Location (0020,1041)
        //value = DicomHelper.getDicomTagValue(metadata, DicomTag.SliceLocation);
        //if (value) {
        //    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.SliceLocation, 1, value);
        //    filterOperation.SelectorName = 'Slice Location';
        //    displaySet.FilterOperationsSequence.push(filterOperation);
        //}
        // View Code Sequence (0054,0220) 
        // Others
        //value = DicomHelper.getDicomTagValue(metadata, DicomTag.SeriesNumber);
        //if (value) {
        //    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.SeriesNumber, 1, value);
        //    filterOperation.SelectorName = 'Series Number';
        //    displaySet.FilterOperationsSequence.push(filterOperation);
        // Patient Orientation (0020,0020)
        //value = DicomHelper.getDicomTagValue(metadata, DicomTag.PatientOrientation);
        //if (value) {
        //    filterOperation = HangingProtocolHelper.get_FilterOperation(DicomTag.PatientOrientation, 1, value);
        //    filterOperation.SelectorName = 'Patient Orientation';
        //    displaySet.FilterOperationsSequence.push(filterOperation);
        //}
    };
    HangingProtocolHelper.checkSortingOperations = function (displaySet, cell) {
        if (cell.derivatives.count > 0) { // <== means MPR original cell (i.e. not derived MPR cell)
            this.setSortingOperationsMpr(displaySet, cell);
            return;
        }
        var medicalViewerSortingOperations;
        var sortingOperationsSequence = new Array();
        medicalViewerSortingOperations = cell.sortingOperationsSequence;
        if (medicalViewerSortingOperations != null) {
            medicalViewerSortingOperations.forEach(function (medicalViewerSortingOperation) {
                var sortingOperations = new Models.SortingOperations();
                sortingOperations.Convert(medicalViewerSortingOperation);
                sortingOperationsSequence.push(sortingOperations);
            });
            if (sortingOperationsSequence.length > 0) {
                displaySet.SortingOperationsSequence = sortingOperationsSequence;
            }
        }
        // default -- no sorting option chosen in the menu
        else {
        }
    };
    HangingProtocolHelper.setNominalScreenDefinitionSequence = function (hp) {
        hp.NominalScreenDefinitionSequence = new Array();
        var nsc = new Models.NominalScreenDefinition();
        nsc.NumberOfHorizontalPixels = 1024;
        nsc.NumberOfVerticalPixels = 768;
        nsc.DisplayEnvironmentSpatialPosition = [0, 1, 1, 0];
        nsc.ScreenMinimumColorBitDepth = 8;
        hp.NominalScreenDefinitionSequence.push(nsc);
    };
    HangingProtocolHelper.setFilterOperationsMpr = function (displaySet, cell) {
        var filterOperation = new Models.FilterOperation();
        filterOperation.SelectorName = 'Image Plane';
        filterOperation.FilterByCategory = "IMAGE_PLANE";
        filterOperation.SelectorAttributeVr = "CS";
        filterOperation.SelectorValue = this.GetCellMprTypeSelectorValue(cell.mprType); //"TRANSVERSE";
        filterOperation.FilterByOperator = Models.FilterByOperator.MemberOf;
        displaySet.FilterOperationsSequence.push(filterOperation);
    };
    HangingProtocolHelper.setSortingOperationsMpr = function (displaySet, cell) {
        var medicalViewerSortingOperations;
        var sortingOperationsSequence = new Array();
        medicalViewerSortingOperations = cell.sortingOperationsSequence;
        var sortingOperations = new Models.SortingOperations();
        sortingOperations.SortByCategory = Models.SortByCategory.AlongAxis;
        sortingOperations.SortingDirection = Models.SortingDirection.Increasing;
        sortingOperationsSequence.push(sortingOperations);
        if (sortingOperationsSequence.length > 0) {
            displaySet.SortingOperationsSequence = sortingOperationsSequence;
        }
    };
    HangingProtocolHelper.setDisplaySetPatientOrientation = function (activeFrame, displaySet) {
        displaySet.DisplaySetPatientOrientation = null;
        if (activeFrame.targetOrientation != undefined) {
            displaySet.DisplaySetPatientOrientation = activeFrame.targetOrientation;
        }
    };
    //public static checkReformatting(displaySet: Models.DisplaySet, cell: lt.Controls.Medical.Cell) {
    //    var medicalViewerSortingOperations: lt.Controls.Medical.SortingOperation[];
    //    var sortingOperationsSequence: Array<Models.SortingOperations> = new Array<Models.SortingOperations>();
    //    medicalViewerSortingOperations = cell.sortingOperationsSequence;
    //    if (medicalViewerSortingOperations != null) {
    //        medicalViewerSortingOperations.forEach((medicalViewerSortingOperation: lt.Controls.Medical.SortingOperation) => {
    //            var sortingOperations: Models.SortingOperations = new Models.SortingOperations();
    //            sortingOperations.Convert(medicalViewerSortingOperation);
    //            sortingOperationsSequence.push(sortingOperations);
    //        });
    //        if (sortingOperationsSequence.length > 0) {
    //            displaySet.SortingOperationsSequence = sortingOperationsSequence;
    //        }
    //    }
    //}
    HangingProtocolHelper.get_FilterOperation = function (tag, index, value) {
        var filterOperation = new Models.FilterOperation();
        filterOperation.WCFSelectorAttribute = Utils.insert(tag, 4, ":");
        filterOperation.SelectorValueNumber = index;
        filterOperation.SelectorValue = value;
        filterOperation.FilterByOperator = Models.FilterByOperator.MemberOf;
        return filterOperation;
    };
    HangingProtocolHelper.get_ModalityItemsInView = function (viewer) {
        var modalityItems = new Array();
        var count = viewer.layout.items.count;
        for (var i = 0; i < count; i++) {
            var cell = viewer.layout.items.item(i);
            if (cell.frames.count > 0) {
                var frame = cell.frames.item(0);
                if (frame["metadata"]) {
                    var modality = DicomHelper.getDicomTagValue(frame["metadata"], DicomTag.Modality);
                    var ars = DicomHelper.getCodeSequenceList(frame["metadata"], DicomTag.AnatomicRegionSequence, null);
                    var pcs = DicomHelper.getCodeSequenceList(frame["metadata"], DicomTag.ProcedureCodeSequence, null);
                    var rfrpcs = DicomHelper.getCodeSequenceList(frame["metadata"], DicomTag.ReasonForRequestedProcedureCodeSequence, null);
                    var studyDescription = DicomHelper.getDicomTagValue(frame["metadata"], DicomTag.StudyDescription);
                    var bpe = DicomHelper.getDicomTagValue(frame["metadata"], DicomTag.BodyPartExamined);
                    var pn = DicomHelper.getDicomTagValue(frame["metadata"], DicomTag.ProtocolName);
                    var item;
                    if (pcs.length > 0 || rfrpcs.length > 0) {
                        studyDescription = '';
                    }
                    else {
                        if ((bpe && bpe.length > 0) || (pn && pn.length > 0)) {
                            studyDescription = '';
                        }
                    }
                    item = Utils.findFirst(modalityItems, function (item) {
                        return item.Modality == modality && item.StudyDescription == studyDescription && Utils.is_equal(item.AnatomicRegionSequence, ars) &&
                            Utils.is_equal(item.ProcedureCodeSequence, pcs) && Utils.is_equal(item.ReasonForRequestedProcedureCodeSequence, rfrpcs);
                    });
                    if (!item) {
                        var item = new ModalityItem(frame["metadata"], modality);
                        item.AnatomicRegionSequence = ars;
                        item.ProcedureCodeSequence = pcs;
                        item.ReasonForRequestedProcedureCodeSequence = rfrpcs;
                        item.StudyDescription = studyDescription;
                        item.BodyPartExamined = bpe;
                        item.ProtocolName = pn;
                        modalityItems.push(item);
                    }
                }
            }
        }
        return modalityItems;
    };
    HangingProtocolHelper.get_emptyCellImageBox = function (cell, boxNumber) {
        var box = new Models.ImageBox();
        box.Position = HangingProtocolHelper.get_position(cell.bounds);
        box.ImageBoxNumber = boxNumber;
        if (cell.parent.viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
            box.RowPosition = cell.rowPosition;
            box.ColumnPosition = cell.columnsPosition;
            box.NumberOfRows = cell.numberOfRows;
            box.NumberOfColumns = cell.numberOfColumns;
        }
        box.ImageBoxLayoutType = Models.ImageBoxLayoutType.Single;
        return box;
    };
    HangingProtocolHelper.get_cellScrollType = function (cell, box) {
        if (cell == null || box == null) {
            return;
        }
        switch (cell.scrollType) {
            default:
            case lt.Controls.Medical.ScrollType.none:
                box.ImageBoxScrollDirection = Models.ScrollDirection.None;
                box.ImageBoxSmallScrollType = Models.ScrollType.None;
                box.ImageBoxLargeScrollType = Models.ScrollType.None;
                box.ImageBoxSmallScrollAmount = 1;
                box.ImageBoxLargeScrollAmount = 1;
                break;
            case lt.Controls.Medical.ScrollType.normal:
                box.ImageBoxScrollDirection = Models.ScrollDirection.Vertical;
                box.ImageBoxSmallScrollType = Models.ScrollType.Image;
                box.ImageBoxLargeScrollType = Models.ScrollType.Image;
                box.ImageBoxSmallScrollAmount = 1;
                box.ImageBoxLargeScrollAmount = 1;
                break;
            case lt.Controls.Medical.ScrollType.row:
                box.ImageBoxScrollDirection = Models.ScrollDirection.Vertical;
                box.ImageBoxSmallScrollType = Models.ScrollType.RowColumn;
                box.ImageBoxLargeScrollType = Models.ScrollType.RowColumn;
                box.ImageBoxSmallScrollAmount = 1;
                box.ImageBoxLargeScrollAmount = 1;
                break;
            case lt.Controls.Medical.ScrollType.column:
                box.ImageBoxScrollDirection = Models.ScrollDirection.Horizontal;
                box.ImageBoxSmallScrollType = Models.ScrollType.RowColumn;
                box.ImageBoxLargeScrollType = Models.ScrollType.RowColumn;
                box.ImageBoxSmallScrollAmount = 1;
                box.ImageBoxLargeScrollAmount = 1;
                break;
            case lt.Controls.Medical.ScrollType.page:
                box.ImageBoxScrollDirection = Models.ScrollDirection.Vertical;
                box.ImageBoxSmallScrollType = Models.ScrollType.Page;
                box.ImageBoxLargeScrollType = Models.ScrollType.Page;
                box.ImageBoxSmallScrollAmount = 1;
                box.ImageBoxLargeScrollAmount = 1;
                break;
        }
    };
    HangingProtocolHelper.ConvertToHangingProtocolCineOptions = function (cinePlayer) {
        if (cinePlayer == null)
            return null;
        var playback = null;
        var loop = cinePlayer.get_loop();
        switch (cinePlayer.get_direction()) {
            case lt.Controls.Medical.PlayingDirection.forward:
                playback = loop ? Models.PlaybackSequencing.Looping : Models.PlaybackSequencing.Stop;
                break;
            case lt.Controls.Medical.PlayingDirection.sweep:
                playback = loop ? Models.PlaybackSequencing.Sweeping : Models.PlaybackSequencing.SweepingStop;
                break;
            case lt.Controls.Medical.PlayingDirection.backward:
                playback = loop ? Models.PlaybackSequencing.Backward : Models.PlaybackSequencing.BackwardStop;
                break;
            case lt.Controls.Medical.PlayingDirection.shuffle:
                playback = loop ? Models.PlaybackSequencing.Shuffle : Models.PlaybackSequencing.ShuffleStop;
                break;
        }
        return playback;
    };
    HangingProtocolHelper.ConvertToCellCinePlayer = function (cell, displaySet) {
        if (displaySet == null || displaySet.Boxes == null || displaySet.Boxes.length == 0)
            return;
        var box = displaySet.Boxes[0];
        if (box.PreferredPlaybackSequencing == null || box.RecommendedDisplayFrameRate == null)
            return null;
        var cinePlayer = cell.get_cinePlayer();
        if (cinePlayer == null)
            return;
        // RecommendedDisplayFrameRate
        cinePlayer.set_FPS(box.RecommendedDisplayFrameRate);
        // PreferredPlaybackSequencing
        switch (box.PreferredPlaybackSequencing) {
            case Models.PlaybackSequencing.Looping: // 0 Looping (1,2,...,n,1,2,...,n,1,2,...,n,...)
                cinePlayer.set_loop(true);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.forward);
                break;
            case Models.PlaybackSequencing.Sweeping: // 1 Sweeping (1,2,...n,n-1,...2,1,2,...n,...)
                cinePlayer.set_loop(true);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.sweep);
                break;
            case Models.PlaybackSequencing.Stop: // 2 Stop (1,2,...,n)
                cinePlayer.set_loop(false);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.forward);
                break;
            // Non-hanging Protocol Defined
            case Models.PlaybackSequencing.SweepingStop: // 3 (1,2,...n,n-1,...2,1)
                cinePlayer.set_loop(false);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.sweep);
                break;
            case Models.PlaybackSequencing.Backward: // 4 (n, n-1, ..., 2, 1, n, n-1, ..., 2, 1)
                cinePlayer.set_loop(true);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.backward);
                break;
            case Models.PlaybackSequencing.BackwardStop: // 5 (n, n-1, ..., 2, 1)
                cinePlayer.set_loop(false);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.backward);
                break;
            case Models.PlaybackSequencing.Shuffle: // 6 Random Continuous
                cinePlayer.set_loop(true);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.shuffle);
                break;
            case Models.PlaybackSequencing.ShuffleStop: // 7 Random one time 
                cinePlayer.set_loop(false);
                cinePlayer.set_direction(lt.Controls.Medical.PlayingDirection.shuffle);
                break;
        }
    };
    HangingProtocolHelper.get_CineOptions = function (cell, box) {
        if (cell.cinePlayer != null) {
            // Preferred Playback Sequencing (Conditional)
            box.PreferredPlaybackSequencing = this.ConvertToHangingProtocolCineOptions(cell.cinePlayer);
            // Recommended Display Frame Rate (Conditional) 
            box.RecommendedDisplayFrameRate = cell.cinePlayer.FPS;
            // Cine Relative to Real-Time (Conditional)
            // XX
        }
    };
    HangingProtocolHelper.ConvertToScrollType = function (displaySet) {
        var scrollType = lt.Controls.Medical.ScrollType.normal;
        if (displaySet == null || displaySet.Boxes == null || displaySet.Boxes.length == 0) {
            return scrollType;
        }
        var box = displaySet.Boxes[0];
        switch (box.ImageBoxSmallScrollType) {
            case Models.ScrollType.None:
                scrollType = lt.Controls.Medical.ScrollType.none;
                break;
            case Models.ScrollType.Image:
                scrollType = lt.Controls.Medical.ScrollType.normal;
                break;
            case Models.ScrollType.RowColumn:
                if (box.ImageBoxScrollDirection == Models.ScrollDirection.Vertical) {
                    scrollType = lt.Controls.Medical.ScrollType.row;
                }
                else {
                    scrollType = lt.Controls.Medical.ScrollType.column;
                }
                break;
            case Models.ScrollType.Page:
                scrollType = lt.Controls.Medical.ScrollType.page;
                break;
        }
        return scrollType;
    };
    HangingProtocolHelper.get_cellImageBox = function (cell, boxNumber) {
        var box = new Models.ImageBox();
        var injector = angular.element(document.getElementById('app')).injector();
        var seriesManagerService = injector.get('seriesManagerService');
        var instances = seriesManagerService.get_instances(cell.seriesInstanceUID, cell.divID);
        var subCell = cell.selectedItem;
        if (!subCell)
            subCell = (cell.imageViewer.items.item(0));
        box.Position = HangingProtocolHelper.get_position(cell.bounds);
        // Image Box Number (Mandatory)
        box.ImageBoxNumber = boxNumber;
        if (cell.viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
            box.RowPosition = cell.rowPosition;
            box.ColumnPosition = cell.columnsPosition;
            box.NumberOfRows = cell.numberOfRows;
            box.NumberOfColumns = cell.numberOfColumns;
        }
        for (var index = 0; index < cell.frames.count; index++) {
            var frame = cell.frames.item(index);
            if (angular.isDefined(frame.Instance)) {
                var sopInstanceUID = (frame).Instance.SOPInstanceUID;
                box.referencedSOPInstanceUID.push(sopInstanceUID);
            }
        }
        if (cell.arrangement == lt.Controls.Medical.FrameArrangement.grid && (cell.gridLayout.columns > 1 || cell.gridLayout.rows > 1)) {
            // Image Box Tile Horizontal Dimension (Conditional)
            box.ImageBoxTileHorizontalDimension = cell.gridLayout.columns;
            // Image Box Tile Vertical Dimension (Conditional)
            box.ImageBoxTileVerticalDimension = cell.gridLayout.rows;
            // Image Box Scroll Direction (Conditional)
            // Image Box Small Scroll Type (Conditional)
            // Image Box Small Scroll Amount (Conditional)
            // Image Box Large Scroll Type (Conditional)
            // Image Box Large Scroll Amount (Conditional)
            this.get_cellScrollType(cell, box);
        }
        if (angular.isDefined(subCell["horizontalAlignment"]))
            box.HorizontalJustification = subCell["horizontalAlignment"];
        if (angular.isDefined(subCell["verticalAlignment"]))
            box.VerticalJustification = subCell["verticalAlignment"];
        if ( /*cell.currentOffset != 0 &&*/angular.isDefined(cell.frames.item(cell.currentOffset).Instance)) {
            box.FirstFrame = new Models.FirstFrame();
            box.FirstFrame.SOPClassUID = cell.frames.item(cell.currentOffset).Instance.SOPClassUID;
            box.FirstFrame.SOPInstanceUID = cell.frames.item(cell.currentOffset).Instance.SOPInstanceUID;
            box.FirstFrame.FrameNumber = cell.currentOffset + 1;
        }
        if (subCell && subCell.attachedFrame) {
            var renderer = subCell.attachedFrame.get_wlRenderer();
            if (renderer) {
                var owlc = renderer.originalWindowLevelCenter;
                var owlw = renderer.originalWindowLevelWidth;
                if (subCell.attachedFrame.windowCenter != owlc || subCell.attachedFrame.windowWidth != owlw) {
                    box.WindowWidth = subCell.attachedFrame.windowWidth;
                    box.WindowCenter = subCell.attachedFrame.windowCenter;
                }
            }
        }
        // Image Box Layout Type (Mandatory)
        if (cell.arrangement == lt.Controls.Medical.FrameArrangement.grid && (box.ImageBoxTileHorizontalDimension > 1 || box.ImageBoxTileVerticalDimension > 1)) {
            box.ImageBoxLayoutType = Models.ImageBoxLayoutType.Tiled;
        }
        else if (instances.length == 1 && instances[0].NumberOfFrames > 1) {
            box.ImageBoxLayoutType = Models.ImageBoxLayoutType.Cine;
        }
        else if (instances.length == 1) {
            box.ImageBoxLayoutType = Models.ImageBoxLayoutType.Single;
        }
        else if (instances.length > 1) {
            box.ImageBoxLayoutType = Models.ImageBoxLayoutType.Stack;
        }
        // Image Box Overlap Priority (Optional)  
        // Preferred Playback Sequencing (Conditional)
        // Recommended Display Frame Rate (Conditional) 
        // Cine Relative to Real-Time (Conditional)
        this.get_CineOptions(cell, box);
        return box;
    };
    HangingProtocolHelper.split_cells = function (viewer) {
        var cells = viewer.layout.items.toArray();
        var injector = angular.element(document.getElementById('app')).injector();
        var seriesManagerService = injector.get('seriesManagerService');
        var modalitySplit = {};
        if (cells.length > 1) {
            modalitySplit = cells.reduce(function (buckets, item) {
                var seriesInfo = seriesManagerService.get_seriesInfo(item.seriesInstanceUID);
                if (seriesInfo) {
                    var modality = seriesInfo.Modality;
                    var key = '';
                    if (item.frames.count > 0) {
                        var metadata = item.frames.item(0)["metadata"];
                        if (!metadata) {
                            metadata = item.generator.frames.item(0)["metadata"];
                        }
                        if (metadata) {
                            key = DicomHelper.getDicomTagValue(metadata, DicomTag.BodyPartExamined);
                            if (!key)
                                key = '';
                        }
                        if (key.length == 0) {
                            var studyDescription = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyDescription);
                            if (!studyDescription)
                                studyDescription = "";
                            key += studyDescription;
                        }
                    }
                    if (!buckets[modality + key])
                        buckets[modality + key] = [];
                    buckets[modality + key].push(item);
                }
                return buckets;
            }, {});
            for (var name in modalitySplit) {
                if (modalitySplit.hasOwnProperty(name)) {
                    HangingProtocolHelper.sort_cells(modalitySplit[name]);
                }
            }
        }
        return modalitySplit;
    };
    HangingProtocolHelper.sort_cells = function (cells) {
        cells.sort(function (a, b) {
            if (a.frames.count > 0 && b.frames.count > 0) {
                var aMetadata = a.frames.item(0)['metadata'];
                var bMetadata = b.frames.item(0)['metadata'];
                if (aMetadata && bMetadata) {
                    var aDate = DicomHelper.getDicomTagValue(aMetadata, DicomTag.StudyDate);
                    var bDate = DicomHelper.getDicomTagValue(bMetadata, DicomTag.StudyDate);
                    var aTime = DicomHelper.getDicomTagValue(aMetadata, DicomTag.StudyTime);
                    var bTime = DicomHelper.getDicomTagValue(bMetadata, DicomTag.StudyTime);
                    var acompare = HangingProtocolHelper.combine_datetime(aDate, aTime);
                    var bcompare = HangingProtocolHelper.combine_datetime(bDate, bTime);
                    a['studyDate'] = acompare;
                    b['studyDate'] = bcompare;
                    return bcompare.compareTo(acompare);
                }
            }
            else if (a.frames.count == 0 && b.frames.count > 0) {
                return -1;
            }
            else if (a.frames.count > 0 && b.frames.count == 0) {
                return 1;
            }
            return 0;
        });
    };
    HangingProtocolHelper.sort_series = function (series) {
        series.sort(function (a, b) {
            if (a.frames.count > 0 && b.frames.count > 0) {
                var aMetadata = a.frames.item(0)['metadata'];
                var bMetadata = b.frames.item(0)['metadata'];
                if (aMetadata && bMetadata) {
                    var aDate = DicomHelper.getDicomTagValue(aMetadata, DicomTag.StudyDate);
                    var bDate = DicomHelper.getDicomTagValue(bMetadata, DicomTag.StudyDate);
                    var aTime = DicomHelper.getDicomTagValue(aMetadata, DicomTag.StudyTime);
                    var bTime = DicomHelper.getDicomTagValue(bMetadata, DicomTag.StudyTime);
                    var acompare = HangingProtocolHelper.combine_datetime(aDate, aTime);
                    var bcompare = HangingProtocolHelper.combine_datetime(bDate, bTime);
                    a['studyDate'] = acompare;
                    b['studyDate'] = bcompare;
                    return bcompare.compareTo(acompare);
                }
            }
            else if (a.frames.count == 0 && b.frames.count > 0) {
                return -1;
            }
            else if (a.frames.count > 0 && b.frames.count == 0) {
                return 1;
            }
            return 0;
        });
    };
    HangingProtocolHelper.combine_datetime = function (date, time) {
        if (date && time) {
            var datetime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds());
            return datetime;
        }
        if (date && !time)
            return date;
        return time;
    };
    HangingProtocolHelper.get_position = function (rect) {
        var position = new Models.FramePosition();
        position.leftTop = new lt.LeadPointD();
        position.leftTop.x = rect.topLeft.x;
        position.leftTop.y = Math.abs(rect.topLeft.y - 1);
        position.rightBottom = new lt.LeadPointD();
        position.rightBottom.x = position.leftTop.x + rect.width;
        position.rightBottom.y = position.leftTop.y - rect.height;
        return position;
    };
    HangingProtocolHelper.get_PrimaryCell = function (viewer, seriesManagerService) {
        var cells = viewer.layout.items.toArray();
        if (cells.length > 1) {
            HangingProtocolHelper.sort_cells(cells);
        }
        return cells[0];
    };
    HangingProtocolHelper.setReferenceLine = function (viewer, hp) {
        if (viewer.showReferenceLine || viewer.showFirstAndLastReferenceLine) {
            var displaySets = hp.DisplaySets;
            var matchedCells = viewer.matchedCells;
            var navigationIndicatorSequence = new Array();
            angular.forEach(matchedCells, function (matchedCell) {
                var navigationIndicator = new Models.NavigationIndicator();
                navigationIndicator.NavigationDisplaySet = null; // Required if there is a one-way interaction.  Our reference line interaction is always two-way. 
                navigationIndicator.ReferenceDisplaySets = new Array();
                angular.forEach(matchedCell, function (oneCell) {
                    var col = oneCell.columnsPosition;
                    var row = oneCell.rowPosition;
                    var d = Utils.findFirst(displaySets, function (item) {
                        return oneCell == item['cell'];
                    });
                    if (d) {
                        navigationIndicator.ReferenceDisplaySets.push(d.DisplaySetNumber);
                    }
                });
                if (navigationIndicator.ReferenceDisplaySets.length > 0) {
                    navigationIndicatorSequence.push(navigationIndicator);
                }
            });
            if (navigationIndicatorSequence.length > 0) {
                hp.NavigationIndicatorSequence = navigationIndicatorSequence;
            }
        }
    };
    HangingProtocolHelper.setSynchronizedScrolling = function (viewer, hp) {
        if (viewer.enableSynchronization) {
            var displaySets = hp.DisplaySets;
            var matchedCells = viewer.matchedCells;
            var synchronizedScrollingSequence = new Array();
            angular.forEach(matchedCells, function (matchedCell) {
                var synchronizedScrolling = new Models.SynchronizedScrolling();
                synchronizedScrolling.DisplaySetScrollingGroup = new Array();
                angular.forEach(matchedCell, function (oneCell) {
                    var col = oneCell.columnsPosition;
                    var row = oneCell.rowPosition;
                    var d = Utils.findFirst(displaySets, function (item) {
                        return oneCell == item['cell'];
                    });
                    if (d) {
                        synchronizedScrolling.DisplaySetScrollingGroup.push(d.DisplaySetNumber);
                    }
                });
                if (synchronizedScrolling.DisplaySetScrollingGroup.length > 0) {
                    synchronizedScrollingSequence.push(synchronizedScrolling);
                }
            });
            if (synchronizedScrollingSequence.length > 0) {
                hp.SynchronizedScrollingSequence = synchronizedScrollingSequence;
            }
        }
    };
    HangingProtocolHelper.GetCellDisplaySet = function (cell, hp) {
        var d = Utils.findFirst(hp.DisplaySets, function (item) {
            return cell == item['cell'];
        });
        return d;
    };
    HangingProtocolHelper.setSynchronizedScrollingMprDerived = function (viewer, hp) {
        var count = viewer.layout.items.count;
        for (var i = 0; i < count; i++) {
            var cell = viewer.layout.items.item(i);
            if (cell.frames.count > 0) {
                if (cell.derivatives.count > 0) {
                    // MPR derived
                    // Create new synchronized scrolling entry
                    if (hp.SynchronizedScrollingSequence == null) {
                        hp.SynchronizedScrollingSequence = new Array();
                    }
                    var synchronizedScrolling = new Models.SynchronizedScrolling();
                    synchronizedScrolling.DisplaySetScrollingGroup = new Array();
                    hp.SynchronizedScrollingSequence.push(synchronizedScrolling);
                    // Add the parent of the MPR group (the cell that is not derived)
                    var displaySetParent = this.GetCellDisplaySet(cell, hp);
                    if (displaySetParent != null) {
                        synchronizedScrolling.DisplaySetScrollingGroup.push(displaySetParent.DisplaySetNumber);
                    }
                    // Add the children of the MPR group (the derived cells)
                    for (var d = 0; d < cell.derivatives.count; d++) {
                        var displaySet = this.GetCellDisplaySet(cell.derivatives.get_item(d), hp);
                        if (displaySet != null) {
                            synchronizedScrolling.DisplaySetScrollingGroup.push(displaySet.DisplaySetNumber);
                        }
                    }
                }
            }
        }
    };
    return HangingProtocolHelper;
}());
var SeriesLayout = /** @class */ (function () {
    function SeriesLayout() {
        this.Boxes = new Array();
        this.TemplateId = "";
    }
    return SeriesLayout;
}());
var StructuredDisplayHelper = /** @class */ (function () {
    function StructuredDisplayHelper() {
    }
    StructuredDisplayHelper.getPosition = function (rect) {
        var position = new Models.FramePosition();
        position.leftTop = new lt.LeadPointD();
        position.leftTop.x = rect.topLeft.x;
        position.leftTop.y = Math.abs(rect.topLeft.y - 1);
        position.rightBottom = new lt.LeadPointD();
        position.rightBottom.x = position.leftTop.x + rect.width;
        position.rightBottom.y = position.leftTop.y - rect.height;
        return position;
    };
    StructuredDisplayHelper.getSeriesLayout = function (cell) {
        var items = cell.imageViewer.items;
        var seriesLayout = new SeriesLayout();
        // var boxes: Array<Models.ImageBox> = new Array<Models.ImageBox>();
        for (var i = 0; i < items.count; i++) {
            var subcell = (items.item(i));
            var box = new Models.ImageBox();
            var viewBounds = cell.imageViewer.convertBoundsToView(subcell.bounds, false);
            box.Position = this.getPosition(subcell.bounds);
            if (subcell.attachedFrame != null) {
                if (angular.isDefined(subcell.attachedFrame.Instance)) {
                    var sopInstanceUID = subcell.attachedFrame.Instance.SOPInstanceUID;
                    box.referencedSOPInstanceUID.push(sopInstanceUID);
                }
            }
            seriesLayout.Boxes.push(box);
        }
        if (seriesLayout.Boxes.length > 0) {
            seriesLayout.TemplateId = "";
            if (angular.isDefined(cell.templateId)) {
                seriesLayout.TemplateId = cell.templateId;
            }
            return seriesLayout;
        }
    };
    return StructuredDisplayHelper;
}());
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Models;
(function (Models) {
    var CodeSequence = /** @class */ (function () {
        function CodeSequence() {
            this.CodeValue = "";
            this.CodeSchemeDesignator = "";
            this.CodingSchemeVersion = "";
            this.CodeMeaning = "";
        }
        CodeSequence.prototype.toString = function () {
            return this.CodeMeaning;
        };
        CodeSequence.prototype.toFullString = function () {
            var sequenceString = '';
            sequenceString += "[" + this.CodeValue + "," + this.CodeSchemeDesignator + "," + this.CodeMeaning;
            if (this.CodingSchemeVersion && this.CodingSchemeVersion.length > 0)
                sequenceString += "," + this.CodingSchemeVersion;
            sequenceString += "]";
            return sequenceString;
        };
        return CodeSequence;
    }());
    Models.CodeSequence = CodeSequence;
    var AnatomicDescription = /** @class */ (function () {
        function AnatomicDescription() {
            this.Name = '';
            this.AnatomicRegionSequence = new CodeSequence();
            this.AnatomicRegionModifierSequence = new CodeSequence();
            this.Laterality = 0;
        }
        return AnatomicDescription;
    }());
    Models.AnatomicDescription = AnatomicDescription;
    var Frame = /** @class */ (function () {
        function Frame(position) {
            this.Position = position;
            this.Id = UUID.genV4().toString();
            this.FrameNumber = -1;
            this.SequenceNumber = -1;
            this.Rotation = FrameRotation.None;
            this.ImageComments = '';
            this.AnatomicDescription = new AnatomicDescription();
            this.Script = '';
            this.Flip = false;
            this.Reverse = false;
            this.Invert = false;
            this.HorizontalJustification = FrameHorizontalJustification.Center;
            this.VerticalJustification = FrameVerticalJustification.Center;
            this.PresentationSizeMode = FramePresentationSizeMode.ScaleToFit;
            this.Magnification = 1.0;
        }
        return Frame;
    }());
    Models.Frame = Frame;
    var Template = /** @class */ (function () {
        function Template(name) {
            this.Id = UUID.genV4().toString();
            this.Name = name;
            this.CreateDate = new Date();
            this.Modality = "";
            this.Comments = "";
            this.AutoMatching = "";
            this.BuiltIn = false;
            this.Hidden = false;
            this.Frames = new Array();
            this.Availability = TemplateAvailability.SeriesAndStudy;
        }
        return Template;
    }());
    Models.Template = Template;
    var FramePosition = /** @class */ (function () {
        function FramePosition(leftTop, rightBottom) {
            this.leftTop = leftTop;
            this.rightBottom = rightBottom;
        }
        return FramePosition;
    }());
    Models.FramePosition = FramePosition;
    var FrameRotation;
    (function (FrameRotation) {
        FrameRotation[FrameRotation["None"] = 0] = "None";
        FrameRotation[FrameRotation["Rotate90"] = 1] = "Rotate90";
        FrameRotation[FrameRotation["Rotate180"] = 2] = "Rotate180";
        FrameRotation[FrameRotation["Rotate270"] = 3] = "Rotate270";
    })(FrameRotation = Models.FrameRotation || (Models.FrameRotation = {}));
    var FrameHorizontalJustification;
    (function (FrameHorizontalJustification) {
        FrameHorizontalJustification[FrameHorizontalJustification["Left"] = 0] = "Left";
        FrameHorizontalJustification[FrameHorizontalJustification["Center"] = 1] = "Center";
        FrameHorizontalJustification[FrameHorizontalJustification["Right"] = 2] = "Right";
    })(FrameHorizontalJustification = Models.FrameHorizontalJustification || (Models.FrameHorizontalJustification = {}));
    var FrameVerticalJustification;
    (function (FrameVerticalJustification) {
        FrameVerticalJustification[FrameVerticalJustification["Top"] = 0] = "Top";
        FrameVerticalJustification[FrameVerticalJustification["Center"] = 1] = "Center";
        FrameVerticalJustification[FrameVerticalJustification["Bottom"] = 2] = "Bottom";
    })(FrameVerticalJustification = Models.FrameVerticalJustification || (Models.FrameVerticalJustification = {}));
    var Laterality;
    (function (Laterality) {
        Laterality[Laterality["Left"] = 0] = "Left";
        Laterality[Laterality["Right"] = 1] = "Right";
        Laterality[Laterality["Both"] = 2] = "Both";
        Laterality[Laterality["Unpaired"] = 3] = "Unpaired";
    })(Laterality = Models.Laterality || (Models.Laterality = {}));
    var FramePresentationSizeMode;
    (function (FramePresentationSizeMode) {
        FramePresentationSizeMode[FramePresentationSizeMode["ScaleToFit"] = 0] = "ScaleToFit";
        FramePresentationSizeMode[FramePresentationSizeMode["TrueSize"] = 1] = "TrueSize";
        FramePresentationSizeMode[FramePresentationSizeMode["Magnify"] = 2] = "Magnify";
    })(FramePresentationSizeMode = Models.FramePresentationSizeMode || (Models.FramePresentationSizeMode = {}));
    var TemplateAvailability;
    (function (TemplateAvailability) {
        TemplateAvailability[TemplateAvailability["None"] = 0] = "None";
        TemplateAvailability[TemplateAvailability["Series"] = 1] = "Series";
        TemplateAvailability[TemplateAvailability["Study"] = 2] = "Study";
        TemplateAvailability[TemplateAvailability["SeriesAndStudy"] = 3] = "SeriesAndStudy";
    })(TemplateAvailability = Models.TemplateAvailability || (Models.TemplateAvailability = {}));
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Modality = /** @class */ (function () {
    function Modality(name, description, classType, saveDescription) {
        this.name = name;
        this.description = description;
        this.classType = classType;
        this.saveDescription = saveDescription;
    }
    return Modality;
}());
var TemplateEditorService = /** @class */ (function () {
    function TemplateEditorService() {
        this._modalities = new Array();
        this.initializeModalities();
    }
    Object.defineProperty(TemplateEditorService.prototype, "automation", {
        get: function () {
            return this._automation;
        },
        set: function (value) {
            this._automation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TemplateEditorService.prototype, "selectedFrames", {
        get: function () {
            return this._selectedFrames;
        },
        set: function (value) {
            this._selectedFrames = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TemplateEditorService.prototype, "templateEditController", {
        get: function () {
            return this._templateController;
        },
        set: function (value) {
            this._templateController = value;
        },
        enumerable: false,
        configurable: true
    });
    TemplateEditorService.prototype.loadTemplates = function () {
        return null;
    };
    TemplateEditorService.prototype.deleteSelectedAnnotations = function () {
        if (this._automation != null && this._automation.canDeleteObjects) {
            this._automation.deleteSelectedObjects();
        }
    };
    TemplateEditorService.prototype.loadBW2 = function () {
        var boxes = new Array();
        boxes.push(new Models.Frame(new Models.FramePosition(lt.LeadPointD.create(0.06, 0.75), lt.LeadPointD.create(0.45, 0.25))));
        boxes.push(new Models.Frame(new Models.FramePosition(lt.LeadPointD.create(0.55, 0.75), lt.LeadPointD.create(0.94, 0.25))));
        return boxes;
    };
    TemplateEditorService.prototype.initializeModalities = function () {
        var length;
        this._modalities.push(new Modality('IO', 'Intra Oral X-Ray', 'DXIntraoralImageStorageProcessing'));
        this._modalities.push(new Modality('SC', 'Secondary Capture', 'SCImageStorage'));
        this._modalities.push(new Modality('VL', 'Endoscopy', 'VLEndoscopicImageStorage', true));
        this._modalities.push(new Modality('VL', 'Microscopy', 'VLMicroscopicImageStorage', true));
        this._modalities.push(new Modality('VL', 'Photography', 'VLPhotographicImageStorage', true));
        this._modalities.push(new Modality('DX', 'Panaromic', 'DXImageStoragePresentation', true));
        this._modalities.push(new Modality('DX', 'Cephalometric', 'DXImageStoragePresentation', true));
        this._modalities.push(new Modality('DX', 'General', 'DXImageStoragePresentation', true));
        this._modalities.push(new Modality('DX', 'Skull', 'DXImageStoragePresentation', true));
        this._modalities.push(new Modality('MG', 'Mammography', 'DXMammographyImageStorageProcessing'));
        this._modalities.push(new Modality('CR', 'Computed Radiography', 'CRImageStorage'));
    };
    TemplateEditorService.prototype.getModalityDescriptions = function () {
        var descriptions = "NONE";
        var length = this._modalities.length;
        for (var i = 0; i < length; i++) {
            descriptions += "|" + this._modalities[i].name + ":" + this._modalities[i].description;
        }
        return descriptions;
    };
    TemplateEditorService.prototype.getModalities = function () {
        return this._modalities;
    };
    return TemplateEditorService;
}());
services.service('templateEditorService', TemplateEditorService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var TemplateService = /** @class */ (function () {
    function TemplateService(config, authenticationService, $http) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._templateServiceUrl = config.urls.serviceUrl + config.urls.templateServiceName;
        this._currentStudyLayout = null;
    }
    Object.defineProperty(TemplateService.prototype, "currentStudyLayoutID", {
        get: function () {
            return this._currentStudyLayoutID;
        },
        set: function (value) {
            this._currentStudyLayoutID = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TemplateService.prototype, "currentStudyLayout", {
        get: function () {
            return this._currentStudyLayout;
        },
        set: function (value) {
            this._currentStudyLayout = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TemplateService.prototype, "currentHangingProtocol", {
        get: function () {
            return this._currentHangingProtocol;
        },
        set: function (value) {
            this._currentHangingProtocol = value;
        },
        enumerable: false,
        configurable: true
    });
    TemplateService.prototype.GetAnatomicDescriptions = function (userData) {
        return this._http.get(this._templateServiceUrl + "/GetAnatomicDescriptions?" + "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&data=" + JSON.stringify(userData));
    };
    TemplateService.prototype.GetAllTemplates = function (userData) {
        return this._http.get(this._templateServiceUrl + "/GetAllTemplates?" + "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&data=" + JSON.stringify(userData) + "&r=" + Date.now());
    };
    TemplateService.prototype.AddTemplate = function (template) {
        var templateCopy = angular.copy(template);
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            template: templateCopy,
            userData: null
        };
        return this._http.post(this._templateServiceUrl + "/AddTemplate", JSON.stringify(data, this.templateReplacer));
    };
    TemplateService.prototype.UpdateTemplate = function (template) {
        var templateCopy = angular.copy(template);
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            template: templateCopy,
            userData: null
        };
        return this._http.post(this._templateServiceUrl + "/UpdateTemplate", JSON.stringify(data, this.templateReplacer));
    };
    TemplateService.prototype.DeleteTemplate = function (templateId) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            templateId: templateId,
            userData: null
        };
        return this._http.post(this._templateServiceUrl + "/DeleteTemplate", JSON.stringify(data, this.templateReplacer));
    };
    TemplateService.prototype.ExportAllTemplates = function () {
        var url = this._templateServiceUrl + "/ExportAllTemplates?" + "auth=" + encodeURIComponent(this._authenticationService.authenticationCode);
        OpenUrl(url, true);
    };
    TemplateService.prototype.ImportTemplates = function (Upload, file) {
        return Upload.upload({
            url: this._templateServiceUrl + "/ImportTemplates",
            file: file,
            fields: {
                'auth': this._authenticationService.authenticationCode
            },
        });
    };
    TemplateService.prototype.templateReplacer = function (key, value) {
        if (key.toLowerCase().indexOf('create') >= 0 || key.toLowerCase().indexOf('date') >= 0) {
            if (typeof value == 'string') {
                var date = new Date(value);
                if (date != 'Invalid Date') {
                    return date.toUTCString();
                }
            }
        }
        if (value instanceof lt.LeadPointD) {
            var x = Utils.roundNumber(value.x, 7);
            var y = Utils.roundNumber(value.y, 7);
            //
            // lt.LeadPointD is serializing as {_x, _y}.  Need to change to {x, y}.
            //
            return { x: x, y: y };
        }
        return value;
    };
    TemplateService.$inject = ['app.config', 'authenticationService', '$http'];
    return TemplateService;
}());
services.service('templateService', TemplateService);
function emptyFunction(e) {
    if (e.type == 'mouseleave')
        e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.0)';
    else
        e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
}
function ShowStudyTimeLine(tab, controller, enable) {
    if (enable == controller.studyTimeLineVisible) {
        return;
    }
    controller.studyTimeLineVisible = enable;
    tab.showStudyTimeLine = enable;
    controller.toggleView('south', true, false);
}
var currentInteractiveIcon = {};
var currentInteractiveMode = {};
var currentIcon = {};
var currentIconPressed = {};
var currentIconDisabled = {};
var currentIconDisabledPressed = {};
var parentDiv;
var testDiv;
function PressButton(toolbarService, tab, commandId, showpressed) {
    if (commandId == "")
        return;
    if (tab) {
        if (currentIcon[tab.id]) {
            if (currentIcon[tab.id].id == commandId)
                return;
        }
    }
    if (commandId != null) {
        if (angular.isUndefined(showpressed) || showpressed) {
            toolbarService.press(commandId);
        }
    }
    var originalId;
    if (currentIcon[tab.id] != null) {
        var enabled = toolbarService.isEnabled(currentIcon[tab.id].id);
        $(currentInteractiveIcon[tab.id]).addClass(enabled ? currentIcon[tab.id].original : currentIconDisabled[tab.id]);
        $(currentInteractiveIcon[tab.id]).removeClass(enabled ? currentIconPressed[tab.id] : currentIconDisabledPressed[tab.id]);
    }
    currentIcon[tab.id] = {};
    originalId = $("#" + commandId + "_icon").attr('original-id');
    currentInteractiveIcon[tab.id] = "#" + commandId + "_icon";
    currentIcon[tab.id].id = commandId;
    currentIcon[tab.id].original = originalId;
    currentIconPressed[tab.id] = originalId + "Pressed";
    currentIconDisabled[tab.id] = "Disabled" + originalId;
    currentIconDisabledPressed[tab.id] = "Disabled" + originalId + "Pressed";
}
function showCustomWindowlevelDialog(toolbarService, seriesManagerService, tab, model) {
    if (toolbarService.isEnabled("WindowLevel" + tab.id)) {
        var modalInstance = null;
        var settings = {};
        var cell = seriesManagerService.get_activeCell();
        var width;
        var center;
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            var cell3D = cell;
            settings.width = cell3D.information.windowWidth;
            settings.center = cell3D.information.windowCenter;
            settings.originalWindowLevelCenter = cell3D.defaultWindowLevelCenter;
            settings.originalWindowLevelWidth = cell3D.defaultWindowLevelWidth;
        }
        else {
            var frame = seriesManagerService.get_activeCellFrame();
            var renderer = frame.get_wlRenderer();
            if (renderer) {
                settings.width = renderer.get_windowLevelWidth();
                settings.center = renderer.get_windowLevelCenter();
                settings.originalWindowLevelCenter = renderer.originalWindowLevelCenter;
                settings.originalWindowLevelWidth = renderer.originalWindowLevelWidth;
            }
            else
                return;
        }
        modalInstance = model.open({
            templateUrl: 'views/dialogs/WindowLevelCustom.html',
            controller: Controllers.WindowLevelCustomController,
            backdrop: false,
            resolve: {
                settings: function () {
                    return settings;
                },
                currentFrame: function () {
                    return frame;
                },
                seriesService: function () {
                    return seriesManagerService;
                }
            }
        });
        if (modalInstance == null)
            return;
        modalInstance.result.then(function (wlSettings) {
            if (cell instanceof lt.Controls.Medical.Cell3D) {
                var cell3D = cell;
                cell3D.information.windowWidth = wlSettings.width;
                cell3D.information.windowCenter = wlSettings.center;
                cell3D.updateWindowLevelValues();
            }
            else {
                var linked = cell.get_linked();
                if (linked) {
                    seriesManagerService.enumerateFrames(cell, function (frame, index) {
                        if (seriesManagerService.withinVisibleRange(cell, index)) {
                            frame.setWindowLevel(wlSettings.width, wlSettings.center);
                        }
                    });
                }
                else {
                    frame.setWindowLevel(wlSettings.width, wlSettings.center);
                }
            }
            //toolbarService.unpress("Perio" + tab.id);
            //toolbarService.unpress("Endo" + tab.id);
            //toolbarService.unpress("Dentin" + tab.id);
        });
    }
}
function HideTab_And_ShiftToolbarButtons() {
    // to remove the tab from the demo.
    var tabView = document.getElementById('ltTabWrapper');
    var navTab = tabView.getElementsByClassName('nav nav-tabs')[0];
    /*navTab.style.left = "10000px";
    navTab.style.width = "0px";
    navTab.style.position = "absolute";*/
    // to scroll the toolbar buttons the left to make room for the MiPACS logo.
    var scrollBarArray = tabView.getElementsByClassName('toolbarbodyArea');
    var scrollBar = scrollBarArray[scrollBarArray.length - 1];
    // the scroll ammount
    var width = (lt.LTHelper.device == lt.LTDevice.mobile) ? 56 : 128;
    var height = (lt.LTHelper.device == lt.LTDevice.mobile) ? 26 : 53;
    var marginTop = (lt.LTHelper.device == lt.LTDevice.mobile) ? 8 : 16;
    var scrollBarParent = scrollBar.parentNode;
    var imageBackground = document.createElement("div");
    imageBackground.className = "appLogo scroll-body";
    imageBackground.style.width = width + "px";
    imageBackground.style.height = "100%";
    imageBackground.style.zIndex = "300";
    imageBackground.style.position = "absolute";
    var image = document.createElement("img");
    image.style.left = "0px";
    image.style.top = "0px";
    image.style.width = width + "px";
    image.style.height = height + "px";
    image.style.position = "absolute";
    image.style.marginTop = marginTop + "px";
    image.style.zIndex = "300";
    image.src = ("images/mipacs2.png");
    var toolbarItem = scrollBarParent.children[0];
    toolbarItem.style.left = width + "px";
    scrollBarParent.insertBefore(imageBackground, toolbarItem);
    scrollBarParent.insertBefore(image, toolbarItem);
}
function ChangeScrollType(cell) {
    var oldScrollType = cell.scrollType;
    var newScrollType = oldScrollType;
    switch (cell.scrollType) {
        case lt.Controls.Medical.ScrollType.none:
            newScrollType = lt.Controls.Medical.ScrollType.normal;
            alert("ScrollType.normal");
            break;
        case lt.Controls.Medical.ScrollType.normal:
            newScrollType = lt.Controls.Medical.ScrollType.row;
            alert("ScrollType.row");
            break;
        case lt.Controls.Medical.ScrollType.row:
            newScrollType = lt.Controls.Medical.ScrollType.column;
            alert("ScrollType.column");
            break;
        case lt.Controls.Medical.ScrollType.column:
            newScrollType = lt.Controls.Medical.ScrollType.page;
            alert("ScrollType.page");
            break;
        case lt.Controls.Medical.ScrollType.page:
            newScrollType = lt.Controls.Medical.ScrollType.none;
            alert("ScrollType.none");
            break;
    }
    cell.scrollType = newScrollType;
}
function GetImageProcessingIndex(cellFrame, commandName) {
    var index = 0;
    var length = cellFrame.imageProcessingList.count;
    for (index = 0; index < length; index++) {
        if (cellFrame.imageProcessingList.get_item(index).get_command() == commandName) {
            return index;
        }
    }
    return -1;
}
function ChangeStructureDisplay(e) {
}
function edgeEnhancment(e) {
    var index = e.currentTarget.getAttribute("itemIndex");
    var cellFrame = e.currentTarget.cellFrame;
    var cell = e.currentTarget.cell;
    var ipIndex = GetImageProcessingIndex(cellFrame, "Endo");
    var ip = new lt.ImageProcessing();
    ip.set_jsFilePath("");
    ip.set_command("Endo");
    ip.get_arguments()["UnsharpMask"] = (index * 50).toString() + "," + (30 + (index * 5)).toString() + ",0";
    if (ipIndex == -1)
        cellFrame.imageProcessingList.add(ip);
    else
        cellFrame.imageProcessingList.set_item(parseInt(ipIndex.toString()), ip);
}
function functionClick(e) {
    var index = e.currentTarget.getAttribute("itemIndex");
    var cellFrame = e.currentTarget.cellFrame;
    var cell = e.currentTarget.cell; //parentCell;
    var seriesManagerService = e.currentTarget.seriesManagerService;
    var model = e.currentTarget.model;
    var toolbarService = e.currentTarget.toolbarService;
    var tab = e.currentTarget.tab;
    var info = e.currentTarget.sortInfo;
    var item = e.currentTarget.item;
    if (info == null) {
        showCustomWindowlevelDialog(toolbarService, seriesManagerService, tab, model);
    }
    else {
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            var cell3D = cell;
            cell3D.information.windowWidth = info.W;
            cell3D.information.windowCenter = info.C;
            cell3D.updateWindowLevelValues();
        }
        else {
            if (cell.linked) {
                seriesManagerService.enumerateFrames(cell, function (frame, index) {
                    frame.setWindowLevel(info.W, info.C);
                    frame.currentCustomWindowlevel = item;
                });
            }
            else {
                cellFrame.setWindowLevel(info.W, info.C);
                cellFrame.currentCustomWindowlevel = item;
            }
        }
    }
}
function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function (letter, index) {
        return index != 0 ? letter.toLowerCase() : letter.toUpperCase();
    });
}
function getWidthAndCenter(metadata, index) {
    var width;
    var center;
    var windowWidthTag = metadata[DicomTag.WindowWidth];
    var windowCenterTag = metadata[DicomTag.WindowCenter];
    if (windowWidthTag == null)
        windowWidthTag = this.findTag(metadata, DicomTag.WindowWidth);
    if (null != windowWidthTag && windowWidthTag.Value && windowWidthTag.Value.length > index) {
        width = windowWidthTag.Value[index] >> 0;
    }
    else {
        return null;
    }
    if (windowCenterTag == null)
        windowCenterTag = this.findTag(metadata, DicomTag.WindowCenter);
    if (null != windowCenterTag && windowCenterTag.Value && windowCenterTag.Value.length > 0) {
        center = windowCenterTag.Value[0] >> 0;
    }
    else {
        return null;
    }
    return { W: width, C: center };
}
function isFullscreen() {
    return document.fullscreenElement
        || document.webkitFullscreenElement
        || document.mozFullScreenElement
        || document.webkitCurrentFullScreenElement;
}
var keyDownAdded = false;
//commangular.command('EnableKey', ['seriesManagerService', 'tabService', 'dicomLoaderService', '$commangular', function (seriesManagerService: SeriesManagerService, tabService: TabService, dicomLoaderService: DicomLoaderService, $commangular) {
//    return {
//        execute: function () {
//            window.addEventListener('keydown', function (e) {
//                keyDownAdded = true;
//                if (e.keyCode == 13) {
//                    $commangular.dispatch('ToggleFullScreen');
//                }
//            }, false);
//        }
//    }
//}]);
commangular.command('Pan', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Offset, buttonId);
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.Offset, buttonId);
                    //cell.runCommand(MedicalViewerAction.Offset);
                    //cell.runCommand(MedicalViewerAction.Offset2);
                });
            }
        };
    }]);
commangular.command('ZoomToInteractiveMode', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Scale, buttonId);
                enumerateCell(tabService, function (cell) {
                    //cell.stopCommand(MedicalViewerAction.Offset2);
                    CommandManager.RunCommand(cell, MedicalViewerAction.Scale, buttonId);
                });
            }
        };
    }]);
commangular.command('InteractiveMagnifyGlass', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Magnify, buttonId);
                enumerateCell(tabService, function (cell) {
                    //cell.stopCommand(MedicalViewerAction.Offset2);
                    //cell.runCommand(MedicalViewerAction.Magnify);
                    CommandManager.RunCommand(cell, MedicalViewerAction.Magnify, buttonId);
                });
            }
        };
    }]);
commangular.command('InteractiveStack', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Stack, buttonId);
                enumerateCell(tabService, function (cell) {
                    //cell.stopCommand(MedicalViewerAction.Offset2);
                    //cell.runCommand(MedicalViewerAction.Stack);
                    CommandManager.RunCommand(cell, MedicalViewerAction.Stack, buttonId);
                });
            }
        };
    }]);
commangular.command('WindowLevelInteractiveMode', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (toolbarService.isEnabled("WindowLevel" + tab.id)) {
                    SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.WindowLevel, buttonId);
                    enumerateCell(tabService, function (cell) {
                        //cell.stopCommand(MedicalViewerAction.Offset2);
                        //cell.runCommand(MedicalViewerAction.WindowLevel);
                        CommandManager.RunCommand(cell, MedicalViewerAction.WindowLevel, buttonId);
                        if (cell.getCommandInteractiveMode != null) {
                            var command = cell.getCommandInteractiveMode(MedicalViewerAction.WindowLevel);
                            if (command != null) {
                                var started = function (e) {
                                    //toolbarService.unpress("Perio" + tab.id);
                                    //toolbarService.unpress("Endo" + tab.id);
                                    //toolbarService.unpress("Dentin" + tab.id);
                                };
                                command.add_workStarted(started);
                            }
                        }
                    });
                }
            }
        };
    }]);
function GetPresetWindowLevelValuesArray() {
    var wlArray = new Array();
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.Lung, Text: camelize('LUNG'), Info: { W: 1500, C: -600 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.Mediastinum, Text: camelize('MEDIASTINUM'), Info: { W: 640, C: 95 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.AbdoPelvis, Text: camelize('ABDO PELVIS'), Info: { W: 400, C: 40 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.Liver, Text: camelize('LIVER'), Info: { W: 160, C: 70 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.SoftTissue, Text: camelize('SOFT TISSUE'), Info: { W: 400, C: 40 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.Bone, Text: camelize('BONE'), Info: { W: 1500, C: 150 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.Brain, Text: camelize('BRAIN'), Info: { W: 150, C: 40 } });
    wlArray.push({ VR: "CT", VoiType: Models.VoiType.PostFossa, Text: camelize('POST FOSSA'), Info: { W: 250, C: 45 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.BrainT1, Text: camelize('Brain T1'), Info: { W: 500, C: 250 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.BrainT2, Text: camelize('Brain T2'), Info: { W: 350, C: 150 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.SagT2, Text: camelize('Sag T2'), Info: { W: 300, C: 150 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.HeadNeck, Text: camelize('Head / Neck'), Info: { W: 500, C: 250 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.Spine, Text: camelize('Spine'), Info: { W: 500, C: 250 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.AbdomenPelvisT1, Text: camelize('Abdomen / Pelvis T1'), Info: { W: 600, C: 180 } });
    wlArray.push({ VR: "MR", VoiType: Models.VoiType.AbdomenPelvisT2, Text: camelize('Abdomen/ Pelvis T2'), Info: { W: 850, C: 150 } });
    wlArray.push({ VR: "US", VoiType: Models.VoiType.LowContrast, Text: camelize('Low Contrast'), Info: { W: 190, C: 80 } });
    wlArray.push({ VR: "US", VoiType: Models.VoiType.MediumContrast, Text: camelize('Medium Contrast'), Info: { W: 160, C: 70 } });
    wlArray.push({ VR: "US", VoiType: Models.VoiType.HighContrast, Text: camelize('High Contrast'), Info: { W: 120, C: 60 } });
    return wlArray;
}
;
function AddOtherPresetWindowLevelValues(modality, items) {
    var wlArray = GetPresetWindowLevelValuesArray();
    for (var i = 0; i < wlArray.length; i++) {
        var item = wlArray[i];
        if (item["VR"] == modality)
            items.add(item);
    }
}
function FindPresetWindowLevelValue(voiType) {
    var wlArray = GetPresetWindowLevelValuesArray();
    for (var i = 0; i < wlArray.length; i++) {
        var item = wlArray[i];
        if (item["VoiType"] == voiType)
            return item;
    }
    return null;
}
//function AddOtherPresetWindowLevelValues(modality, items) {
//    var wlArray: Array<Object> = GetPresetWindowLevelValuesArray();
//    switch (modality) {
//        case 'CT':
//            items.add({ VoiType: Models.VoiType.Lung, Text: camelize('LUNG'), Info: { W: 1500, C: -600 } });
//            items.add({ VoiType: Models.VoiType.Mediastinum, Text: camelize('MEDIASTINUM'), Info: { W: 640, C: 95 } });
//            items.add({ VoiType: Models.VoiType.AbdoPelvis, Text: camelize('ABDO PELVIS'), Info: { W: 400, C: 40 } });
//            items.add({ VoiType: Models.VoiType.Liver, Text: camelize('LIVER'), Info: { W: 160, C: 70 } });
//            items.add({ VoiType: Models.VoiType.SoftTissue, Text: camelize('SOFT TISSUE'), Info: { W: 400, C: 40 } });
//            items.add({ VoiType: Models.VoiType.Bone, Text: camelize('BONE'), Info: { W: 1500, C: 150 } });
//            items.add({ VoiType: Models.VoiType.Brain, Text: camelize('BRAIN'), Info: { W: 150, C: 40 } });
//            items.add({ VoiType: Models.VoiType.PostFossa, Text: camelize('POST FOSSA'), Info: { W: 250, C: 45 } });
//            break;
//        case 'MR':
//            items.add({ VoiType: Models.VoiType.BrainT1, Text: camelize('Brain T1'), Info: { W: 500, C: 250 } });
//            items.add({ VoiType: Models.VoiType.BrainT2, Text: camelize('Brain T2'), Info: { W: 350, C: 150 } });
//            items.add({ VoiType: Models.VoiType.SagT2, Text: camelize('Sag T2'), Info: { W: 300, C: 150 } });
//            items.add({ VoiType: Models.VoiType.HeadNeck, Text: camelize('Head / Neck'), Info: { W: 500, C: 250 } });
//            items.add({ VoiType: Models.VoiType.Spine, Text: camelize('Spine'), Info: { W: 500, C: 250 } });
//            items.add({ VoiType: Models.VoiType.AbdomenPelvisT1, Text: camelize('Abdomen / Pelvis T1'), Info: { W: 600, C: 180 } });
//            items.add({ VoiType: Models.VoiType.AbdomenPelvisT2, Text: camelize('Abdomen/ Pelvis T2'), Info: { W: 850, C: 150 } });
//            break;
//        case 'US':
//            items.add({ VoiType: Models.VoiType.LowContrast, Text: camelize('Low Contrast'), Info: { W: 190, C: 80 } });
//            items.add({ VoiType: Models.VoiType.MediumContrast, Text: camelize('Medium Contrast'), Info: { W: 160, C: 70 } });
//            items.add({ VoiType: Models.VoiType.HighContrast, Text: camelize('High Contrast'), Info: { W: 120, C: 60 } });
//            break;
//    }
//}
commangular.command('OnEdgeEnhancment', ['toolbarService', 'tabService', 'buttonId', '$modal', 'seriesManagerService', function (toolbarService, tabService, buttonId, $modal, seriesManagerService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame = seriesManagerService.get_activeCellFrame();
                var metadata = cellFrame.metadata;
                var index = 0;
                var items = [];
                items.add({ Text: " No Effect", Info: 0 });
                for (index = 1; index < 11; index++) {
                    items.add({ Text: " Sharpen ( " + (index).toString() + " )", Info: 0 });
                }
                // get the icon.
                var id = 'EdgeEnhancment' + tab.id;
                var icon = document.getElementById(id);
                // show the menu.
                ShowMenu(items, icon, edgeEnhancment, cellFrame, toolbarService, tabService, seriesManagerService, $modal, tab, -1);
            }
        };
    }]);
commangular.command('WindowLevelCustom', ['toolbarService', 'tabService', 'buttonId', '$modal', 'seriesManagerService', function (toolbarService, tabService, buttonId, $modal, seriesManagerService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame;
                var defaultWW;
                var defaultWC;
                var metadata;
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    var cell3D = cell;
                    metadata = cell3D.JSON;
                    defaultWW = cell3D.defaultWindowLevelWidth;
                    defaultWC = cell3D.defaultWindowLevelCenter;
                }
                else {
                    cellFrame = seriesManagerService.get_activeCellFrame();
                    metadata = cellFrame.metadata;
                    defaultWW = cellFrame.defaultWindowLevelWidth;
                    defaultWC = cellFrame.defaultWindowLevelCenter;
                }
                var items = [];
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    var widthCenter3D = { W: cell.bone.width, C: cell.bone.center };
                    items.add({ Text: "Bone", Info: widthCenter3D });
                }
                else {
                    var explantationTag = metadata[DicomTag.WindowCenterWidthExplanation];
                    var modality = metadata[DicomTag.Modality].Value[0];
                    // get the menu item text
                    var explantationTag = metadata[DicomTag.WindowCenterWidthExplanation];
                    var presetValueInDataSet = ((explantationTag != null) && (explantationTag.Value.length > 0));
                    if (presetValueInDataSet) {
                        var length = explantationTag.Value.length;
                        var index = 0;
                        for (index = 0; index < length; index++) {
                            var widthCenter = getWidthAndCenter(cellFrame.metadata, index);
                            items.add({ Text: camelize(explantationTag.Value[index]), Info: widthCenter });
                        }
                    }
                    // adding the modality specific preset window level value.
                    AddOtherPresetWindowLevelValues(modality, items);
                }
                var customItem = { VoiType: Models.VoiType.Undefined, Text: "Custom", Info: null };
                // no preset window level value, so just show the custom window level dialog.
                if (items.length == 0) {
                    showCustomWindowlevelDialog(toolbarService, seriesManagerService, tab, $modal);
                    cellFrame.currentCustomWindowlevel = customItem;
                    return;
                }
                // adding default one, to revert to the original window level value.
                if (!presetValueInDataSet) {
                    items.insert(0, { Text: "Auto", Info: { W: defaultWW, C: defaultWC } });
                }
                // custom to show the custom window level dialog.
                items.add(customItem);
                // get the icon.
                var id = 'WindowLevelCustom' + tab.id;
                var icon = document.getElementById(id);
                // show the menu.
                ShowMenu(items, icon, functionClick, cellFrame, toolbarService, tabService, seriesManagerService, $modal, tab, -1);
            }
        };
    }]);
commangular.command('FitImage', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.set_offsetX(0);
                            frame.set_offsetY(0);
                            frame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.fit, 1);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.set_offsetX(0);
                        cellFrame.set_offsetY(0);
                        cellFrame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.fit, 1);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('OnStructureDisplay', ['toolbarService', 'tabService', 'buttonId', '$modal', 'seriesManagerService', function (toolbarService, tabService, buttonId, $modal, seriesManagerService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame = seriesManagerService.get_activeCellFrame();
                var metadata = cellFrame.metadata;
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var structuredDisplay = seriesManagerService.structuredDisplayList;
                var index = 0;
                var length = structuredDisplay.length;
                var items = [];
                for (index = 0; index < length; index++) {
                    items.add({ Text: structuredDisplay[index].Name, Info: structuredDisplay[index] });
                }
                // get the icon.
                var id = 'StructureDisplay' + tab.id;
                var icon = document.getElementById(id);
                // show the menu.
                ShowMenu(items, icon, ChangeStructureDisplay, cellFrame, toolbarService, tabService, seriesManagerService, $modal, tab, -1);
            }
        };
    }]);
commangular.command('OneToOne', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.actualSize, 1);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.actualSize, 1);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
function getSortingOperation(sortType, dicomTag) {
    var sortingOp = new lt.Controls.Medical.SortingOperation();
    sortingOp.sortByCategory = sortType;
    sortingOp.selectorAttribute = parseInt(dicomTag, 16);
    return sortingOp;
}
commangular.command('TrueSizeDisplay', ['seriesManagerService', 'tabService', 'toolbarService', '$modal', function (seriesManagerService, tabService, toolbarService, $modal) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame = seriesManagerService.get_activeCellFrame();
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.set_offsetX(0);
                            frame.set_offsetY(0);
                            frame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.trueSize, 1);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.set_offsetX(0);
                        cellFrame.set_offsetY(0);
                        cellFrame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.trueSize, 1);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('ZoomIn', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.zoom(frame.get_scaleMode(), frame.get_scale() * 2);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.zoom(cellFrame.get_scaleMode(), cellFrame.get_scale() * 2);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('ZoomOut', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.zoom(frame.get_scaleMode(), frame.get_scale() / 2);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.zoom(cellFrame.get_scaleMode(), cellFrame.get_scale() / 2);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('RotateClockwise', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            var angle = GetRealRotationAngle(90, frame);
                            frame.set_rotateAngle(frame.get_rotateAngle() + angle);
                            frame.IPFunctionParams.Rotate.Angle = frame.get_rotateAngle();
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        var angle = GetRealRotationAngle(90, cellFrame);
                        cellFrame.set_rotateAngle(cellFrame.get_rotateAngle() + angle);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('RotateCounterclockwise', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            var angle = GetRealRotationAngle(-90, frame);
                            frame.set_rotateAngle(frame.get_rotateAngle() + angle);
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        var angle = GetRealRotationAngle(-90, cellFrame);
                        cellFrame.set_rotateAngle(cellFrame.get_rotateAngle() + angle);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('Flip', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.set_flipped(!frame.get_flipped());
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.set_flipped(!cellFrame.get_flipped());
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('Reverse', ['seriesManagerService', 'tabService', function (seriesManagerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.set_reversed(!frame.get_reversed());
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.set_reversed(!cellFrame.get_reversed());
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('DentalPanoramic', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                cell.runCommand(MedicalViewerAction.PanoramicPolygon);
                var panoramicAction = cell.getCommand(MedicalViewerAction.PanoramicPolygon);
                function panoramicGenerated(sender, args) {
                    panoramicAction.remove_panoramicGenerated(panoramicGenerated);
                    MakeRoomFor(cell.viewer, 1);
                    var polygon = sender;
                    var derivative = new lt.Controls.Medical.PanoramicCell(cell.viewer, cell, cell.divID);
                    derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                    derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                    polygon.panoramicCell = derivative;
                    function derivativeDisposed() {
                        polygon.dispose();
                        cell.invalidate(lt.LeadRectD.empty);
                        derivative.remove_disposing(derivativeDisposed);
                    }
                    derivative.add_disposing(derivativeDisposed);
                    var engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                    SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.WindowLevel, buttonId);
                    enumerateCell(tabService, function (currentCell) {
                        CommandManager.RunCommand(currentCell, MedicalViewerAction.WindowLevel, "");
                    });
                    if (engine) {
                        engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                    }
                }
                panoramicAction.add_panoramicGenerated(panoramicGenerated);
            }
        };
    }]);
commangular.command('Invert', ['seriesManagerService', 'tabService', 'dicomLoaderService', function (seriesManagerService, tabService, dicomLoaderService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    var cell3D = cell;
                    cell3D.inverted = !cell3D.inverted;
                    //cell3D.benchmark();
                }
                else if (cell != null) {
                    var loader = seriesManagerService.get_seriesLoaderById(cell);
                    var linked = cell.get_linked();
                    cell.get_imageViewer().beginUpdate();
                    if (linked) {
                        var seriesInstanceUID = cell.get_seriesInstanceUID();
                        var instances = seriesManagerService.get_instances(seriesInstanceUID, cell.get_divID());
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            try {
                                var inverted = !frame.inverted;
                                frame.set_inverted(inverted);
                            }
                            catch (exception) { }
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        var inverted = !cellFrame.inverted;
                        cellFrame.set_inverted(inverted);
                    }
                    cell.get_imageViewer().endUpdate();
                }
            }
        };
    }]);
commangular.command('ShowDicom', ['seriesManagerService', '$modal', function (seriesManagerService, $modal) {
        return {
            execute: function () {
                var cellFrame = null;
                var cell = seriesManagerService.get_activeCell();
                var derivedText;
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    var cell3D = cell;
                    cell = cell3D.referenceCell;
                    cellFrame = seriesManagerService.get_activeItemForCell(cell).attachedFrame;
                }
                else {
                    cellFrame = seriesManagerService.get_activeViewer().attachedFrame;
                }
                if (cellFrame != null) {
                    var modalInstance = $modal.open({
                        templateUrl: (lt.LTHelper.device == lt.LTDevice.mobile) ? 'views/dialogs/ViewDicom_Mobile.html' : 'views/dialogs/ViewDicom.html',
                        controller: Controllers.ViewDicomController,
                        backdrop: 'static',
                        resolve: {
                            dicom: function () {
                                return cellFrame.metadata;
                            },
                            frame: function () {
                                return cellFrame;
                            }
                        }
                    });
                }
            }
        };
    }]);
commangular.command('SetLinked', ['seriesManagerService', 'tabService', 'toolbarService', 'optionsService', function (seriesManagerService, tabService, toolbarService, optionsService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var cell = seriesManagerService.get_activeCell();
                    if (cell != null) {
                        var linked = !cell.get_linked();
                        tabService.set_tabData(tab.id, TabDataKeys.Linked, linked);
                        cell.set_linked(linked);
                        toolbarService.updateClass('LinkImages' + tab.id, 'Linked', 'UnLinked', function () { return linked; });
                    }
                }
            }
        };
    }]);
commangular.command('OnReload', ['seriesManagerService', 'dicomLoaderService', 'toolbarService', 'tabService', 'optionsService', function (seriesManagerService, dicomLoaderService, toolbarService, tabService, optionsService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell != null) {
                    var loader = seriesManagerService.get_seriesLoaderById(cell);
                    var instances = seriesManagerService.get_instances(cell.get_seriesInstanceUID(), cell.get_divID());
                    //cell.progress = null;
                    seriesManagerService.enumerateFrames(cell, function (frame, index) {
                        frame.reset();
                        Utils.clearAllShutter(frame, optionsService.get(OptionNames.AnnotationStrokeColor));
                        frame.set_offsetX(0);
                        frame.set_offsetY(0);
                        if (frame.subCell != null)
                            Utils.subCell_setPresentationMode(frame.subCell);
                        frame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.middle;
                        frame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.middle;
                        if (frame.imageProcessingList.count != 0) {
                            frame.imageProcessingList.clear();
                            toolbarService.checkDentalEffects(cell.viewer, cell, tab.id);
                        }
                    }, function (cell3D) {
                        cell3D.reset();
                    });
                }
            }
        };
    }]);
commangular.command('OnToggleTags', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var visible = !tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
                    enumerateCell(tabService, function (cell) {
                        cell.set_overlayTextVisible(visible);
                        cell.onSizeChanged();
                        cell.invalidate(lt.LeadRectD.empty);
                    });
                    tabService.set_tabData(tab.id, TabDataKeys.TagToggle, visible);
                }
            }
        };
    }]);
commangular.command('ScrollFrame', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var visible = !tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
                    enumerateCell(tabService, function (cell) {
                        cell.scrollType = lt.Controls.Medical.ScrollType.normal;
                    });
                    tabService.set_tabData(tab.id, TabDataKeys.TagToggle, visible);
                }
            }
        };
    }]);
commangular.command('ScrollRow', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var visible = !tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
                    enumerateCell(tabService, function (cell) {
                        cell.scrollType = lt.Controls.Medical.ScrollType.row;
                    });
                    tabService.set_tabData(tab.id, TabDataKeys.TagToggle, visible);
                }
            }
        };
    }]);
commangular.command('ScrollColumn', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var visible = !tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
                    enumerateCell(tabService, function (cell) {
                        cell.scrollType = lt.Controls.Medical.ScrollType.column;
                    });
                    tabService.set_tabData(tab.id, TabDataKeys.TagToggle, visible);
                }
            }
        };
    }]);
var pointCounter = 0;
commangular.command('PreviousPoint', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    pointCounter--;
                    if (pointCounter <= 0)
                        pointCounter = 0;
                    enumerateCell(tabService, function (cell) {
                        cell.invalidate(lt.LeadRectD.empty);
                    });
                }
            }
        };
    }]);
commangular.command('NextPoint', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    pointCounter++;
                    enumerateCell(tabService, function (cell) {
                        cell.invalidate(lt.LeadRectD.empty);
                    });
                }
            }
        };
    }]);
commangular.command('ScrollPage', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var visible = !tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
                    enumerateCell(tabService, function (cell) {
                        cell.scrollType = lt.Controls.Medical.ScrollType.page;
                    });
                    tabService.set_tabData(tab.id, TabDataKeys.TagToggle, visible);
                }
            }
        };
    }]);
commangular.command('SetEnableSeriesSynchronization', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                var viewer = tabService.getActiveViewer();
                if (viewer) {
                    var synchronization = !viewer.get_enableSynchronization();
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    viewer.set_enableSynchronization(synchronization);
                    toolbarService.updateClass('SynchronizeSeries' + tab.id, 'EnabledSynchronization', 'Synchronization', function () { return synchronization; });
                }
            }
        };
    }]);
var LinkedOn = false;
function markCell(sender, e) {
    var cell = sender.parentCell;
    if (Studies[cell.studyInstanceUID]) {
        var index = 0;
        var length = Studies[cell.studyInstanceUID].PointsList.length;
        var point;
        for (index = 0; index < length; index++) {
            var frame = Studies[cell.studyInstanceUID].PointsList[index].Frame;
            if (frame.subCell == null)
                continue;
            if (frame.subCell.parentCell != cell)
                continue;
            point = lt.Controls.Medical.Tools.logicalToPhysical(cell.selectedItem, Studies[cell.studyInstanceUID].PointsList[index].Point);
            //if (cell.selectedItem.attachedFrame != frame)
            //    return;
            if (!point)
                return;
            e.context.save();
            e.context.beginPath();
            e.context.strokeStyle = "blue";
            e.context.fillStyle = "blue";
            e.context.rect(point.x - 20, point.y - 20, 40, 40);
            e.context.font = "20px Arial";
            e.context.textAlign = "center";
            e.context.textBaseline = "middle";
            e.context.fillText(index.toString(), point.x, point.y);
            e.context.stroke();
            e.context.restore();
        }
    }
}
function markCellClicked(sender, e) {
    if (e.mouseButton == lt.Controls.MouseButtons.left) {
        var cell = sender;
        AddFidutialPoint(cell, e.position.x, e.position.y);
        //if ((<any>cell).markedPoint == null)
        //    (<any>cell).markedPoint = [];
        //(<any>cell).markedPoint[pointCounter] = { Point: lt.Controls.Medical.Tools.physicalToLogical(cell.selectedItem, lt.LeadPointD.create(e.position.x, e.position.y)), Frame: cell.selectedItem.attachedFrame };
        cell.invalidate(lt.LeadRectD.empty);
    }
}
var Studies = [];
function AddFidutialPoint(cell, x, y) {
    var frame = cell.selectedItem.attachedFrame;
    //var imagePosition = frame.imagePosition;
    //var convertedPoint: number[] = lt.Controls.Medical.Cursor3D.get3DPointPosition(frame, lt.LeadPointD.create(x, y) );
    //var pointPosition = lt.Controls.Medical.LeadPoint3D.create(convertedPoint[0], convertedPoint[1], convertedPoint[2])
    if (!Studies[cell.studyInstanceUID]) {
        Studies[cell.studyInstanceUID] = {};
    }
    if (Studies[cell.studyInstanceUID].PointsList == null)
        Studies[cell.studyInstanceUID].PointsList = [];
    var point = lt.Controls.Medical.Tools.physicalToLogical(cell.selectedItem, lt.LeadPointD.create(x, y));
    var previousPoint = Studies[cell.studyInstanceUID].PointsList[pointCounter];
    Studies[cell.studyInstanceUID].PointsList[pointCounter] = { Frame: frame, Point: point };
    if (previousPoint != null)
        previousPoint.Frame.subCell.parentCell.invalidate();
}
commangular.command('SpatialRegsiteration', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                var cells = [];
                var points = [];
                var points1 = [];
                var points2 = [];
                var cells1 = [];
                enumerateCell(tabService, function (cell) {
                    if (!LinkedOn) {
                        cell.add_postRender(markCell);
                        cell.add_mouseDown(markCellClicked);
                    }
                    else {
                        cell.remove_postRender(markCell);
                        cell.remove_cellClicked(markCellClicked);
                        cell.invalidate(lt.LeadRectD.empty);
                    }
                });
                if (LinkedOn) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                    var medicalViewer = controller.getViewer();
                    for (var itemID in Studies) {
                        if (Studies.hasOwnProperty(itemID)) {
                            var item = Studies[itemID];
                            var index = 0;
                            var length = item.PointsList.length;
                            var convertedPoint = [];
                            var output;
                            for (index = 0; index < length; index++) {
                                output = lt.Controls.Medical.Cursor3DInteractiveMode.get3DPointPosition(item.PointsList[index].Frame, item.PointsList[index].Point);
                                convertedPoint[index] = lt.Controls.Medical.LeadPoint3D.create(output[0], output[1], output[2]);
                            }
                            cells.add(itemID);
                            points.add(convertedPoint);
                        }
                    }
                    medicalViewer.synchronizeStudies("test", cells, points);
                }
                LinkedOn = !LinkedOn;
            }
        };
    }]);
commangular.command('LinkCells', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                var cells = [];
                var points = [];
                var studies = [];
                enumerateCell(tabService, function (cell) {
                    if (cell.tickBoxes.length > 0) {
                        if (cell.tickBoxes[0].checked) {
                            var frame = cell.selectedItem.attachedFrame;
                            var position = frame.imagePosition;
                            studies.add(cell.studyInstanceUID);
                            // Here, we are adding only one point, for the crude stack synchronization.
                            var fedutialPoints = [];
                            fedutialPoints[0] = lt.Controls.Medical.LeadPoint3D.create(position[0], position[1], position[2]);
                            points.add(fedutialPoints);
                        }
                    }
                });
                medicalViewer.synchronizeStudies("test", studies, points);
            }
        };
    }]);
function CreateDateFormat(now) {
    var date = now;
    var output = date.toLocaleDateString();
    output += "  ";
    output += date.toLocaleTimeString();
    return output;
}
commangular.command('OnSecondaryCapture', ['seriesManagerService', 'tabService', 'optionsService', 'objectStoreService', 'eventService', '$modal', 'dialogs', '$translate', 'toolbarService',
    function (seriesManagerService, tabService, optionsService, objectStoreService, eventService, $modal, dialogs, $translate, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.selectedTab;
                if (!toolbarService.isEnabled("SecondaryCapture" + tab.id))
                    return;
                var derivedInfo = new Models.DerivedInfo();
                var metadata = seriesManagerService.get_metaData();
                var cell = seriesManagerService.get_activeCell();
                var derivedText;
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    derivedText = OptionNames.Derived3DSeriesDescriptionText;
                }
                else if (cell instanceof lt.Controls.Medical.PanoramicCell) {
                    derivedText = OptionNames.DerivedPanoramicSeriesDescriptionText;
                    metadata = cell.frames.get_item(0).JSON;
                }
                else {
                    derivedText = OptionNames.DerivedSeriesDescriptionText;
                }
                if (metadata != null) {
                    var message = "";
                    var title = "";
                    var failedMessage = "";
                    var errorTitle = "";
                    derivedInfo.description = DicomHelper.getDicomTagValue(metadata, DicomTag.SeriesDescription);
                    derivedInfo.protocolName = DicomHelper.getDicomTagValue(metadata, DicomTag.ProtocolName);
                    if (!derivedInfo.description || (derivedInfo.description.length == 0)) {
                        derivedInfo.description = optionsService.get(derivedText);
                    }
                    else {
                        derivedInfo.description += " " + optionsService.get(derivedText);
                    }
                    $translate('NOTIFY_DERIVED_IMAGE_SAVED').then(function (translation) {
                        message = translation;
                    });
                    $translate('NOTIFY_DERIVED_IMAGE_FAILED').then(function (translation) {
                        failedMessage = translation;
                    });
                    $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                        title = translation;
                    });
                    $translate('DIALOGS_ERROR').then(function (translation) {
                        errorTitle = translation;
                    });
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/SaveAsDerived.html',
                        controller: Controllers.SaveAsDerivedController,
                        backdrop: 'static',
                        resolve: {
                            derivedInfo: function () {
                                return derivedInfo;
                            }
                        }
                    });
                    var __this = this;
                    modalInstance.result.then(function (derivedInfo) {
                        var canvasData = seriesManagerService.capture_currentFrame(true);
                        if (canvasData) {
                            var cellFrame = seriesManagerService.get_activeCellFrame();
                            objectStoreService.StoreSecondaryCapture(canvasData, cellFrame.Instance.SOPInstanceUID, derivedInfo.number, derivedInfo.description, derivedInfo.protocolName)
                                .then(function (result) {
                                if (angular.isDefined(result.data) && angular.isDefined(result.data.Message)) {
                                    dialogs.error(errorTitle, result.data.Message);
                                }
                                else {
                                    dialogs.notify(title, message);
                                    result.data.Date = CreateDateFormat(new Date(Date.now()));
                                    eventService.publish(EventNames.DerivedImageCreated, { series: result.data });
                                }
                            }, function (error) {
                                dialogs.error(errorTitle, failedMessage);
                            });
                        }
                    });
                }
            }
        };
    }]);
function exportResult(exportManagerService, authenticationService, options, config, title, dialogs, fileName, toolbarService, tabId, seriesInstanceUID, sopInstanceUIDs) {
    exportManagerService.Export(options.options, options.source, seriesInstanceUID, sopInstanceUIDs).then(function (result) {
        Utils.ShowProcessingScreen("", false, 1000);
        if (!result)
            return;
        if (!result.data.FaultType) {
            var url = result.data;
            url = url.replace(/\"/g, "");
            if (url.indexOf("/Files/") === -1) {
                url = url + "&auth=" + encodeURIComponent(authenticationService.authenticationCode) + "&fileName=" + fileName;
            }
            OpenUrl(config.urls.serviceUrl + url, true, fileName);
            // this is to enable the pop capture after done processing, so the user wont click twice on it.
            if (toolbarService)
                toolbarService.enable("PopupCapture" + tabId);
        }
        else {
            dialogs.error(title, result.data.Message);
        }
    }, function (error) {
    });
}
function GetCaptureSize(optionsService) {
    return Math.min(8000, Math.max(100, optionsService.get(OptionNames.PrintSize)));
}
function getSOPInstanceUIDs(viewer) {
    var index;
    var sopInstanceUIDs = [];
    var length = viewer.layout.get_items().get_count();
    for (index = 0; index < length; index++) {
        if (viewer.layout.get_items().get_item(index) instanceof lt.Controls.Medical.Cell) {
            var currentCell = viewer.layout.get_items().get_item(index);
            var frame = currentCell.frames.get_item(currentCell.get_currentOffset());
            if (frame.Instance.SOPInstanceUID)
                sopInstanceUIDs.add(frame.Instance.SOPInstanceUID);
        }
    }
    return sopInstanceUIDs;
}
commangular.command('OnExport', ['seriesManagerService', 'exportManagerService', '$modal', 'app.config', 'dialogs', '$translate', 'objectRetrieveService', 'authenticationService', 'optionsService', function (seriesManagerService, exportManagerService, $modal, config, dialogs, $translate, objectRetrieveService, authenticationService, optionsService) {
        return {
            execute: function () {
                if (seriesManagerService.get_activeCell() != null) {
                    var seriesInstanceUID = seriesManagerService.activeSeriesInstanceUID;
                    var layout = Utils.get_seriesLayout(seriesManagerService.get_activeCell());
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Export.html',
                        controller: Controllers.ExportController,
                        backdrop: 'static',
                        resolve: {
                            hasLayout: function () {
                                return (seriesManagerService.currentStructuredDisplay != null);
                            }
                        }
                    });
                    modalInstance.result.then(function (result) {
                        var title = "";
                        $translate('DIALOGS_ERROR_EXPORT_TITLE').then(function (translation) {
                            title = translation;
                        });
                        Utils.ShowProcessingScreen("Export", true, 0);
                        Utils.ResizeProcessingScreen(-1, 84, -1, -1);
                        result.options.LayoutImageWidth = GetCaptureSize(optionsService);
                        var cell = seriesManagerService.get_activeCell();
                        var sopInstanceUIDs = getSOPInstanceUIDs(cell.viewer);
                        var format = result.options.FileFormat;
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        var metadata = null;
                        if (cellFrame != null)
                            metadata = cellFrame.metadata;
                        var tokenFileName = tokenizeFileName(seriesManagerService.currentStructuredDisplay, metadata, optionsService.get(OptionNames.PrintName), null, true, null) + result.options.Ext;
                        // upload annotation only if it's not dicomZip or dicomGray
                        if (result.options.BurnDisplayedAnnotations && (!(format.toLowerCase() == "dicomzip" || format.toLowerCase() == "DicomGray"))) {
                            if (cell) {
                                var seriesInstanceUID = cell.get_seriesInstanceUID();
                                var annotationsData = seriesManagerService.get_allCellsAnnotations(cell, null, false);
                                if (annotationsData.length != 0) {
                                    objectRetrieveService.UploadAnnotations(annotationsData).then(function (ret) {
                                        var fileName = ret.data.replace(/"/g, "");
                                        result.options.AnnotationsFileName = fileName;
                                        exportResult(exportManagerService, authenticationService, result, config, title, dialogs, tokenFileName, null, null, null, sopInstanceUIDs);
                                    });
                                }
                                else {
                                    exportResult(exportManagerService, authenticationService, result, config, title, dialogs, tokenFileName, null, null, null, sopInstanceUIDs);
                                }
                            }
                        }
                        else {
                            result.options.AnnotationsFileName = "";
                            exportResult(exportManagerService, authenticationService, result, config, title, dialogs, tokenFileName, null, null, null, sopInstanceUIDs);
                        }
                    });
                }
            }
        };
    }]);
commangular.command('OnPrint', ['seriesManagerService', 'exportManagerService', '$modal', 'app.config', 'dialogs', '$translate', 'objectRetrieveService', function (seriesManagerService, exportManagerService, $modal, config, dialogs, $translate, objectRetrieveService) {
        return {
            execute: function () {
                if (seriesManagerService.get_activeCell() != null) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Print.html',
                        controller: Controllers.PrintController,
                        backdrop: 'static'
                    });
                    function print(ret) {
                        exportManagerService.Print(ret.options, ret.source).then(function (result) {
                            if (!result.data.FaultType) {
                                var url = result.data;
                                url = url.replace(/\"/g, "");
                                OpenUrl(config.urls.serviceUrl + url, true, null);
                            }
                            else {
                                var title = "Printing Error";
                                dialogs.error(title, result.data.Message);
                            }
                        }, function (error) {
                            var title = "Printing Error";
                            dialogs.error(title, error);
                        });
                    }
                    modalInstance.result.then(function (ret) {
                        ret.options.LayoutImageWidth = 1024;
                        if (ret.options.BurnAnnotations) {
                            var cell = seriesManagerService.get_activeCell();
                            if (cell) {
                                var seriesInstanceUID = cell.get_seriesInstanceUID();
                                var annotationsData = seriesManagerService.get_cellAnnotations(cell, false);
                                if (annotationsData.length != 0) {
                                    objectRetrieveService.UploadAnnotations(annotationsData).then(function (result) {
                                        var fileName = result.data.replace(/"/g, "");
                                        ret.options.AnnotationsFileName = fileName;
                                        print(ret);
                                    });
                                }
                                else {
                                    print(ret);
                                }
                            }
                        }
                        else {
                            ret.options.AnnotationsFileName = "";
                            print(ret);
                        }
                    });
                }
            }
        };
    }]);
commangular.command('OnPrintView', ['seriesManagerService', 'exportManagerService', 'tabService', 'app.config', 'dialogs', '$translate', 'objectRetrieveService', function (seriesManagerService, exportManagerService, tabService, config, dialogs, $translate, objectRetrieveService) {
        return {
            execute: function () {
                var viewer = tabService.getActiveViewer();
                var element = document.getElementById(viewer.divId);
                html2canvas(element.parentElement, {
                    onrendered: function (canvas) {
                        OpenPrintViewUrl(canvas.toDataURL());
                    }
                });
            }
        };
    }]);
// parse the format by placing everything on a seperate array item.
function parseFormat(format) {
    var outputArray = [];
    var index = 0;
    if (!format)
        return null;
    var length = format.length;
    var currentFormat = "";
    var formatchar = "";
    for (index = 0; index < length; index++) {
        formatchar = format[index].toLowerCase();
        if (currentFormat != formatchar) {
            // a new format item
            outputArray.add(formatchar);
            currentFormat = formatchar;
        }
        else {
            // add to the current format.
            if (outputArray.length != 0)
                outputArray[outputArray.length - 1] += formatchar;
        }
    }
    return outputArray;
}
function formatJSONValue(tokenName, value, format) {
    if (!tokenName)
        return value;
    if (!value)
        return value;
    // if the token is a date. then prase it properly.
    if (tokenName.indexOf("Date") != -1) {
        try {
            var date = new Date(value);
            if (!date)
                return value;
            var month = date.getMonth();
            var year = date.getFullYear();
            var day = date.getDate();
            // if the user hasn't passed a format, then use the default one (e.g 03-11-2019)
            var outputArray = parseFormat(format);
            if (!outputArray) {
                return (month + 101).toString().slice(1) + "-" + (day + 100).toString().slice(1) + "-" + year.toString();
            }
            var output = "";
            // this is the number that we add so we can have left hand side 0 if the user wants the number to be for example (07) instead of (7)
            var formatter = 101;
            var slice = 1;
            var index = 0;
            var length = outputArray.length;
            var item;
            for (index = 0; index < length; index++) {
                item = outputArray[index];
                if (!item)
                    continue;
                formatter = item.length > 1 ? 101 : 1;
                slice = item.length > 1 ? 1 : 0;
                if (item.indexOf('m') != -1) {
                    output += (month + formatter).toString().slice(slice);
                }
                else if (item.indexOf('d') != -1) {
                    output += (day + formatter - 1).toString().slice(slice);
                }
                else if (item.indexOf('y') != -1) {
                    output += (item.length < 3) ? year.toString().slice(2) : year.toString();
                }
                else
                    output += item;
            }
            return output;
        }
        catch (e) {
            return value;
        }
    }
    else if (tokenName.indexOf("Time") != -1) {
        try {
            var date = new Date(value);
            if (!date)
                return value;
            var hour = date.getHours();
            var minute = date.getMinutes();
            var seconds = date.getSeconds();
            var am_pm = "AM";
            // if the user hasn't passed a format, then use the default one (e.g 03.11.45 AM)
            var outputArray = parseFormat(format);
            if (!outputArray) {
                if (hour > 12) {
                    hour -= 12;
                    am_pm = "PM";
                }
                return (hour + 100).toString().slice(1) + "." + (minute + 100).toString().slice(1) + "." + (seconds + 100).toString().slice(1) + am_pm;
            }
            var output = "";
            // this is the number that we add so we can have left hand side 0 if the user wants the number to be for example (07) instead of (7)
            var formatter = 101;
            var slice = 1;
            // does the format contains AM/PM?
            var index = 0;
            var length = outputArray.length;
            var item;
            for (index = 0; index < length; index++) {
                if (outputArray[index].indexOf('t')) {
                    // yes it has an AM/PM, subract 12 if larger than 12 and set the time to PM instead of AM
                    if (hour > 12) {
                        hour -= 12;
                        am_pm = "PM";
                        break;
                    }
                }
            }
            // for the final look for the time format.
            for (index = 0; index < length; index++) {
                item = outputArray[index];
                if (!item)
                    continue;
                formatter = item.length > 1 ? 100 : 0;
                slice = item.length > 1 ? 1 : 0;
                if (item.indexOf('h') != -1) {
                    output += (hour + formatter).toString().slice(slice);
                }
                else if (item.indexOf('m') != -1) {
                    output += (minute + formatter).toString().slice(slice);
                }
                else if (item.indexOf('s') != -1) {
                    output += (seconds + formatter).toString().slice(slice);
                }
                else if (item.indexOf('t') != -1) {
                    output += am_pm;
                }
                else
                    output += item;
            }
            return output;
        }
        catch (e) {
            return value;
        }
    }
    return value;
}
function GetDictItem(dict, tokenName) {
    if (!dict)
        return null;
    if (!tokenName)
        return null;
    var lowerCaseToken = tokenName.toLowerCase();
    for (var i in dict) {
        if (i.toLowerCase() == lowerCaseToken) {
            if (!dict[i])
                return "-";
            return dict[i];
        }
    }
    return null;
}
function specialTokenHandle(tokenName) {
    switch (tokenName.toLowerCase().trim()) {
        case "currentdate":
        case "currenttime":
            return Date.now();
    }
    return null;
}
function parseToken(sd, json, token, exception, dataNoAvailableText) {
    if (token.indexOf("<") != 0) {
        return token;
    }
    else {
        // strip the token from the brackets < and >
        var tokenName = token.substr(1, token.length - 2);
        if (exception) {
            // is the token part of the exception list, meaning that it should be left as is
            if (exception.indexOf(tokenName.toLowerCase()) != -1)
                return token;
        }
        var value = null;
        // extracting the format
        var formatIndex = tokenName.indexOf(":");
        var format = "";
        if (formatIndex != -1) {
            format = tokenName.slice(formatIndex + 1);
            tokenName = tokenName.substring(0, formatIndex);
        }
        // handle special tokens that don't exist in the structred display or the dicom json
        value = specialTokenHandle(tokenName);
        // if the structred display or a the JSON is empty, then just return "not_aviablie" in the text.
        if (!value) {
            if (sd) {
                // try to get the value as if you are trying to get it from the strcutured display.
                value = GetDictItem(sd, tokenName);
            }
        }
        // it's not there? then maybe what you got is a JSON. try to get the value from here.
        if (!value)
            value = DicomHelper.getDicomTagValue(json, GetDictItem(DicomTag, tokenName));
        // format the data to it's presented properly... like date, present it in a MM-DD-YYYY
        value = formatJSONValue(tokenName, value, format);
        // no data on either side.
        if (!value) {
            value = (dataNoAvailableText != null) ? dataNoAvailableText : "";
        }
        return (value ? value : tokenName);
    }
}
function tokenizeFileName(sd, json, tokenName, exceptions, replaceCharacters, dataNoAvailableText) {
    var fileName = "";
    if (!tokenName)
        return "UnspecifiedName";
    var listOfTokens = [];
    var index = -1;
    var currentPosition = 0;
    do {
        currentPosition = index + 1;
        index = tokenName.indexOf("<", currentPosition);
        if (index != -1) {
            listOfTokens.add(tokenName.substr(currentPosition, index - currentPosition));
            currentPosition = index;
            index = tokenName.indexOf(">", currentPosition);
            if (index == -1)
                return "ErrorParsingTags";
            listOfTokens.add(tokenName.substr(currentPosition, index - currentPosition + 1));
            currentPosition++;
        }
    } while (index != -1);
    if (currentPosition < tokenName.length)
        listOfTokens.add(tokenName.substr(currentPosition, tokenName.length));
    var output = "";
    for (index = 0; index < listOfTokens.length; index++) {
        output += parseToken(sd, json, listOfTokens[index], exceptions, dataNoAvailableText);
    }
    if (replaceCharacters) {
        //These characters cannot be in a filename, so call this last:
        output = output.replace("/", "-");
        output = output.replace("*", "_");
        output = output.replace("?", "_");
        output = output.replace("\"", "'");
        output = output.replace("<", "_");
        output = output.replace(">", "_");
        output = output.replace("|", "_");
        output = output.replace(" ", "_");
        output = output.replace("\\", "-");
        output = output.replace(":", ".");
        //TODO: remove anything that start with & and end up with ;
        output = output.replace("&quot;", "'");
        output = output.replace("&amp;", "_");
        output = output.replace("&lt;", "_");
        output = output.replace("&gt;", "_");
    }
    return output;
}
commangular.command('OnSecondaryCapturePopup', ['seriesManagerService', 'exportManagerService', '$modal', 'app.config', 'dialogs', '$translate', 'authenticationService', 'optionsService', 'tabService', 'toolbarService', 'objectRetrieveService',
    function (seriesManagerService, exportManagerService, $modal, config, dialogs, $translate, authenticationService, optionsService, tabService, toolbarService, objectRetrieveService) {
        return {
            execute: function () {
                // if there is a layout, and "capture layout flag is enabled", then capture the whole layout in a pdf with the size specified in "capture size"
                var layout = Utils.get_seriesLayout(seriesManagerService.get_activeCell());
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame = seriesManagerService.get_activeCellFrame();
                var metadata = null;
                if (cellFrame != null)
                    metadata = cellFrame.metadata;
                var printLayout = true;
                if (!optionsService.get(OptionNames.PrintLayout))
                    printLayout = false;
                // don't print layout if it's a derivative cell.
                if ((cell instanceof lt.Controls.Medical.Cell3D) || (cell instanceof lt.Controls.Medical.PanoramicCell) || (cell instanceof lt.Controls.Medical.PanoramicCell))
                    printLayout = false;
                if (printLayout) {
                    var result = {};
                    result.options = {};
                    result.options.LayoutImageWidth = GetCaptureSize(optionsService);
                    result.options.AnnotationsFileName = "";
                    result.options.Anonymize = false;
                    result.options.BurnDisplayedAnnotations = true;
                    result.options.BurnAnnotations = false;
                    result.options.CreateDICOMDIR = false;
                    result.options.DczPassword = "";
                    result.options.FileFormat = "PDF";
                    result.options.ImageCompression = 1;
                    result.options.IncludeOverflowImages = false;
                    result.options.IncludeViewer = false;
                    result.options.PatientInfo = true;
                    result.options.ReduceGrayscaleTo8BitsSelected = false;
                    result.options.WhiteBackground = false;
                    result.options.BackgroundColor = optionsService.get(OptionNames.PdfBackgroundColor);
                    result.options.TextBackgroundColor = optionsService.get(OptionNames.TextBackgroundColor);
                    result.options.TextColor = optionsService.get(OptionNames.TextColor);
                    result.source = ExportImagesSource.Layout;
                    if (toolbarService && tab)
                        toolbarService.disable("PopupCapture" + tab.id);
                    Utils.ShowProcessingScreen("Printing", true, 0);
                    Utils.ResizeProcessingScreen(-1, 84, -1, -1);
                    var fileName = tokenizeFileName(seriesManagerService.currentStructuredDisplay, metadata, optionsService.get(OptionNames.PrintName), null, true, null) + ".pdf";
                    var annotationsData = seriesManagerService.get_allCellsAnnotations(cell, null, false);
                    if (annotationsData.length != 0) {
                        objectRetrieveService.UploadAnnotations(annotationsData).then(function (ret) {
                            var annotationFileName = ret.data.replace(/"/g, "");
                            result.options.AnnotationsFileName = annotationFileName;
                            exportResult(exportManagerService, authenticationService, result, config, "", dialogs, fileName, toolbarService, tab ? tab.id : "", seriesManagerService.currentStructuredDisplay ? seriesManagerService.currentStructuredDisplay.SeriesInstanceUID : null, null);
                        });
                    }
                    else {
                        exportResult(exportManagerService, authenticationService, result, config, "", dialogs, fileName, toolbarService, tab ? tab.id : "", seriesManagerService.currentStructuredDisplay ? seriesManagerService.currentStructuredDisplay.SeriesInstanceUID : null, null);
                    }
                }
                else {
                    if (seriesManagerService.get_activeCell() != null) {
                        exportManagerService.PopupCapture();
                    }
                }
            }
        };
    }]);
commangular.command('OnSort', ['seriesManagerService', 'toolbarService', 'tabService', 'exportManagerService', '$modal', 'app.config', 'dialogs', '$translate', function (seriesManagerService, toolbarService, tabService, exportManagerService, $modal, config, dialogs, $translate) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var cellFrame = seriesManagerService.get_activeCellFrame();
                var metadata = cellFrame.metadata;
                // get the menu item text
                var items = [];
                items[0] = { Text: "Acquisition Time", Info: getSortingOperation(lt.Controls.Medical.SortType.byAcquisitionTime, "") };
                items[1] = { Text: "Axis", Info: getSortingOperation(lt.Controls.Medical.SortType.byAxis, "") };
                items[2] = { Text: "Instance Number", Info: getSortingOperation(lt.Controls.Medical.SortType.none, DicomTag.InstanceNumber) };
                // items[6] = { Text: "Instance Number ", Info: getSortingOperation(lt.Controls.Medical.SortType.none, DicomTag.InstanceNumber) };
                // items[7] = { Text: "Instance Number ", Info: getSortingOperation(lt.Controls.Medical.SortType.none, DicomTag.InstanceNumber) };
                // get the icon.
                var id = 'SortSeries' + tab.id;
                var icon = document.getElementById(id);
                // show the menu.
                ShowMenu(items, icon, sortClick, cellFrame, toolbarService, tabService, seriesManagerService, $modal, tab, currentSelectedSortOrder);
            }
        };
    }]);
commangular.command('OnLineProfile', ['seriesManagerService', 'tabService', 'eventService', 'exportManagerService', '$modal', 'app.config', 'dialogs', '$translate', function (seriesManagerService, tabService, eventService, exportManagerService, $modal, config, dialogs, $translate) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var frame = seriesManagerService.get_activeCellFrame();
                CommandManager.RunCommand(cell, MedicalViewerAction.LineProfile, "");
                if (!parentDiv) {
                    parentDiv = $("<div id='dialog' title='Line Profile' >" +
                        "<canvas id='lineProfileCanvas' z-index='3' style='left:29px; top:10px; position:absolute'></canvas>" +
                        "<canvas id='outerlineProfileCanvas'></canvas>" +
                        "<div align= 'right'>" +
                        "<div style='float: left'> <label><input type='radio' id='radioColor' name='radioButtonGroup' style= 'float: left; display:lock; text-align:left'> Color </input></label></div>" +
                        "<div style='float: right'> <label><input type='radio' id='radioGray' checked='true' name='radioButtonGroup' style= 'float: left; display:lock; text-align:left'> Gray</input></label></div>" +
                        "</div><br/><br/>" +
                        "<label><input id='checkboxRed' checked='true' disabled='true' type='checkbox' value= 'Red' > Red </input> </label><br/>" +
                        "<label><input id='checkboxGreen' checked='true' disabled='true' type='checkbox' value='Green'> Green </input></label> <br/>" +
                        "<label><input id='checkboxBlue' checked='true' disabled='true' type='checkbox' value='Blue'> Blue </input></label><br/>" +
                        "<label  style='float: right'><button type='button' id='closeButton'>Close</button></label><br/>" +
                        "</div>");
                    parentDiv.dialog({
                        autoOpen: false
                    });
                }
                eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                    var tab = tabService.find_tab(data.args.currentTab.id);
                    enumerateCell(tabService, function (cell) {
                        CommandManager.RunCommand(cell, MedicalViewerAction.WindowLevel, "");
                        if (cell.lineProfile != null)
                            cell.lineProfile.end();
                    }, data.args.previousTab);
                    $('#dialog').dialog("close");
                });
                if ($('#dialog').dialog('isOpen'))
                    return;
                if (!testDiv) {
                    testDiv = $("<div id='dialog2' title='Line Profile' >" +
                        "<canvas id='testCanvas' width = '500' height ='500' z-index='3' style='background-color:red; width:500px; height:500px; position:absolute'></canvas>" +
                        "</div>");
                    testDiv.dialog({
                        autoOpen: false
                    });
                    $('#dialog').on('dialogclose', function (event) {
                        enumerateCell(tabService, function (cell) {
                            CommandManager.RunCommand(cell, MedicalViewerAction.WindowLevel, "");
                            if (cell.lineProfile != null)
                                cell.lineProfile.end();
                        });
                    });
                }
                $("#dialog").dialog(({
                    closeOnEscape: false,
                    open: function (event, ui) {
                        $(".ui-dialog-titlebar-close", ui.dialog | ui).hide();
                    }
                }));
                $("#dialog").dialog("open");
                var mainDiv = document.getElementById('dialog');
                var width = mainDiv.clientWidth - 24;
                var height = 220;
                //var left = 29;
                var closeButton = document.getElementById('closeButton');
                closeButton.addEventListener('click', function (e) { $('#dialog').dialog("close"); }, true);
                var outerlineCanvas = document.getElementById('outerlineProfileCanvas');
                var context = outerlineCanvas.getContext('2d');
                var left = context.measureText("65535").width;
                //outerlineCanvas.style.width = width + "px";
                //outerlineCanvas.style.height = height + "px";
                outerlineCanvas.width = width;
                outerlineCanvas.height = height;
                height = 180;
                var innerLineCanvas = document.getElementById('lineProfileCanvas');
                var space = width / 15;
                width = width - space - left;
                height = height - space;
                //innerLineCanvas.style.width = "300px";//width + "px";
                //innerLineCanvas.style.height = "300px";//height + "px";
                innerLineCanvas.width = width;
                innerLineCanvas.height = height;
                innerLineCanvas.style.left = left + 12 + "px";
                var top = innerLineCanvas.offsetTop - outerlineCanvas.offsetTop;
                var innerLineCanvas = document.getElementById('lineProfileCanvas');
                var outerlineCanvas = document.getElementById('outerlineProfileCanvas');
                context = outerlineCanvas.getContext('2d');
                context.beginPath();
                context.strokeStyle = 'red';
                context.strokeStyle = "black";
                context.moveTo(left + 0.5, height + top + 1.5);
                context.lineTo(left + width + 0.5, height + top + 1.5);
                context.textAlign = "left";
                context.textBaseline = "top";
                context.fillText("0%", left, top + height);
                context.textAlign = "right";
                context.fillText("100%", left + width - 0.5, top + height);
                if (isGrayScale16(frame.information)) {
                    context.fillText(frame.information.maxValue <= 0 ? "65556" : frame.information.maxValue.toString(), left - 0.5, 0);
                }
                else
                    context.fillText("256", left - 0.5, 0);
                context.textBaseline = "bottom";
                if (isGrayScale16(frame.information)) {
                    context.fillText(frame.information.minValue.toString(), left - 0.5, height + top);
                }
                else {
                    context.fillText("0", left - 0.5, height + top);
                }
                context.stroke();
                UpdateSliderPosition(0);
                outerlineCanvas.addEventListener('mousedown', function (e) { outerlineCanvas_mouseDown(outerlineCanvas, e); }, true);
                outerlineCanvas.addEventListener('mousemove', function (e) { outerlineCanvas_mouseMove(outerlineCanvas, e); }, true);
                outerlineCanvas.addEventListener('mouseup', function (e) { outerlineCanvas_mouseUp(outerlineCanvas, e); }, true);
                outerlineCanvas.onselectstart = function () { return false; };
                innerLineCanvas.addEventListener('mousedown', function (e) { innerLineCanvas_mouseDown(innerLineCanvas, e); }, true);
                innerLineCanvas.addEventListener('mousemove', function (e) { innerLineCanvas_mouseMove(innerLineCanvas, e); }, true);
                innerLineCanvas.addEventListener('mouseup', function (e) { innerLineCanvas_mouseUp(innerLineCanvas, e); }, true);
                innerLineCanvas.onselectstart = function () { return false; };
                var profileColorRadio = document.getElementById('radioColor');
                profileColorRadio.addEventListener('click', radioColor);
                var profileGrayRadio = document.getElementById('radioGray');
                profileGrayRadio.addEventListener('click', radioGray);
                var redCheckBox = document.getElementById('checkboxRed');
                redCheckBox.addEventListener('click', function (e) { checkbox_click("checkboxRed"); });
                var greenCheckBox = document.getElementById('checkboxGreen');
                greenCheckBox.addEventListener('click', function (e) { checkbox_click("checkboxGreen"); });
                var blueCheckBox = document.getElementById('checkboxBlue');
                blueCheckBox.addEventListener('click', function (e) { checkbox_click("checkboxBlue"); });
            }
        };
    }]);
commangular.command('OnRunApplication', ['externalApplicationsService', 'exportService', 'seriesManagerService', 'toolbarService', '$modal', function (externalApplicationsService, exportService, seriesManagerService, toolbarService, $modal) {
        return {
            execute: function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/RunApp.html',
                    controller: Controllers.RunAppController,
                    backdrop: 'static'
                });
            }
        };
    }]);
commangular.command('OnAddApplication', ['externalApplicationsService', 'toolbarService', '$modal', function (externalApplicationsService, toolbarService, $modal) {
        return {
            execute: function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddApp.html',
                    controller: Controllers.AddAppController,
                    backdrop: 'static'
                });
            }
        };
    }]);
commangular.command('OnWaveformBasicAudio', ['seriesManagerService', 'toolbarService', '$modal', function (seriesManagerService, toolbarService, $modal) {
        return {
            execute: function () {
                if (seriesManagerService.get_activeCell() != null) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Audio.html',
                        controller: Controllers.AudioController,
                        backdrop: 'static'
                    });
                }
            }
        };
    }]);
function cinePlayerActive(cell) {
    var index;
    var length = cell.viewer.layout.get_items().get_count();
    for (index = 0; index < length; index++) {
        var currentCell = cell.viewer.layout.get_items().get_item(index);
        if (currentCell.cinePlayer != null) {
            if (currentCell.cinePlayer.isPlaying)
                return true;
        }
    }
    return false;
}
commangular.command('OnToggleCine', ['seriesManagerService', 'toolbarService', '$modal', 'cinePlayerService', 'tabService', function (seriesManagerService, toolbarService, $modal, cinePlayerService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var viewer = cell.viewer;
                var checkFound = false;
                var enable = false;
                if (cell != null) {
                    var index;
                    var length = cell.viewer.layout.get_items().get_count();
                    for (index = 0; index < length; index++) {
                        if (viewer.layout.get_items().get_item(index) instanceof lt.Controls.Medical.Cell3D)
                            continue;
                        var currentCell = viewer.layout.get_items().get_item(index);
                        if (cell.tickBoxes.length > 0) {
                            if (currentCell.tickBoxes[0].checked) {
                                checkFound = true;
                                if (currentCell.cinePlayer != null) {
                                    if (!currentCell.cinePlayer.isPlaying) {
                                        currentCell.cinePlayer.play();
                                        enable = true;
                                    }
                                    else {
                                        currentCell.cinePlayer.stop();
                                        enable = false;
                                    }
                                }
                            }
                        }
                    }
                    if (!checkFound) {
                        if (!cell.cinePlayer.isPlaying)
                            cell.cinePlayer.play();
                        else
                            cell.cinePlayer.stop();
                        enable = !cell.cinePlayer.isPlaying;
                    }
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var menuIcon = "#" + "ToggleCine" + tab.id + "_icon";
                }
            }
        };
    }]);
commangular.command('CinePlayer', ['seriesManagerService', 'toolbarService', '$modal', 'cinePlayerService', function (seriesManagerService, toolbarService, $modal, cinePlayerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var modalInstance;
                    cinePlayerService.attachCell(cell);
                    modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/CinePlayer.html',
                        controller: Controllers.CinePlayerController,
                        backdrop: 'static'
                    });
                }
            }
        };
    }]);
var _ipInstance;
commangular.command('BrightnessContrast', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell != null) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    if (cell && toolbarService.isEnabled("BrightnessContrast" + tab.id)) {
                        var seriesInstanceUID = cell.get_seriesInstanceUID();
                        var modalInstance;
                        modalInstance = $modal.open({
                            templateUrl: 'views/dialogs/BrightnessContrast.html',
                            controller: Controllers.BrightnessContrastController,
                            backdrop: 'static',
                        });
                        modalInstance.result.then(function (ipVals) {
                            var frame = seriesManagerService.get_activeCellFrame();
                            var ip;
                            ip = new lt.ImageProcessing();
                            ip.set_jsFilePath(_jsFileCoreColorPath);
                            ip.set_command("ContrastBrightnessIntensity");
                            ip.get_arguments()["brightness"] = ipVals.brightness * 10;
                            ip.get_arguments()["contrast"] = ipVals.contrast * 10;
                            ip.get_arguments()["intensity"] = 0;
                            frame.imageProcessingList.add(ip);
                            frame.subCell.invalidate();
                        });
                    }
                }
            }
        };
    }]);
commangular.command('HSL', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell && toolbarService.isEnabled("HSL" + tab.id)) {
                    var seriesInstanceUID = cell.get_seriesInstanceUID();
                    var modalInstance;
                    modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Hsl.html',
                        controller: Controllers.HSLController,
                        backdrop: 'static',
                    });
                    modalInstance.result.then(function (ipVals) {
                        var frame = seriesManagerService.get_activeCellFrame();
                        var ip;
                        ip = new lt.ImageProcessing();
                        ip.set_jsFilePath(_jsFileCoreColorPath);
                        ip.set_command("ChangeHueSaturationIntensity");
                        ip.get_arguments()["hue"] = ipVals.hue * 100;
                        ip.get_arguments()["saturation"] = ipVals.saturation * 10;
                        ip.get_arguments()["intensity"] = ipVals.lightness * 10;
                        frame.imageProcessingList.add(ip);
                        frame.subCell.invalidate();
                    });
                }
            }
        };
    }]);
commangular.command('StretchHistogram', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell && toolbarService.isEnabled("StretchHistogram" + tab.id)) {
                    var frame = seriesManagerService.get_activeCellFrame();
                    var ip;
                    var canvas = ((frame.lowResImage != null) ? frame.lowResImage.canvas : frame.thumbnailImage.canvas);
                    var imageContext = canvas.getContext("2d");
                    var imageData = imageContext.getImageData(0, 0, canvas.width, canvas.height);
                    var point = lt.Controls.Medical.ImageProcessing.getHistogramPoint(imageData, 10);
                    stretchIntensityLow = point.x;
                    stretchIntensityHigh = point.y;
                    ip = new lt.ImageProcessing();
                    ip.set_jsFilePath(_jsFileCoreColorPath);
                    ip.set_command("StretchHistogram");
                    ip.get_arguments()["low"] = stretchIntensityLow;
                    ip.get_arguments()["high"] = stretchIntensityHigh;
                    frame.imageProcessingList.add(ip);
                    frame.subCell.invalidate();
                }
            }
        };
    }]);
commangular.command('OnShutterObject', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'eventService', function (seriesManagerService, $modal, toolbarService, tabService, eventService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var frame = seriesManagerService.get_activeCellFrame();
                var automation = cell.get_automation();
                if (automation == null)
                    return;
                var editObject = automation.get_currentEditObject();
                if (!editObject) {
                    alert("no selected annotation object found!");
                    return;
                }
                if (!lt.Controls.Medical.ShutterObject.isValid(editObject)) {
                    alert("Cannot create a shutter using the selected annotation object");
                    return;
                }
                frame.get_shutter().get_objects().clear();
                frame.get_shutter().get_objects().add(automation.get_currentEditObject());
                frame.get_shutter().fillStyle = "rgba(0, 0, 0, 1)";
            }
        };
    }]);
var _automationFrame;
var _automation;
commangular.command('OnShutterObjectFreeHand', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.ShutterFreeHand, "");
                });
            }
        };
    }]);
commangular.command('OnShutterObjectPolygon', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.ShutterPolygon, "");
                });
            }
        };
    }]);
commangular.command('OnShutterObjectRectangle', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.ShutterRect, "");
                });
            }
        };
    }]);
commangular.command('OnShutterObjectEllipse', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', function (seriesManagerService, $modal, toolbarService, tabService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.ShutterEllipse, "");
                });
            }
        };
    }]);
function FindGeneratorCell(cell) {
    var generator = null;
    generator = cell.generator ? cell.generator : cell;
    return generator;
}
function FindRelatedCells(cell) {
    var cells = [];
    var generator = FindGeneratorCell(cell);
    var index = 0;
    var length = generator.derivatives.count;
    for (index = 0; index < length; index++) {
        cells.add(generator.derivatives.get_item(index));
    }
    return cells;
}
function InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService, fullRange) {
    var tab = seriesManagerService.get_seriesTab(cell.get_seriesInstanceUID());
    var seriesInfo = seriesManagerService.get_seriesInfo(cell.get_seriesInstanceUID());
    var seriesInstanceUID = cell.get_seriesInstanceUID();
    derivative.add_disposing(function () {
        var seriesInstanceUID = derivative.seriesInstanceUID;
        Utils.disposeAutomation(derivative.get_automation());
        seriesManagerService.remove_cell(derivative);
    });
    derivative.drawCrossHairLines = false;
    var frame = derivative.frames.get_item(0);
    frame.width = cell.frames.get_item(0).width;
    frame.height = cell.frames.get_item(0).height;
    frame.rowSpacing = cell.frames.get_item(0).rowSpacing;
    frame.columnSpacing = cell.frames.get_item(0).columnSpacing;
    frame.JSON = cell.frames.get_item(0).JSON;
    frame.Instance = cell.frames.get_item(0).Instance;
    var newSeriesInfo = jQuery.extend(true, {}, seriesInfo);
    newSeriesInfo.InstanceUID = cell.seriesInstanceUID;
    var series = new MedicalViewerSeries(newSeriesInfo.InstanceUID, "", "", 1, 1);
    series.seriesInstanceUID = newSeriesInfo.InstanceUID;
    overlayManagerService.set_cellOverlays(derivative, derivative.frames.get_item(0).JSON, false);
    derivative.overlayTextVisible = true;
    derivative.seriesInstanceUID = cell.seriesInstanceUID;
    derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
    var castViewer = cell.viewer;
    series.link = cell.get_linked();
    castViewer.InitializeCell(derivative, series);
    var query = new Models.QueryOptions();
    query.SeriesOptions.SeriesInstanceUID = cell.seriesInstanceUID;
    var _frame = cell.frames.get_item(0);
    var sopInstanceUID = _frame.Instance.SOPInstanceUID;
    derivative.engine = tab.AddnewEngine(cell, derivative.divID, queryArchiveService, query, sopInstanceUID, optionsService);
    cell.derivatives.add(derivative);
    function objectReady(sender, args) {
        switch (args.status) {
            case lt.Controls.Medical.Object3DStatus.error:
                var medicalViewer = derivative.viewer;
                medicalViewer.layout.get_items().remove(derivative);
                seriesManagerService.remove_cell(derivative);
                derivative.dispose();
                alert(args.message);
                break;
            case lt.Controls.Medical.Object3DStatus.ready:
                if (derivative.engine.progress == 100) {
                    var json = {};
                    json["WindowWidth"] = "";
                    json["WindowCenter"] = "";
                    json["DefaultWindowWidth"] = "";
                    json["DefaultWindowCenter"] = "";
                    json["MinimumValue"] = "";
                    json["MaximumValue"] = "";
                    json["AutoScaleSlope"] = "";
                    json["AutoScaleIntercept"] = "";
                    json["Signed"] = "";
                    json = JSON.stringify(json);
                    queryArchiveService.Get3DSettings(json, derivative.engine.id).then(function (data) {
                        try {
                            var fillJson = JSON.parse(data.data);
                            var info = new lt.Controls.Medical.DICOMImageInformation();
                            info = _frame.information.clone();
                            var width = parseFloat(fillJson["DefaultWindowWidth"]);
                            var center = parseFloat(fillJson["DefaultWindowCenter"]);
                            var slope = parseFloat(fillJson["AutoScaleSlope"]);
                            var intercept = -parseFloat(fillJson["AutoScaleIntercept"]);
                            var minValue = parseFloat(fillJson["MinimumValue"]);
                            var maxValue = parseFloat(fillJson["MaximumValue"]);
                            var lowBit = _frame.information.lowBit;
                            var highBit = _frame.information.highBit;
                            var signed = parseInt(fillJson["Signed"]) == 1;
                            if (width == 0) {
                                width = parseFloat(fillJson["WindowWidth"]) / slope;
                                center = (parseFloat(fillJson["WindowCenter"]) - intercept) / slope;
                            }
                            if (fullRange) {
                                width = 0xffff;
                                center = width >> 1;
                                slope = 1;
                                intercept = 0;
                                minValue = 0;
                                maxValue = 0xffff;
                                lowBit = 0;
                                highBit = 15;
                                signed = false;
                            }
                            // TODO: get these values from the 3D object instead of assuming it's the same as the first frame of the original cell.
                            info.bitsPerPixel = _frame.information.bitsPerPixel;
                            info.photometricInterpretation = _frame.information.photometricInterpretation;
                            info.windowWidth = width;
                            info.windowCenter = center;
                            info.minValue = minValue;
                            info.maxValue = maxValue;
                            info.lowBit = lowBit;
                            info.highBit = highBit;
                            info.autoScaleSlope = slope;
                            info.autoScaleIntercept = intercept;
                            info.signed = signed;
                            var index = 0;
                            var count = derivative.frames.get_count();
                            for (index = 0; index < count; index++) {
                                derivative.frames.get_item(index).set_information(info);
                                derivative.frames.get_item(index).JSON = _frame.JSON;
                                derivative.frames.get_item(index).Instance = _frame.Instance;
                            }
                        }
                        catch (e) {
                        }
                    });
                    derivative.engine.remove_statusChanged(objectReady);
                }
                break;
        }
    }
    CommandManager.RunCommand(derivative, CommandManager.LastCommand.Action, CommandManager.LastCommand.ButtonID);
    derivative.engine.add_statusChanged(objectReady);
    return derivative.engine;
}
commangular.command('OnCTRTool', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell.drawables["CTRTool"]) {
                    var ctrTool = cell.drawables["CTRTool"];
                    ctrTool.dispose();
                }
                else {
                    var ctrTool = new lt.Controls.Medical.CTRTool(cell.selectedItem.attachedFrame);
                    ctrTool.add_disposing(function () {
                        delete cell.drawables["CTRTool"];
                        cell.invalidate(null);
                        cell.imageViewer.automationInvalidate(null);
                    });
                    cell.drawables["CTRTool"] = ctrTool;
                    cell.invalidate(null);
                    cell.imageViewer.automationInvalidate(null);
                    cell.runCommand(MedicalViewerAction.AnnSelect);
                }
            }
        };
    }]);
commangular.command('OnProbeTool', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.ProbeTool, buttonId);
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.ProbeTool, buttonId);
                });
            }
        };
    }]);
commangular.command('OnHistogramToolBox', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', 'eventService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService, eventService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var _this = this;
                // get the dialog that will hold the histogram box.
                var parentDiv = document.getElementById("mainView");
                var dialog = parentDiv.getElementsByClassName("modlessDialog")[0];
                if (dialog != null) {
                    closeModlessDialog(dialog);
                    return;
                }
                // whenever the window level changes, the user curve should get updated based on the new window level value.
                function windowLevelChanged(sender, args) {
                    // this check is to make sure that the updates here will only happens if the window level changes from outside the dialog.
                    if (!_histogramMouseDown) {
                        // change the windowl level width and center.
                        _widthInput.value = _frame.windowWidth.toString();
                        _centerInput.value = _frame.windowCenter.toString();
                        // update the curve.
                        setWidthCenterToCurve(parseInt(_widthInput.value), parseInt(_centerInput.value));
                        // paint the histogram.
                        drawHistogram(_histogram);
                    }
                }
                function drawHistogram(histogram) {
                    var parentDiv = document.getElementById("mainView");
                    var canvas = parentDiv.getElementsByClassName("histogram")[0];
                    if (!canvas)
                        return;
                    if (!canvas.backCanvas) {
                        canvas.backCanvas = document.createElement("canvas");
                    }
                    var backCanvas = canvas.backCanvas;
                    var backCanvasContext = backCanvas.getContext("2d");
                    var context = canvas.getContext("2d");
                    canvas.width = canvas.parentElement.clientWidth;
                    canvas.height = canvas.parentElement.clientHeight;
                    var lineWidth = Math.max(1, Math.floor(histogram.length / canvas.width));
                    backCanvas.height = canvas.height;
                    var index = 0;
                    var length = canvas.width;
                    var lines = 0;
                    var totalHistogram = [];
                    var counter = 0;
                    var max = 1;
                    var total = 0;
                    var histogramLength = histogram.length - (histogram.length % lineWidth);
                    backCanvas.width = histogramLength / lineWidth;
                    for (index = 1; index < histogramLength; index += lineWidth) {
                        total = 0;
                        for (lines = 0; lines < lineWidth; lines++) {
                            total += histogram[lines + index];
                        }
                        totalHistogram[counter] = total;
                        counter++;
                        max = Math.max(max, total);
                    }
                    var ratio = (max > canvas.height) ? canvas.height / max : 1;
                    backCanvasContext.beginPath();
                    for (index = 1; index < backCanvas.width; index++) {
                        backCanvasContext.strokeStyle = '#252830';
                        backCanvasContext.moveTo(index + 0.5, canvas.height);
                        backCanvasContext.lineTo(index + 0.5, (canvas.height) - totalHistogram[index] * ratio);
                    }
                    backCanvasContext.stroke();
                    var margin = 5;
                    if (!canvas.point1)
                        canvas.point1 = { x: 0, y: 0 };
                    if (!canvas.point2)
                        canvas.point2 = { x: canvas.width - 1 - (margin << 1), y: canvas.height - 1 - (margin << 1) };
                    var x1 = canvas.point1.x + margin;
                    var y1 = canvas.point1.y + margin;
                    var x2 = canvas.point2.x + margin;
                    var y2 = canvas.point2.y + margin;
                    var height = (canvas.height - 1);
                    context.drawImage(backCanvas, margin + 0.5, margin + 0.5, canvas.width - 1 - (margin << 1), canvas.height - 1 - (margin << 1));
                    context.strokeStyle = '#9099A0';
                    context.fillStyle = '#9099A0';
                    context.setLineDash([5, 3]);
                    var points = findboundariesPoints(false);
                    points[0].x = points[0].x + margin;
                    points[1].x = points[1].x + margin;
                    points[0].y = height - (points[0].y + margin);
                    points[1].y = height - (points[1].y + margin);
                    context.beginPath();
                    context.moveTo(points[0].x + 0.5, points[0].y + 0.5);
                    context.lineTo(points[1].x + 0.5, points[1].y + 0.5);
                    context.stroke();
                    context.strokeStyle = '#9099A0';
                    context.setLineDash([]);
                    context.beginPath();
                    context.arc(x1 + 0.5, height - y1 + 0.5, margin, 0, 2 * Math.PI);
                    context.stroke();
                    context.fill();
                    context.beginPath();
                    context.arc(x2 + 0.5, height - y2 + 0.5, margin, 0, 2 * Math.PI);
                    context.stroke();
                    context.fill();
                    context.lineWidth = 2;
                    context.beginPath();
                    context.moveTo(x1 + 0.5, height - y1 + 0.5);
                    context.lineTo(x2 + 0.5, height - y2 + 0.5);
                    context.stroke();
                    context.beginPath();
                    context.strokeStyle = '#9099A0';
                    context.moveTo(margin + 0.5, canvas.height - 0.5 - (margin));
                    context.lineTo(canvas.width - 0.5 - margin, (canvas.height - 0.5) - (margin));
                    context.moveTo(margin + 0.5, margin + 0.5);
                    context.lineTo(margin + 0.5, (canvas.height - 0.5) - (margin));
                    context.stroke();
                }
                function selectionChanged(sender, args) {
                    var viewer;
                    if (sender instanceof lt.Controls.Medical.Cell)
                        viewer = sender.viewer;
                    else if (viewer instanceof lt.Controls.Medical.MedicalViewer)
                        viewer = sender;
                    else
                        return;
                    if (!viewer.layout.selectedItem) {
                        // TODO: empty the histogram.
                        return;
                    }
                    if (viewer.layout.selectedItem instanceof lt.Controls.Medical.Cell) {
                        var selectedCell = cell.viewer.layout.selectedItem;
                        if (_frame != null)
                            _frame.remove_windowLevelChanged(windowLevelChanged);
                        _frame = selectedCell.selectedItem.attachedFrame;
                        _invert.checked = _frame.inverted;
                        _frame.add_windowLevelChanged(windowLevelChanged);
                        var from = (1 << _frame.information.lowBit) - 1;
                        var to = (1 << _frame.information.highBit + 1);
                        _fromText.innerHTML = from.toString();
                        _toText.innerHTML = to.toString();
                        _widthInput.value = _frame.windowWidth.toString();
                        _centerInput.value = _frame.windowCenter.toString();
                        drawHistogram(_histogram);
                        fixCurve();
                    }
                }
                var _mouseDown = false;
                var _histogramMouseDown = false;
                var _histogramHitTest = -1;
                var _histogram;
                var _canvas;
                var _pointDistance = 0;
                var _fromText;
                var _toText;
                var _invert;
                var _widthInput;
                var _centerInput;
                var _offsetX;
                var _offsetY;
                var _canvasWidth;
                var _canvasHeight;
                var _margin = 5;
                var _frame;
                var _this = this;
                function histogramInputChanged(args) {
                    // if the histogram mouse is down, that means we are moving the curve already.
                    if (!_histogramMouseDown) {
                        setWidthCenterToCurve(parseInt(_widthInput.value), parseInt(_centerInput.value));
                        if (_frame != null) {
                            _frame.setWindowLevel(parseInt(_widthInput.value), parseInt(_centerInput.value));
                        }
                        drawHistogram(_histogram);
                    }
                }
                function isOnLine(offsetX, offsetY) {
                    if (_histogramHitTest != -1)
                        return;
                    var x1 = _canvas.point1.x;
                    var x2 = _canvas.point2.x;
                    var y1 = _canvas.point1.y;
                    var y2 = _canvas.point2.y;
                    // just to remove an excessive value.
                    if (Math.abs(x2 - x1) < 0.5)
                        x2 += 1;
                    if (Math.abs(y2 - y1) < 0.5)
                        y2 += 1;
                    var m = (y2 - y1) / (x2 - x1);
                    var c = y1 - m * x1;
                    var per_m = -1 / m;
                    var per_c = offsetY - (per_m * offsetX);
                    var x = (c - per_c) / (per_m - m);
                    var y = per_m * x + per_c;
                    x = x - offsetX;
                    y = y - offsetY;
                    if (Math.sqrt(x * x + y * y) < 8) {
                        _offsetX = (offsetX - x1);
                        _offsetY = (offsetY - y1);
                        return true;
                    }
                    return false;
                }
                function getMouseArgs(args) {
                    var offsetX = args.offsetX - _margin;
                    var offsetY = args.offsetY - _margin;
                    offsetY = _canvasHeight - offsetY;
                    return { x: offsetX, y: offsetY };
                }
                function mouseDownHistogram(args) {
                    _histogramMouseDown = true;
                    var offset = getMouseArgs(args);
                    var offsetX = offset.x;
                    var offsetY = offset.y;
                    var rect = lt.LeadRectD.create(_canvas.point1.x, _canvas.point1.y, 1, 1);
                    rect.inflate(12, 12);
                    if (rect.contains(offsetX, offsetY)) {
                        _histogramHitTest = 0;
                        _offsetX = offsetX - _canvas.point1.x;
                        _offsetY = offsetY - _canvas.point1.y;
                    }
                    rect = lt.LeadRectD.create(_canvas.point2.x, _canvas.point2.y, 1, 1);
                    rect.inflate(12, 12);
                    if (rect.contains(offsetX, offsetY)) {
                        _histogramHitTest = 1;
                        _offsetX = offsetX - _canvas.point2.x;
                        _offsetY = offsetY - _canvas.point2.y;
                    }
                    if (isOnLine(offsetX, offsetY)) {
                        _histogramHitTest = 2;
                    }
                }
                function mouseDown(args) {
                    if (args.currentTarget instanceof HTMLDivElement) {
                        _mouseDown = true;
                        _offsetX = args.offsetX;
                        _offsetY = args.offsetY;
                    }
                    else {
                        args.stopPropagation();
                    }
                }
                function inRange(value, rangeFrom, rangeTo) {
                    if (Math.round(value) > rangeTo)
                        return false;
                    if (Math.round(value) < rangeFrom)
                        return false;
                    return true;
                }
                function setWidthCenterToCurve(width, center) {
                    var xRatio = ((_canvasWidth - 1) / _histogram.length);
                    var yRatio = (_canvasHeight - 1) / 0xffff;
                    var from = center - ((width + 1) >> 1);
                    var to = center + (width >> 1);
                    from += _frame.information.autoScaleIntercept;
                    to += _frame.information.autoScaleIntercept;
                    var point1 = { x: from * xRatio, y: 0 };
                    var point2 = { x: to * xRatio, y: _canvasHeight - 1 };
                    // maintain the distance between the points when you move the curve.
                    if (_pointDistance != 0) {
                        var centerPoint = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 };
                        var m = (point2.y - centerPoint.y) / (point2.x - centerPoint.x);
                        // find find the distance between the point
                        var x = Math.sqrt((_pointDistance / 2) * (_pointDistance / 2) / (1 + (m * m)));
                        var y = m * x;
                        // move te curve so it wont snap back to the middle, by trying to maintain where it is in graph
                        var centerY = (_canvas.point2.y + _canvas.point1.y) / 2;
                        var centerX = (centerY - centerPoint.y) / m + centerPoint.x;
                        var centerPoint = { x: centerX, y: centerY };
                        // if the line is outside the canvas, then reset, fuck it
                        if (!lt.LeadRectD.create(0, 0, _canvasWidth, _canvasHeight).contains(centerPoint.x, centerPoint.y)) {
                            _canvas.point1 = point1;
                            _canvas.point2 = point2;
                        }
                        else {
                            _canvas.point1 = { x: centerPoint.x + x, y: centerPoint.y + y };
                            _canvas.point2 = { x: centerPoint.x - x, y: centerPoint.y - y };
                        }
                    }
                    else {
                        _canvas.point1 = point1;
                        _canvas.point2 = point2;
                    }
                }
                function calculateWidthCenter() {
                    var x1 = _canvas.point1.x;
                    var x2 = _canvas.point2.x;
                    var y1 = _canvas.point1.y;
                    var y2 = _canvas.point2.y;
                    if (Math.abs(x1 - x2) < 1) {
                        x1 = x1 < x2 ? x1 - 1 : x1 + 1;
                    }
                    if (Math.abs(y1 - y2) < 1) {
                        y1 = y1 < y2 ? y1 - 1 : y1 + 1;
                    }
                    var m = (y2 - y1) / (x2 - x1);
                    var c = y1 - m * x1;
                    var minValue = _frame.information.minValue;
                    var maxValue = _frame.information.maxValue;
                    var furtherstLeft = -_canvasWidth / _histogram.length * 1000000;
                    var furtherstRight = _canvasWidth / _histogram.length * 1000000;
                    var from = Math.max(furtherstLeft, -c / m);
                    var to = Math.min(furtherstRight, (_canvasHeight - c) / m);
                    // invert if the slope is in negative.
                    _frame.inverted =
                        _invert.checked = (m < 0);
                    var width = Math.abs(to - from) * _histogram.length / _canvasWidth;
                    var center = ((to + from) >> 1) * _histogram.length / _canvasWidth;
                    center = Math.round(center - _frame.information.autoScaleIntercept);
                    width = Math.round(width / _frame.information.autoScaleSlope);
                    _widthInput.value = width.toString();
                    _centerInput.value = center.toString();
                    if (_frame != null) {
                        _frame.setWindowLevel(width, center);
                    }
                    drawHistogram(_histogram);
                }
                function findboundariesPoints(intersect) {
                    var margin = 5;
                    var canvasWidth = _canvasWidth;
                    var canvasHeight = _canvasHeight - margin;
                    var p1 = _canvas.point1;
                    var p2 = _canvas.point2;
                    var points = [];
                    if (Math.abs(p2.y - p1.y) < 0.0001) {
                        points[0] = { x: 0, y: p1.y };
                        points[1] = { x: canvasWidth, y: p1.y };
                        return points;
                    }
                    if (Math.abs(p2.x - p1.x) < 0.0001) {
                        points[0] = { x: p1.x, y: 0 };
                        points[1] = { x: p1.x, y: canvasHeight };
                        return points;
                    }
                    var m = (p2.y - p1.y) / (p2.x - p1.x);
                    var c = p1.y - m * p1.x;
                    var pointLeft = { x: 0, y: c };
                    var pointRight = { x: canvasWidth, y: m * canvasWidth + c };
                    var pointTop = { x: (canvasHeight - c) / m, y: canvasHeight };
                    var pointBottom = { x: (-c) / m, y: 0 };
                    var counter = 0;
                    if (inRange(pointLeft.y, 0, canvasHeight)) {
                        points[counter] = pointLeft;
                        counter++;
                    }
                    if (inRange(pointRight.y, 0, canvasHeight)) {
                        points[counter] = pointRight;
                        counter++;
                    }
                    if (inRange(pointTop.x, 1, canvasWidth - 1)) {
                        points[counter] = pointTop;
                        counter++;
                    }
                    if (inRange(pointBottom.x, 1, canvasWidth - 1)) {
                        points[counter] = pointBottom;
                        counter++;
                    }
                    if (counter < 2) {
                        points = [_canvas.point1, _canvas.point2];
                    }
                    if (intersect) {
                        var intersectPoints = [];
                        counter = 0;
                        var rect = lt.LeadRectD.fromLTRB(_canvas.point1.x, _canvas.point1.y, _canvas.point2.x, _canvas.point2.y);
                        for (var i = 0; i < points.length; i++) {
                            if (rect.contains(points[i].x, points[i].y)) {
                                intersectPoints[counter] = points[i];
                                counter++;
                            }
                        }
                        points = intersectPoints;
                    }
                    return points;
                }
                // Restriction on how the points should not go outside the histogram area.
                // we need less restriction to allow a more freely movable line.
                function RestrictToHistogramArea(point, difference) {
                    var clientX = point.x;
                    var clientY = point.y;
                    var margin = 5;
                    var maxX = _canvas.width - 1 - (margin << 1);
                    var maxY = _canvas.height - 1 - (margin << 1);
                    if (clientX < 0)
                        clientX = 0;
                    if (clientX > maxX)
                        clientX = maxX;
                    if (clientY < 0)
                        clientY = 0;
                    if (clientY > maxY)
                        clientY = maxY;
                    var newPoint2X = clientX + difference.x;
                    var newPoint2Y = clientY + difference.y;
                    if (newPoint2X < 0)
                        newPoint2X = 0;
                    if (newPoint2X > maxX)
                        newPoint2X = maxX;
                    if (newPoint2Y < 0)
                        newPoint2Y = 0;
                    if (newPoint2Y > maxY)
                        newPoint2Y = maxY;
                    clientX = newPoint2X - difference.x;
                    clientY = newPoint2Y - difference.y;
                    point.x = clientX;
                    point.y = clientY;
                }
                function fixCurve() {
                    var points = findboundariesPoints(true);
                    var handles = [_canvas.point1, _canvas.point2];
                    var margin = 5;
                    var rect = lt.LeadRectD.fromLTRB(0, 0, _canvas.width - (margin >> 1), _canvas.height - (margin >> 1));
                    var counter = 0;
                    for (var i = 0; i < 2; i++) {
                        if (!rect.contains(handles[i].x, handles[i].y)) {
                            handles[i] = points[counter++];
                        }
                    }
                    _canvas.point1 = handles[0];
                    _canvas.point2 = handles[1];
                    drawHistogram(_histogram);
                }
                function invertCurve(args) {
                    if (!_canvas)
                        return;
                    var x = (_canvas.point2.x + _canvas.point1.x) / 2;
                    var y = (_canvas.point2.y + _canvas.point1.y) / 2;
                    _canvas.point1.x = (x - _canvas.point1.x) + x;
                    _canvas.point2.x = (x - _canvas.point2.x) + x;
                    if (_frame)
                        _frame.inverted = _invert.checked;
                    drawHistogram(_histogram);
                }
                function mouseMove(args) {
                    if (_mouseDown) {
                        var parentDiv = document.getElementById("mainView");
                        var dialog = parentDiv.getElementsByClassName("modlessDialog")[0];
                        var clientX = (args.clientX - _offsetX);
                        var clientY = (args.clientY - _offsetY);
                        dialog.style.left = clientX + "px";
                        dialog.style.top = clientY + "px";
                    }
                    if (_histogramMouseDown) {
                        var position = lt.LTHelper.getPosition(_canvas, null);
                        var originalClientX = args.clientX - _margin;
                        var originalClientY = args.clientY - _margin;
                        var offsetX = (originalClientX - position.x);
                        var offsetY = _canvasHeight - (originalClientY - position.y);
                        var clientX = offsetX - _offsetX;
                        var clientY = offsetY - _offsetY;
                        //clientX = Math.max(0, Math.min(_canvasWidth, clientX));
                        //clientY = Math.max(0, Math.min(_canvasHeight, clientY));
                        switch (_histogramHitTest) {
                            case 0:
                                _canvas.point1.x = clientX;
                                _canvas.point1.y = clientY;
                                OnPointUpdated();
                                break;
                            case 1:
                                _canvas.point2.x = clientX;
                                _canvas.point2.y = clientY;
                                OnPointUpdated();
                                break;
                            case 2:
                                var difference = { x: _canvas.point2.x - _canvas.point1.x, y: _canvas.point2.y - _canvas.point1.y };
                                var point1 = { x: clientX, y: clientY };
                                RestrictToHistogramArea(point1, difference);
                                _canvas.point1.x = point1.x;
                                _canvas.point1.y = point1.y;
                                _canvas.point2.x = _canvas.point1.x + difference.x;
                                _canvas.point2.y = _canvas.point1.y + difference.y;
                                OnPointUpdated();
                                break;
                        }
                    }
                }
                function getPoint(pointIndex) {
                    switch (pointIndex) {
                        case 0:
                            return _canvas.point1;
                        case 1:
                            return _canvas.point2;
                    }
                    return null;
                }
                // this fixes the point that is outside the canvas range and put it back in.
                function fixPoint(pointIndex) {
                    var points = findboundariesPoints(true);
                    var margin = 5;
                    var canvasWidth = _canvasWidth;
                    var canvasHeight = _canvasHeight - margin;
                    // get the point in question.
                    var point = getPoint(pointIndex);
                    if (!point)
                        return;
                    // the rect that represents the canvas area.
                    var rect = lt.LeadRectD.create(0, 0, canvasWidth, canvasHeight);
                    // the point is already inside... no need to change anything.
                    if (rect.contains(point.x, point.y))
                        return;
                    // something is wrong here.. no intersection at all ???!!!
                    if (points.length == 0)
                        return;
                    // find the closest point that lay on the ranged area.
                    var minimumDistance = calculatePointsDistance(points[0], point);
                    var closestPoint = points[0];
                    for (var i = 1; i < points.length; i++) {
                        var newDistance = calculatePointsDistance(points[i], point);
                        if (newDistance < minimumDistance) {
                            minimumDistance = newDistance;
                            closestPoint = points[i];
                        }
                    }
                    point.x = closestPoint.x;
                    point.y = closestPoint.y;
                    drawHistogram(_histogram);
                }
                function OnPointUpdated() {
                    calculatePointDistance();
                    calculateWidthCenter();
                    drawHistogram(_histogram);
                }
                function calculatePointsDistance(point1, point2) {
                    var dx = point2.x - point1.x;
                    var dy = point2.y - point1.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                function calculatePointDistance() {
                    _pointDistance = calculatePointsDistance(_canvas.point1, _canvas.point2);
                }
                function closeModlessDialog(dialog) {
                    if (dialog != null) {
                        var titlebar = dialog.getElementsByClassName("modelssDialog-titlebar")[0];
                        if (titlebar != null) {
                            var closeButton = titlebar.children.item(1);
                            if (closeButton != null) {
                                closeButton.removeEventListener('click', closeDialog);
                                closeButton.removeEventListener('mousedown', mouseDown, false);
                            }
                            titlebar.removeEventListener('mousedown', mouseDown, false);
                        }
                        document.removeEventListener('mousemove', dialog.mouseMove, false);
                        document.removeEventListener('mouseup', dialog.histogramMouseUp);
                        if (cell)
                            cell.viewer.remove_selectionChanged(selectionChanged);
                        _canvas = dialog.getElementsByClassName("histogram")[0];
                        if (_canvas)
                            _canvas.removeEventListener("mousedown", mouseDownHistogram, true);
                        var parent = dialog.parentElement;
                        parent.removeChild(dialog);
                    }
                }
                function histogramMouseUp(args) {
                    var dialog = parentDiv.getElementsByClassName("modlessDialog")[0];
                    window.localStorage.setItem("Histogram.Position.X", dialog.offsetLeft.toString());
                    window.localStorage.setItem("Histogram.Position.Y", dialog.offsetTop.toString());
                    fixPoint(_histogramHitTest);
                    if (_histogramHitTest == -1)
                        fixCurve();
                    _mouseDown = false;
                    _histogramMouseDown = false;
                    _histogramHitTest = -1;
                }
                function closeDialog() {
                    var parentDiv = document.getElementById("mainView");
                    var dialog = parentDiv.getElementsByClassName("modlessDialog")[0];
                    closeModlessDialog(dialog);
                }
                function resetButton() {
                    _pointDistance = 0;
                    _frame.setWindowLevel(_frame.defaultWindowLevelWidth, _frame.defaultWindowLevelCenter);
                }
                function scrollChanged() {
                    var frame = cell.get_selectedItem().attachedFrame;
                    _histogram = lt.Controls.Medical.ImageProcessing.getHistogram(frame);
                    selectionChanged(cell, null);
                    var margin = 5;
                    _canvasWidth = _canvas.width - (margin << 1);
                    _canvasHeight = _canvas.height - (margin << 1);
                    histogramInputChanged(null);
                    fixCurve();
                }
                if (cell) {
                    {
                        var div = document.createElement("div");
                        div.id = "histogramBox";
                        div.className = "modlessDialog";
                        $(div).load("views/histogramBox.html", function () {
                            var positionX = parseInt(window.localStorage.getItem("Histogram.Position.X"));
                            var positionY = parseInt(window.localStorage.getItem("Histogram.Position.Y"));
                            if (parentDiv.clientWidth < positionX + div.clientWidth) {
                                positionX = parentDiv.clientWidth - div.clientWidth;
                            }
                            if (parentDiv.clientHeight < positionY + div.clientHeight) {
                                positionY = parentDiv.clientHeight - div.clientHeight;
                            }
                            if (positionX < 0) {
                                positionX = 1;
                            }
                            if (positionY < 0) {
                                positionY = 1;
                            }
                            div.style.left = positionX ? positionX + "px" : "100px";
                            div.style.top = positionY ? positionY + "px" : "100px";
                            parentDiv.appendChild(div);
                            var titlebar = div.getElementsByClassName("modelssDialog-titlebar")[0];
                            // 4
                            var closeButton = titlebar.children.item(1);
                            closeButton.addEventListener('click', closeDialog);
                            closeButton.addEventListener('mousedown', mouseDown, false);
                            // 1
                            titlebar.addEventListener('mousedown', mouseDown, false);
                            // 2
                            document.addEventListener('mousemove', mouseMove);
                            // 3
                            document.addEventListener('mouseup', histogramMouseUp);
                            div.mouseMove = mouseMove;
                            div.histogramMouseUp = histogramMouseUp;
                            var button = document.getElementById('resetWindowLevel');
                            button.addEventListener('click', resetButton);
                            // 5
                            cell.viewer.add_selectionChanged(selectionChanged);
                            _canvas = div.getElementsByClassName("histogram")[0];
                            // 6
                            _canvas.addEventListener("mousedown", mouseDownHistogram, true);
                            _widthInput = div.getElementsByClassName("modelssDialog-input")[0];
                            _widthInput.addEventListener('input', histogramInputChanged);
                            _centerInput = div.getElementsByClassName("modelssDialog-input")[1];
                            _centerInput.addEventListener('input', histogramInputChanged);
                            _invert = div.getElementsByClassName("checkmark")[0].parentElement.children[0];
                            _invert.addEventListener("change", invertCurve);
                            _fromText = div.getElementsByClassName("windowLevelRange")[0];
                            _toText = div.getElementsByClassName("windowLevelRange")[1];
                            var frame = cell.get_selectedItem().attachedFrame;
                            _histogram = lt.Controls.Medical.ImageProcessing.getHistogram(frame);
                            cell.add_scrollChanged(scrollChanged);
                            selectionChanged(cell, null);
                            var margin = 5;
                            _canvasWidth = _canvas.width - (margin << 1);
                            _canvasHeight = _canvas.height - (margin << 1);
                            histogramInputChanged(null);
                            fixCurve();
                            //var tool = new HistogramToolBox(dialog);
                            //tool.close();
                            eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                                var parentDiv = document.getElementById("mainView");
                                var dialog = parentDiv.getElementsByClassName("modlessDialog")[0];
                                closeModlessDialog(dialog);
                            });
                        });
                    }
                }
            }
        };
    }]);
commangular.command('Cephalometric', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                MakeRoomFor(cell.viewer, 1);
                var derivative = new lt.Controls.Medical.CephalometricCell(cell.viewer, cell, cell.divID);
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                var engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService, true);
                var action = derivative.getCommand(MedicalViewerAction.WindowLevel);
                action.serverSideRendering = true;
                var overlay = new lt.Controls.Medical.OverlayText();
                overlay.alignment = lt.Controls.Medical.OverlayAlignment.topLeft;
                overlay.positionIndex = 10;
                overlay.type = lt.Controls.Medical.OverlayTextType.volumeBrightnessContrast;
                derivative.overlays.add(overlay);
                derivative.onSizeChanged();
                for (var i = 0; i < derivative.overlays.count; i++) {
                    overlay = derivative.overlays.get_item(i);
                    if (overlay.type == lt.Controls.Medical.OverlayTextType.windowLevel) {
                        derivative.overlays.removeAt(i);
                        break;
                    }
                }
                if (engine) {
                    engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                }
            }
        };
    }]);
commangular.command('CutLine', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var firstCell = false;
                var secondCell = false;
                var engine = null;
                var cutline = null;
                if (!cell.drawables["CutLine"]) {
                    cell.drawables["CutLine"] = new lt.Controls.Medical.CutLines(cell);
                }
                MakeRoomFor(cell.viewer, 2);
                cutline = cell.drawables["CutLine"];
                cell.invalidate(lt.LeadRectD.empty);
                firstCell = (cutline.firstLineCell != null);
                secondCell = (cutline.secondLineCell != null);
                if (!firstCell) {
                    var derivative = new lt.Controls.Medical.Derivative3D(cell.viewer, cell, lt.Controls.Medical.RenderingType.server, cell.divID, 1, 1);
                    derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                    derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                    engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                    cutline.firstLineCell = derivative;
                }
                if (!secondCell) {
                    var derivative = new lt.Controls.Medical.Derivative3D(cell.viewer, cell, lt.Controls.Medical.RenderingType.server, cell.divID, 1, 1);
                    derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                    derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                    engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                    cutline.secondLineCell = derivative;
                }
                if (engine) {
                    engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                }
            }
        };
    }]);
commangular.command('RotationTool', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', 'queryArchiveService', 'optionsService', 'overlayManagerService', function (seriesManagerService, $modal, toolbarService, tabService, buttonId, queryArchiveService, optionsService, overlayManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var cell = FindGeneratorCell(cell);
                var cells = FindRelatedCells(cell);
                var hide = false;
                var length = cells.length;
                var derivativeCell;
                for (var index = 0; index < length; index++) {
                    derivativeCell = cells[index];
                    if (derivativeCell.drawables["RotationTool"]) {
                        hide = true;
                        var rotatationTool = cells[index].drawables["RotationTool"];
                        if (rotatationTool) {
                            cell.derivatives.remove(derivativeCell);
                            derivativeCell.dispose();
                        }
                    }
                }
                if (hide)
                    return;
                MakeRoomFor(cell.viewer, 3);
                cell.drawCrossHairLines = false;
                var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, lt.Controls.Medical.RenderingType.server, lt.Controls.Medical.CellMPRType.coronal);
                cells = [];
                cells.add(derivative);
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                derivative.drawCrossHairLines = false;
                var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, lt.Controls.Medical.RenderingType.server, lt.Controls.Medical.CellMPRType.sagittal);
                cells.add(derivative);
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                derivative.drawCrossHairLines = false;
                var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, lt.Controls.Medical.RenderingType.server, lt.Controls.Medical.CellMPRType.axial);
                cells.add(derivative);
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                var engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                derivative.drawCrossHairLines = false;
                var length = cells.length;
                for (var index = 0; index < length; index++) {
                    cells[index].drawables["RotationTool"] = new lt.Controls.Medical.RotationTool();
                    var rotatationTool = cells[index].drawables["RotationTool"];
                    rotatationTool.cells = cells;
                }
                cell.invalidate(lt.LeadRectD.empty);
                if (engine) {
                    engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                }
            }
        };
    }
]);
commangular.command('OnCrossHair', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', function (seriesManagerService, $modal, toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                enumerateCell(tabService, function (cell) {
                    cell.drawCrossHairLines = !cell.drawCrossHairLines;
                });
            }
        };
    }]);
commangular.command('OnCursor3D', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'buttonId', function (seriesManagerService, $modal, toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Cursor3D, buttonId, false);
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.Cursor3D, buttonId);
                });
            }
        };
    }]);
commangular.command('Compose', ['toolbarService', 'tabService', 'buttonId', 'authenticationService', function (toolbarService, tabService, buttonId, authenticationService) {
        return {
            execute: function () {
                var tab = tabService.selectedTab;
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var canSaveHangingProtocol = authenticationService.hasPermission(PermissionNames.CanSaveHangingProtocol);
                var canSaveStructuredDisplay = authenticationService.hasPermission(PermissionNames.CanSaveStructuredDisplay);
                if (!(canSaveStructuredDisplay && canSaveHangingProtocol))
                    return;
                toolbarService.enable('DeleteStudyStructuredDisplay' + tab.id, function () {
                    return canSaveStructuredDisplay;
                });
                toolbarService.enable('SaveStructuredDisplay' + tab.id, function () {
                    return canSaveStructuredDisplay;
                });
                toolbarService.enable('HangingProtocol' + tab.id, function () {
                    return canSaveHangingProtocol;
                });
                if (controller.isComposing) {
                    toolbarService.unpress('LayoutCompose' + tab.id);
                    toolbarService.hide(['MergeCells' + tab.id, 'SaveStructuredDisplay' + tab.id, 'DeleteStudyStructuredDisplay' + tab.id, 'HangingProtocol' + tab.id]);
                    toolbarService.disable('MergeCells' + tab.id);
                    if (!controller['reShowTimeLine'])
                        controller.hideTimeLine();
                }
                else {
                    toolbarService.press('LayoutCompose' + tab.id);
                    toolbarService.show(['MergeCells' + tab.id, 'SaveStructuredDisplay' + tab.id, 'DeleteStudyStructuredDisplay' + tab.id, 'HangingProtocol' + tab.id]);
                    toolbarService.enable("DeleteStudyStructuredDisplay" + tab.id, function () {
                        return controller.hasLayout();
                    });
                    controller['reShowTimeLine'] = controller.isTimeLineShowing();
                    controller.showTimeLine();
                }
                controller.isComposing = !controller.isComposing;
            }
        };
    }]);
commangular.command('MergeCells', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                var tab = tabService.selectedTab;
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                controller.mergeSelectedCells();
            }
        };
    }]);
commangular.command('DeleteStudyStructuredDisplay', ['toolbarService', 'tabService', 'objectStoreService', '$translate', 'dialogs', function (toolbarService, tabService, objectStoreService, $translate, dialogs) {
        return {
            execute: function () {
                var tab = tabService.selectedTab;
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var studyLayout = controller.getStudyLayout();
                var message, failedMessage;
                var title, errorTitle;
                $translate('NOTIFY_DELETE_STUDYLAYOUT_FAILED').then(function (translation) {
                    failedMessage = translation;
                });
                $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                    title = translation;
                });
                $translate('DIALOGS_ERROR').then(function (translation) {
                    errorTitle = translation;
                });
                objectStoreService.DeleteStudyLayout(studyLayout['studyInstanceUID']).then(function (result) {
                    if (angular.isDefined(result.data) && angular.isDefined(result.data.Message)) {
                        dialogs.error(errorTitle, result.data.Message);
                    }
                    else {
                        $translate('NOTIFY_DELETE_STUDYLAYOUT_SUCCESS').then(function (translation) {
                            dialogs.notify(title, translation);
                        });
                        controller.clearLayout();
                        toolbarService.enable("DeleteStudyStructuredDisplay" + tab.id, function () {
                            return false;
                        });
                    }
                }, function (error) {
                    dialogs.error(errorTitle, error);
                });
            }
        };
    }]);
commangular.command('HangingProtocol', ['toolbarService', 'tabService', 'buttonId', '$modal', 'seriesManagerService', 'objectStoreService', '$translate', 'dialogs', function (toolbarService, tabService, buttonId, $modal, seriesManagerService, objectStoreService, $translate, dialogs) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var cell = seriesManagerService.get_activeCell();
                var modalInstance;
                var metadata = null;
                var primaryCell = HangingProtocolHelper.get_PrimaryCell(cell.viewer, seriesManagerService);
                var hp;
                var viewer = cell.viewer;
                var title;
                var successMessage;
                if (primaryCell.frames.count > 0) {
                    var frame = primaryCell.frames.item(0);
                    metadata = frame['metadata'];
                }
                $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                    title = translation;
                });
                $translate('NOTIFY_SAVE_HP_SUCCESS').then(function (translation) {
                    successMessage = translation;
                });
                hp = HangingProtocolHelper.get_HangingProtocol(primaryCell.viewer, primaryCell, metadata);
                modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/HangingProtocol.html',
                    controller: Controllers.HPDialogControllerScope,
                    backdrop: 'static',
                    resolve: {
                        dataset: function () {
                            return metadata;
                        },
                        hp: function () {
                            return hp;
                        }
                    }
                });
                modalInstance.result.then(function () {
                    angular.forEach(hp.DisplaySets, function (displaySet, index) {
                        delete displaySet['cell'];
                        delete displaySet['metadata'];
                    });
                    angular.forEach(hp.ImageSetsSequence, function (imageSet, index) {
                        delete imageSet['metadata'];
                    });
                    viewer.layout.highlightedItems.clear();
                    objectStoreService.StoreHangingProtocol(hp).success(function (response) {
                        if (angular.isDefined(response.FaultType)) {
                            alert(response.Message);
                        }
                        else {
                            dialogs.notify(title, successMessage);
                        }
                    }).
                        error(function (error) {
                        alert(error);
                    });
                }, function () {
                    viewer.layout.highlightedItems.clear();
                });
            }
        };
    }]);
commangular.command('SaveStructuredDisplay', ['seriesManagerService', 'eventService', 'tabService', 'objectStoreService', 'dialogs', '$translate', 'toolbarService', function (seriesManagerService, eventService, tabService, objectStoreService, dialogs, $translate, toolbarService) {
        return {
            execute: function () {
                var studyLayout = new Models.StudyLayout();
                var medicalViewer = tabService.getActiveViewer();
                var studyInstanceUID = '';
                var title = '';
                var message = '';
                var number = 1;
                var activeStudyInstanceUID = tabService.get_tabData(tabService.selectedTab.id, TabDataKeys.LaunchingStudy);
                $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                    title = translation;
                });
                $translate('NOTIFY_STRUCTUREDDISPLAY_SUCCESS').then(function (translation) {
                    message = translation;
                });
                if (medicalViewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
                    studyLayout.Rows = medicalViewer.gridLayout.rows;
                    studyLayout.Columns = medicalViewer.gridLayout.columns;
                }
                enumerateCell(tabService, function (cell) {
                    var seriesItem = new Models.SeriesInfo();
                    var box = HangingProtocolHelper.get_cellImageBox(cell, number);
                    var series = seriesManagerService.get_seriesInfo(cell.seriesInstanceUID);
                    var instances = seriesManagerService.get_instances(cell.seriesInstanceUID, cell.divID);
                    var activeFrame = HangingProtocolHelper.get_activeFrame(cell);
                    // Display Set Horizontal Justification (Optional)
                    box.HorizontalJustification = HangingProtocolHelper.ConvertToFrameHorizontalJustication(activeFrame.horizontalAlignment);
                    // Display Set Vertical Justification (Optional)        
                    box.VerticalJustification = HangingProtocolHelper.ConvertToFrameVerticalJustication(activeFrame.verticalAlignment);
                    seriesItem.AnnotationData = seriesManagerService.get_cellAnnotations(cell, false);
                    if (!activeStudyInstanceUID && series) {
                        activeStudyInstanceUID = series.StudyInstanceUID;
                    }
                    seriesItem.StudyInstanceUID = series.StudyInstanceUID;
                    seriesItem.SeriesInstanceUID = cell.seriesInstanceUID;
                    if (series.StudyInstanceUID == activeStudyInstanceUID) {
                        studyLayout.SeriesPush(seriesItem);
                    }
                    else {
                        var otherStudies = $.grep(studyLayout.OtherStudies, function (item) {
                            return item.StudyInstanceUID == series.StudyInstanceUID;
                        });
                        var study;
                        if (otherStudies.length > 0) {
                            study = otherStudies[0];
                        }
                        else {
                            study = new Models.OtherStudies();
                            study.StudyInstanceUID = series.StudyInstanceUID;
                            studyLayout.OtherStudies.push(study);
                        }
                        study.Series.push(seriesItem);
                    }
                    seriesItem.ImageBoxNumber = box.ImageBoxNumber;
                    studyLayout.Boxes.push(box);
                    number++;
                });
                enumerateEmptyCell(tabService, function (cell) {
                    var box = new Models.ImageBox();
                    var seriesItem = new Models.SeriesInfo();
                    box.Position = HangingProtocolHelper.get_position(cell.bounds);
                    box.ImageBoxNumber = number;
                    if (medicalViewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
                        box.RowPosition = cell.rowPosition;
                        box.ColumnPosition = cell.columnsPosition;
                        box.NumberOfRows = cell.numberOfRows;
                        box.NumberOfColumns = cell.numberOfColumns;
                    }
                    studyLayout.Boxes.push(box);
                    number++;
                });
                objectStoreService.StoreStudyLayout(activeStudyInstanceUID, studyLayout).success(function (response) {
                    if (angular.isDefined(response.FaultType)) {
                        alert(response.Message);
                    }
                    else {
                        var controller = tabService.get_tabData(tabService.selectedTab.id, TabDataKeys.ViewController);
                        controller.setStudyLayout(studyLayout);
                        dialogs.notify(title, message);
                        toolbarService.enable("DeleteStudyStructuredDisplay" + tabService.selectedTab.id, function () {
                            return true;
                        });
                    }
                }).
                    error(function (error) {
                    alert(error);
                });
            }
        };
    }]);
commangular.command('ImageAlignLeft', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell) {
                    var linked = cell.get_linked();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.left;
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.left;
                    }
                }
            }
        };
    }]);
commangular.command('ImageAlignRight', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                if (cell) {
                    var linked = cell.get_linked();
                    if (linked) {
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            frame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.right;
                        });
                    }
                    else {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.right;
                    }
                }
            }
        };
    }]);
commangular.command('ImageAlignCenter', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var linked = cell.get_linked();
                if (linked) {
                    seriesManagerService.enumerateFrames(cell, function (cellFrame, index) {
                        cellFrame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.middle;
                    });
                }
                else {
                    var cellFrame = seriesManagerService.get_activeCellFrame();
                    cellFrame.horizontalAlignment = lt.Controls.Medical.HorizontalAlignmentType.middle;
                }
            }
        };
    }]);
commangular.command('ImageAlignTop', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var linked = cell.get_linked();
                if (linked) {
                    seriesManagerService.enumerateFrames(cell, function (cellFrame, index) {
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.top;
                    });
                }
                else {
                    if (cell) {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.top;
                    }
                }
            }
        };
    }]);
commangular.command('ImageAlignBottom', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var linked = cell.get_linked();
                if (linked) {
                    seriesManagerService.enumerateFrames(cell, function (cellFrame, index) {
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.bottom;
                    });
                }
                else {
                    if (cell) {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.bottom;
                    }
                }
            }
        };
    }]);
commangular.command('ImageAlignMiddle', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var linked = cell.get_linked();
                if (linked) {
                    seriesManagerService.enumerateFrames(cell, function (cellFrame, index) {
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.middle;
                    });
                }
                else {
                    if (cell) {
                        var cellFrame = seriesManagerService.get_activeCellFrame();
                        cellFrame.verticalAlignment = lt.Controls.Medical.VerticalAlignmentType.middle;
                    }
                }
            }
        };
    }]);
function copyOverlays(mprCell, cell) {
    var length = cell.get_overlays().get_count();
    var index = 0;
    var overlay;
    var newOverlay;
    for (index = 0; index < length; index++) {
        overlay = cell.get_overlays().get_item(index);
        newOverlay = new lt.Controls.Medical.OverlayText();
        if (overlay.type == lt.Controls.Medical.OverlayTextType.userData)
            newOverlay.text = overlay.text;
        newOverlay.type = overlay.type;
        newOverlay.positionIndex = overlay.positionIndex;
        newOverlay.weight = overlay.weight;
        newOverlay.color = overlay.color;
        newOverlay.alignment = overlay.alignment;
        mprCell.get_overlays().add(newOverlay);
    }
}
function reArrangeCellBasedOnMPRType(mprCell, mprType) {
    switch (mprType) {
        case lt.Controls.Medical.CellMPRType.sagittal:
            mprCell.rowPosition = 1;
            mprCell.columnsPosition = -1;
            break;
        case lt.Controls.Medical.CellMPRType.coronal:
            mprCell.rowPosition = 1;
            mprCell.columnsPosition = -1;
            break;
        case lt.Controls.Medical.CellMPRType.axial:
            mprCell.rowPosition = 0;
            mprCell.columnsPosition = -1;
            break;
    }
}
function find3DObject(medicalViewer, cell) {
    var index = 0;
    var length = medicalViewer.layout.get_items().get_count();
    var cell;
    for (index = 0; index < length; index++) {
        var currentCell = medicalViewer.layout.get_items().get_item(index);
        if (currentCell instanceof lt.Controls.Medical.Cell3D) {
            if ((currentCell.stackInstanceUID == cell.stackInstanceUID) && (currentCell.seriesInstanceUID == cell.seriesInstanceUID))
                return currentCell;
        }
    }
    return null;
}
function GetMPRFramePosition(cell, mprType) {
    if (cell.mprType == mprType)
        return cell.currentOffset;
    if (cell.derivatives != null) {
        if (cell.derivatives.get_item(0) != null) {
            if (cell.derivatives.get_item(0).mprType == mprType)
                return cell.derivatives.get_item(0).currentOffset;
        }
        if (cell.derivatives.get_item(1) != null) {
            if (cell.derivatives.get_item(1).mprType == mprType)
                return cell.derivatives.get_item(1).currentOffset;
        }
    }
    return -1;
}
function ConnectMPRWith3DObject(cell, parentCell, viewer, queryArchiveService) {
    if (queryArchiveService != null) {
        cell.add_currentOffsetChanged(function () {
            var cell3D = find3DObject(viewer, parentCell);
            if (cell3D == null)
                return;
            cell3D.beginUpdate();
            cell3D.MPR.axialPosition = GetMPRFramePosition(parentCell, lt.Controls.Medical.CellMPRType.axial);
            cell3D.MPR.sagittalPosition = GetMPRFramePosition(parentCell, lt.Controls.Medical.CellMPRType.sagittal);
            cell3D.MPR.coronalPosition = GetMPRFramePosition(parentCell, lt.Controls.Medical.CellMPRType.coronal);
            cell3D.endUpdate();
        });
    }
}
//function createMPRCell(objectRetrieveService: ObjectRetrieveService, queryArchiveService: QueryArchiveService, seriesManagerService: SeriesManagerService, viewer: lt.Controls.Medical.MedicalViewer, cell: lt.Controls.Medical.Cell, mprType: lt.Controls.Medical.CellMPRType, eventService: EventService, serverSideRendering : boolean) {
//    var cellName = 'MedicalCell' + Date.now();
//    var tab1: Models.Tab = seriesManagerService.get_seriesTab(cell.get_seriesInstanceUID());
//    var seriesInfo = seriesManagerService.get_seriesInfo(cell.get_seriesInstanceUID());
//    var seriesInstanceUID = cell.get_seriesInstanceUID();
//    switch (mprType) {
//        case lt.Controls.Medical.CellMPRType.sagittal:
//            seriesInstanceUID += "_Sagittal";
//            cellName = cell.divID + "_Sagittal";
//            break;
//        case lt.Controls.Medical.CellMPRType.coronal:
//            seriesInstanceUID += "_Coronal";
//            cellName = cell.divID + "_Coronal";
//            break;
//        case lt.Controls.Medical.CellMPRType.axial:
//            seriesInstanceUID += "_Axial";
//            cellName = cell.divID + "_Axial";
//            break;
//    }
//    var newSeriesInfo = jQuery.extend(true, {}, seriesInfo);
//    newSeriesInfo.InstanceUID = seriesInstanceUID;
//    seriesManagerService.set_seriesTab(seriesInstanceUID, tab1);
//    seriesManagerService.set_seriesInfo(seriesInstanceUID, newSeriesInfo);
//    seriesManagerService.set_activeCell(cellName);
//    var mprCell = new lt.Controls.Medical.MPRCell_old(cell, mprType, cellName, false);
//    mprCell.add_frameRequested(function (sender, args: lt.Controls.Medical.MPRFrameRequestedEventArgs) {
//        var cell3D: lt.Controls.Medical.Cell3D = (<any>cell).cell3D;
//        if (cell3D.object3D.volumeReady)
//            args.image.src = objectRetrieveService.GetMPRFrame(cell3D.object3D.id, args.mprType, args.index);
//    });
//    mprCell.tickBoxes[0].visible = false;
//    reArrangeCellBasedOnMPRType(mprCell, mprType);
//    mprCell.frameOfReferenceUID = cell.frameOfReferenceUID;
//    ConnectMPRWith3DObject(mprCell, cell, viewer, queryArchiveService);
//    mprCell.overlayTextVisible = cell.overlayTextVisible;
//    var castViewer: any = viewer;
//    var series: MedicalViewerSeries = new MedicalViewerSeries(newSeriesInfo.InstanceUID, "", "", 1, 1);
//    series.seriesInstanceUID = newSeriesInfo.InstanceUID;
//    series.link = cell.get_linked();
//    castViewer.InitializeCell(mprCell, series);
//    CommandManager.RunCommand(mprCell, CommandManager.LastCommand.Action, CommandManager.LastCommand.ButtonID);
//    return mprCell;
//}
var _seriesManagerService;
function MakeRoomFor(viewer, roomFor) {
    var desiredNumber = viewer.layout.items.count + roomFor;
    if (roomFor == 0)
        return;
    if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
        if (desiredNumber >= viewer.gridLayout.rows * viewer.gridLayout.columns) {
            var rows = Math.round(Math.sqrt(desiredNumber));
            var col = Math.ceil(desiredNumber / rows);
            viewer.layout.beginUpdate();
            viewer.gridLayout.rows = rows;
            viewer.gridLayout.columns = col;
            viewer.layout.endUpdate();
        }
    }
}
function createMPRCell(objectRetrieveService, queryArchiveService, seriesManagerService, overlayManagerService, optionsService, viewer, cell, mprType, eventService, serverSideRendering) {
    var cellName = 'MedicalCell' + Date.now();
    var tab1 = seriesManagerService.get_seriesTab(cell.get_seriesInstanceUID());
    var seriesInfo = seriesManagerService.get_seriesInfo(cell.get_seriesInstanceUID());
    var seriesInstanceUID = cell.get_seriesInstanceUID();
    switch (mprType) {
        case lt.Controls.Medical.CellMPRType.sagittal:
            seriesInstanceUID += "_Sagittal";
            cellName = cell.divID + "_Sagittal";
            break;
        case lt.Controls.Medical.CellMPRType.coronal:
            seriesInstanceUID += "_Coronal";
            cellName = cell.divID + "_Coronal";
            break;
        case lt.Controls.Medical.CellMPRType.axial:
            seriesInstanceUID += "_Axial";
            cellName = cell.divID + "_Axial";
            break;
    }
    var newSeriesInfo = jQuery.extend(true, {}, seriesInfo);
    newSeriesInfo.InstanceUID = seriesInstanceUID;
    seriesManagerService.set_seriesTab(seriesInstanceUID, tab1);
    seriesManagerService.set_seriesInfo(seriesInstanceUID, newSeriesInfo);
    seriesManagerService.set_activeCell(cellName);
    var renderingType = serverSideRendering ? lt.Controls.Medical.RenderingType.server : lt.Controls.Medical.RenderingType.client;
    var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, renderingType, lt.Controls.Medical.CellMPRType.sagittal);
    derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
    derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
    InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
}
function VolumeWithMPR(seriesManagerService, $modal, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService, volumeType) {
    var tab = tabService.get_allTabs()[tabService.activeTab];
    var currentController = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
    var side = (optionsService.get(OptionNames.MPRRenderSide));
    var serverSideRendering = side.trim() == "Server Side";
    var cell = seriesManagerService.get_activeCell();
    if (cell instanceof lt.Controls.Medical.Cell3D) {
        var cell3D = cell;
        if (cell3D.object3D.progress == 100)
            cell3D.volumeType = volumeType;
        return true;
    }
    var status = lt.Controls.Medical.MPRCell.canDoMPR(cell);
    switch (status) {
        case lt.Controls.Medical.MPRStatus.imageOrientationNotTheSame:
            alert('3D view cannot be created for this cell, because each frame in the cell has a different orientation.');
            return;
        case lt.Controls.Medical.MPRStatus.ok:
            break;
        case lt.Controls.Medical.MPRStatus.cellNotValid:
            alert('You can\'t create an 3D out of this cell, image position data are not valid');
            return;
        case lt.Controls.Medical.MPRStatus.imagePositionNotReady:
            alert('The first and second position of the cell is not present');
            return;
        case lt.Controls.Medical.MPRStatus.notEnoughFrames:
            alert('the cell must have at least 3 frames to generate a 3D cell out of it');
            return;
    }
    if (currentController != null && seriesManagerService.get_activeCell() != null) {
        var viewer = currentController.getViewer();
        if (alreadyHaveA3Dobject(cell, volumeType))
            return;
        var currentCellCount = cell.derivatives.count;
        if (cell.generator != null)
            currentCellCount = cell.generator.derivatives.count;
        MakeRoomFor(viewer, Math.max(0, 2 - currentCellCount));
        Create3DObject(seriesManagerService, toolbarService, tabService, queryArchiveService, overlayManagerService, optionsService, eventService, volumeType);
        var cell = seriesManagerService.get_activeCell();
        /*if (cell instanceof lt.Controls.Medical.Cell3D) {
            cell = (<lt.Controls.Medical.Cell3D>cell).referenceCell;
            if (viewer.layout.items.indexOf(cell) == -1)
                return;
        }

        if (cell.derivatives.count != 0) {
            return;
        }



        cell.currentOffset = cell.frames.count >> 1;

        var firstCellMPRType: lt.Controls.Medical.CellMPRType;
        var secondCellMPRType: lt.Controls.Medical.CellMPRType;
        switch (cell.mprType) {

            case lt.Controls.Medical.CellMPRType.axial:
                firstCellMPRType = lt.Controls.Medical.CellMPRType.coronal;
                secondCellMPRType = lt.Controls.Medical.CellMPRType.sagittal;
                break;

            case lt.Controls.Medical.CellMPRType.coronal:
                firstCellMPRType = lt.Controls.Medical.CellMPRType.axial;
                secondCellMPRType = lt.Controls.Medical.CellMPRType.sagittal;
                break;

            case lt.Controls.Medical.CellMPRType.sagittal:
                firstCellMPRType = lt.Controls.Medical.CellMPRType.axial;
                secondCellMPRType = lt.Controls.Medical.CellMPRType.coronal;
                break;
        }

        var loadingDiv: any;


        function generateMPRCells(sender, e) {

            if (cell instanceof lt.Controls.Medical.Cell3D) {
                cell = <any>(cell).referenceCell;
            }

            var mprCell = createMPRCell(objectRetrieveService, queryArchiveService, seriesManagerService, viewer, cell, firstCellMPRType, eventService, serverSideRendering);
            copyOverlays(mprCell, cell);
            mprCell = createMPRCell(objectRetrieveService, queryArchiveService, seriesManagerService, viewer, cell, secondCellMPRType, eventService, serverSideRendering);
            copyOverlays(mprCell, cell);


            toolbarService.enable("CrossHair" + tab.id, function () {
                return cell.derivatives.count > 0;
            });

            enumerateCell(tabService, function (cell: lt.Controls.Medical.Cell) {
                cell.drawCrossHairLines = true;
            });

            loadingDiv = cell.div.getElementsByClassName('loader' + cell.div.id)[0];
            if (loadingDiv != null) {
                cell.div.removeChild(loadingDiv);
                loadingDiv.id = '';
            }
            cell.viewer.layout.selectedItem = cell;

        }


        function generateMPRLayout(sender, e) {

            generateMPRCells(sender, e);

        }

        function progressCompleted(sender, e) {

            loadingDiv = document.createElement("div");
            loadingDiv.id = 'loader';
            loadingDiv.className = 'loader' + cell.div.id;
            loadingDiv.style.width = "50px";
            loadingDiv.style.height = "50px";

            cell.div.appendChild(loadingDiv);

            if (lt.LTHelper.device == lt.LTDevice.desktop && lt.LTHelper.browser != lt.LTBrowser.internetExplorer && !serverSideRendering) {
                if (cell.frames.count > 200) {
                    cell.create3D = true;
                }
                else
                    generateMPRLayout(null, null);
            }
            else
                generateMPRLayout(null, null);



            cell.add_data3DGenerated(generateMPRLayout);
        }



        if (!serverSideRendering) {
            if (!cell.fullDownload && (!serverSideRendering)) {
                cell.fullDownload = true;
                cell.add_progressCompleted(progressCompleted);
            }
            else
                progressCompleted(null, null);

            reArrangeCellBasedOnMPRType(cell, cell.mprType);
        }
        else*/
        {
            var renderingType = serverSideRendering ? lt.Controls.Medical.RenderingType.server : lt.Controls.Medical.RenderingType.client;
            var loadingDiv;
            function createSagittalAndCorornalCells() {
                Utils.EndLoading(cell, loadingDiv);
                var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, renderingType, lt.Controls.Medical.CellMPRType.sagittal);
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                derivative.drawCrossHairLines = true;
                var derivative = new lt.Controls.Medical.MPRCell(cell.viewer, cell, cell.divID, renderingType, lt.Controls.Medical.CellMPRType.coronal);
                derivative.frameOfReferenceUID = cell.frameOfReferenceUID;
                derivative.frames.add(new lt.Controls.Medical.SliceFrame(derivative, derivative.engine));
                var engine = InitializeDerivativeCell(cell, derivative, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                derivative.drawCrossHairLines = true;
                if (engine) {
                    engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                }
            }
            cell.drawCrossHairLines = true;
            if (renderingType == lt.Controls.Medical.RenderingType.client) {
                cell.fullDownload = true;
                cell.add_progressCompleted(function () { Utils.StartLoading(cell, loadingDiv); cell.create3D = true; });
                cell.add_data3DGenerated(createSagittalAndCorornalCells);
            }
            else
                createSagittalAndCorornalCells();
        }
    }
}
commangular.command('OnMPR', ['seriesManagerService', '$modal', 'toolbarService', 'tabService', 'eventService', 'queryArchiveService', 'overlayManagerService', 'optionsService', 'objectRetrieveService', function (seriesManagerService, $modal, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService) {
        return {
            execute: function () {
            }
        };
    }]);
function toggleImageProcessing(frame, ip, items) {
    var ipList = frame.imageProcessingList.toArray();
    var ipItem = $.grep(ipList, function (item) { return item.command == ip.command; });
    removeImageProcessing(frame, items);
    if (ipItem && ipItem.length > 0) {
        frame.imageProcessingList.remove(ipItem[0]);
        return true;
    }
    else {
        frame.imageProcessingList.add(ip);
    }
    return false;
}
function removeImageProcessing(frame, items) {
    for (var i = 0; i < items.length; i++) {
        var ipList = frame.imageProcessingList.toArray();
        var ipItem = $.grep(ipList, function (item) { return item.command == items[i]; });
        if (ipItem && ipItem.length > 0) {
            frame.imageProcessingList.remove(ipItem[0]);
            return true;
        }
    }
}
function imageProcessingReady(sender, e) {
    sender.imageProcessingReady.remove(imageProcessingReady);
    sender.ip.toolbarService.enable(sender.ip.buttons, function () {
        return true;
    });
}
commangular.command('OnTogglePerio', ['seriesManagerService', 'tabService', 'toolbarService', '$commangular', function (seriesManagerService, tabService, toolbarService, $commangular) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var unpress = false;
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell != null) {
                    var linked = cell.get_linked();
                    var ip;
                    ip = new lt.ImageProcessing();
                    ip.set_jsFilePath('');
                    ip.set_command("Perio");
                    ip.get_arguments()["MultiscaleEnhancement"] = "1000,-1,-1,-1,-1,'Gaussian'=";
                    ip.get_arguments()["GammaCorrect"] = "65=";
                    ip.get_arguments()["UnsharpMask"] = "150,150,0";
                    if (linked) {
                        var activeFrame = seriesManagerService.get_activeCellFrame();
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            toggleImageProcessing(frame, ip, ["Endo", "Dentin"]);
                        });
                    }
                    else {
                        var frame = seriesManagerService.get_activeCellFrame();
                        var shouldUnpress = toggleImageProcessing(frame, ip, ["Endo", "Dentin"]);
                        if (!shouldUnpress) {
                            // the code below disables the button during processing  to address the problem that happens when you alternate between Endo, Perio and Dentin
                            cell.imageProcessingReady.add(imageProcessingReady);
                        }
                    }
                    toolbarService.checkDentalEffects(cell.viewer, cell, tabService.get_allTabs()[tabService.activeTab].id);
                }
            }
        };
    }]);
commangular.command('OnToggleDentin', ['seriesManagerService', 'tabService', 'toolbarService', '$commangular', function (seriesManagerService, tabService, toolbarService, $commangular) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var unpress = false;
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell != null) {
                    var linked = cell.get_linked();
                    var ip;
                    ip = new lt.ImageProcessing();
                    ip.set_jsFilePath('');
                    ip.set_command("Dentin");
                    ip.get_arguments()["MultiscaleEnhancement"] = "1000,-1,-1,-1,-1,'Gaussian'=";
                    ip.get_arguments()["GammaCorrect"] = "76=";
                    ip.get_arguments()["UnsharpMask"] = "150,150,0";
                    if (linked) {
                        var activeFrame = seriesManagerService.get_activeCellFrame();
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            toggleImageProcessing(frame, ip, ["Endo", "Perio"]);
                        });
                    }
                    else {
                        var frame = seriesManagerService.get_activeCellFrame();
                        var shouldUnpress = toggleImageProcessing(frame, ip, ["Endo", "Perio"]);
                        if (!shouldUnpress) {
                            cell.imageProcessingReady.add(imageProcessingReady);
                        }
                    }
                    toolbarService.checkDentalEffects(cell.viewer, cell, tabService.get_allTabs()[tabService.activeTab].id);
                }
            }
        };
    }]);
commangular.command('OnToggleEndo', ['seriesManagerService', 'tabService', 'toolbarService', '$commangular', function (seriesManagerService, tabService, toolbarService, $commangular) {
        return {
            execute: function () {
                var cell = seriesManagerService.get_activeCell();
                var unpress = false;
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (cell != null) {
                    var linked = cell.get_linked();
                    var ip;
                    ip = new lt.ImageProcessing();
                    ip.set_jsFilePath('');
                    ip.set_command("Endo");
                    ip.get_arguments()["MultiscaleEnhancement"] = "1000,-1,-1,-1,-1,'Gaussian'=";
                    ip.get_arguments()["GammaCorrect"] = "85=";
                    ip.get_arguments()["UnsharpMask"] = "150,150,0";
                    if (linked) {
                        var activeFrame = seriesManagerService.get_activeCellFrame();
                        seriesManagerService.enumerateFrames(cell, function (frame, index) {
                            var shouldUnpress = toggleImageProcessing(frame, ip, ["Perio", "Dentin"]);
                            if (frame == activeFrame && !shouldUnpress) {
                                unpress = true;
                            }
                            frame.subCell.invalidate();
                        });
                    }
                    else {
                        var frame = seriesManagerService.get_activeCellFrame();
                        var shouldUnpress = toggleImageProcessing(frame, ip, ["Perio", "Dentin"]);
                        unpress = shouldUnpress;
                        if (!shouldUnpress) {
                            // the code below disables the button during processing  to address the problem that happens when you alternate between Endo, Perio and Dentin
                            //var buttons: Array<string> = ["Dentin" + tab.id, "Perio" + tab.id];
                            //(<any>cell).ip = {
                            //    toolbarService: toolbarService,
                            //    buttons: buttons
                            //}
                            //toolbarService.enable(buttons, function () {
                            //    return false;
                            //});
                            cell.imageProcessingReady.add(imageProcessingReady);
                        }
                    }
                    toolbarService.checkDentalEffects(cell.viewer, cell, tabService.get_allTabs()[tabService.activeTab].id);
                }
            }
        };
    }]);
commangular.command('StudyTimeLine', ['tabService', function (tabService) {
        return {
            execute: function () {
                if (tabService.activeTab != -1) {
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                    ShowStudyTimeLine(tab, controller, !controller.studyTimeLineVisible);
                }
            }
        };
    }]);
commangular.command('Compare', ['seriesManagerService', 'tabService', 'series', 'eventService', function (seriesManagerService, tabService, series, eventService) {
        return {
            execute: function () {
                try {
                    eventService.publish(EventNames.SeriesSelected, {
                        study: null,
                        series: series,
                        remote: false,
                        forCompare: true
                    });
                }
                catch (e) {
                    console.log(e);
                }
                finally {
                }
                //$rootScope.$apply();
            }
        };
    }]);
commangular.command('OnStudyLayout', ['seriesManagerService', '$modal', 'tabService', function (seriesManagerService, $modal, tabService) {
        return {
            execute: function () {
                var layout = {};
                var modalInstance;
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                if (medicalViewer.exploded) {
                    medicalViewer.explode(medicalViewer.explodedCell, false);
                }
                layout.rows = parseInt(medicalViewer.get_gridLayout().get_rows());
                layout.columns = parseInt(medicalViewer.get_gridLayout().get_columns());
                if (angular.isDefined(medicalViewer.customLayout)) {
                    layout.custom = medicalViewer.customLayout;
                }
                modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/StudyLayout.html',
                    controller: Controllers.StudyLayoutController,
                    backdrop: 'static',
                    resolve: {
                        layout: function () {
                            return layout;
                        }
                    }
                });
                modalInstance.result.then(function (layout) {
                    if (layout.custom == null) {
                        medicalViewer.get_gridLayout().set_rows(layout.rows);
                        medicalViewer.get_gridLayout().set_columns(layout.columns);
                        medicalViewer.set_cellsArrangement(0);
                        delete (medicalViewer.customLayout);
                    }
                    else {
                        if (layout.custom.Frames == null) {
                            // StudyLevel.xml 
                            medicalViewer.customLayout = layout.custom.Text;
                            medicalViewer.set_cellsArrangement(1);
                            medicalViewer.layout.beginUpdate();
                            medicalViewer.set_totalCells(layout.custom.length);
                            resetSeriesArrangement(medicalViewer, layout.custom.length);
                            rearrangeSeries(medicalViewer, layout.custom);
                            medicalViewer.layout.endUpdate();
                        }
                        else {
                            // Templates
                            medicalViewer.set_cellsArrangement(1);
                            medicalViewer.layout.beginUpdate();
                            var templateFrameCount = layout.custom.Frames.length;
                            medicalViewer.set_totalCells(templateFrameCount);
                            resetSeriesArrangement(medicalViewer, templateFrameCount);
                            rearrangeSeriesTemplate(medicalViewer, layout.custom.Frames);
                            medicalViewer.layout.endUpdate();
                        }
                    }
                });
                function resetSeriesArrangement(medicalViewer, layoutLength) {
                    var cellsWithImagesCount = medicalViewer.layout.get_items().get_count();
                    var cellLength = Math.min(layoutLength, cellsWithImagesCount);
                    for (var index = 0; index < cellLength; index++) {
                        medicalViewer.layout.get_items().get_item(index).set_position(index);
                    }
                    var emptyDivCount = medicalViewer.get_emptyDivs().get_items().get_count();
                    for (index = 0; index < emptyDivCount; index++) {
                        var emptyDiv = medicalViewer.get_emptyDivs().get_items().get_item(index);
                        emptyDiv.set_position(index + cellLength);
                    }
                }
                function rearrangeSeriesTemplate(medicalViewer, frames) {
                    // medicalViewer.layout.beginUpdate();
                    var emptyDivs = medicalViewer.get_emptyDivs();
                    var emptyDivCount = emptyDivs.get_items().get_count();
                    for (var index = 0; index < emptyDivCount; index++) {
                        var emptyDiv = emptyDivs.get_items().get_item(index);
                        var positionIndex = emptyDiv.get_position();
                        // 
                        // Frame Coordinates
                        //
                        //   _
                        //   |
                        //   y
                        //     x --->
                        //   
                        // Convert to
                        //  
                        // Viewer Coordinates
                        // 
                        //     x --->
                        //   y
                        //   |
                        //   -
                        var left = frames[positionIndex].Position.leftTop.x;
                        var top = 1.0 - frames[positionIndex].Position.leftTop.y;
                        var right = frames[positionIndex].Position.rightBottom.x;
                        var bottom = 1.0 - frames[positionIndex].Position.rightBottom.y;
                        emptyDiv.set_bounds(Utils.createLeadRect(left, top, right, bottom));
                        // emptyDiv.backgroundColor = 'rgba(30, 30, 30, 1)';
                        emptyDiv.onSizeChanged();
                    }
                    var cellsWithImagesCount = medicalViewer.layout.get_items().get_count();
                    var templateFrameCount = frames.length;
                    length = Math.min(templateFrameCount, cellsWithImagesCount);
                    for (var index = 0; index < length; index++) {
                        var layoutItem = medicalViewer.layout.get_items().get_item(index);
                        var positionIndex = layoutItem.get_position();
                        var left = frames[positionIndex].Position.leftTop.x;
                        var top = 1.0 - frames[positionIndex].Position.leftTop.y;
                        var right = frames[positionIndex].Position.rightBottom.x;
                        var bottom = 1.0 - frames[positionIndex].Position.rightBottom.y;
                        layoutItem.set_bounds(Utils.createLeadRect(left, top, right, bottom));
                        layoutItem.onSizeChanged();
                    }
                    var index1 = index;
                    for (; index < cellsWithImagesCount; index++) {
                        //medicalViewer.layout.get_items().get_item(index).set_bounds(Utils.createLeadRect(0, 0, 0, 0));
                        medicalViewer.layout.get_items().get_item(index1).dispose();
                    }
                    // medicalViewer.layout.endUpdate();
                }
                function rearrangeSeries(medicalViewer, layout) {
                    medicalViewer.layout.beginUpdate();
                    var length = medicalViewer.get_emptyDivs().get_items().get_count();
                    for (var index = 0; index < length; index++) {
                        var positionIndex = medicalViewer.get_emptyDivs().get_items().get_item(index).get_position();
                        medicalViewer.get_emptyDivs().get_items().get_item(index).set_bounds(Utils.createLeadRect(layout[positionIndex][0], layout[positionIndex][1], layout[positionIndex][2], layout[positionIndex][3]));
                        medicalViewer.get_emptyDivs().get_items().get_item(index).onSizeChanged();
                    }
                    length = Math.min(layout.length, medicalViewer.layout.get_items().get_count());
                    for (var index = 0; index < length; index++) {
                        var positionIndex = medicalViewer.layout.get_items().get_item(index).get_position();
                        medicalViewer.layout.get_items().get_item(index).set_bounds(Utils.createLeadRect(layout[positionIndex][0], layout[positionIndex][1], layout[positionIndex][2], layout[positionIndex][3]));
                        medicalViewer.layout.get_items().get_item(index).onSizeChanged();
                    }
                    length = medicalViewer.layout.get_items().get_count();
                    for (; index < length; index++) {
                        medicalViewer.layout.get_items().get_item(index).set_bounds(Utils.createLeadRect(0, 0, 0, 0));
                    }
                    medicalViewer.layout.endUpdate();
                }
            }
        };
    }]);
commangular.command('OnSeriesLayout', ['seriesManagerService', '$modal', 'tabService', 'optionsService', 'eventService', 'dicomLoaderService', 'toolbarService', function (seriesManagerService, $modal, tabService, optionsService, eventService, dicomLoaderService, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.selectedTab;
                if (!toolbarService.isEnabled("SeriesLayouts" + tab.id))
                    return;
                var layout = {};
                var modalInstance;
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var cell = seriesManagerService.get_activeCell();
                var overflowManager = controller.getOverflowManager();
                if (cell != null) {
                    var medicalViewer = controller.getViewer();
                    if (medicalViewer.exploded) {
                        medicalViewer.explode(medicalViewer.explodedCell, false);
                    }
                    layout.rows = cell.get_gridLayout().get_rows();
                    layout.columns = cell.get_gridLayout().get_columns();
                    layout.custom = cell.templateId;
                    modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/SeriesLayout.html',
                        controller: Controllers.SeriesLayoutController,
                        backdrop: 'static',
                        resolve: {
                            layout: function () {
                                return layout;
                            }
                        }
                    });
                    function updateMultiFrame(cell) {
                        var maxStack = seriesManagerService.get_maxAllowedStackIndex(cell);
                        var enableMultiFrame = (maxStack > 1);
                        var tabId = tab.id;
                        toolbarService.enable(['CinePlayer' + tabId, 'Stack' + tabId], function () {
                            return enableMultiFrame;
                        });
                    }
                    modalInstance.result.then(function (layout) {
                        var imageViewer = cell.get_imageViewer();
                        if (layout.custom == null) {
                            if ((layout.rows > 10) || (layout.rows < 1)) {
                                alert('valid value is between 1 and 10');
                                return false;
                            }
                            if ((layout.columns > 10) || (layout.columns < 1)) {
                                alert('valid value is between 1 and 10');
                                return false;
                            }
                            //cell.frames.clear();
                            cell.framesMappingIndex = null;
                            seriesManagerService.delete_sopMappings(cell.seriesInstanceUID);
                            delete (cell.templateId);
                            cell.beginUpdate();
                            cell.gridLayout.rows = layout.rows;
                            cell.gridLayout.columns = layout.columns;
                            if (cell.arrangement != 0)
                                cell.arrangement = 0;
                            cell.endUpdate();
                            //dicomLoaderService.loadSeries(cell, [], null, false);
                            updateMultiFrame(cell);
                            eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: cell.seriesInstanceUID });
                        }
                        else {
                            var template = (layout.custom);
                            var overflow = Array();
                            Utils.createViewerLayout(cell, template, false);
                            seriesManagerService.set_layout(cell.seriesInstanceUID, cell.divID, undefined, undefined);
                            overflow = seriesManagerService.set_framesMapping(cell, template.Frames);
                            seriesManagerService.clear_seriesOverflow(cell.seriesInstanceUID);
                            eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: cell.seriesInstanceUID });
                            for (var index = 0; index < overflow.length; index++) {
                                var cellFrame = overflow[index];
                                eventService.publish(EventNames.InstanceOverflow, { instance: cellFrame.Instance, metadata: cellFrame.metadata, frame: 0, parentCell: cell });
                            }
                            if (overflow.length == 0) {
                                eventService.publish(EventNames.InstanceOverflowClose, { seriesInstanceUID: cell.seriesInstanceUID });
                            }
                            imageViewer.endUpdate();
                            cell.onSizeChanged();
                        }
                    });
                }
            }
        };
    }]);
commangular.command('DeleteCell', ['seriesManagerService', 'tabService', 'eventService', 'queryArchiveService', function (seriesManagerService, tabService, eventService, queryArchiveService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                var cell = seriesManagerService.get_activeCell();
                var count;
                if (medicalViewer.exploded) {
                    medicalViewer.explode(medicalViewer.explodedCell, false);
                }
                if (cell != null) {
                    var seriesInstanceUID = cell.seriesInstanceUID;
                    medicalViewer.layout.get_items().remove(cell);
                    Utils.disposeAutomation(cell.get_automation());
                    seriesManagerService.remove_cell(cell);
                    cell.dispose();
                    $("#dialog").dialog('close');
                    count = medicalViewer.layout.get_items().get_count();
                    if (count > 0) {
                        cell = medicalViewer.layout.get_items().get_item(0);
                        seriesManagerService.set_activeCell(cell.divID);
                        seriesInstanceUID = cell.get_seriesInstanceUID();
                        eventService.publish(EventNames.ActiveSeriesChanged, { seriesInstanceUID: seriesInstanceUID, id: cell.divID });
                    }
                    else {
                        //
                        // If there are no more cells we will remove the tab
                        //
                        seriesManagerService.set_activeCell(null);
                        eventService.publish(EventNames.DeleteTab, { id: tab.id });
                    }
                }
                else
                    alert('no cell to delete');
            }
        };
    }]);
var cobb;
function AddTag(text, index) {
    var newOverlay = new lt.Controls.Medical.OverlayText();
    newOverlay.text = text;
    newOverlay.type = lt.Controls.Medical.OverlayTextType.userData;
    newOverlay.positionIndex = index;
    newOverlay.weight = 1;
    newOverlay.alignment = lt.Controls.Medical.OverlayAlignment.topLeft;
    return newOverlay;
}
commangular.command('OnSettings3D', ['toolbarService', 'tabService', 'buttonId', '$modal', 'seriesManagerService', 'queryArchiveService', function (toolbarService, tabService, buttonId, $modal, seriesManagerService, queryArchiveService) {
        return {
            execute: function () {
                var cell3D = seriesManagerService.get_activeItem(); // get_activeViewer().attachedFrame;
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/Settings3D.html',
                    controller: Controllers.Settings3DController,
                    backdrop: 'static',
                    resolve: {
                        cell: function () {
                            return cell3D;
                        }
                    }
                });
                modalInstance.result.then(function (settings) {
                    cell3D.beginUpdate();
                    cell3D.showVolumeBorder = settings.ShowVolumeBorder;
                    cell3D.showRotationCube = settings.ShowRotationCube;
                    cell3D.projection = settings.ProjectionMethod;
                    cell3D.volume.enableClippingFrame = settings.ShowClippingFrame;
                    cell3D.volume.lowResQuality = settings.LowResQuality;
                    cell3D.MPR.enableCrossLines = settings.ShowMPRCrossLines;
                    cell3D.endUpdate();
                });
            }
        };
    }]);
function handle_request3DData(cell3D, toolbarService, tabService, sender, args, queryArchiveService, query, seriesManagerService, volumeType, sopInstanceUID, renderingMethod) {
    switch (args.type) {
        case lt.Controls.Medical.Requested3DDataType.render:
            cell3D.image.src = args.JSON;
            break;
        case lt.Controls.Medical.Requested3DDataType.delete3DObject:
            {
                var cell = cell3D.get_referenceCell();
                if (cell)
                    cell.divID = UUID.genV4().toString();
            }
            break;
        case lt.Controls.Medical.Requested3DDataType.update3DSettings:
            queryArchiveService.Update3DSettings(args.JSON, cell3D.object3D.id).then(function (data) {
                cell3D.refresh();
            });
            break;
        case lt.Controls.Medical.Requested3DDataType.get3DInfo:
            queryArchiveService.Get3DSettings(args.JSON, cell3D.object3D.id).then(function (data) {
                var info = new lt.Controls.Medical.WindowLevelInformation();
                try {
                    var json = JSON.parse(data.data);
                    info.windowWidth = json["WindowWidth"];
                    info.windowCenter = json["WindowCenter"];
                    info.minValue = json["MinimumValue"];
                    info.maxValue = json["MaximumValue"];
                    info.autoScaleSlope = cell3D.information.autoScaleSlope;
                    info.autoScaleIntercept = cell3D.information.autoScaleIntercept;
                    cell3D.bone = {};
                    cell3D.bone.width = json["BoneWindowWidth"];
                    cell3D.bone.center = json["BoneWindowCenter"];
                    cell3D.information = info;
                    if (DicomHelper.GetTagText(cell3D.JSON[DicomTag.Modality]) == "CT") {
                        info.windowWidth = json["BoneWindowWidth"];
                        info.windowCenter = json["BoneWindowCenter"];
                    }
                    cell3D.information = info;
                }
                catch (e) {
                }
            });
            break;
    }
}
function alreadyHaveA3Dobject(cell, volumeType) {
    var viewer = cell.viewer;
    var index = 0;
    var length = viewer.layout.items.count;
    var cell3D;
    for (index = 0; index < length; index++) {
        if (viewer.layout.items.get_item(index) instanceof lt.Controls.Medical.Cell3D) {
            cell3D = viewer.layout.items.get_item(index);
            if (cell3D.object3D.progress == 100)
                cell3D.volumeType = volumeType;
            if (cell3D.referenceCell == cell) {
                return true;
            }
        }
    }
    return false;
}
function Create3DObject(seriesManagerService, toolbarService, tabService, queryArchiveService, overlayManagerService, optionsService, eventService, volumeType) {
    var cell = seriesManagerService.get_activeCell();
    var query = new Models.QueryOptions();
    query.SeriesOptions.SeriesInstanceUID = cell.seriesInstanceUID;
    var tab = tabService.get_allTabs()[tabService.activeTab];
    var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
    var medicalViewer = controller.getViewer();
    // change the volume type if the volume exist.
    if (cell instanceof lt.Controls.Medical.Cell3D) {
        var cell3D = cell;
        if (cell3D.object3D.progress == 100)
            cell3D.volumeType = volumeType;
        return true;
    }
    // if the cell has a 3d volume, then just return.
    if (alreadyHaveA3Dobject(cell, volumeType))
        return;
    var viewer = cell.viewer;
    // increase the viewer cell count to show the 3d volume.
    if ((viewer.layout.items.count + viewer.emptyDivs.items.count) < 3) {
        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.grid;
        viewer.layout.beginUpdate();
        viewer.gridLayout.rows = 2;
        viewer.gridLayout.columns = 2;
        viewer.layout.endUpdate();
    }
    if (viewer.exploded)
        viewer.exploded = false;
    // TODO: remove this
    cell.Id3D = cell.divID + "_3D";
    var frame = cell.frames.get_item(0);
    var sopInstanceUID = frame.Instance.SOPInstanceUID;
    var cell3D = new lt.Controls.Medical.Cell3D(viewer, cell.Id3D);
    cell3D.object3D = tab.AddnewEngine(cell, cell.divID, queryArchiveService, query, sopInstanceUID, optionsService);
    cell3D.add_volumeTypeChanged(function (sender, args) {
        eventService.publish(EventNames.ActiveSeriesChanged, { seriesInstanceUID: cell.seriesInstanceUID, id: cell.divID });
    });
    cell3D.referenceCell = cell;
    cell.cell3D = cell3D;
    var renderingMethod = optionsService.get(OptionNames.RenderingMethod);
    var renderingIndex = (renderingMethod.indexOf("Hardware") != -1) ? 0 : 1;
    cell.object3D = cell3D.object3D;
    cell3D.object3D.add_request3DData(function (sender, args) {
        handle_request3DData(cell3D, toolbarService, tabService, sender, args, queryArchiveService, query, seriesManagerService, volumeType, sopInstanceUID, renderingIndex);
    });
    cell3D.object3D.add_statusChanged(function (sender, args) {
        switch (args.status) {
            case lt.Controls.Medical.Object3DStatus.error:
                var medicalViewer = cell3D.viewer;
                medicalViewer.layout.get_items().remove(cell3D);
                seriesManagerService.remove_cell(cell3D);
                cell3D.dispose();
                alert(args.message);
                break;
            case lt.Controls.Medical.Object3DStatus.ready:
                if (cell3D.object3D.progress == 100) {
                    cell3D.URL = queryArchiveService.Get3DImage();
                    var inputJson = {};
                    inputJson["BoneWindowWidth"] = '';
                    inputJson["BoneWindowCenter"] = '';
                    inputJson = JSON.stringify(inputJson);
                    if (DicomHelper.GetTagText(frame.JSON[DicomTag.Modality]) == "CT") {
                        queryArchiveService.Get3DSettings(inputJson, cell3D.object3D.id).then(function (data) {
                            var info = new lt.Controls.Medical.WindowLevelInformation();
                            inputJson = JSON.parse(data.data);
                            var json = {};
                            json["WindowWidth"] = inputJson["BoneWindowWidth"];
                            json["WindowCenter"] = inputJson["BoneWindowCenter"];
                            queryArchiveService.Update3DSettings(json, cell3D.object3D.id).then(function (data) {
                                cell3D.beginUpdate();
                                cell3D.volumeType = volumeType;
                                cell3D.endUpdate();
                                var tab = tabService.get_allTabs()[tabService.activeTab];
                                toolbarService.enable("VolumeType" + tab.id);
                                //var viewer = cell3D.referenceCell.get_viewer();
                                //ConnectMPRWith3DObject(cell3D.referenceCell, cell3D.referenceCell, viewer, queryArchiveService);
                            });
                        });
                    }
                    else {
                        cell3D.beginUpdate();
                        cell3D.volumeType = volumeType;
                        cell3D.endUpdate();
                        var tab = tabService.get_allTabs()[tabService.activeTab];
                        toolbarService.enable("VolumeType" + tab.id);
                    }
                }
        }
    });
    var frame = cell.frames.get_item(0);
    var metadata = frame.metadata;
    cell3D.JSON = metadata;
    var patientId = DicomHelper.getPatientName(metadata, DicomTag.PatientName);
    var StudyDescription = DicomHelper.GetTagTextValue(metadata, DicomTag.StudyDescription);
    var StudyDate = DicomHelper.parseDicomDate(DicomHelper.GetTagTextValue(metadata, DicomTag.StudyDate));
    var SeriesDate = DicomHelper.parseDicomDate(DicomHelper.GetTagTextValue(metadata, DicomTag.SeriesDate));
    var SeriesDescription = DicomHelper.GetTagTextValue(metadata, DicomTag.SeriesDescription);
    overlayManagerService.set_cellOverlays(cell3D, metadata, false);
    cell3D.stackInstanceUID = cell.stackInstanceUID;
    cell3D.seriesInstanceUID = cell.seriesInstanceUID;
    cell3D.studyInstanceUID = "3D";
    cell3D.set_unselectedBorderColor(optionsService.get(OptionNames.UnSelectedBorderColor));
    cell3D.set_selectedSubCellBorderColor(optionsService.get(OptionNames.SelectedSubCellBorderColor));
    cell3D.set_selectedBorderColor(optionsService.get(OptionNames.SelectedBorderColor));
    cell3D.set_highlightedSubCellBorderColor(optionsService.get(OptionNames.SelectedBorderColor));
    cell3D.set_showFrameBorder(optionsService.get(OptionNames.ShowFrameBorder));
    var parent = document.getElementById(viewer.divId);
    viewer.layout.get_items().add(cell3D);
    var id = cell3D.get_divID();
    seriesManagerService.add_seriesCell(cell3D);
    $("#" + id).attr('seriesInstanceUID', cell3D.get_seriesInstanceUID());
    var tab = tabService.get_allTabs()[tabService.activeTab];
    toolbarService.disable("VolumeType" + tab.id);
    cell3D.start("");
    //cell.derivatives.add(cell3D);
    CommandManager.RunCommand(cell3D, CommandManager.LastCommand.Action, CommandManager.LastCommand.ButtonID);
}
commangular.command('OnVRT', ['seriesManagerService', 'toolbarService', 'tabService', 'dicomLoaderService', 'queryArchiveService', 'overlayManagerService', 'optionsService', 'eventService', 'objectRetrieveService', function (seriesManagerService, toolbarService, tabService, dicomLoaderService, queryArchiveService, overlayManagerService, optionsService, eventService, objectRetrieveService) {
        return {
            execute: function () {
                VolumeWithMPR(seriesManagerService, null, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService, lt.Controls.Medical.VolumeType.VRT);
            }
        };
    }]);
commangular.command('OnMIP', ['seriesManagerService', 'toolbarService', 'tabService', 'dicomLoaderService', 'queryArchiveService', 'overlayManagerService', 'optionsService', 'eventService', 'objectRetrieveService', function (seriesManagerService, toolbarService, tabService, dicomLoaderService, queryArchiveService, overlayManagerService, optionsService, eventService, objectRetrieveService) {
        return {
            execute: function () {
                VolumeWithMPR(seriesManagerService, null, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService, lt.Controls.Medical.VolumeType.MIP);
            }
        };
    }]);
commangular.command('OnSSD', ['seriesManagerService', 'toolbarService', 'tabService', 'dicomLoaderService', 'queryArchiveService', 'overlayManagerService', 'optionsService', 'eventService', 'objectRetrieveService', function (seriesManagerService, toolbarService, tabService, dicomLoaderService, queryArchiveService, overlayManagerService, optionsService, eventService, objectRetrieveService) {
        return {
            execute: function () {
                VolumeWithMPR(seriesManagerService, null, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService, lt.Controls.Medical.VolumeType.SSD);
            }
        };
    }]);
commangular.command('OnMPRVolume', ['seriesManagerService', 'toolbarService', 'tabService', 'dicomLoaderService', 'queryArchiveService', 'overlayManagerService', 'optionsService', 'eventService', 'objectRetrieveService', function (seriesManagerService, toolbarService, tabService, dicomLoaderService, queryArchiveService, overlayManagerService, optionsService, eventService, objectRetrieveService) {
        return {
            execute: function () {
                VolumeWithMPR(seriesManagerService, null, toolbarService, tabService, eventService, queryArchiveService, overlayManagerService, optionsService, objectRetrieveService, lt.Controls.Medical.VolumeType.MPR);
            }
        };
    }]);
commangular.command('OnRotate3D', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.Rotate3D, buttonId);
                enumerateCell(tabService, function (cell) {
                    CommandManager.RunCommand(cell, MedicalViewerAction.Rotate3D, buttonId);
                });
            }
        };
    }]);
commangular.command('ToggleFullScreen', ['seriesManagerService', 'tabService', 'dicomLoaderService', function (seriesManagerService, tabService, dicomLoaderService) {
        return {
            execute: function () {
                // check if the Enter key has been pressed for the nanotation text.
                var textElement = document.getElementById("textObject");
                if (textElement != null)
                    return;
                if (!isFullscreen()) {
                    if (document.fullscreenEnabled ||
                        document.webkitFullscreenEnabled ||
                        document.mozFullScreenEnabled ||
                        document.msFullscreenEnabled) {
                        var tab = tabService.get_allTabs()[tabService.activeTab];
                        var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                        if (!controller)
                            return;
                        var medicalViewer = controller.getViewer();
                        var cell = seriesManagerService.get_activeCell();
                        var element = document.getElementById(medicalViewer.divId);
                        element = element.parentElement;
                        if (element.requestFullscreen) {
                            element.requestFullscreen();
                        }
                        else if (element.webkitRequestFullscreen) {
                            element.webkitRequestFullscreen();
                        }
                        else if (document.mozRequestFullScreen) {
                            document.mozRequestFullScreen();
                        }
                        else if (document.msRequestFullscreen) {
                            document.msRequestFullscreen();
                        }
                    }
                }
                else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                    else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                    else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    }
                    else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }
        };
    }]);
commangular.command('ToggleReferenceLine', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                if (medicalViewer != null) {
                    var value = !medicalViewer.get_showReferenceLine();
                    medicalViewer.set_showReferenceLine(value);
                    if (value)
                        toolbarService.press('ReferenceLine' + tab.id);
                    else {
                        toolbarService.unpress('ReferenceLine' + tab.id);
                    }
                    medicalViewer.invalidate();
                }
            }
        };
    }]);
commangular.command('ShowFirstLastReferenceLine', ['seriesManagerService', 'tabService', 'toolbarService', function (seriesManagerService, tabService, toolbarService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                if (medicalViewer != null) {
                    var value = !medicalViewer.get_showFirstAndLastReferenceLine();
                    medicalViewer.set_showFirstAndLastReferenceLine(value);
                    if (value)
                        toolbarService.press('ShowFirstLast' + tab.id);
                    else
                        toolbarService.unpress('ShowFirstLast' + tab.id);
                    medicalViewer.invalidate();
                }
            }
        };
    }]);
function OpenUrl(url, newWindow, name) {
    var newWindow = newWindow || false;
    if ((lt.LTHelper.OS == lt.LTOS.iOS && !lt.LTDevice.mobile) || newWindow) {
        var a = document.createElement('a');
        // anything you want can go here and will safely be run on the next digest.
        if ((a.download != undefined) && (name)) {
            setTimeout(function () {
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
            }, 1);
            return;
        }
        var newtab = window.open("", "_blank");
        if (newtab) {
            window.focus();
            newtab.location.href = url;
            newtab.focus();
        }
        else {
            //newtab is undefined, most likely b/c of chrome security feature (not allowing a service callback to open a tab)
            //it has to be initiated by a user interaction (clicking on a URL), we show a popup dialog that has the URL
            if (lt.LTHelper.browser === lt.LTBrowser.chrome && newWindow) {
                if ($('#dialogForPrintPdf').length) {
                    $('#dialogForPrintPdf').remove();
                }
                parentDiv = $("<div id='dialogForPrintPdf' title='File Ready' ><a href='" + url + "'  target='_blank'>Click here to open or download</a></div>");
                parentDiv.dialog({ autoOpen: false });
                $('#dialogForPrintPdf').dialog("open");
            }
            else {
                window.location.href = url;
            }
        }
    }
    else {
        window.location.href = url;
    }
}
function OpenPrintViewUrl(url) {
    var win = window.open();
    if (win)
        win.document.write('<img onload="document.location=\'#\';" src="' + url + '" ></img>');
}
function SetCurrentInteractiveMode(toolbarService, tabService, interactiveMode, commandId, showpressed) {
    var tb = toolbarService;
    var tab = tabService.get_allTabs()[tabService.activeTab];
    if (currentInteractiveMode[tab.id] == interactiveMode)
        return;
    currentInteractiveMode[tab.id] = interactiveMode;
    PressButton(toolbarService, tab, commandId, showpressed);
}
function GetCurrentInteractiveMode(tabId) {
    var index = -1;
    if (angular.isDefined(currentInteractiveMode[tabId]))
        index = currentInteractiveMode[tabId];
    if (index == -1)
        return MedicalViewerAction.WindowLevel;
    return index;
}
function enumerateCell(tabService, cellFunction, myTab) {
    if (tabService.activeTab != -1) {
        var tab = myTab ? myTab : tabService.get_allTabs()[tabService.activeTab];
        var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
        if (controller == null)
            return;
        var medicalViewer = controller.getViewer();
        if (medicalViewer == null)
            return;
        var index = 0;
        var length = medicalViewer.layout.get_items().get_count();
        var cell;
        for (index = 0; index < length; index++) {
            cell = medicalViewer.layout.get_items().get_item(index);
            if (cell != null)
                cellFunction(cell);
        }
    }
}
function enumerateEmptyCell(tabService, cellFunction) {
    if (tabService.activeTab != -1) {
        var tab = tabService.get_allTabs()[tabService.activeTab];
        var controller = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
        var medicalViewer = controller.getViewer();
        if (medicalViewer == null)
            return;
        var index = 0;
        var length = medicalViewer.emptyDivs.items.count;
        var cell;
        for (index = 0; index < length; index++) {
            cell = medicalViewer.emptyDivs.items.item(index);
            if (cell != null)
                cellFunction(cell);
        }
    }
}
function radioColor() {
    var redCheckBox = document.getElementById('checkboxRed');
    var greenCheckBox = document.getElementById('checkboxGreen');
    var blueCheckBox = document.getElementById('checkboxBlue');
    redCheckBox.disabled = false;
    greenCheckBox.disabled = false;
    blueCheckBox.disabled = false;
    var position = currentPosition;
    colorType = lt.Controls.Medical.ColorType.RGB;
    UpdateSliderPosition(position);
}
function radioGray() {
    var redCheckBox = document.getElementById('checkboxRed');
    var greenCheckBox = document.getElementById('checkboxGreen');
    var blueCheckBox = document.getElementById('checkboxBlue');
    redCheckBox.disabled = true;
    greenCheckBox.disabled = true;
    blueCheckBox.disabled = true;
    var position = currentPosition;
    colorType = lt.Controls.Medical.ColorType.gray;
    UpdateSliderPosition(position);
}
function checkbox_click(value) {
    RenderLineProfileHistogram(0, 0, false);
}
function GetRealRotationAngle(angle, frame) {
    var direction = 1;
    if (frame.get_flipped() ^ frame.get_reversed())
        direction = -1;
    return direction * angle;
}
function isOverLineProfileSlider(e) {
    var targetTouchePageY = e.pageY;
    var targetTouchePageX = e.pageX;
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    return (targetTouchePageY >= innerLineCanvas.height);
}
var mouseDown = false;
var lineProfileHistogram = null;
var currentLineProfileFrame = null;
var lineProfileInteractiveMode = null;
var colorType = lt.Controls.Medical.ColorType.auto;
function HistogramUpdated() {
    lineProfileSliderPosition = 0;
    RenderLineProfileHistogram(0, 0, false);
    //var left = context.measureText("65535").width;
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    if (innerLineCanvas == null)
        return;
    UpdateSliderPosition(innerLineCanvas.clientWidth);
}
function UpdateSliderSize() {
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    var sliderSize = 0;
    var pixelCount = getPixelLength();
    if (innerLineCanvas.width < pixelCount) {
        var sliderSize = pixelCount - innerLineCanvas.width;
    }
    else {
        sliderSize = 0;
    }
    lineProfileSliderSize = sliderSize;
    //outerLineCanvas.setAttribute("sliderSize", sliderSize.toString());
}
function Refresh() {
    var maxValue = 0;
    if (isGrayScale16(currentLineProfileFrame.information)) {
        maxValue = currentLineProfileFrame.information.maxValue <= 0 ? 65556 : currentLineProfileFrame.information.maxValue;
    }
    else
        maxValue = 256;
    var minMaxDelta = maxValue - currentLineProfileFrame.information.minValue;
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    var outerLineCanvas = document.getElementById('outerlineProfileCanvas');
    if (innerLineCanvas == null)
        return;
    if (outerLineCanvas == null)
        return;
    if (currentLineProfileFrame == null)
        return;
    var context = innerLineCanvas.getContext("2d");
    var height = innerLineCanvas.height;
    var componant = 0;
    var componantCount = (colorType == lt.Controls.Medical.ColorType.gray) ? 1 : 3;
    var colors = [];
    var colorEnabled = [];
    if (componantCount == 3) {
        colors[0] = 'red';
        colorEnabled[0] = $("#checkboxRed").is(':checked') ? true : false;
        colors[1] = 'green';
        colorEnabled[1] = $("#checkboxGreen").is(':checked') ? true : false;
        colors[2] = 'blue';
        colorEnabled[2] = $("#checkboxBlue").is(':checked') ? true : false;
    }
    else {
        colors[0] = 'black';
        colorEnabled[0] = true;
    }
    context.clearRect(0, 0, innerLineCanvas.width, innerLineCanvas.height);
    context.save();
    for (componant = 0; componant < componantCount; componant++) {
        if (!colorEnabled[componant])
            continue;
        var index = 0;
        var length = Math.min(lineProfileHistogram.length / componantCount, innerLineCanvas.width);
        var yLine = (height) - ((lineProfileHistogram[lineProfileSliderPosition * componantCount + componant] - currentLineProfileFrame.information.minValue) * (height) / minMaxDelta);
        context.beginPath();
        context.strokeStyle = colors[componant];
        context.moveTo(0, yLine);
        var pixel;
        for (index = 1; index < length; index++) {
            pixel = lineProfileHistogram[(lineProfileSliderPosition + index) * componantCount + componant] - currentLineProfileFrame.information.minValue;
            yLine = height - (pixel * height / minMaxDelta);
            context.lineTo(index, yLine);
        }
        context.stroke();
    }
}
function RenderLineProfileHistogram(x, y, drawLine) {
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    var outerLineCanvas = document.getElementById('outerlineProfileCanvas');
    if (innerLineCanvas == null)
        return;
    if (outerLineCanvas == null)
        return;
    if (currentLineProfileFrame == null)
        return;
    var context = innerLineCanvas.getContext("2d");
    var height = innerLineCanvas.height;
    var maxValue = 0;
    if (isGrayScale16(currentLineProfileFrame.information)) {
        maxValue = currentLineProfileFrame.information.maxValue <= 0 ? 65556 : currentLineProfileFrame.information.maxValue;
    }
    else
        maxValue = 256;
    var minMaxDelta = maxValue - currentLineProfileFrame.information.minValue;
    var normalizedValue = height;
    if (lineProfileHistogram.length == 0)
        return;
    //UpdateSliderPosition(lineProfileSliderSize - 1);
    UpdateSliderSize();
    Refresh();
    var componant = 0;
    var componantCount = (colorType == lt.Controls.Medical.ColorType.gray) ? 1 : 3;
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    var height = innerLineCanvas.height;
    if (lineProfileHistogram.length == 0)
        return;
    if (drawLine) {
        var context = innerLineCanvas.getContext("2d");
        var left = context.measureText("65535").width;
        var xLine = (x + left);
        var yLine = 0;
        var textPosition = xLine;
        var pixelValue = "";
        var pixelPosition;
        for (componant = 0; componant < componantCount; componant++) {
            pixelPosition = (lineProfileSliderPosition + xLine) * componantCount + componant;
            if (pixelPosition >= lineProfileHistogram.length)
                continue;
            xLine = (x + left);
            yLine = (height) - ((lineProfileHistogram[pixelPosition] - currentLineProfileFrame.information.minValue) * (height) / minMaxDelta);
            context.beginPath();
            context.strokeStyle = 'black';
            context.fillStyle = 'rgba(230, 230, 128, 0.5)';
            context.arc(xLine + 0.5, yLine, 4, 0, 2 * Math.PI);
            context.moveTo(xLine + 0.5, yLine);
            context.lineTo(xLine + 0.5, height);
            currentLineProfileFrame.parentCell.lineProfile.histogramMarker = lineProfileSliderPosition + xLine;
            pixelValue += lineProfileHistogram[pixelPosition].toString();
            if (componant < (componantCount - 1)) {
                pixelValue += ',';
            }
            context.fill();
            context.stroke();
        }
        if (xLine < context.measureText(pixelValue).width + 10) {
            context.textAlign = "left";
            // fixed value to push the text away from the mouse/finger
            textPosition += 10;
        }
        else {
            context.textAlign = "right";
            // fixed value to push the text away from the mouse/finger
            textPosition -= 4;
        }
        if (pixelValue) {
            context.beginPath();
            context.textBaseline = "baseline";
            context.fillStyle = 'black';
            context.fillText(pixelValue, textPosition, y);
            context.fillStyle = 'gray';
            context.strokeText(pixelValue, textPosition, y);
            context.fill();
            context.stroke();
        }
    }
    else
        currentLineProfileFrame.parentCell.lineProfile.histogramMarker = -1;
    context.restore();
}
function isOverGraph(e) {
    var targetTouchePageY = e.pageY;
    var targetTouchePageX = e.pageX;
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    return (targetTouchePageY < innerLineCanvas.height) && (targetTouchePageX < innerLineCanvas.width);
}
var currentPosition = 0;
var lineProfileSliderSize = 0;
var lineProfileSliderPosition = 0;
function getPixelLength() {
    var componantCount = (colorType == lt.Controls.Medical.ColorType.gray) ? 1 : 3;
    return (lineProfileHistogram.length / componantCount);
}
function UpdateSliderPosition(newPosition) {
    if (!lineProfileHistogram)
        return;
    if (lineProfileHistogram.length == 0)
        return;
    var mainDiv = document.getElementById('dialog');
    var width = mainDiv.clientWidth - 24;
    var height = 180;
    var outerlineCanvas = document.getElementById('outerlineProfileCanvas');
    var innerLineCanvas = document.getElementById('lineProfileCanvas');
    var context = outerlineCanvas.getContext('2d');
    var space = width / 15;
    var left = context.measureText("65535").width;
    var top = innerLineCanvas.offsetTop - outerlineCanvas.offsetTop;
    var width = width - space - left;
    var height = innerLineCanvas.clientHeight;
    context.clearRect(0, height + 2 + top, outerlineCanvas.width, outerlineCanvas.height - height);
    if (lineProfileSliderSize == 0)
        return;
    height = 180;
    context.lineWidth = 1;
    context.beginPath();
    context.strokeStyle = "rgba(255, 0, 0, 0.5)";
    context.moveTo(left + 0.5, height + top + 15 + 0.5);
    context.lineTo(left + width + 0.5, height + top + 15 + 0.5);
    context.stroke();
    context.beginPath();
    currentPosition = newPosition;
    currentPosition = Math.min(left + width + 0.5, Math.max(left, left + 0.5 + currentPosition));
    var realPosition = currentPosition - left;
    lineProfileSliderPosition = Math.round((realPosition * lineProfileSliderSize / width));
    context.lineWidth = 2;
    context.fillStyle = "rgba(255, 128, 128, 1)";
    context.arc(currentPosition, height + top + 15, 6, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    context.textAlign = "left";
    context.textBaseline = "top";
    var length = getPixelLength();
    var height = innerLineCanvas.clientHeight;
    var fromPercentage = Math.round(lineProfileSliderPosition * 100 / length);
    var toPercentage = Math.round(((lineProfileSliderPosition + width) * 100) / length);
    context.fillText(fromPercentage + "%", left, height + top + 1);
    context.textAlign = "right";
    context.fillText(toPercentage + "%", left + width - 0.5, height + top + 1);
}
function getMousePoint(args, canvas) {
    var outerlineCanvas = document.getElementById('outerlineProfileCanvas');
    var context = outerlineCanvas.getContext('2d');
    var left = context.measureText("65535").width;
    var position = lt.LTHelper.getPosition(canvas, null);
    var targetTouchePageX = args.pageX - parseInt(position.x.toString()) - left;
    var targetTouchePageY = args.pageY - parseInt(position.y.toString());
    return lt.LeadPointD.create(targetTouchePageX, targetTouchePageY);
}
function outerlineCanvas_mouseDown(canvas, e) {
    mouseDown = false;
    //e.target.setCapture();
    var outerlineCanvas = document.getElementById('outerlineProfileCanvas');
    //lineProfileSliderSize = parseInt(outerlineCanvas.getAttribute("sliderSize"));
    if (isOverLineProfileSlider(e)) {
        mouseDown = true;
        var point = getMousePoint(e, canvas);
        UpdateSliderPosition(point.x);
        RenderLineProfileHistogram(0, 0, false);
    }
    e.preventDefault();
    //e.stopImmediatePropagation();
}
function outerlineCanvas_mouseMove(canvas, args) {
    if (mouseDown) {
        var point = getMousePoint(args, canvas);
        UpdateSliderPosition(point.x);
        RenderLineProfileHistogram(0, 0, false);
    }
    else {
        if (isOverGraph(args)) {
        }
    }
    args.preventDefault();
    args.stopImmediatePropagation();
}
function outerlineCanvas_mouseUp(canvas, args) {
    mouseDown = false;
    args.preventDefault();
    args.stopImmediatePropagation();
}
function isGrayScale16(info) {
    return (info.BitsPerPixel == 16 || info.BitsPerPixel == 12) && info.PhotometricInterpretation == "MONOCHROME2" || info.PhotometricInterpretation == "MONOCHROME1";
}
var histogramMouseDown = false;
function innerLineCanvas_mouseDown(canvas, e) {
    histogramMouseDown = false;
    var innerlineCanvas = document.getElementById('lineProfileCanvas');
    histogramMouseDown = true;
    var point = getMousePoint(e, canvas);
    UpdateLineOnHistogram(point.x, point.y, histogramMouseDown);
    e.preventDefault();
}
function innerLineCanvas_mouseMove(canvas, args) {
    if (histogramMouseDown) {
        var point = getMousePoint(args, canvas);
        UpdateLineOnHistogram(point.x, point.y, histogramMouseDown);
    }
    else {
    }
    args.preventDefault();
    args.stopImmediatePropagation();
}
function innerLineCanvas_mouseUp(canvas, args) {
    histogramMouseDown = false;
    UpdateLineOnHistogram(0, 0, histogramMouseDown);
    args.preventDefault();
    args.stopImmediatePropagation();
}
function UpdateLineOnHistogram(x, y, drawLine) {
    // resting the slider so it start showing the line histogram from the start
    lineProfileSliderPosition = 0;
    RenderLineProfileHistogram(x, y, drawLine);
}
function ShowMenu(items, icon, functionCallBack, cellFrame, toolbarService, tabService, seriesManagerService, $modal, tab, selectedIndex) {
    var menu = document.getElementById('customWidnowLevel_expandMenu');
    if (menu != null) {
        menu.style.visibility = 'visible';
        return;
    }
    setTimeout(function () {
        window.addEventListener("click", menuClick, true);
        function menuClick(e) {
            window.removeEventListener("click", menuClick);
            var menu = document.getElementById('customWidnowLevel_expandMenu');
            if (menu != null) {
                if (menu.style.visibility == 'visible') {
                    menu.style.visibility = 'hidden';
                    menu.parentNode.removeChild(menu);
                    menu.id = '';
                    menu.innerHTML = '';
                }
            }
        }
    }, 10);
    var leftScroll = document.getElementById('scrollLeft_toolbar_button');
    var left = 0;
    var tabView = document.getElementById('ltTabWrapper');
    if (tabView) {
        // to scroll the toolbar buttons the left to make room for the MiPACS logo.
        var scrollBarArray = tabView.getElementsByClassName('scroll-body-inner');
        if ((scrollBarArray != null) && (scrollBarArray.length != 0)) {
            var scrollBar = scrollBarArray[scrollBarArray.length - 1];
            if (scrollBar)
                left = scrollBar.offsetLeft;
        }
    }
    var parent = tabService.getWindowLayout();
    var _customWindowLevelMenu = document.createElement('div');
    _customWindowLevelMenu.id = 'customWidnowLevel_expandMenu';
    _customWindowLevelMenu.style.position = 'absolute';
    _customWindowLevelMenu.style.visibility = 'visible';
    _customWindowLevelMenu.style.zIndex = '200';
    _customWindowLevelMenu.style.backgroundColor = "#151515"; //'rgba(91, 162, 243, 1)';
    _customWindowLevelMenu.style.width = '250';
    _customWindowLevelMenu.style.top = "84px";
    _customWindowLevelMenu.style.left = leftScroll.offsetLeft + leftScroll.clientWidth + icon.offsetLeft + left + 'px';
    _customWindowLevelMenu.style.display = 'block';
    _customWindowLevelMenu.style.height = '200px';
    parent.appendChild(_customWindowLevelMenu);
    var cell = seriesManagerService.get_activeCell();
    var length = items.length;
    var direction = cell.SortOrderAcsending ? ' \u2193' : ' \u2191';
    var selected;
    var counter = 0;
    for (var index = 0; index < length; index++) {
        selected = items[index].Text == (cell.CurrentSelectedSortOrder);
        if (index == 0)
            _customWindowLevelMenu.innerHTML += ("<a class='menuBar' style='display: block;'></a>");
        else
            _customWindowLevelMenu.innerHTML += ("<a class='itemDivider' style='display: block;'></a>");
        _customWindowLevelMenu.innerHTML += ("<a class='menuItemText2' id='dropdownmenuitem" + index + "' style='display: block; cursor: pointer;       text-decoration:none;'>" + (selected ? '\u2713 ' : '') + items[index].Text + (selected ? direction : "") + '</a>');
    }
    var item;
    for (var index = 0; index < length; index++) {
        item = document.getElementById("dropdownmenuitem" + index.toString());
        item.setAttribute("itemIndex", index.toString());
        item.cellFrame = cellFrame;
        item.toolbarService = toolbarService;
        item.seriesManagerService = seriesManagerService;
        item.model = $modal;
        item.tab = tab;
        item.cell = cell;
        item.sortInfo = items[index].Info;
        item.item = items[index];
        item.addEventListener('mouseover', emptyFunction, false);
        item.addEventListener('mouseleave', emptyFunction, false);
        item.addEventListener("touchstart", functionCallBack, false);
        if (lt.LTHelper.msPointerEnabled)
            item.addEventListener(lt.Controls.Medical.Tools.pointerup, functionCallBack, false);
        else
            item.addEventListener("mouseup", functionCallBack, false);
        if (lt.LTHelper.msPointerEnabled)
            item.addEventListener(lt.Controls.Medical.Tools.pointerdown, function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }, false);
        else
            item.addEventListener("mousedown", function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }, false);
    }
    _customWindowLevelMenu.style.height = item.offsetTop + item.clientHeight + 1 + "px";
}
var currentSelectedSortOrder = -1;
var _sort_timer_event;
function sortClick(e) {
    var index = parseInt(e.currentTarget.getAttribute("itemIndex"));
    var cellFrame = e.currentTarget.cellFrame;
    var seriesManagerService = e.currentTarget.seriesManagerService;
    var model = e.currentTarget.model;
    var toolbarService = e.currentTarget.toolbarService;
    var tab = e.currentTarget.tab;
    var cell = e.currentTarget.cell;
    var info = e.currentTarget.sortInfo;
    if (e.currentTarget.text.indexOf('\u2713') != -1) {
        cell.SortOrderAcsending = !cell.SortOrderAcsending;
    }
    else {
        cell.CurrentSelectedSortOrder = e.currentTarget.text;
    }
    info.order = !cell.SortOrderAcsending ? lt.Controls.Medical.SortOrder.descending : lt.Controls.Medical.SortOrder.ascending;
    currentSelectedSortOrder = index;
    cell.fullDownload = true;
    cell._sort_timer_event = window.setInterval(function (e) {
        seriesManagerService.enumerateFrames(cell, function (frame, index) {
            if (frame.JSON == null)
                return;
        });
        var sortingOp = [info];
        cell.sortingOperationsSequence = sortingOp;
        window.clearInterval(cell._sort_timer_event);
    }, 500);
    //sortingOp[0] = new lt.Controls.Medical.SortingOperation();
    //sortingOp[0].order = lt.Controls.Medical.SortOrder.descending;
    //sortingOp[0].sortByCategory = lt.Controls.Medical.SortType.byAxis;
}
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AddAppController = /** @class */ (function () {
        function AddAppController($scope, $modalInstance, externalApplicationsService) {
            var _this = this;
            $scope.add = function () {
                try {
                    var externalApp = new ExternalApp();
                    externalApp.name = _this.$scope.name;
                    externalApp.args = _this.$scope.args;
                    externalApp.path = _this.$scope.path;
                    _this.externalApplicationsService.addApp(externalApp);
                    $modalInstance.dismiss("");
                }
                catch (e) {
                    alert(e);
                }
            };
            $scope.cancel = function () {
                $modalInstance.dismiss("cancel");
            };
            this.externalApplicationsService = externalApplicationsService;
            this.$scope = $scope;
        }
        AddAppController.$inject = ["$scope", "$modalInstance", "externalApplicationsService"];
        return AddAppController;
    }());
    Controllers.AddAppController = AddAppController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var RunAppController = /** @class */ (function () {
        function RunAppController($scope, $modalInstance, externalApplicationsService, exportService, seriesManagerService) {
            var _this = this;
            var instanceUID = "";
            var cell = seriesManagerService.get_activeCell();
            if (cell) {
                instanceUID = cell.get_seriesInstanceUID();
            }
            $scope.externalApplications = [];
            var appList = externalApplicationsService.getAppList();
            for (var x in appList) {
                $scope.externalApplications.push(appList[x].name);
            }
            $scope.selectedApp = "";
            $scope.run = function () {
                var xtrnal = _this.externalApplicationsService.getAppList();
                var app = xtrnal[_this.$scope.selectedApp];
                if (app.args.indexOf("%pathname%") >= 0) {
                    if (instanceUID === "") {
                        alert("No active cell, please select one before you launch selected application");
                    }
                    else {
                        var prom = exportService.GetInstanceLocalPathName(instanceUID);
                        prom.success(function (pathname) {
                            app.args = app.args.replace("%pathname%", pathname);
                            _this.externalApplicationsService.runApp(app);
                        });
                        prom.error(function (err) {
                            alert(err);
                        });
                    }
                }
                else {
                    _this.externalApplicationsService.runApp(app);
                }
                $modalInstance.dismiss("");
            };
            $scope.cancel = function () {
                $modalInstance.dismiss("cancel");
            };
            $scope.deleteapp = function () {
                _this.externalApplicationsService.deleteApp(_this.$scope.selectedApp);
                $modalInstance.dismiss("");
            };
            this.externalApplicationsService = externalApplicationsService;
            this.$scope = $scope;
        }
        RunAppController.$inject = ["$scope", "$modalInstance", "externalApplicationsService", "exportService", "seriesManagerService"];
        return RunAppController;
    }());
    Controllers.RunAppController = RunAppController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var DicomLoader = /** @class */ (function () {
    function DicomLoader(retrieveLocalUrl, authenticationService, objectRetrieveService, eventService, queryArchiveService, $q, seriesManagerService, objectStoreService, optionService) {
        this._objectRetrieveService = objectRetrieveService;
        this._queryArchiveService = queryArchiveService;
        this._objectStoreService = objectStoreService;
        this._eventService = eventService;
        this._qService = $q;
        this._seriesManagerService = seriesManagerService;
        this._retrieveLocalUrl = retrieveLocalUrl;
        this._authenticationService = authenticationService;
        this._optionService = optionService;
        this._findInstances = null;
    }
    DicomLoader.prototype.loadSeries = function (cell, stackInstanceUIDs, template, generateMRTI, modality, mrtiCell, loadLayout) {
        var self = this;
        var seriesInstanceUID = cell.get_seriesInstanceUID();
        var id = cell.divID;
        if (loadLayout) {
            return this.loadLayout(seriesInstanceUID, id, template)
                .then(function () {
                self._eventService.publish(EventNames.MrtiInfoReady, { seriesInstanceUID: seriesInstanceUID });
                self.getInfo(seriesInstanceUID, id, stackInstanceUIDs, modality, null);
            }.bind(this));
        }
        else {
            self._eventService.publish(EventNames.OnLoadLayout, { layout: "", seriesInstanceUID: seriesInstanceUID, id: id, template: "" });
            self._eventService.publish(EventNames.MrtiInfoReady, { seriesInstanceUID: seriesInstanceUID });
            self.getInfo(seriesInstanceUID, id, stackInstanceUIDs, modality, null);
        }
    };
    DicomLoader.prototype.getInfo = function (seriesInstanceUID, id, stackInstanceUIDs, modality, presentationInfo) {
        var _this = this;
        this.findSeriesInstances(seriesInstanceUID, id, modality, stackInstanceUIDs)
            .then(function (result) {
            _this.getDicomJSON(result, id).then(function (data) {
                _this.setImageInformation(presentationInfo, seriesInstanceUID, id);
                // optimization 4, check this.
                _this.loadPresentationState(data, id, stackInstanceUIDs);
            }.bind(this));
        }.bind(this));
    };
    DicomLoader.prototype.setImageInformation = function (presentationInfo, seriesInstanceUID, id) {
        var cell = this._seriesManagerService.get_seriesCellById(id);
        if (cell != null && cell.frames.count > 0) {
            var instances = this._seriesManagerService.get_instances(cell.seriesInstanceUID, id);
            var __this = this;
            var frameArray = cell.frames.toArray();
            if (instances) {
                var instanceLength = instances.length;
                var lastIndex = 0;
                var numFrames = instances[0].NumberOfFrames;
                for (var instanceCounter = 0; instanceCounter < instanceLength; instanceCounter++) {
                    var instance = instances[instanceCounter];
                    if (instance != null && instance.Pages != null && instance.Pages.length > 0) {
                        var framesLength = instance.Pages.length;
                        var currentPageInfo;
                        var pageInfo = instance.Pages[0];
                        for (var index = 0; index < framesLength; index++) {
                            if ((index + lastIndex) < cell.frames.count) {
                                var cellFrame;
                                if (numFrames == 1) {
                                    cellFrame = Utils.findFirst(frameArray, function (frame) {
                                        var cellFrameInstance = frame.Instance;
                                        if (cellFrameInstance) {
                                            return cellFrameInstance.SOPInstanceUID == instance.SOPInstanceUID;
                                        }
                                        return false;
                                    });
                                }
                                else {
                                    cellFrame = cell.frames.item(index + lastIndex);
                                }
                                currentPageInfo = instance.Pages[index];
                                if (currentPageInfo != null) {
                                    if (pageInfo.TileSize.width != 0)
                                        pageInfo = currentPageInfo;
                                }
                                var supportWindowLevel = pageInfo.SupportWindowLevel;
                                if (pageInfo.ImagePositionPatientArray != null) {
                                    cellFrame.set_imagePosition(pageInfo.ImagePositionPatientArray);
                                }
                                if (pageInfo.ImageOrientationPatientArray != null) {
                                    cellFrame.set_imageOrientation(pageInfo.ImageOrientationPatientArray);
                                }
                                if (pageInfo.PatientOrientation != null) {
                                    cellFrame.set_patientProjection(pageInfo.PatientOrientation);
                                }
                                if (pageInfo.PixelSpacingPatientArray != null && pageInfo.PixelSpacingPatientArray.length == 2) {
                                    cellFrame.set_rowSpacing(parseFloat(pageInfo.PixelSpacingPatientArray[1]));
                                    cellFrame.set_columnSpacing(parseFloat(pageInfo.PixelSpacingPatientArray[0]));
                                }
                                {
                                    var mrtiInfo = new lt.Controls.Medical.MRTIImage();
                                    mrtiInfo.imageUri = this._retrieveLocalUrl + '/GetImageTile?auth=' + encodeURIComponent(this._authenticationService.authenticationCode) + '&instance=' + instance.SOPInstanceUID;
                                    mrtiInfo.imageName = pageInfo.ImageName;
                                    mrtiInfo.mimeType = pageInfo.MimeType;
                                    mrtiInfo.fullDpi = lt.LeadSizeD.create(150, 150);
                                    mrtiInfo.tileSize = lt.LeadSizeD.create(pageInfo.TileSize.width, pageInfo.TileSize.height);
                                    mrtiInfo.frameIndex = index;
                                    mrtiInfo.supportWindowLevel = supportWindowLevel && !cellFrame.isWaveForm;
                                    mrtiInfo.resolutions = [];
                                    for (var i = 0; i < pageInfo.Resolutions.length; i++) {
                                        mrtiInfo.resolutions[i] = lt.LeadSizeD.create(pageInfo.Resolutions[i].width, pageInfo.Resolutions[i].height);
                                    }
                                    cellFrame.set_width(mrtiInfo.resolutions[0].width);
                                    cellFrame.set_height(mrtiInfo.resolutions[0].height);
                                    mrtiInfo.fullSize = lt.LeadSizeD.create(cellFrame.get_width(), cellFrame.get_height());
                                    var bgSize;
                                    // if the structured display is selected, then use the background size for the structured display
                                    if (this._seriesManagerService.SeriesInstancesList)
                                        bgSize = parseInt(this._optionService.get(OptionNames.SDBackgroundSize));
                                    else
                                        bgSize = parseInt(this._optionService.get(OptionNames.BackgroundSize));
                                    cellFrame.set_backgroundSize(lt.LeadSizeD.create(bgSize, bgSize));
                                    cellFrame.mrtiInfo = mrtiInfo;
                                }
                            }
                        }
                        lastIndex += framesLength;
                    }
                }
            }
            else {
                setTimeout($.proxy(function () {
                    __this.setImageInformation(presentationInfo, seriesInstanceUID, id);
                }, this), 350);
            }
            this._eventService.publish(EventNames.OnFrameLoaded, { cell: cell });
        }
    };
    DicomLoader.prototype.getSeriesStacks = function (seriesIntanceUID) {
        var __this = this;
        return this._objectRetrieveService.GetSeriesStacks(seriesIntanceUID).then(function (data) {
            if (data.data != null) {
                return { stacks: data.data };
            }
        });
    };
    DicomLoader.prototype.loadFrameDicomJSON = function (cellFrame, doEvent) {
        var __this = this;
        return this._objectRetrieveService.GetDicomJSON(cellFrame.Instance.StudyInstanceUID, cellFrame.Instance.SeriesInstanceUID, cellFrame.Instance.SOPInstanceUID).then(function (data) {
            if (data.data != null) {
                var metadata = JSON.parse(data.data);
                var information = DicomHelper.GetDicomImageInformation(metadata);
                var publish = doEvent || true;
                cellFrame.set_information(information);
                cellFrame.set_imagePosition(information.position);
                if (information.orientation)
                    cellFrame.set_imageOrientation(information.orientation);
                cellFrame.set_imageType(information.imageType);
                cellFrame.set_lossyCompression(information.lossyImageCompression);
                cellFrame.metadata = metadata;
                cellFrame.JSON = metadata;
                cellFrame.isWaveForm = information.isWaveForm;
                cellFrame.set_width(information.get_width());
                cellFrame.set_height(information.get_height());
                cellFrame.set_rowSpacing(information.rowSpacing);
                cellFrame.set_columnSpacing(information.columnSpacing);
                cellFrame.originalSize = { width: information.get_width(), height: information.get_height() };
                if (publish) {
                    __this._eventService.publish(EventNames.ImageInformationReady, { seriesInstanceUID: cellFrame.Instance.SeriesInstanceUID, frameIndex: cellFrame.FrameIndex });
                }
                __this._eventService.publish(EventNames.LoadedDicomJSON, { seriesInstanceUID: cellFrame.Instance.SeriesInstanceUID, cellFrame: cellFrame });
                return { xmlData: data, cellFrame: cellFrame };
            }
        });
    };
    DicomLoader.prototype.loadLayout = function (seriesInstanceUID, id, template) {
        var __this = this;
        return this._objectRetrieveService.GetSeriesLayout(seriesInstanceUID, '')
            .then(function (layout) {
            __this._eventService.publish(EventNames.OnLoadLayout, { layout: layout.data, seriesInstanceUID: seriesInstanceUID, id: id, template: template });
            return { seriesInstanceUID: seriesInstanceUID, layout: layout.data };
        });
    };
    DicomLoader.prototype.loadPresentationInfo = function (seriesInstanceUID, id, stackInstanceUIDs) {
        var __this = this;
        return this._objectRetrieveService.GetPresentationInfo(seriesInstanceUID).then(function (data) {
            var presentationInfo = data.data;
            if (stackInstanceUIDs && stackInstanceUIDs.length > 0) {
                presentationInfo = $.grep(presentationInfo, function (item, index) {
                    return stackInstanceUIDs.indexOf(item.SOPInstanceUID) >= 0;
                });
            }
            __this._eventService.publish(EventNames.OnPresentationInfoLoaded, { seriesInstanceUID: seriesInstanceUID, presentationInfo: presentationInfo, id: id });
            return { seriesInstanceUID: seriesInstanceUID, presentationInfo: presentationInfo, id: id };
        });
    };
    DicomLoader.prototype.loadPresentationState = function (result, id, stackInstanceUIDs) {
        var __this = this;
        return this._queryArchiveService.FindPresentationState(result.seriesInstanceUID).then(function (data) {
            var annotations = data.data;
            if (stackInstanceUIDs && stackInstanceUIDs.length > 0) {
                annotations = $.grep(annotations, function (item, index) {
                    var sops = $.grep(item.ReferencedSOPInstanceUIDs, function (item, index) {
                        return stackInstanceUIDs.indexOf(item) >= 0;
                    });
                    return sops.length > 0;
                });
            }
            __this._eventService.publish(EventNames.PresentationStateLoaded, { seriesInstanceUID: result.seriesInstanceUID, annotations: annotations, id: id });
        });
    };
    DicomLoader.prototype.findSeriesInstances = function (seriesInstanceUID, id, modality, stackInstanceUIDs) {
        var __this = this;
        var query = new Models.QueryOptions();
        var stackInstanceUID = angular.isDefined(stackInstanceUIDs) && (stackInstanceUIDs != null) && stackInstanceUIDs.length > 0 ? stackInstanceUIDs[0] : '';
        query.SeriesOptions.SeriesInstanceUID = seriesInstanceUID;
        //// if it's a structured dispaly, then we don't just wann return portion of the series, we wanna return the whole series and store it
        //// to not call this expenisve function again to get another instance of that series.
        //if (__this._seriesManagerService.currentStructuredDisplay)
        //    stackInstanceUID = null;
        if (__this._seriesManagerService.SeriesInstancesList) {
            if (__this._seriesManagerService.SeriesInstancesList[seriesInstanceUID] != null) {
                var deferred = __this._qService.defer();
                var instances = __this._seriesManagerService.SeriesInstancesList[seriesInstanceUID];
                if (stackInstanceUIDs && stackInstanceUIDs.length > 0) {
                    var index = 0;
                    var length = stackInstanceUIDs.length;
                    var output = [];
                    var itemIndex;
                    var j;
                    for (index = 0; index < length; index++) {
                        for (j = 0; j < instances.length; j++) {
                            if (instances[j] != null) {
                                if (stackInstanceUIDs[index] == instances[j].SOPInstanceUID) {
                                    output.add(instances[j]);
                                    break;
                                }
                            }
                        }
                    }
                    instances = output;
                }
                __this._eventService.publish(EventNames.OnInstancesFound, { seriesInstanceUID: seriesInstanceUID, instances: instances, id: id, stackInstanceUID: stackInstanceUID });
                deferred.resolve({
                    seriesInstanceUID: seriesInstanceUID,
                    instances: instances,
                    id: id
                });
                return deferred.promise;
            }
        }
        var findInstancesResults = function (data) {
            var instances = data.data;
            var presentationInfo = __this._seriesManagerService.get_presentationInfo(seriesInstanceUID, id);
            /*if (stackInstanceUIDs && stackInstanceUIDs.length > 0) {
                instances = $.grep(instances, function (item: any, index: number) {
                    if (item != null)
                    return stackInstanceUIDs.indexOf(item.SOPInstanceUID) >= 0;
                    else
                        return false;
                });
            }*/
            if (stackInstanceUIDs && stackInstanceUIDs.length > 0) {
                var index = 0;
                var length = stackInstanceUIDs.length;
                var output = [];
                var itemIndex;
                var j;
                for (index = 0; index < length; index++) {
                    for (j = 0; j < instances.length; j++) {
                        if (instances[j] != null) {
                            if (stackInstanceUIDs[index] == instances[j].SOPInstanceUID) {
                                output.add(instances[j]);
                                break;
                            }
                        }
                    }
                }
                instances = output;
            }
            __this._eventService.publish(EventNames.OnInstancesFound, { seriesInstanceUID: seriesInstanceUID, instances: instances, id: id, stackInstanceUID: stackInstanceUID });
            return { seriesInstanceUID: seriesInstanceUID, instances: instances, id: id };
        };
        return this._queryArchiveService.FindInstances(query, stackInstanceUID).then(findInstancesResults);
    };
    DicomLoader.prototype.getDicomJSON = function (result, id) {
        var instance = result.instances[0];
        var __this = this;
        return this._objectRetrieveService.GetDicomJSON(instance.StudyInstanceUID, instance.SeriesInstanceUID, instance.SOPInstanceUID)
            .then(function (data) {
            var metadata = JSON.parse(data.data);
            __this._eventService.publish(EventNames.OnDicomJSONRetrieved, {
                seriesInstanceUID: result.seriesInstanceUID,
                instances: result.instances,
                metadata: metadata,
                id: id,
                sopInstanceUID: instance.SOPInstanceUID
            });
            __this._eventService.publish(EventNames.LoadedDicomJSON, { seriesInstanceUID: result.seriesInstanceUID, cellFrame: null, id: id });
            return { seriesInstanceUID: result.seriesInstanceUID, instances: result.instances, metadata: metadata };
        });
    };
    DicomLoader.prototype.sortInstances = function (instance1, instance2) {
        return parseInt(instance1.InstanceNumber) - parseInt(instance2.InstanceNumber);
    };
    DicomLoader.prototype.getDataSize = function (dicomData) {
        var imageWidthTag = DicomHelper.getDicomTag(dicomData, DicomTag.Columns);
        var imageHeightTag = DicomHelper.getDicomTag(dicomData, DicomTag.Rows);
        var width;
        var height;
        var maxSize = Utils.isTabletOrMobile() ? 256 : 512;
        if (imageWidthTag != null && imageWidthTag.length > 0) {
            width = parseInt(DicomHelper.GetTagText(imageWidthTag[0]), 10);
        }
        else {
            width = 512;
        }
        if (imageHeightTag != null && imageHeightTag.length) {
            height = parseInt(DicomHelper.GetTagText(imageHeightTag[0]), 10);
        }
        else {
            height = 512;
        }
        var newWidth = width;
        var newHeight = height;
        if (Math.max(width, height) < maxSize)
            return lt.LeadSizeD.create(newWidth, height);
        if (width > height) {
            newWidth = maxSize;
            newHeight = height * maxSize / width;
        }
        else {
            newHeight = maxSize;
            newWidth = width * maxSize / height;
        }
        return lt.LeadSizeD.create(parseInt(newWidth), parseInt(newHeight));
    };
    DicomLoader.$inject = ["retrieveLocalUrl", "authenticationService", "objectRetrieveService", "eventService", "queryArchiveService", "$q", "seriesManagerService", "objectStoreService", "optionService"];
    return DicomLoader;
}());
commangular.command('OnAnnotationSelect', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnSelect);
            }
        };
    }]);
function SetOrientation(seriesManagerService, face) {
    var cell = seriesManagerService.get_activeCell();
    var cell3D = cell;
    cell3D.orientation = face;
}
commangular.command('OnHeadOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.superior);
            }
        };
    }]);
commangular.command('OnFeetOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.inferior);
            }
        };
    }]);
commangular.command('OnLeftOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.left);
            }
        };
    }]);
commangular.command('OnRightOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.right);
            }
        };
    }]);
commangular.command('OnAnteriorOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.anterior);
            }
        };
    }]);
commangular.command('OnPosteriorOrientation', ['seriesManagerService', function (seriesManagerService) {
        return {
            execute: function () {
                SetOrientation(seriesManagerService, lt.Controls.Medical.OrientationFace.posterior);
            }
        };
    }]);
commangular.command('OnAnnotationArrow', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnPointer);
            }
        };
    }]);
commangular.command('OnAnnotationPoint', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnPoint);
            }
        };
    }]);
commangular.command('OnAnnotationRectangle', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnRectangle);
            }
        };
    }]);
commangular.command('OnAnnotationTextPointer', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnTextPointer);
            }
        };
    }]);
commangular.command('OnAnnotationEllipse', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnEllipse);
            }
        };
    }]);
commangular.command('OnAnnotationCurve', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnCurve);
            }
        };
    }]);
commangular.command('OnAnnotationLine', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnLine);
            }
        };
    }]);
commangular.command('OnAnnotationFreehand', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnFreeHand);
            }
        };
    }]);
commangular.command('OnAnnotationPolyline', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnPolyline);
            }
        };
    }]);
commangular.command('OnAnnotationPolygon', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnPolygon);
            }
        };
    }]);
commangular.command('OnAnnotationText', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnText);
            }
        };
    }]);
commangular.command('OnAnnotationNote', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnNote);
            }
        };
    }]);
commangular.command('OnAnnotationHighlight', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnHighlight);
            }
        };
    }]);
commangular.command('OnAnnotationRuler', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnRuler);
            }
        };
    }]);
commangular.command('OnAnnotationPolyRuler', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnPolyRuler);
            }
        };
    }]);
commangular.command('OnAnnotationProtractor', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                setAnnTool(toolbarService, tabService, buttonId, MedicalViewerAction.AnnProtractor);
            }
        };
    }]);
commangular.command('OnAnnotationShowHide', ['seriesManagerService', 'toolbarService', '$commangular', 'authenticationService', 'tabService',
    function (seriesManagerService, toolbarService, $commangular, authenticationService, tabService) {
        return {
            execute: function () {
                //var visibility = seriesManagerService.toggleAnnotationVisiblity();
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var visibility = tabService.get_tabData(tab.id, TabDataKeys.AnnotationVisiblity);
                if (angular.isUndefined(visibility)) {
                    visibility = true;
                }
                visibility = !visibility;
                enumerateCell(tabService, function (cell) {
                    var automation = cell.get_automation();
                    automation.get_activeContainer().set_isVisible(visibility);
                    automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                });
                //
                // update the current mode by disabling the automation as an interactive mode.
                //
                if (!visibility) {
                    $commangular.dispatch('Pan', { buttonId: 'Pan' + tab.id });
                }
                toolbarService.enable(['Select' + tab.id, 'Arrow' + tab.id, 'Ellipse' + tab.id, 'Highlight' + tab.id, 'Rectangle' + tab.id, 'Text' + tab.id,
                    'Ruler' + tab.id, 'PolyRuler' + tab.id, 'Protractor' + tab.id, 'Curve' + tab.id, 'Line' + tab.id, 'Freehand' + tab.id, 'Point' + tab.id,
                    'Polyline' + tab.id, 'Polygon' + tab.id, 'Note' + tab.id, 'DeleteAnnotations' + tab.id, 'ClearAnnotations' + tab.id,
                    'ClearAllAnnotations' + tab.id], function () {
                    return visibility;
                });
                toolbarService.enable('CalibrateRuler' + tab.id, function () {
                    var cell = seriesManagerService.get_activeCell();
                    var automation = cell.get_automation();
                    var container = automation.activeContainer;
                    return visibility && (automation.currentDesigner != null && container.selectionObject.selectedObjects.count == 1 && container.selectionObject.selectedObjects.item(0) instanceof lt.Annotations.Engine.AnnPolyRulerObject);
                });
                toolbarService.enable('SaveAnn' + tab.id, function () {
                    return visibility && authenticationService.hasPermission(PermissionNames.CanStoreAnnotations);
                });
                toolbarService.enable('LoadAnn' + tab.id, function () {
                    var cell = seriesManagerService.get_activeCell();
                    return visibility && authenticationService.hasPermission(PermissionNames.CanViewAnnotations) &&
                        seriesManagerService.get_annotationIDs(cell.seriesInstanceUID, cell.divID).length > 0;
                });
                tabService.set_tabData(tab.id, TabDataKeys.AnnotationVisiblity, visibility);
            }
        };
    }]);
commangular.command('OnDeleteAnnotation', ['seriesManagerService', 'toolbarService', 'authenticationService', 'tabService', function (seriesManagerService, toolbarService, authenticationService, tabService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                seriesManagerService.deleteSelectedAnnotations();
            }
        };
    }]);
commangular.command('OnClearAnnotation', ['seriesManagerService', 'toolbarService', 'authenticationService', 'tabService', function (seriesManagerService, toolbarService, authenticationService, tabService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (toolbarService.isEnabled("ClearAnnotations" + tab.id)) {
                    seriesManagerService.clearAnnotations();
                    if (toolbarService.isEnabled("CalibrateRuler" + tab.id)) {
                        toolbarService.disable("CalibrateRuler" + tab.id);
                    }
                }
            }
        };
    }]);
commangular.command('OnClearAllAnnotation', ['seriesManagerService', 'toolbarService', 'tabService', function (seriesManagerService, toolbarService, tabService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (toolbarService.isEnabled("ClearAllAnnotations" + tab.id)) {
                    seriesManagerService.clearAllAnnotations();
                    if (toolbarService.isEnabled("CalibrateRuler" + tab.id)) {
                        toolbarService.disable("CalibrateRuler" + tab.id);
                    }
                }
            }
        };
    }]);
commangular.command('OnLoadAnnotations', ['seriesManagerService', 'toolbarService', '$modal', 'eventService', 'objectRetrieveService', '$translate', 'dialogs', 'tabService', 'optionsService',
    function (seriesManagerService, toolbarService, $modal, eventService, objectRetrieveService, $translate, dialogs, tabService, optionsService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (toolbarService.isEnabled("LoadAnn" + tab.id)) {
                    var cell = seriesManagerService.get_activeCell();
                    var annotations = seriesManagerService.get_annotationIDs(cell.seriesInstanceUID, cell.divID);
                    var frame = seriesManagerService.get_activeCellFrame();
                    var children = frame.get_container().get_children();
                    var count = children.count;
                    var _container = frame.get_container();
                    var notifyTitle = "";
                    var no;
                    var ann;
                    var found;
                    $translate('DIALOGS_NOTIFY').then(function (translation) {
                        notifyTitle = translation;
                    });
                    $translate('NO').then(function (translation) {
                        no = translation;
                    });
                    $translate('ANNOTATIONS').then(function (translation) {
                        ann = translation.toLowerCase();
                    });
                    $translate('FOUND').then(function (translation) {
                        found = translation;
                    });
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Annotations.html',
                        controller: Controllers.AnnotationsController,
                        backdrop: 'static',
                        resolve: {
                            annotations: function () {
                                return annotations;
                            },
                            seriesInstanceUID: function () {
                                return cell.seriesInstanceUID;
                            }
                        }
                    });
                    modalInstance.result.then(function (selectedAnnotation) {
                        var calibrateUsingDPI = optionsService.get(OptionNames.CalibrateUsingDpi);
                        var userData = seriesManagerService.createLoadAnnotationUserData(cell.viewer, selectedAnnotation.ReferencedSOPInstanceUIDs, calibrateUsingDPI);
                        objectRetrieveService.GetMappedPresentationAnnotations(selectedAnnotation.SOPInstanceUID, userData).then(function (result) {
                            if (result.status == 200) {
                                if (result.data && result.data.length > 0) {
                                    var xmlAnnotations = $.parseXML(result.data);
                                    seriesManagerService.add_annotations(cell.viewer, xmlAnnotations);
                                }
                                else {
                                    dialogs.notify(notifyTitle, no + " " + ann + " " + found);
                                }
                            }
                        }, function (error) {
                            $translate('DIALOGS_ERROR').then(function (translation) {
                                dialogs.error(translation, error);
                            });
                        });
                    }).finally(function (result) {
                        var annotations = seriesManagerService.get_annotationIDs(cell.seriesInstanceUID, cell.divID);
                        toolbarService.enable("LoadAnn" + tab.id, function () {
                            return angular.isDefined(annotations) && annotations.length > 0;
                        });
                    });
                }
            }
        };
    }]);
function AnyAnnFound(cell) {
    var length = cell.get_frames().get_count();
    var annFound = false;
    for (var index = 0; index < length; index++) {
        var frame = cell.get_frames().item(index);
        var children = frame.get_container().get_children();
        var count = children.count;
        if (!annFound) {
            if (count != 0) {
                annFound = true;
            }
        }
    }
    return annFound;
}
commangular.command('OnSaveAnnotations', ['seriesManagerService', 'toolbarService', 'objectStoreService', 'authenticationService', '$modal', '$translate', 'dialogs', 'tabService', 'optionsService', 'objectRetrieveService', 'eventService',
    function (seriesManagerService, toolbarService, objectStoreService, authenticationService, $modal, $translate, dialogs, tabService, optionsService, objectRetrieveService, eventService) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var _container;
                var frame = seriesManagerService.get_activeCellFrame();
                var annFound;
                if (toolbarService.isEnabled("SaveAnn" + tab.id)) {
                    var cell = seriesManagerService.get_activeCell();
                    if (!cell)
                        return;
                    var medicalViewer = cell.viewer;
                    var structuredDisplay = seriesManagerService.currentStructuredDisplay != null;
                    if (structuredDisplay) {
                        length = medicalViewer.layout.get_items().count;
                        for (var index = 0; index < length; index++) {
                            var currentCell = medicalViewer.layout.get_items().get_item(index);
                            annFound = AnyAnnFound(currentCell);
                            if (annFound)
                                break;
                        }
                    }
                    else {
                        annFound = AnyAnnFound(cell);
                    }
                    if (!annFound) {
                        alert('no annotation found to save');
                        return;
                    }
                    if (cell) {
                        var seriesInstanceUID = cell.get_seriesInstanceUID();
                        var annotationsSaved = "";
                        var notifyTitle = "";
                        var errorTitle = "Error";
                        $translate('ANNOTATIONS_SAVED').then(function (translation) {
                            annotationsSaved = translation.toLowerCase();
                        });
                        $translate('DIALOGS_NOTIFY').then(function (translation) {
                            notifyTitle = translation;
                        });
                        $translate('DIALOGS_ERROR').then(function (translation) {
                            errorTitle = translation;
                        });
                        var calibrateUsingDPI = optionsService.get(OptionNames.CalibrateUsingDpi);
                        var rowSpacings = [];
                        var columnSpacings = [];
                        var sopInstanceUIDs = [];
                        var calibreated = false;
                        if (structuredDisplay) {
                            calibreated = seriesManagerService.get_structuredDisplayCalibratedPixelSpacing(medicalViewer, rowSpacings, columnSpacings, sopInstanceUIDs);
                            seriesInstanceUID = seriesManagerService.currentStructuredDisplay.InstanceUID;
                        }
                        else
                            calibreated = seriesManagerService.get_pixelSpacing(cell, rowSpacings, columnSpacings);
                        /*if (annotationsData.length > 0)*/ {
                            var modalInstance = $modal.open({
                                templateUrl: 'views/dialogs/AnnotationsSave.html',
                                controller: Controllers.AnnotationsSaveController,
                                backdrop: 'static',
                                resolve: {
                                    showDerived: function () {
                                        return calibrateUsingDPI && calibreated;
                                    },
                                    seriesDescription: function () {
                                        if (frame && frame.JSON)
                                            return DicomHelper.getDicomTagValue(frame.JSON, DicomTag.SeriesDescription);
                                        else
                                            return "";
                                    }
                                }
                            });
                            function StoreAnnotations(seriesUID, annData, description, useRulerCalibrationScale) {
                                Utils.ShowProcessingScreen("Saving Annotations", true, 0);
                                var _ids = seriesUID;
                                objectStoreService.StoreAnnotations(seriesUID, annData, description, "", useRulerCalibrationScale).then(function (result) {
                                    Utils.ShowProcessingScreen("", false, 0);
                                    if (angular.isDefined(result.data) && angular.isDefined(result.data.Message)) {
                                        dialogs.error(errorTitle, result.data.Message);
                                    }
                                    else {
                                        var dentalMode = optionsService.isSeriesView();
                                        var ids = _ids.split('\\');
                                        var index = 0;
                                        var length = ids.length;
                                        for (index = 0; index < length; index++) {
                                            seriesManagerService.add_annotationID(ids[index], cell.divID, result.data);
                                        }
                                        if (dentalMode) {
                                            toolbarService.hilightBorder("LoadAnn" + tab.id, "1px", "#ff0000");
                                        }
                                        toolbarService.enable('LoadAnn' + tab.id, function () {
                                            return authenticationService.hasPermission(PermissionNames.CanViewAnnotations);
                                        });
                                        toolbarService.enable("SaveAnn" + tab.id, function () {
                                            return authenticationService.hasPermission(PermissionNames.CanStoreAnnotations);
                                        });
                                        dialogs.notify(notifyTitle, annotationsSaved);
                                    }
                                }, function (error) {
                                    Utils.ShowProcessingScreen("", false, 0);
                                    var message = "";
                                    if (angular.isDefined(error.status)) {
                                        message = Utils.get_httpStatusText(error.status);
                                    }
                                    else {
                                        message = error;
                                    }
                                    $translate('DIALOGS_ERROR').then(function (translation) {
                                        dialogs.error(translation, message);
                                    });
                                });
                            }
                            modalInstance.result.then(function (info) {
                                if (info.saveAsDerived) {
                                    Utils.ShowProcessingScreen("Saving Derived Series", true, 0);
                                    if (structuredDisplay) {
                                        objectStoreService.StoreStructuredDisplay(seriesInstanceUID, info.derivedSeriesNumber, info.derivedSeriesDescription, info.derivedProtocol, sopInstanceUIDs, rowSpacings, columnSpacings).then(function (result) {
                                            eventService.publish(EventNames.DerivedImageCreated, { series: result.data });
                                            var list = result.data.MappedSeriesInstanceUIDs;
                                            var referencedSeries = [];
                                            var annotationsData = seriesManagerService.get_calibratedStructuredDisplayAnnotations(cell, list, referencedSeries, calibrateUsingDPI);
                                            var derivedSeriesInstanceUID = Utils.combineString(referencedSeries, '\\');
                                            StoreAnnotations(derivedSeriesInstanceUID, annotationsData, info.description, false);
                                        });
                                    }
                                    else {
                                        objectStoreService.StoreDerivedSeries(seriesInstanceUID, info.derivedSeriesNumber, info.derivedSeriesDescription, info.derivedProtocol, rowSpacings, columnSpacings).then(function (result) {
                                            eventService.publish(EventNames.DerivedImageCreated, { series: result.data });
                                            var derivedSeriesInstanceUID = result.data.InstanceUID;
                                            var list = result.data.MappedSopInstanceUIDs;
                                            var annotationsData = seriesManagerService.get_Annotations(cell, list);
                                            StoreAnnotations(derivedSeriesInstanceUID, annotationsData, info.description, false);
                                        });
                                    }
                                }
                                else {
                                    if (structuredDisplay) {
                                        var referencedSeries = [];
                                        var annotationsData = seriesManagerService.get_allCellsAnnotations(cell, referencedSeries, calibrateUsingDPI);
                                        var seriesInstances = Utils.combineString(referencedSeries, '\\');
                                        StoreAnnotations(seriesInstances, annotationsData, info.description, true);
                                    }
                                    else {
                                        var annotationsData = seriesManagerService.get_cellAnnotations(cell, calibrateUsingDPI);
                                        StoreAnnotations(seriesInstanceUID, annotationsData, info.description, true);
                                    }
                                }
                            });
                        }
                    }
                }
            }
        };
    }]);
commangular.command('OnCalibrateRuler', ['seriesManagerService', 'toolbarService', 'tabService', '$modal', function (seriesManagerService, toolbarService, tabService, $modal) {
        return {
            execute: function () {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                if (toolbarService.isEnabled("CalibrateRuler" + tab.id)) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/CalibrateRuler.html',
                        controller: Controllers.CalibrateRulerController,
                        backdrop: 'static'
                    });
                    modalInstance.result.then(function (calibration) {
                        if (isNaN(calibration.length)) {
                            alert('Invalid Length');
                        }
                        else {
                            var cell = seriesManagerService.get_activeCell();
                            var automation = cell.get_automation();
                            var annObject = automation.get_currentEditObject();
                            var unit = parseInt(calibration.unit, 10);
                            if (!calibration.applyToAll) {
                                var frame = seriesManagerService.get_activeCellFrame();
                                var container = frame.container;
                                container.get_mapper().calibrate(annObject.getRulerLength(1), 0, lt.LeadLengthD.create(calibration.length), unit);
                                annObject.measurementUnit = unit;
                            }
                            else {
                                var length = cell.get_frames().count;
                                while (length--) {
                                    var frame = cell.get_frames().item(length);
                                    var container = frame.get_container();
                                    container.get_mapper().calibrate(annObject.getRulerLength(1), 0, lt.LeadLengthD.create(calibration.length), unit);
                                    container.children.toArray().forEach(function (item, index) {
                                        if (item instanceof lt.Annotations.Engine.AnnPolyRulerObject) {
                                            item.measurementUnit = unit;
                                        }
                                    });
                                }
                            }
                        }
                        automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                    });
                }
            }
        };
    }]);
function setAnnTool(toolbarService, tabService, buttonId, tool) {
    if (toolbarService.isEnabled(buttonId)) {
        SetCurrentInteractiveMode(toolbarService, tabService, tool, buttonId, false);
        enumerateCell(tabService, function (cell) {
            //var command = cell.getCommand(MedicalViewerAction.Offset2);
            //if (command != null && command.isStarted) {
            //    cell.stopCommand(MedicalViewerAction.Offset2);
            //}
            CommandManager.RunCommand(cell, tool, buttonId);
            //cell.runCommand(tool);                        
        });
    }
}
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var ViewDicomController = /** @class */ (function () {
        function ViewDicomController($scope, eventService, toolbarService, $modalInstance, optionsService, dicom, frame, objectRetrieveService, $translate) {
            this._unknownString = "Unknown";
            var model = [];
            var __this = this;
            this._dateFormat = optionsService.get(OptionNames.DateFormat);
            this._timeFormat = optionsService.get(OptionNames.TimeFormat);
            this._scope = $scope;
            this._objectRetrieveService = objectRetrieveService;
            $scope.gridOptions = {
                columnDefs: [
                    {
                        headerName: "Tag", field: "tag", width: 150,
                        cellRenderer: {
                            renderer: 'group',
                            innerRenderer: this.innerCellRenderer.bind(this)
                        }
                    },
                    { headerName: "Name", field: "name", width: 250 },
                    {
                        headerName: "Value",
                        field: "value",
                        width: 250
                    }
                ],
                rowData: this.buildData(dicom, new Array()),
                rowSelection: 'multiple',
                rowsAlreadyGrouped: true,
                enableColResize: true,
                enableSorting: true,
                rowHeight: 20,
                icons: {
                    groupExpanded: '<i class="fa fa-minus-square-o"/>',
                    groupContracted: '<i class="fa fa-plus-square-o"/>'
                },
                onGridReady: function () {
                    $scope.gridOptions.api.hideOverlay();
                },
            };
            $scope.ok = function () {
                $modalInstance.close();
            };
            $translate('UNKNOWN').then(function (translation) {
                this._unknownString = translation;
            }.bind(this));
            eventService.subscribe(EventNames.StackChanged, this.stackChanged.bind(this));
        }
        ViewDicomController.prototype.innerCellRenderer = function (params) {
            if (params.data.vr == 'SQ') {
                return '<span><i class="fa fa-tags" style="color: blue"></i>&nbsp;' + params.data.tag + '</span>';
            }
            return '<span><i class="fa fa-tag" style="color: blue"></i>&nbsp;' + params.data.tag + '</span>';
        };
        ViewDicomController.prototype.buildData = function (dicom, data) {
            for (var key in dicom) {
                var dcmData = new Models.DicomData(this.splitCamelCaseToString(dicom[key].keyword), key);
                var row = new Models.DicomTagRow(dcmData);
                if (!dcmData.name) {
                    dcmData.name = this._unknownString;
                }
                dcmData.vr = dicom[key].vr;
                if (dicom[key].vr == 'PN') {
                    dcmData.value = DicomHelper.getPatientNameFromTag(dicom[key]);
                }
                else if (dicom[key].vr != 'SQ') {
                    var value = DicomHelper.getConvertValue(dicom[key]);
                    if (dicom[key].vr == 'DA') {
                        if (value) {
                            var DateJS = (new Date(DicomHelper.parseDicomDate(value)));
                            value = DateJS.toString(this._dateFormat);
                        }
                    }
                    if (dicom[key].vr == 'TM') {
                        if (value) {
                            var DateJS = Date.today().at(DicomHelper.parseDicomTime(value));
                            value = DateJS.toString(this._timeFormat);
                        }
                    }
                    dcmData.value = value;
                }
                else {
                    if (dicom[key].Value && dicom[key].Value.length > 0) {
                        var length = dicom[key].Value.length;
                        row.group = true;
                        row.expanded = false;
                        for (var index = 0; index < length; index++) {
                            var dcmData = new Models.DicomData("Item", "FFFEE000");
                            var itemRow = new Models.DicomTagRow(dcmData);
                            itemRow.group = true;
                            itemRow.expanded = false;
                            row.children.push(itemRow);
                            this.buildData(dicom[key].Value[index], itemRow.children);
                        }
                    }
                }
                data.push(row);
            }
            return data;
        };
        ViewDicomController.prototype.getDateTime = function () {
            var DateJS = (new Date());
            var formattedString;
            formattedString = DateJS.toString(this._dateFormat + " " + this._timeFormat);
            return formattedString;
        };
        ViewDicomController.prototype.splitCamelCaseToString = function (s) {
            if (!s)
                return '';
            return s.replace(/(^[a-z]+)|[0-9]+|[A-Z][a-z]+|[A-Z]+(?=[A-Z][a-z]|[0-9])/g, function (match, first) {
                if (first)
                    match = match[0].toUpperCase() + match.substr(1);
                return match + ' ';
            }).trim();
        };
        ViewDicomController.prototype.stackChanged = function (event, data) {
            var frame = data.args.frame;
            if (frame && frame.metadata != null) {
                var tagRow = new Array();
                var rows = this.buildData(frame.metadata, tagRow);
                this._scope.gridOptions.api.setRowData(rows);
            }
            else if (frame && !frame.metadata) {
                if (frame.Instance) {
                    this._objectRetrieveService.GetDicomJSON(frame.Instance.StudyInstanceUID, frame.Instance.SeriesInstanceUID, frame.Instance.SOPInstanceUID).success(function (result) {
                        try {
                            frame.metadata = JSON.parse(result);
                            if (frame.metadata) {
                                var tagRow = new Array();
                                var rows = this.buildData(frame.metadata, tagRow);
                                this._scope.gridOptions.api.setRowData(rows);
                            }
                        }
                        catch (e) {
                            console.log(e);
                        }
                    }.bind(this));
                }
            }
        };
        ViewDicomController.$inject = ['$scope', 'eventService', 'toolbarService', '$modalInstance', 'optionsService', 'dicom', 'frame', 'objectRetrieveService', '$translate'];
        return ViewDicomController;
    }());
    Controllers.ViewDicomController = ViewDicomController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var SaveAsDerivedController = /** @class */ (function () {
        function SaveAsDerivedController($scope, optionsService, $modalInstance, derivedInfo) {
            $scope.derivedInfo = derivedInfo;
            $scope.editSeriesNumber = optionsService.get(OptionNames.EnableSeriesNumberEdit);
            $scope.editProtocolName = optionsService.get(OptionNames.EnableProtocolNameEdit);
            $scope.ok = function () {
                $modalInstance.close($scope.derivedInfo);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        SaveAsDerivedController.$inject = ['$scope', 'optionsService', '$modalInstance', 'derivedInfo'];
        return SaveAsDerivedController;
    }());
    Controllers.SaveAsDerivedController = SaveAsDerivedController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var ExportSource = /** @class */ (function () {
        function ExportSource(value, displayName) {
            this.value = value;
            this.displayName = displayName;
            this.selectable = true;
        }
        return ExportSource;
    }());
    Controllers.ExportSource = ExportSource;
    var ExportController = /** @class */ (function () {
        function ExportController($scope, $modal, optionsService, $modalInstance, hasLayout) {
            $scope.exportFormats = new Array();
            $scope.exportFormats.push(new Models.ExportImageFormat("BMP", "Bmp", true, false));
            $scope.exportFormats.push(new Models.ExportImageFormat("JPG", "Jpeg", true, false, true));
            $scope.exportFormats.push(new Models.ExportImageFormat("JPG Lossless", "JpegLossy", true, true));
            $scope.exportFormats.push(new Models.ExportImageFormat("PNG", "Png", true, false));
            $scope.exportFormats.push(new Models.ExportImageFormat("TIF", "Tif", true, true));
            $scope.exportFormats.push(new Models.ExportImageFormat("CMP", "Cmp", true, false, true));
            $scope.exportFormats.push(new Models.ExportImageFormat("PDF", "PDF", false, false, false, true, true));
            $scope.exportFormats.push(new Models.ExportImageFormat("DICOM", "DicomGray", false, true));
            $scope.exportOptions = new Models.ExportOptions();
            $scope.source = {};
            $scope.exportSources = new Array();
            $scope.exportSources.push(new ExportSource("PrintCurrentView", "Screenshot Current View"));
            $scope.exportSources.push(new ExportSource("AllPatientImages", "All Patient Images"));
            $scope.exportSources.push(new ExportSource("CurrentSeries", "Current Series"));
            // selected images only work when you have a layout attached with the series.
            if (hasLayout) {
                $scope.exportSources.push(new ExportSource("SelectedImages", "Selected Images"));
            }
            // set export source.
            var value = window.localStorage.getItem("Export.ExportSource");
            if (value)
                $scope.source.exportType = this.getExportSourceItem($scope, value);
            else
                $scope.source.exportType = $scope.exportSources[0];
            // set export format.
            value = window.localStorage.getItem("Export.ExportFormats");
            if (value)
                $scope.source.selectedFormat = this.getExportFormatItem($scope, value);
            else
                $scope.source.selectedFormat = $scope.exportFormats[3];
            // set burn annotation.
            value = window.localStorage.getItem("Export.BurnAnnotations");
            if (value)
                $scope.exportOptions.BurnAnnotations = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.WhiteBackground");
            if (value)
                $scope.exportOptions.WhiteBackground = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.PatientInfo");
            if (value)
                $scope.exportOptions.PatientInfo = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.CreateDICOMDIR");
            if (value)
                $scope.exportOptions.CreateDICOMDIR = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.ImageCompression");
            if (value)
                $scope.exportOptions.ImageCompression = parseInt(value);
            value = window.localStorage.getItem("Export.Anonymize");
            if (value)
                $scope.exportOptions.Anonymize = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.IncludeViewer");
            if (value)
                $scope.exportOptions.IncludeViewer = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.BurnDisplayedAnnotations");
            if (value)
                $scope.exportOptions.BurnDisplayedAnnotations = (value == "true" ? true : false);
            value = window.localStorage.getItem("Export.ZipType");
            if (value)
                $scope.exportOptions.ZipType = value;
            else
                $scope.exportOptions.ZipType = 'dcz';
            $scope.passwordValid = function () {
                return $scope.exportOptions.DczPassword && $scope.exportOptions.DczPassword.trim().length > 0;
            };
            $scope.passwordRequired = function () {
                return $scope.isDICOM() && ($scope.exportOptions.ZipType == "dcz");
            };
            $scope.isDICOM = function () {
                return $scope.source.exportType.value != 'PrintCurrentView' && ($scope.source.selectedFormat.Format == "DicomGray");
            };
            $scope.isPDF = function () {
                return ($scope.source.selectedFormat.Format == 'PDF') && ($scope.source.exportType.value != 'PrintCurrentView');
            };
            $scope.GetExtention = function () {
                var format = $scope.source.selectedFormat.Format;
                var extention = ".zip";
                if (format.toLowerCase() == "pdf")
                    extention = ".pdf";
                if (format.toLowerCase() == "pdf")
                    extention = ".pdf";
                if ($scope.exportOptions.DczPassword.trim())
                    extention = ".dcz";
                return extention;
            };
            $scope.ok = function () {
                if ((!$scope.passwordValid()) && $scope.passwordRequired()) {
                    alert('Password is required');
                    $scope.exportOptions.DczPassword = "";
                    return;
                }
                var ananomize = $scope.exportOptions.Anonymize;
                var displayWarningAgain = !(window.localStorage.getItem("Export.DontAskAgain") == "true" ? true : false);
                if (ananomize && displayWarningAgain) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/Warning.html',
                        controller: Controllers.WarningController,
                        backdrop: 'static'
                    });
                    modalInstance.result.then(function () {
                        $scope.saveAndExport();
                    });
                }
                else
                    $scope.saveAndExport();
            };
            $scope.saveAndExport = function () {
                window.localStorage.setItem("Export.ExportSource", $scope.source.exportType.value);
                window.localStorage.setItem("Export.ExportFormats", $scope.source.selectedFormat.Format);
                window.localStorage.setItem("Export.BurnAnnotations", $scope.exportOptions.BurnAnnotations.toString());
                window.localStorage.setItem("Export.BurnDisplayedAnnotations", $scope.exportOptions.BurnDisplayedAnnotations.toString());
                window.localStorage.setItem("Export.WhiteBackground", $scope.exportOptions.WhiteBackground.toString());
                window.localStorage.setItem("Export.PatientInfo", $scope.exportOptions.PatientInfo.toString());
                window.localStorage.setItem("Export.CreateDICOMDIR", $scope.exportOptions.CreateDICOMDIR.toString());
                window.localStorage.setItem("Export.ImageCompression", $scope.exportOptions.ImageCompression.toString());
                window.localStorage.setItem("Export.Anonymize", $scope.exportOptions.Anonymize.toString());
                window.localStorage.setItem("Export.IncludeViewer", $scope.exportOptions.IncludeViewer.toString());
                window.localStorage.setItem("Export.ZipType", $scope.exportOptions.ZipType.toString());
                if ($scope.exportOptions.ZipType != 'dcz')
                    $scope.exportOptions.DczPassword = "";
                $scope.exportOptions.Ext = $scope.GetExtention();
                $scope.exportOptions.FileFormat = $scope.source.selectedFormat.Format == "JpegLossy" ? "Jpg Lossless" : $scope.source.selectedFormat.Format;
                $scope.exportOptions.LayoutImageWidth = 0;
                $modalInstance.close({ options: $scope.exportOptions, source: $scope.source.exportType.value });
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        ExportController.prototype.getExportSourceItem = function ($scope, value) {
            var index = 0;
            var length = $scope.exportSources.length;
            if (length == 0)
                return;
            for (index = 0; index < length; index++) {
                if ($scope.exportSources[index].value == value)
                    return $scope.exportSources[index];
            }
            return $scope.exportSources[0];
        };
        ExportController.prototype.getExportFormatItem = function ($scope, value) {
            var index = 0;
            var length = $scope.exportFormats.length;
            if (length == 0)
                return;
            for (index = 0; index < length; index++) {
                if ($scope.exportFormats[index].Format == value)
                    return $scope.exportFormats[index];
            }
            return $scope.exportFormats[0];
        };
        ExportController.$inject = ['$scope', '$modal', 'optionsService', '$modalInstance', 'hasLayout'];
        return ExportController;
    }());
    Controllers.ExportController = ExportController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var AnnotationsController = /** @class */ (function () {
        function AnnotationsController($scope, $modalInstance, optionsService, eventService, annotations, authenticationService, objectStoreService, seriesManagerService, seriesInstanceUID) {
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            $scope.gridOptions = {
                enableSorting: true,
                enableRowSelection: true,
                enableRowHeaderSelection: lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet,
                noUnselect: false,
                multiSelect: false,
                onRegisterApi: function (gridApi) {
                    gridApi.selection.on.rowSelectionChanged($scope, function (selectedRow) {
                        $scope.selectedAnnotation = selectedRow.entity;
                    });
                    $scope.gridApi = gridApi;
                    // select first item in the grid.
                    if ($scope.gridOptions.data && $scope.gridOptions.data.length > 0) {
                        $scope.gridApi.grid.modifyRows($scope.gridOptions.data);
                        $scope.gridApi.selection.selectRow($scope.gridOptions.data[0]);
                    }
                },
                columnDefs: [
                    { name: "Description", field: "ContentDescription", enableHiding: false },
                    { name: "Create Date", field: "CreationDate", enableHiding: false },
                    { name: "Creator Name", field: "ContentCreatorName", enableHiding: false },
                ],
                data: annotations
            };
            $scope.selectedAnnotation = null;
            $scope.ok = function () {
                var sopInstanceUid = "";
                if ($scope.selectedAnnotation != null) {
                    sopInstanceUid = $scope.selectedAnnotation.SOPInstanceUID;
                }
                $modalInstance.close($scope.selectedAnnotation);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope['delete'] = function () {
                objectStoreService.DeleteAnnotations($scope.selectedAnnotation.SOPInstanceUID).then(function () {
                    var cell = seriesManagerService.get_activeCell();
                    seriesManagerService.remove_annotationID(seriesInstanceUID, cell.divID, $scope.selectedAnnotation.SOPInstanceUID);
                    $scope.selectedAnnotation = null;
                }, function (error) {
                });
            };
            $scope.canDeleteAnnotations = function () {
                return authenticationService.hasPermission(PermissionNames.CanDeleteAnnotations) && ($scope.selectedAnnotation != null);
            };
            $scope.onSelectRow = function (rowid, data) {
                $scope.selectedAnnotation = data;
                $scope.$apply();
            };
            $scope.annotations = annotations;
        }
        AnnotationsController.$inject = ['$scope', '$modalInstance', 'optionsService', 'eventService', 'annotations', 'authenticationService', 'objectStoreService', 'seriesManagerService', 'seriesInstanceUID'];
        return AnnotationsController;
    }());
    Controllers.AnnotationsController = AnnotationsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Controllers;
(function (Controllers) {
    var AnnotationsSaveController = /** @class */ (function () {
        function AnnotationsSaveController($scope, $modalInstance, showDerived, seriesDescription) {
            $scope.info = {};
            $scope.info.description = "";
            $scope.info.saveAsDerived = false;
            $scope.info.derivedSeriesNumber = "";
            $scope.info.derivedSeriesDescription = seriesDescription;
            $scope.info.derivedProtocol = "";
            $scope.enableDerived = function () {
                return showDerived;
            };
            $scope.ok = function () {
                if ($scope.info.description && $scope.info.description.length != 0) {
                    if (showDerived && !$scope.info.saveAsDerived) {
                        alert("Cannot save calibrated annotation, you can only save it to a copy of the series");
                        return;
                    }
                    $modalInstance.close($scope.info);
                }
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        AnnotationsSaveController.$inject = ['$scope', '$modalInstance', 'showDerived', 'seriesDescription'];
        return AnnotationsSaveController;
    }());
    Controllers.AnnotationsSaveController = AnnotationsSaveController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Controllers;
(function (Controllers) {
    var AudioController = /** @class */ (function () {
        function AudioController($scope, $modalInstance, seriesManagerService, objectRetrieveService) {
            var cellFrame = seriesManagerService.get_activeCellFrame();
            var sopInstanceUID = cellFrame.Instance.SOPInstanceUID;
            $scope.uiType = "none";
            objectRetrieveService.GetAudioGroupsCount(sopInstanceUID).then(function (result) {
                if (result.status == 200) {
                    if (result.data && result.data > 0) {
                        if (lt.LTHelper.OS == lt.LTOS.iOS) {
                            if (lt.LTHelper.device == lt.LTDevice.tablet) {
                                $scope.uiType = "download";
                            }
                        }
                        if ($scope.uiType != 'download') {
                            $scope.uiType = 'playback';
                        }
                        $scope.href = objectRetrieveService.BuildAudioUrl(sopInstanceUID, 0, 'audio/wav');
                    }
                    else
                        $scope.uiType = 'none';
                }
            }, function (error) {
                $scope.uiType = 'none';
            });
            $scope.close = function () {
                $modalInstance.close();
            };
        }
        AudioController.$inject = ['$scope', '$modalInstance', 'seriesManagerService', 'objectRetrieveService'];
        return AudioController;
    }());
    Controllers.AudioController = AudioController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Controllers;
(function (Controllers) {
    var CinePlayerController = /** @class */ (function () {
        function CinePlayerController($scope, $modalInstance, seriesManagerService, cinePlayerService, eventService, safeApply) {
            var previousCell = null;
            $scope.enabled = true;
            $scope.service = cinePlayerService;
            $scope.player = {};
            $scope.player.currentFrame = cinePlayerService.currentFrame;
            $scope.first = function () {
                cinePlayerService.first();
            };
            $scope.previous = function () {
                cinePlayerService.previous();
            };
            $scope.stop = function () {
                cinePlayerService.stop();
            };
            $scope.play = function () {
                previousCell = seriesManagerService.get_activeCell();
                cinePlayerService.start();
            };
            $scope.next = function () {
                cinePlayerService.next();
            };
            $scope.last = function () {
                cinePlayerService.last();
            };
            $scope.close = function () {
                $modalInstance.close();
            };
            eventService.subscribe(EventNames.PlayerStopped, function (event, data) {
                $scope.player.currentFrame = data.args.frame + 1;
            });
            cinePlayerService.set_frameChanged(function (frame) {
                $scope.player.currentFrame = frame + 1;
            });
        }
        CinePlayerController.$inject = ['$scope', '$modalInstance', 'seriesManagerService', 'cinePlayerService', 'eventService', 'safeApply'];
        return CinePlayerController;
    }());
    Controllers.CinePlayerController = CinePlayerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var InteractiveVerticalSlider = /** @class */ (function (_super) {
    __extends(InteractiveVerticalSlider, _super);
    function InteractiveVerticalSlider(element, steps) {
        var _this = _super.call(this) || this;
        _this._unitSize = 0;
        _this._currentStep = 0;
        _this._inMin = true;
        _this._inMax = false;
        _this._screenY = 0;
        _this._isStarted = false;
        _this._workCompleted = null;
        _this._stepChanged = null;
        _super.prototype.set_enableMouseWheel.call(_this, false);
        _this._scrollBar = element;
        _this._steps = steps;
        _this._slider = document.createElement('div');
        _this._slider.className = 'slider';
        _this._scrollBar.appendChild(_this._slider);
        _this.createControl(_this._scrollBar, _this._scrollBar.parentElement, _this._slider);
        if (lt.LTHelper.supportsTouch) {
            _this.set_hitTestBuffer(15);
        }
        _this.setupSlider();
        _this.startListening();
        return _this;
    }
    InteractiveVerticalSlider.prototype.setupSlider = function () {
        var sliderHeight = this.calculateSliderHeight(this._steps);
        var availableSpace = this._scrollBar.clientHeight - sliderHeight;
        var currentStep;
        this._unitSize = availableSpace / Math.max(1, this._steps - 1);
        currentStep = this.get_currentStep();
        this.set_currentStep(1);
        this._slider.style.height = sliderHeight + "px";
        this._slider.style.position = 'absolute';
        this.set_currentStep(currentStep);
    };
    InteractiveVerticalSlider.prototype.calculateSliderHeight = function (steps) {
        var scrollHeight = this._scrollBar.clientHeight;
        var allSteps = scrollHeight / (steps == 0 ? 1 : steps);
        return ((allSteps > 30) ? allSteps : 30);
    };
    InteractiveVerticalSlider.prototype.get_isWorking = function () {
        return this._isStarted;
    };
    InteractiveVerticalSlider.prototype.get_currentStep = function () {
        return this._currentStep + 1;
    };
    InteractiveVerticalSlider.prototype.set_currentStep = function (step) {
        var offsetTop;
        var offsetY;
        if (step <= 0 || step > this._steps) {
            return;
        }
        step = step - 1;
        offsetTop = $(this._scrollBar).offset().top;
        offsetY = (step * this._unitSize) + offsetTop;
        $(this._slider).offset({ top: offsetY });
        this._currentStep = step;
    };
    InteractiveVerticalSlider.prototype.updateSteps = function (steps) {
        var oldSteps = this.get_currentStep();
        this._steps = steps;
        this._screenY = 0;
        this._unitSize = 0;
        this._inMin = true;
        this._inMax = false;
        this.setupSlider();
        this.set_currentStep(Math.min(oldSteps, steps));
    };
    InteractiveVerticalSlider.prototype.resetSteps = function (steps) {
        this._steps = steps;
        this._screenY = 0;
        this._unitSize = 0;
        this._inMin = true;
        this._inMax = false;
        this.setupSlider();
        this.set_currentStep(1);
    };
    InteractiveVerticalSlider.prototype.add_stepChanged = function (value) {
        this._stepChanged = ss.Delegate.combine(this._stepChanged, value);
    };
    InteractiveVerticalSlider.prototype.remove_stepChanged = function (value) {
        this._stepChanged = ss.Delegate.remove(this._stepChanged, value);
    };
    InteractiveVerticalSlider.prototype.add_workCompleted = function (value) {
        this._workCompleted = ss.Delegate.combine(this._workCompleted, value);
    };
    InteractiveVerticalSlider.prototype.remove_workCompleted = function (value) {
        this._workCompleted = ss.Delegate.remove(this._workCompleted, value);
    };
    InteractiveVerticalSlider.prototype.onDragStarted = function (e) {
        if (this._steps <= 1) {
            return;
        }
        if (!isNaN(this._unitSize)) {
            _super.prototype.onDragStarted.call(this, e);
            this._isStarted = true;
            this._currentPosition = e.position;
        }
    };
    InteractiveVerticalSlider.prototype.onDragCompleted = function (e) {
        if (this._isStarted) {
            this._isStarted = false;
            if (this._workCompleted != null) {
                this._workCompleted(this, null);
            }
        }
    };
    InteractiveVerticalSlider.prototype.onDragDelta = function (e) {
        if (this._isStarted) {
            var offsetY;
            var newScreenY;
            var deltaY;
            var newPosition;
            var offsetTop;
            var min;
            var max;
            var offsetScroll;
            var currentUnit;
            var eventElementSource = e.get_nativeEvent();
            if (eventElementSource.touches != null) {
                eventElementSource = eventElementSource.touches[0];
            }
            offsetY = 0;
            newScreenY = eventElementSource.clientY;
            deltaY = newScreenY - this._screenY;
            newPosition = e.get_position();
            offsetTop = $(this._scrollBar).offset().top;
            min = offsetTop;
            max = (this._scrollBar.clientHeight + offsetTop) - this._slider.clientHeight;
            offsetY = eventElementSource.clientY;
            offsetScroll = offsetY - min;
            currentUnit = offsetScroll / this._unitSize;
            this._screenY = newScreenY;
            if (deltaY == 0) {
                return;
            }
            if (deltaY > 0) {
                currentUnit = Math.ceil(currentUnit);
            }
            else if (deltaY < 0) {
                currentUnit = Math.floor(currentUnit);
            }
            if (currentUnit < 0) {
                currentUnit = 0;
            }
            if (currentUnit > this._steps - 1) {
                currentUnit = this._steps - 1;
            }
            offsetY = (currentUnit * this._unitSize) + offsetTop;
            if (offsetY <= min) {
                if (this._inMin) {
                    return;
                }
                this._inMin = true;
                offsetY = min;
            }
            else {
                this._inMin = false;
            }
            if (offsetY >= max) {
                if (this._inMax) {
                    return;
                }
                this._inMax = true;
                offsetY = max;
            }
            else {
                this._inMax = false;
            }
            if (this._currentStep != currentUnit) {
                this._currentStep = currentUnit;
                $(this._slider).offset({ top: offsetY });
                if (null !== this._stepChanged) {
                    this._stepChanged(this, new StepChangedEventArgs(this.get_currentStep()));
                }
            }
        }
    };
    return InteractiveVerticalSlider;
}(lt.Controls.InteractiveService));
var StepChangedEventArgs = /** @class */ (function (_super) {
    __extends(StepChangedEventArgs, _super);
    function StepChangedEventArgs(newIndex) {
        var _this = _super.call(this) || this;
        _this._newIndex = newIndex;
        return _this;
    }
    StepChangedEventArgs.prototype.get_newIndex = function () {
        return this._newIndex;
    };
    StepChangedEventArgs.prototype.set_newIindex = function (value) {
        this._newIndex = value;
    };
    return StepChangedEventArgs;
}(lt.LeadEventArgs));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var BrightnessContrastController = /** @class */ (function () {
        function BrightnessContrastController($scope, $modalInstance, optionsService, eventService, seriesManagerService) {
            $scope.ipVals = {
                contrast: 0,
                brightness: 0
            };
            function apply() {
                var args = new Array();
                args["contrast"] = $scope.ipVals.contrast * 10;
                args["brightness"] = $scope.ipVals.brightness * 10;
                args["intensity"] = 0;
                $scope.ipApi.applyIPCommand("ContrastBrightnessIntensity", args);
            }
            $scope.slider = {
                'options': {
                    stop: function (event, ui) {
                        apply();
                    }
                }
            };
            $scope.frame = seriesManagerService.get_activeCellFrame();
            $scope.ipApi = {};
            $scope.change = function () {
                apply();
            };
            $scope.ok = function () {
                $modalInstance.close($scope.ipVals);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        BrightnessContrastController.$inject = ['$scope', '$modalInstance', 'optionsService', 'eventService', 'seriesManagerService'];
        return BrightnessContrastController;
    }());
    Controllers.BrightnessContrastController = BrightnessContrastController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var RemotePacsController = /** @class */ (function () {
        function RemotePacsController($scope, $modalInstance, optionsService, $modal, authenticationService, dialogs, $translate, $timeout) {
            var __this = this;
            var saved = false;
            this._modal = $modal;
            $scope.selectedServer = null;
            $scope.pacsConfig = Models.RemoteConfig.Factory(optionsService.get(OptionNames.RemoteConfig));
            $scope.pacsConnections = new Array();
            __this.filter($scope.pacsConfig.servers, $scope.pacsConnections);
            $scope.gridOptions = {
                enableSorting: true,
                enableRowSelection: true,
                enableRowHeaderSelection: lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet,
                noUnselect: false,
                multiSelect: false,
                onRegisterApi: function (gridApi) {
                    $scope.gridApi = gridApi;
                    gridApi.selection.on.rowSelectionChanged($scope, function (selectedRow) {
                        $scope.selectedServer = selectedRow.entity;
                    });
                },
                columnDefs: [
                    { name: "AE Title", field: "AETitle", enableHiding: false, displayName: "AE Title" },
                    { name: "IP Address", field: "IPAddress", enableHiding: false, displayName: "IP Address" },
                    { name: "Port", field: "Port", enableHiding: false },
                    { name: "Default", field: "isDefault", enableHiding: false },
                ],
                data: $scope.pacsConnections
            };
            $scope.addPacsServer = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddPacsServer.html',
                    controller: Controllers.AddPacsServerController,
                    backdrop: 'static',
                    resolve: {
                        server: function () {
                            return undefined;
                        },
                        clientAE: function () {
                            return $scope.pacsConfig.client;
                        }
                    }
                });
                modalInstance.result.then(function (server) {
                    for (var i = 0; i < $scope.pacsConfig.servers.length; i++) {
                        if (server.isDefault) {
                            $scope.pacsConfig.servers[i].isDefault = false;
                        }
                    }
                    $scope.pacsConfig.servers.push(server);
                    __this.filter($scope.pacsConfig.servers, $scope.pacsConnections); //update filtered for view connections                    
                });
            };
            $scope.deletePacsServer = function () {
                var result = $.grep($scope.pacsConfig.servers, function (item, index) {
                    return (item.id == $scope.selectedServer.id) && (item.type == 'pacs');
                });
                if (result.length > 0) {
                    var index = $scope.pacsConfig.servers.indexOf(result[0]);
                    $scope.pacsConfig.servers.splice(index, 1);
                    $scope.selectedServer = null;
                    __this.filter($scope.pacsConfig.servers, $scope.pacsConnections); //update filtered for view connections               
                }
            };
            $scope.editPacsServer = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddPacsServer.html',
                    controller: Controllers.AddPacsServerController,
                    backdrop: 'static',
                    resolve: {
                        server: function () {
                            return $scope.selectedServer;
                        },
                        clientAE: function () {
                            return $scope.pacsConfig.client;
                        }
                    }
                });
                modalInstance.result.then(function (server) {
                    var result = $.grep($scope.pacsConfig.servers, function (item, index) {
                        return (item.id == $scope.selectedServer.id) && (item.type == 'pacs');
                    });
                    if (result.length > 0) {
                        var index = $scope.pacsConfig.servers.indexOf(result[0]);
                        for (var i = 0; i < $scope.pacsConfig.servers.length; i++) {
                            if (i != index && server.isDefault) {
                                $scope.pacsConfig.servers[i].isDefault = false;
                            }
                        }
                        $scope.pacsConfig.servers[index] = server;
                        __this.filter($scope.pacsConfig.servers, $scope.pacsConnections); //update filtered for view connections
                    }
                });
            };
            $scope.save = function () {
                var data = {};
                var json = JSON.stringify($scope.pacsConfig);
                data[OptionNames.RemoteConfig] = json;
                optionsService.saveDefaultOptions(data).success(function () {
                    optionsService.set(OptionNames.RemoteConfig, json);
                    dialogs.notify(__this._notificationTitle, __this._saveSuccessMsg);
                    saved = true;
                }).error(function (e) {
                    dialogs.error(__this._saveFailureMsg + ": " + status);
                });
            };
            $scope.close = function () {
                $modalInstance.close(saved);
            };
            $translate('NOTIFY_PACSCONFIG_SAVE_SUCCESS').then(function (translation) {
                __this._saveSuccessMsg = translation;
            });
            $translate('NOTIFY_PACSCONFIG_SAVE_FAILURE').then(function (translation) {
                __this._saveFailureMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
        }
        RemotePacsController.prototype.filter = function (connections, filtered) {
            if (filtered.length > 0)
                filtered.splice(0, filtered.length);
            for (var index = 0; index < connections.length; index++) {
                if (connections[index].type == 'pacs') {
                    filtered.push(connections[index]);
                }
            }
        };
        RemotePacsController.$inject = ['$scope', '$modalInstance', 'optionsService', '$modal', 'authenticationService', 'dialogs', '$translate', '$timeout'];
        return RemotePacsController;
    }());
    Controllers.RemotePacsController = RemotePacsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AddPacsServerController = /** @class */ (function () {
        function AddPacsServerController($scope, $modalInstance, server, clientAE, queryPacsService, blockUI, $translate, dialogs) {
            var notifyTitle = '';
            var errorTitle = '';
            var verifySuccess = '';
            var verifyFailure = '';
            $scope.title = 'DIALOGS_ADD_REMOTE_PACS_TITLE';
            if (server) {
                $scope.title = 'DIALOGS_EDIT_REMOTE_PACS_TITLE';
                if (typeof server.isDefault == "string") {
                    server.isDefault = (server.isDefault) == "true" ? true : false;
                }
            }
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                errorTitle = translation;
            });
            $translate('VERIFY_SUCCESS').then(function (translation) {
                verifySuccess = translation;
            });
            $translate('VERIFY_FAILURE').then(function (translation) {
                verifyFailure = translation;
            });
            $scope.server = server || new Models.PACSConnection();
            $scope.ok = function () {
                $modalInstance.close($scope.server);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.verify = function () {
                blockUI.start("Verifying Connection...");
                queryPacsService.VerifyConnection($scope.server, clientAE).success(function (message) {
                    blockUI.stop();
                    if (message.replace(/(\r\n|\n|\")/gm, "").length > 0) {
                        dialogs.error(errorTitle, verifyFailure + ": " + message);
                    }
                    else
                        dialogs.notify(notifyTitle, verifySuccess);
                }).
                    error(function (error) {
                    blockUI.stop();
                    if (angular.isDefined(error.Message)) {
                        dialogs.error(errorTitle, verifyFailure + ": " + error.Message);
                    }
                    else
                        dialogs.error(errorTitle, verifyFailure + ": " + error);
                });
            };
        }
        AddPacsServerController.$inject = ['$scope', '$modalInstance', 'server', 'clientAE', 'queryPacsService', 'blockUI', '$translate', 'dialogs'];
        return AddPacsServerController;
    }());
    Controllers.AddPacsServerController = AddPacsServerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/Leadtools.Controls.Medical.d.ts" />
var Models;
(function (Models) {
    var DerivedInfo = /** @class */ (function () {
        function DerivedInfo() {
            this.number = "";
            this.description = "";
            this.protocolName = "";
        }
        Object.defineProperty(DerivedInfo.prototype, "number", {
            get: function () {
                return this._number;
            },
            set: function (value) {
                this._number = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DerivedInfo.prototype, "description", {
            get: function () {
                return this._description;
            },
            set: function (value) {
                this._description = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DerivedInfo.prototype, "protocolName", {
            get: function () {
                return this._protocolName;
            },
            set: function (value) {
                this._protocolName = value;
            },
            enumerable: false,
            configurable: true
        });
        return DerivedInfo;
    }());
    Models.DerivedInfo = DerivedInfo;
    var PrintOptions = /** @class */ (function () {
        function PrintOptions() {
            this.BurnAnnotations = false;
            this.IncludeOverflowImages = false;
            this.LayoutImageWidth = 150;
            this.WhiteBackground = true;
            this.PatientInfo = true;
            this.PageWidth = 0;
            this.PageHeight = 0;
            this.ReduceGrayscaleTo8BitsSelected = false;
            this.AnnotationsFileName = "";
            this.BackgroundColor = "";
            this.TextBackgroundColor = "";
            this.TextColor = "";
            this.BurnDisplayedAnnotations = false;
        }
        return PrintOptions;
    }());
    Models.PrintOptions = PrintOptions;
    var ImageBox = /** @class */ (function () {
        function ImageBox(referencedSOPInstanceUID, left, top, right, bottom) {
            this.referencedSOPInstanceUID = null;
            this.referencedSOPInstanceUID = new Array();
            if (referencedSOPInstanceUID != null && referencedSOPInstanceUID.length > 0) {
                this.referencedSOPInstanceUID.push(referencedSOPInstanceUID);
            }
            if (left != undefined && top != undefined && right != undefined && bottom != undefined) {
                this.Position = new Models.FramePosition(lt.LeadPointD.create(left, top), lt.LeadPointD.create(right, bottom));
            }
            this.RowPosition = -1;
            this.ColumnPosition = -1;
            this.ImageBoxNumber = -1;
            this.NumberOfRows = -1;
            this.NumberOfColumns = -1;
            this.ImageBoxLayoutType = ImageBoxLayoutType.Single;
            this.HorizontalJustification = Models.FrameHorizontalJustification.Center;
            this.VerticalJustification = Models.FrameVerticalJustification.Center;
            this.WindowCenter = -1;
            this.WindowWidth = -1;
            this.ReferencedPresentationStateSOP = "";
            this.ImageBoxTileHorizontalDimension = 1;
            this.ImageBoxTileVerticalDimension = 1;
            this.Inverted = false;
        }
        return ImageBox;
    }());
    Models.ImageBox = ImageBox;
    ;
    var PlaybackSequencing;
    (function (PlaybackSequencing) {
        // Hanging Protocol Defined
        PlaybackSequencing[PlaybackSequencing["Looping"] = 0] = "Looping";
        PlaybackSequencing[PlaybackSequencing["Sweeping"] = 1] = "Sweeping";
        PlaybackSequencing[PlaybackSequencing["Stop"] = 2] = "Stop";
        // Non-hanging Protocol Defined
        PlaybackSequencing[PlaybackSequencing["SweepingStop"] = 3] = "SweepingStop";
        PlaybackSequencing[PlaybackSequencing["Backward"] = 4] = "Backward";
        PlaybackSequencing[PlaybackSequencing["BackwardStop"] = 5] = "BackwardStop";
        PlaybackSequencing[PlaybackSequencing["Shuffle"] = 6] = "Shuffle";
        PlaybackSequencing[PlaybackSequencing["ShuffleStop"] = 7] = "ShuffleStop"; // Random one time through
    })(PlaybackSequencing = Models.PlaybackSequencing || (Models.PlaybackSequencing = {}));
    var SeriesInfo = /** @class */ (function () {
        function SeriesInfo() {
            this.StudyInstanceUID = "";
            this.SeriesInstanceUID = "";
            this.ImageBoxNumber = -1;
            this.AnnotationData = "";
        }
        return SeriesInfo;
    }());
    Models.SeriesInfo = SeriesInfo;
    var FirstFrame = /** @class */ (function () {
        function FirstFrame() {
            this.SOPClassUID = "";
            this.SOPInstanceUID = "";
            this.FrameNumber = -1;
        }
        return FirstFrame;
    }());
    Models.FirstFrame = FirstFrame;
    var Layout = /** @class */ (function () {
        function Layout() {
            this.Boxes = new Array();
            this.TemplateId = "";
        }
        return Layout;
    }());
    Models.Layout = Layout;
    var StudyLayout = /** @class */ (function () {
        function StudyLayout() {
            this.Rows = -1;
            this.Columns = -1;
            this.Series = new Array();
            this.Boxes = new Array();
            this.OtherStudies = new Array();
        }
        StudyLayout.prototype.SeriesExists = function (seriesInfo) {
            if (this.Series == null)
                return false;
            for (var i = 0; i < this.Series.length; i++) {
                if (this.Series[i].SeriesInstanceUID == seriesInfo.SeriesInstanceUID && this.Series[i].StudyInstanceUID == seriesInfo.StudyInstanceUID)
                    return true;
            }
            return false;
        };
        StudyLayout.prototype.SeriesPush = function (seriesInfo) {
            if (this.Series != null) {
                if (this.SeriesExists(seriesInfo) == false) {
                    this.Series.push(seriesInfo);
                }
            }
        };
        return StudyLayout;
    }());
    Models.StudyLayout = StudyLayout;
    var OtherStudies = /** @class */ (function () {
        function OtherStudies() {
            this.StudyInstanceUID = '';
            this.Series = new Array();
        }
        return OtherStudies;
    }());
    Models.OtherStudies = OtherStudies;
    var ExportOptions = /** @class */ (function () {
        function ExportOptions() {
            this.BurnAnnotations = false;
            this.CreateDICOMDIR = false;
            this.ImageCompression = 1;
            this.IncludeOverflowImages = false;
            this.LayoutImageWidth = 150;
            this.FileFormat = "BMP";
            this.ReduceGrayscaleTo8BitsSelected = false;
            this.Anonymize = false;
            this.DczPassword = "";
            this.IncludeViewer = false;
            this.WhiteBackground = true;
            this.PatientInfo = true;
            this.BackgroundColor = "";
            this.TextBackgroundColor = "";
            this.TextColor = "";
            this.BurnDisplayedAnnotations = false;
            this.AnnotationsFileName = "";
            this.ZipType = "dcz";
            this.Ext = ".zip";
        }
        return ExportOptions;
    }());
    Models.ExportOptions = ExportOptions;
    var ExportImageFormat = /** @class */ (function () {
        function ExportImageFormat(displayName, format, canReduceBitdepth, canPreserveBitdepth, canCompress, canWhiteBackground, canPrintPatientInfo) {
            canCompress = canCompress || false;
            this._DisplayName = displayName;
            this._Format = format;
            this._CanReduceBitdepth = canReduceBitdepth;
            this._CanPreserveBitdepth = canPreserveBitdepth;
            this._CanCompress = canCompress;
            this._WhiteBackground = canWhiteBackground;
            this._PrintPatientInfo = canPrintPatientInfo;
        }
        Object.defineProperty(ExportImageFormat.prototype, "WhiteBackground", {
            get: function () {
                return this._WhiteBackground;
            },
            set: function (value) {
                if (this._WhiteBackground != value) {
                    this._WhiteBackground = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "PrintPatientInfo", {
            get: function () {
                return this._PrintPatientInfo;
            },
            set: function (value) {
                if (this._PrintPatientInfo != value) {
                    this._PrintPatientInfo = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "CanCompress", {
            get: function () {
                return this._CanCompress;
            },
            set: function (value) {
                if (this._CanCompress != value) {
                    this._CanCompress = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "CanReduceBitdepth", {
            get: function () {
                return this._CanReduceBitdepth;
            },
            set: function (value) {
                if (this._CanReduceBitdepth != value) {
                    this._CanReduceBitdepth = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "CanPreserveBitdepth", {
            get: function () {
                return this._CanPreserveBitdepth;
            },
            set: function (value) {
                if (this._CanPreserveBitdepth != value) {
                    this._CanPreserveBitdepth = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "DisplayName", {
            get: function () {
                return this._DisplayName;
            },
            set: function (value) {
                if (this._DisplayName != value) {
                    this._DisplayName = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ExportImageFormat.prototype, "Format", {
            get: function () {
                return this._Format;
            },
            set: function (value) {
                if (this._Format != value) {
                    this._Format = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        return ExportImageFormat;
    }());
    Models.ExportImageFormat = ExportImageFormat;
    var AnnUserData = /** @class */ (function () {
        function AnnUserData() {
            this.ReferencedImageSequence = null;
            ;
            this.ImageSize = {};
            this.MapResolution = {};
        }
        return AnnUserData;
    }());
    Models.AnnUserData = AnnUserData;
    var SopInstanceReference = /** @class */ (function () {
        function SopInstanceReference() {
            this.ReferencedSopClassUid = "";
            this.ReferencedSopInstanceUid = "";
            this.ReferencedFrameNumber = new Array();
        }
        return SopInstanceReference;
    }());
    Models.SopInstanceReference = SopInstanceReference;
    var RemoteConnection = /** @class */ (function () {
        function RemoteConnection() {
            this.type = this.getType();
            this.id = UUID.generate();
            this.isDefault = false;
            this.name = '';
        }
        return RemoteConnection;
    }());
    Models.RemoteConnection = RemoteConnection;
    var PACSConnection = /** @class */ (function (_super) {
        __extends(PACSConnection, _super);
        function PACSConnection() {
            var _this = _super.call(this) || this;
            _this.AETitle = '';
            _this.IPAddress = '';
            _this.Port = 0;
            return _this;
        }
        PACSConnection.prototype.getType = function () {
            return 'pacs';
        };
        PACSConnection.prototype.getName = function () {
            return this.AETitle;
        };
        PACSConnection.Factory = function (obj) {
            var result = new PACSConnection();
            result.AETitle = obj.AETitle;
            result.IPAddress = obj.IPAddress;
            result.Port = obj.Port;
            result.id = obj.id;
            result.name = obj.AETitle;
            return result;
        };
        return PACSConnection;
    }(RemoteConnection));
    Models.PACSConnection = PACSConnection;
    var WadoConnection = /** @class */ (function (_super) {
        __extends(WadoConnection, _super);
        function WadoConnection() {
            var _this = _super.call(this) || this;
            _this.dicomWebRoot = '';
            _this.wado = '';
            _this.qido = 'qido-rs';
            _this.rs = 'wado-rs';
            _this.stow = 'stow-rs';
            _this.stowMaxFiles = 0;
            _this.stowMaxFileSize = 0;
            _this.title = '';
            return _this;
        }
        WadoConnection.prototype.getType = function () {
            return 'wado';
        };
        WadoConnection.prototype.getName = function () {
            return this.title;
        };
        WadoConnection.Factory = function (obj) {
            var result = new WadoConnection();
            result.dicomWebRoot = obj.dicomWebRoot;
            result.wado = obj.wado;
            result.qido = obj.qido;
            result.rs = obj.rs;
            result.stow = obj.stow;
            result.stowMaxFiles = obj.stowMaxFiles;
            result.stowMaxFileSize = obj.stowMaxFileSize;
            result.title = obj.title;
            result.id = obj.id;
            result.name = obj.title;
            return result;
        };
        return WadoConnection;
    }(RemoteConnection));
    Models.WadoConnection = WadoConnection;
    var RemoteConfig = /** @class */ (function () {
        function RemoteConfig() {
            this.client = '';
            this.servers = new Array();
        }
        RemoteConfig.Factory = function (json) {
            var obj = new RemoteConfig();
            if (json && json.length > 0) {
                var temp = JSON.parse(json);
                obj.client = temp.client;
                for (var index = 0; index < temp.servers.length; index++) {
                    if (temp.servers[index].type === 'pacs') {
                        obj.servers.push(PACSConnection.Factory(temp.servers[index]));
                    }
                    else if (temp.servers[index].type === 'wado') {
                        obj.servers.push(WadoConnection.Factory(temp.servers[index]));
                    }
                    else {
                        console.error('unsupported object for remote connection');
                    }
                }
            }
            return obj;
        };
        return RemoteConfig;
    }());
    Models.RemoteConfig = RemoteConfig;
    var DownloadInfo = /** @class */ (function () {
        function DownloadInfo() {
            this.Id = '';
            this.Server = null;
            this.Client = null;
            this.PatientID = '';
            this.StudyInstanceUID = '';
            this.SeriesInstanceUID = '';
            this.SOPInstanceUID = '';
            this.Status = DownloadStatus.Idle;
            this.ErrorMessage = '';
            this.UserData = '';
            this.Open = false;
        }
        return DownloadInfo;
    }());
    Models.DownloadInfo = DownloadInfo;
    var SeriesExtraInformation = /** @class */ (function () {
        function SeriesExtraInformation() {
            this.PatientId = "";
            this.PatientName = "";
            this.StudyDescription = "";
            this.SeriesNumber = "";
            this.SeriesDescription = "";
            this.Modality = "";
        }
        return SeriesExtraInformation;
    }());
    Models.SeriesExtraInformation = SeriesExtraInformation;
    var Role = /** @class */ (function () {
        function Role() {
            this.AssignedPermissions = new Array();
            this.Description = "";
            this.Name = "";
        }
        return Role;
    }());
    Models.Role = Role;
    var Permission = /** @class */ (function () {
        function Permission() {
            this.Description = "";
            this.FriendlyName = "";
            this.Name = "";
        }
        return Permission;
    }());
    Models.Permission = Permission;
    var Box = /** @class */ (function () {
        function Box(left, top, right, bottom) {
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        return Box;
    }());
    Models.Box = Box;
    var StudyLayoutOption = /** @class */ (function () {
        function StudyLayoutOption(name, friendlyName, icon) {
            this.name = name;
            this.friendlyName = friendlyName;
            this.icon = icon;
            this.boxes = new Array();
        }
        return StudyLayoutOption;
    }());
    Models.StudyLayoutOption = StudyLayoutOption;
    var PrintViewOptions = /** @class */ (function () {
        function PrintViewOptions() {
            this._Boxes = new Array();
            this._LayoutImageWidth = 1024;
        }
        Object.defineProperty(PrintViewOptions.prototype, "BurnAnnotations", {
            get: function () {
                return this._BurnAnnotations;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PrintViewOptions.prototype, "LayoutImageWidth", {
            get: function () {
                return this._LayoutImageWidth;
            },
            set: function (value) {
                this._LayoutImageWidth = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PrintViewOptions.prototype, "Boxes", {
            get: function () {
                return this._Boxes;
            },
            enumerable: false,
            configurable: true
        });
        return PrintViewOptions;
    }());
    Models.PrintViewOptions = PrintViewOptions;
    var UserPatientPermission = /** @class */ (function () {
        function UserPatientPermission(user, patientId) {
            this.User = user;
            this.PatientId = patientId;
        }
        return UserPatientPermission;
    }());
    Models.UserPatientPermission = UserPatientPermission;
    var RolePatientPermission = /** @class */ (function () {
        function RolePatientPermission(role, patientId) {
            this.Role = role;
            this.PatientId = patientId;
        }
        return RolePatientPermission;
    }());
    Models.RolePatientPermission = RolePatientPermission;
    var MRTIStatus = /** @class */ (function () {
        function MRTIStatus() {
        }
        Object.defineProperty(MRTIStatus, "COMPLETE", {
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MRTIStatus, "PARTIAL", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MRTIStatus, "NONE", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        return MRTIStatus;
    }());
    Models.MRTIStatus = MRTIStatus;
    var ImageBoxLayoutType;
    (function (ImageBoxLayoutType) {
        ImageBoxLayoutType[ImageBoxLayoutType["Tiled"] = 0] = "Tiled";
        ImageBoxLayoutType[ImageBoxLayoutType["Stack"] = 1] = "Stack";
        ImageBoxLayoutType[ImageBoxLayoutType["Cine"] = 2] = "Cine";
        ImageBoxLayoutType[ImageBoxLayoutType["Processed"] = 3] = "Processed";
        ImageBoxLayoutType[ImageBoxLayoutType["Single"] = 4] = "Single";
    })(ImageBoxLayoutType = Models.ImageBoxLayoutType || (Models.ImageBoxLayoutType = {}));
    var ValueRepresentation;
    (function (ValueRepresentation) {
        ValueRepresentation[ValueRepresentation["AE"] = 0] = "AE";
        ValueRepresentation[ValueRepresentation["AS"] = 1] = "AS";
        ValueRepresentation[ValueRepresentation["AT"] = 2] = "AT";
        ValueRepresentation[ValueRepresentation["CS"] = 3] = "CS";
        ValueRepresentation[ValueRepresentation["DA"] = 4] = "DA";
        ValueRepresentation[ValueRepresentation["DS"] = 5] = "DS";
        ValueRepresentation[ValueRepresentation["DT"] = 6] = "DT";
        ValueRepresentation[ValueRepresentation["FD"] = 7] = "FD";
        ValueRepresentation[ValueRepresentation["FL"] = 8] = "FL";
        ValueRepresentation[ValueRepresentation["IS"] = 9] = "IS";
        ValueRepresentation[ValueRepresentation["LO"] = 10] = "LO";
        ValueRepresentation[ValueRepresentation["LT"] = 11] = "LT";
        ValueRepresentation[ValueRepresentation["OB"] = 12] = "OB";
        ValueRepresentation[ValueRepresentation["OW"] = 13] = "OW";
        ValueRepresentation[ValueRepresentation["PN"] = 14] = "PN";
        ValueRepresentation[ValueRepresentation["SH"] = 15] = "SH";
        ValueRepresentation[ValueRepresentation["SL"] = 16] = "SL";
        ValueRepresentation[ValueRepresentation["SQ"] = 17] = "SQ";
        ValueRepresentation[ValueRepresentation["SS"] = 18] = "SS";
        ValueRepresentation[ValueRepresentation["ST"] = 19] = "ST";
        ValueRepresentation[ValueRepresentation["TM"] = 20] = "TM";
        ValueRepresentation[ValueRepresentation["UI"] = 21] = "UI";
        ValueRepresentation[ValueRepresentation["UL"] = 22] = "UL";
        ValueRepresentation[ValueRepresentation["UN"] = 23] = "UN";
        ValueRepresentation[ValueRepresentation["US"] = 24] = "US";
        ValueRepresentation[ValueRepresentation["UT"] = 25] = "UT";
        ValueRepresentation[ValueRepresentation["OF"] = 26] = "OF";
        ValueRepresentation[ValueRepresentation["UR"] = 27] = "UR";
        ValueRepresentation[ValueRepresentation["UC"] = 28] = "UC";
        ValueRepresentation[ValueRepresentation["OD"] = 29] = "OD"; // Other Double String
    })(ValueRepresentation = Models.ValueRepresentation || (Models.ValueRepresentation = {}));
    var HangingProtocol = /** @class */ (function () {
        function HangingProtocol() {
            // Module Hanging Protocol Definition
            this.HangingProtocolName = "";
            this.HangingProtocolDescription = "";
            this.HangingProtocolLevel = HangingProtocolLevel.Site;
            this.HangingProtocolCreator = "";
            this.WCFHangingProtocolCreationDateTime = new Date();
            this.HangingProtocolDefinitionSequence = new Array();
            this.NumberOfPriorsReferenced = 0;
            this.ImageSetsSequence = new Array();
            this.HangingProtocolUserIdentificationCodeSequence = new Array();
            this.HangingProtocolUserGroupName = null;
            // Module Hanging Protocol Environment
            this.NumberOfScreens = 1;
            this.NominalScreenDefinitionSequence = new Array();
            // Module Hanging Protocol Display
            this.DisplaySets = new Array();
            this.PartialDataDisplayHandling = PartialDataDisplayHandling.MaintainLayout;
            this.SynchronizedScrollingSequence = null;
            this.NavigationIndicatorSequence = null;
            // LEAD Specific
            this.Rows = -1;
            this.Columns = -1;
        }
        HangingProtocol.prototype.deleteSimilarFilterOperations = function (inputFilterOperation) {
            var filterOperationValues = new Array();
            var displaySetCount = this.DisplaySets.length;
            for (var d = displaySetCount - 1; d >= 0; d--) {
                var displaySet = this.DisplaySets[d];
                var filterOperationLength = displaySet.FilterOperationsSequence.length;
                for (var f = filterOperationLength - 1; f >= 0; f--) {
                    var filterOperation = displaySet.FilterOperationsSequence[f];
                    if (filterOperation.isFilterOperationsEqual(inputFilterOperation)) {
                        // if (filterOperation.WCFSelectorAttribute == inputFilterOperation.WCFSelectorAttribute) {
                        displaySet.FilterOperationsSequence.splice(f, 1);
                    }
                }
            }
        };
        HangingProtocol.prototype.cloneFilterOperation = function (inputFilterOperation) {
            var displaySetCount = this.DisplaySets.length;
            for (var d = 0; d < displaySetCount; d++) {
                var displaySet = this.DisplaySets[d];
                var exists = displaySet.existsFilterOperation(inputFilterOperation);
                if (exists == false) {
                    // clone the filter operation
                    var newFilterOperation = Utils.clone(inputFilterOperation);
                    var dicom = displaySet['metadata'];
                    var dicomPrevious = null;
                    var result = null;
                    var index = 0; // This needs to change as SelectorSeqencePointerItems (i.e. 1\2\1 );
                    var dicomTags = inputFilterOperation.WCFSelectorSequencePointer.split("\\");
                    var SelectorSeqencePointerItemsArray = inputFilterOperation.WCFSelectorSequencePointerItems.split("\\");
                    for (var i = 0; i < dicomTags.length; i++) {
                        var dicomTag = dicomTags[i].replace(":", "");
                        if (dicom.hasOwnProperty(dicomTag)) {
                            result = dicom[dicomTag];
                            dicomPrevious = dicom;
                            index = parseInt(SelectorSeqencePointerItemsArray[i]) - 1;
                            dicom = DicomHelper.get_TagValue(dicom, dicomTag, index);
                        }
                        // var dicomTagValue: string = DicomHelper.cloneDicomTagValue(displaySet['metadata'], dicomTag);
                    }
                    var dicomTagValue = "";
                    if (result.vr == 'PN') {
                        dicomTagValue = DicomHelper.getPatientNameFromTag(result);
                    }
                    else if (result.vr != 'SQ') {
                        var value = DicomHelper.getConvertValue(result);
                        //if (result.vr == 'DA') {
                        //    if (value) {
                        //        var DateJS: IDateJS = <any>(new Date(DicomHelper.parseDicomDate(value)));
                        //        value = DateJS.toString(this._dateFormat);
                        //    }
                        //}
                        //if (result.vr == 'TM') {
                        //    if (value) {
                        //        var DateJS: IDateJS = (<any>Date).today().at(DicomHelper.parseDicomTime(value));
                        //        value = DateJS.toString(this._timeFormat);
                        //    }
                        //}
                        dicomTagValue = value;
                    }
                    else {
                        if (result.Value && result.Value.length > 0) {
                            var lastIndex = dicomTags.length - 1;
                            var lastDicomTag = dicomTags[lastIndex].replace(":", "");
                            var lastSelectorItemIndex = SelectorSeqencePointerItemsArray.length - 1;
                            var lastSelectorItemString = null;
                            if (lastSelectorItemIndex >= 0) {
                                lastSelectorItemString = SelectorSeqencePointerItemsArray[lastSelectorItemIndex];
                            }
                            var codeSequenceList = DicomHelper.getCodeSequenceList(dicomPrevious, lastDicomTag, lastSelectorItemString);
                            if (codeSequenceList.length > 0) {
                                newFilterOperation.SelectorCodeSequenceValue = codeSequenceList;
                                var codeSequence = codeSequenceList[0];
                                dicomTagValue = codeSequence.toFullString();
                            }
                            else {
                                newFilterOperation = null;
                            }
                        }
                    }
                    if (newFilterOperation != null) {
                        newFilterOperation.SelectorValue = dicomTagValue;
                        displaySet.FilterOperationsSequence.push(newFilterOperation);
                    }
                }
            }
        };
        HangingProtocol.prototype.mergeFilterOperationValues = function (inputFilterOperation) {
            var filterOperationValues = new Array();
            var displaySetCount = this.DisplaySets.length;
            for (var d = 0; d < displaySetCount; d++) {
                var displaySet = this.DisplaySets[d];
                var filterOperationLength = displaySet.FilterOperationsSequence.length;
                for (var f = 0; f < filterOperationLength; f++) {
                    var filterOperation = displaySet.FilterOperationsSequence[f];
                    if (filterOperation.WCFSelectorAttribute == inputFilterOperation.WCFSelectorAttribute) {
                        if (filterOperationValues.indexOf(filterOperation.SelectorValue) == -1) {
                            filterOperationValues.push(filterOperation.SelectorValue);
                        }
                    }
                }
            }
            var newSelectorValue = filterOperationValues.join("\\");
            for (var d = 0; d < displaySetCount; d++) {
                var displaySet = this.DisplaySets[d];
                var filterOperationLength = displaySet.FilterOperationsSequence.length;
                for (var f = 0; f < filterOperationLength; f++) {
                    var filterOperation = displaySet.FilterOperationsSequence[f];
                    if (filterOperation.WCFSelectorAttribute == inputFilterOperation.WCFSelectorAttribute) {
                        filterOperation.SelectorValue = newSelectorValue;
                    }
                }
            }
        };
        HangingProtocol.prototype.getNextImageSetNumber = function () {
            var nextImageSetNumber = 0;
            for (var i = 0; i < this.ImageSetsSequence.length; i++) {
                this.ImageSetsSequence[i].TimeBasedImageSetsSequence.forEach(function (element) {
                    if (nextImageSetNumber < element.ImageSetNumber) {
                        nextImageSetNumber = element.ImageSetNumber;
                    }
                });
            }
            return nextImageSetNumber + 1;
        };
        HangingProtocol.prototype.getNumberOfPriorsReferenced = function () {
            var numberOfPriorsReferenced = 0;
            for (var i = 0; i < this.ImageSetsSequence.length; i++) {
                numberOfPriorsReferenced += this.ImageSetsSequence[i].TimeBasedImageSetsSequence.length - 1;
            }
            return numberOfPriorsReferenced;
        };
        HangingProtocol.prototype.updateImageSetSelectorValues = function () {
        };
        HangingProtocol.prototype.getTimeBasedImageSetLabel = function (imageSetNumber) {
            var imageSetLabel = "";
            for (var i = 0; i < this.ImageSetsSequence.length; i++) {
                this.ImageSetsSequence[i].TimeBasedImageSetsSequence.forEach(function (element) {
                    if (imageSetNumber == element.ImageSetNumber) {
                        imageSetLabel = element.ImageSetLabel;
                    }
                });
            }
            return imageSetLabel;
        };
        HangingProtocol.prototype.getCellMprTypeName = function (mprType) {
            var ret = "";
            switch (mprType) {
                case InitialViewDirection.Axial:
                    ret = "Axial";
                    break;
                case InitialViewDirection.Sagittal:
                    ret = "Sagittal";
                    break;
                case InitialViewDirection.Coronal:
                    ret = "Coronal";
                    break;
                case InitialViewDirection.None:
                    ret = "";
                    break;
            }
            return ret;
        };
        HangingProtocol.prototype.updateDisplaySetCombinedName = function () {
            for (var i = 0; i < this.DisplaySets.length; i++) {
                var displaySet = this.DisplaySets[i];
                if (displaySet.ReformattingOperationInitialViewDirection != null) {
                    // displaySet["CombinedName"] = displaySet.DisplaySetLabel + " - " + this.getTimeBasedImageSetLabel(displaySet.ImageSetNumber); //imageSet.Name;
                    var mprTypeName = this.getCellMprTypeName(displaySet.ReformattingOperationInitialViewDirection);
                    displaySet["CombinedName"] = displaySet.DisplaySetLabel + " (MPR Reformatted " + mprTypeName + ") - " + this.getTimeBasedImageSetLabel(displaySet.ImageSetNumber); //+ imageSet.Name;
                }
                else {
                    displaySet["CombinedName"] = displaySet.DisplaySetLabel + " - " + this.getTimeBasedImageSetLabel(displaySet.ImageSetNumber); //imageSet.Name;
                }
            }
        };
        HangingProtocol.prototype.sortFilterOperations = function () {
            var count = this.DisplaySets.length;
            for (var i = 0; i < count; i++) {
                this.DisplaySets[i].sortFilterOperations();
            }
        };
        return HangingProtocol;
    }());
    Models.HangingProtocol = HangingProtocol;
    var HangingProtocolDefinition = /** @class */ (function () {
        function HangingProtocolDefinition() {
            this.StudyDescription = "";
            this.AnatomicRegionSequence = new Array();
            this.ProcedureCodeSequence = new Array();
            this.ReasonForRequestedProcedureCodeSequence = new Array();
            this.Laterality = null;
            this.BodyPartExamined = "";
            this.ProtocolName = "";
            this.RequestedProcedureCodeSequence = null;
            this.ScheduledProtocolCodeSequence = null;
        }
        return HangingProtocolDefinition;
    }());
    Models.HangingProtocolDefinition = HangingProtocolDefinition;
    var ImageSet = /** @class */ (function () {
        function ImageSet() {
            this.ImageSetSelectorSequence = new Array();
            this.TimeBasedImageSetsSequence = new Array();
            this.Name = '';
        }
        // Returns 0 if there is no TimeBasedImageSet with that date
        // Otherwise, returns the ImageSetNumber of the TimeBasedImageSet that was found
        ImageSet.prototype.FindTimeBasedImageSetNumber = function (date) {
            if (this.TimeBasedImageSetsSequence == null)
                return 0;
            for (var i = 0; i < this.TimeBasedImageSetsSequence.length; i++) {
                if (this.TimeBasedImageSetsSequence[i].StudyDateTime.equals(date))
                    return this.TimeBasedImageSetsSequence[i].ImageSetNumber;
            }
            return 0;
        };
        ImageSet.prototype.AddTimeBasedImageSet = function (studyDateTime, imageSetNumber) {
            var timeBasedImageSet = new TimeBasedImageSet(imageSetNumber);
            timeBasedImageSet.StudyDateTime = studyDateTime;
            this.TimeBasedImageSetsSequence.push(timeBasedImageSet);
            return imageSetNumber;
        };
        ImageSet.prototype.splitCamelCaseToString = function (s) {
            return s.split(/(?=[A-Z])/).join(' ');
        };
        ImageSet.prototype.UpdateImageSelectorItem = function (metadata, dicomTag, imageSetSelectorName) {
            var tagValue = DicomHelper.getDicomTagValue(metadata, dicomTag);
            if (tagValue != null && tagValue.length != 0) {
                tagValue = tagValue.trim();
                var imageSetSelector = null;
                this.ImageSetSelectorSequence.forEach(function (x) {
                    if (x.SelectorName === imageSetSelectorName)
                        imageSetSelector = x;
                });
                if (imageSetSelector == null) {
                    imageSetSelector = new Models.ImageSetSelector();
                    imageSetSelector.ImageSetSelectorUsageFlag = Models.ImageSetSelectorUsage.Match;
                    imageSetSelector.WCFSelectorAttribute = Utils.insert(dicomTag, 4, ":");
                    imageSetSelector.SelectorValueNumber = 1;
                    imageSetSelector.SelectorValue = tagValue;
                    imageSetSelector.SelectorName = imageSetSelectorName;
                    this.ImageSetSelectorSequence.push(imageSetSelector);
                }
                else {
                    var selectorValues = imageSetSelector.SelectorValue.split('\\');
                    var exists = false;
                    for (var i = 0; i < selectorValues.length; i++) {
                        if (selectorValues[i] == tagValue) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        imageSetSelector.SelectorValue = imageSetSelector.SelectorValue + '\\' + tagValue;
                    }
                }
            }
        };
        return ImageSet;
    }());
    Models.ImageSet = ImageSet;
    var ImageSetSelector = /** @class */ (function () {
        function ImageSetSelector() {
            this.ImageSetSelectorUsageFlag = ImageSetSelectorUsage.Match;
            this.WCFSelectorAttribute = '';
            this.SelectorValueNumber = 0;
            this.SelectorValue = '';
            this.SelectorName = '';
            this.WCFSelectorSequencePointer = '';
            this.SelectorAttributeVr = '';
            this.SelectorCodeSequenceValue = new Array();
        }
        return ImageSetSelector;
    }());
    Models.ImageSetSelector = ImageSetSelector;
    var TimeBasedImageSet = /** @class */ (function () {
        function TimeBasedImageSet(imageSetNumber) {
            this.RelativeTime = new Array();
            this.AbstractPriorValue = new Array();
            this.ImageSetNumber = imageSetNumber;
        }
        return TimeBasedImageSet;
    }());
    Models.TimeBasedImageSet = TimeBasedImageSet;
    var DisplaySet = /** @class */ (function () {
        function DisplaySet() {
            this.Boxes = new Array();
            this.DisplaySetHorizontalJustification = Models.FrameHorizontalJustification.Center;
            this.DisplaySetVerticalJustification = Models.FrameVerticalJustification.Center;
            this.FilterOperationsSequence = new Array();
            this.DisplaySetPatientOrientation = new Array(2);
        }
        // Show Acquisition Techniques Flag
        // Display Set Presentation Group Description
        DisplaySet.prototype.existsFilterOperation = function (testFilterOperation) {
            var exists = false;
            var count = this.FilterOperationsSequence.length;
            for (var i = 0; i < count; i++) {
                var filterOperation = this.FilterOperationsSequence[i];
                exists = filterOperation.isFilterOperationsEqual(testFilterOperation);
                if (exists) {
                    break;
                }
            }
            return exists;
        };
        DisplaySet.prototype.dynamicSort = function (property) {
            var sortOrder = 1;
            if (property[0] === "-") {
                sortOrder = -1;
                property = property.substr(1);
            }
            return function (a, b) {
                var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;
                return result * sortOrder;
            };
        };
        DisplaySet.prototype.filterOperationCompare = function (a, b) {
            return a.WCFSelectorAttribute.localeCompare(b.WCFSelectorAttribute);
        };
        DisplaySet.prototype.sortFilterOperations = function () {
            this.FilterOperationsSequence.sort(this.filterOperationCompare);
        };
        return DisplaySet;
    }());
    Models.DisplaySet = DisplaySet;
    var HangingProtocolUserIdentificationCode = /** @class */ (function () {
        function HangingProtocolUserIdentificationCode() {
        }
        return HangingProtocolUserIdentificationCode;
    }());
    Models.HangingProtocolUserIdentificationCode = HangingProtocolUserIdentificationCode;
    var NominalScreenDefinition = /** @class */ (function () {
        function NominalScreenDefinition() {
        }
        return NominalScreenDefinition;
    }());
    Models.NominalScreenDefinition = NominalScreenDefinition;
    var SynchronizedScrolling = /** @class */ (function () {
        function SynchronizedScrolling() {
            this.DisplaySetScrollingGroup = new Array();
        }
        return SynchronizedScrolling;
    }());
    Models.SynchronizedScrolling = SynchronizedScrolling;
    var NavigationIndicator = /** @class */ (function () {
        function NavigationIndicator() {
        }
        return NavigationIndicator;
    }());
    Models.NavigationIndicator = NavigationIndicator;
    var ValueRange = /** @class */ (function () {
        function ValueRange() {
            this.ValueMinimum = 0;
            this.ValueMaximum = 0;
        }
        return ValueRange;
    }());
    Models.ValueRange = ValueRange;
    var FilterOperation = /** @class */ (function () {
        function FilterOperation() {
            this.ImageSetSelectorUsageFlag = ImageSetSelectorUsage.Match;
            this.SelectorValue = "";
            this.SelectorValueNumber = 0;
            this.SelectorName = "";
            this.WCFSelectorAttribute = "";
        }
        FilterOperation.prototype.isFilterOperationsEqual = function (f1) {
            var isSame = false;
            isSame =
                (this.WCFSelectorAttribute == f1.WCFSelectorAttribute) &&
                    (this.WCFSelectorSequencePointer == f1.WCFSelectorSequencePointer) &&
                    (this.WCFSelectorSequencePointerItems == f1.WCFSelectorSequencePointerItems);
            return isSame;
        };
        return FilterOperation;
    }());
    Models.FilterOperation = FilterOperation;
    var SortingOperations = /** @class */ (function () {
        function SortingOperations() {
        }
        SortingOperations.prototype.Convert = function (sortingOperation) {
            if (Utils.isValidNumber(sortingOperation.selectorAttribute)) {
                this.SelectorAttribute = sortingOperation.selectorAttribute; //Utils.longToDicomTag(sortingOperation.selectorAttribute);
                this.SelectorValueNumber = 1;
            }
            switch (sortingOperation.sortByCategory) {
                case lt.Controls.Medical.SortType.byAxis:
                    this.SortByCategory = SortByCategory.AlongAxis;
                    break;
                case lt.Controls.Medical.SortType.byAcquisitionTime:
                    this.SortByCategory = SortByCategory.ByAcquireTime;
                    break;
            }
            switch (sortingOperation.order) {
                case lt.Controls.Medical.SortOrder.ascending:
                    this.SortingDirection = SortingDirection.Increasing;
                    break;
                case lt.Controls.Medical.SortOrder.descending:
                    this.SortingDirection = SortingDirection.Decreasing;
                    break;
            }
        };
        return SortingOperations;
    }());
    Models.SortingOperations = SortingOperations;
    var HangingProtocolQuery = /** @class */ (function () {
        function HangingProtocolQuery() {
            this.Name = '';
            this.Description = '';
            this.Creator = '';
            this.HangingProtocolDefinitionSequence = new Array();
        }
        return HangingProtocolQuery;
    }());
    Models.HangingProtocolQuery = HangingProtocolQuery;
    var HangingProtocolQueryResult = /** @class */ (function () {
        function HangingProtocolQueryResult() {
            this.Name = '';
            this.SOPInstanceUID = '';
            this.Level = null;
        }
        return HangingProtocolQueryResult;
    }());
    Models.HangingProtocolQueryResult = HangingProtocolQueryResult;
    var DicomData = /** @class */ (function () {
        function DicomData(name, tag) {
            this.name = name;
            this.tag = tag;
            this.value = '';
            this.vr = '';
        }
        return DicomData;
    }());
    Models.DicomData = DicomData;
    var DicomTagRow = /** @class */ (function () {
        function DicomTagRow(data) {
            this.children = new Array();
            this.group = false;
            this.expanded = true;
            this.data = data;
        }
        return DicomTagRow;
    }());
    Models.DicomTagRow = DicomTagRow;
    var HangingProtocolLevel;
    (function (HangingProtocolLevel) {
        HangingProtocolLevel[HangingProtocolLevel["Manufacturer"] = 0] = "Manufacturer";
        HangingProtocolLevel[HangingProtocolLevel["Site"] = 1] = "Site";
        HangingProtocolLevel[HangingProtocolLevel["UserGroup"] = 2] = "UserGroup";
        HangingProtocolLevel[HangingProtocolLevel["SingleUser"] = 3] = "SingleUser";
    })(HangingProtocolLevel = Models.HangingProtocolLevel || (Models.HangingProtocolLevel = {}));
    var ImageSetSelectorUsage;
    (function (ImageSetSelectorUsage) {
        ImageSetSelectorUsage[ImageSetSelectorUsage["Match"] = 0] = "Match";
        ImageSetSelectorUsage[ImageSetSelectorUsage["NoMatch"] = 1] = "NoMatch";
    })(ImageSetSelectorUsage = Models.ImageSetSelectorUsage || (Models.ImageSetSelectorUsage = {}));
    var ImageSetSelectorCategory;
    (function (ImageSetSelectorCategory) {
        ImageSetSelectorCategory[ImageSetSelectorCategory["RelativeTime"] = 0] = "RelativeTime";
        ImageSetSelectorCategory[ImageSetSelectorCategory["AbstractPrior"] = 1] = "AbstractPrior";
    })(ImageSetSelectorCategory = Models.ImageSetSelectorCategory || (Models.ImageSetSelectorCategory = {}));
    var RelativeTimeUnits;
    (function (RelativeTimeUnits) {
        RelativeTimeUnits[RelativeTimeUnits["Seconds"] = 0] = "Seconds";
        RelativeTimeUnits[RelativeTimeUnits["Minutes"] = 1] = "Minutes";
        RelativeTimeUnits[RelativeTimeUnits["Hours"] = 2] = "Hours";
        RelativeTimeUnits[RelativeTimeUnits["Days"] = 3] = "Days";
        RelativeTimeUnits[RelativeTimeUnits["Weeks"] = 4] = "Weeks";
        RelativeTimeUnits[RelativeTimeUnits["Months"] = 5] = "Months";
        RelativeTimeUnits[RelativeTimeUnits["Years"] = 6] = "Years";
    })(RelativeTimeUnits = Models.RelativeTimeUnits || (Models.RelativeTimeUnits = {}));
    var AttributePresence;
    (function (AttributePresence) {
        AttributePresence[AttributePresence["Present"] = 0] = "Present";
        AttributePresence[AttributePresence["NotPresent"] = 1] = "NotPresent";
    })(AttributePresence = Models.AttributePresence || (Models.AttributePresence = {}));
    var FilterByOperator;
    (function (FilterByOperator) {
        FilterByOperator[FilterByOperator["RangeInclusive"] = 0] = "RangeInclusive";
        FilterByOperator[FilterByOperator["RangeExclusive"] = 1] = "RangeExclusive";
        FilterByOperator[FilterByOperator["GreaterOrEqual"] = 2] = "GreaterOrEqual";
        FilterByOperator[FilterByOperator["LessOrEqual"] = 3] = "LessOrEqual";
        FilterByOperator[FilterByOperator["GreaterThan"] = 4] = "GreaterThan";
        FilterByOperator[FilterByOperator["LessThan"] = 5] = "LessThan";
        FilterByOperator[FilterByOperator["MemberOf"] = 6] = "MemberOf";
        FilterByOperator[FilterByOperator["NotMemberOf"] = 7] = "NotMemberOf";
    })(FilterByOperator = Models.FilterByOperator || (Models.FilterByOperator = {}));
    var InitialViewDirection;
    (function (InitialViewDirection) {
        InitialViewDirection[InitialViewDirection["None"] = -1] = "None";
        InitialViewDirection[InitialViewDirection["Axial"] = 0] = "Axial";
        InitialViewDirection[InitialViewDirection["Sagittal"] = 1] = "Sagittal";
        InitialViewDirection[InitialViewDirection["Coronal"] = 2] = "Coronal";
    })(InitialViewDirection = Models.InitialViewDirection || (Models.InitialViewDirection = {}));
    var ReformattingOperationType;
    (function (ReformattingOperationType) {
        ReformattingOperationType[ReformattingOperationType["Mpr"] = 0] = "Mpr";
        ReformattingOperationType[ReformattingOperationType["ThreeDRendering"] = 1] = "ThreeDRendering";
        ReformattingOperationType[ReformattingOperationType["Slab"] = 2] = "Slab";
    })(ReformattingOperationType = Models.ReformattingOperationType || (Models.ReformattingOperationType = {}));
    var ScrollDirection;
    (function (ScrollDirection) {
        ScrollDirection[ScrollDirection["None"] = 0] = "None";
        ScrollDirection[ScrollDirection["Vertical"] = 1] = "Vertical";
        ScrollDirection[ScrollDirection["Horizontal"] = 2] = "Horizontal";
    })(ScrollDirection = Models.ScrollDirection || (Models.ScrollDirection = {}));
    var ScrollType;
    (function (ScrollType) {
        ScrollType[ScrollType["None"] = 0] = "None";
        ScrollType[ScrollType["Page"] = 1] = "Page";
        ScrollType[ScrollType["RowColumn"] = 2] = "RowColumn";
        ScrollType[ScrollType["Image"] = 3] = "Image";
    })(ScrollType = Models.ScrollType || (Models.ScrollType = {}));
    var SortByCategory;
    (function (SortByCategory) {
        SortByCategory[SortByCategory["AlongAxis"] = 0] = "AlongAxis";
        SortByCategory[SortByCategory["ByAcquireTime"] = 1] = "ByAcquireTime";
    })(SortByCategory = Models.SortByCategory || (Models.SortByCategory = {}));
    var SortingDirection;
    (function (SortingDirection) {
        SortingDirection[SortingDirection["Increasing"] = 0] = "Increasing";
        SortingDirection[SortingDirection["Decreasing"] = 1] = "Decreasing";
    })(SortingDirection = Models.SortingDirection || (Models.SortingDirection = {}));
    var PartialDataDisplayHandling;
    (function (PartialDataDisplayHandling) {
        PartialDataDisplayHandling[PartialDataDisplayHandling["Undefined"] = 0] = "Undefined";
        PartialDataDisplayHandling[PartialDataDisplayHandling["MaintainLayout"] = 1] = "MaintainLayout";
        PartialDataDisplayHandling[PartialDataDisplayHandling["AdaptLayout"] = 2] = "AdaptLayout";
    })(PartialDataDisplayHandling = Models.PartialDataDisplayHandling || (Models.PartialDataDisplayHandling = {}));
    var VoiType;
    (function (VoiType) {
        // Hanging Protocol defined
        VoiType[VoiType["Undefined"] = 0] = "Undefined";
        VoiType[VoiType["Lung"] = 1] = "Lung";
        VoiType[VoiType["Mediastinum"] = 2] = "Mediastinum";
        VoiType[VoiType["AbdoPelvis"] = 3] = "AbdoPelvis";
        VoiType[VoiType["Liver"] = 4] = "Liver";
        VoiType[VoiType["SoftTissue"] = 5] = "SoftTissue";
        VoiType[VoiType["Bone"] = 6] = "Bone";
        VoiType[VoiType["Brain"] = 7] = "Brain";
        VoiType[VoiType["PostFossa"] = 8] = "PostFossa";
        // Demo Specific
        VoiType[VoiType["BrainT1"] = 9] = "BrainT1";
        VoiType[VoiType["BrainT2"] = 10] = "BrainT2";
        VoiType[VoiType["SagT2"] = 11] = "SagT2";
        VoiType[VoiType["HeadNeck"] = 12] = "HeadNeck";
        VoiType[VoiType["Spine"] = 13] = "Spine";
        VoiType[VoiType["AbdomenPelvisT1"] = 14] = "AbdomenPelvisT1";
        VoiType[VoiType["AbdomenPelvisT2"] = 15] = "AbdomenPelvisT2";
        VoiType[VoiType["LowContrast"] = 16] = "LowContrast";
        VoiType[VoiType["MediumContrast"] = 17] = "MediumContrast";
        VoiType[VoiType["HighContrast"] = 18] = "HighContrast";
    })(VoiType = Models.VoiType || (Models.VoiType = {}));
    (function (VoiType) {
        function fromString(s) {
            if (s == "LUNG")
                return VoiType.Lung;
            if (s == "Mediastinum")
                return VoiType.Mediastinum;
            if (s == "AbdoPelvis")
                return VoiType.AbdoPelvis;
            if (s == "Liver")
                return VoiType.Liver;
            if (s == "SoftTissue")
                return VoiType.SoftTissue;
            if (s == "Bone")
                return VoiType.Bone;
            if (s == "Brain")
                return VoiType.Brain;
            if (s == "PostFossa")
                return VoiType.PostFossa;
            //if (s == "XXXXX")
            //    return VoiType.Xxxx;
            return VoiType.Undefined;
        }
        VoiType.fromString = fromString;
    })(VoiType = Models.VoiType || (Models.VoiType = {}));
    // Used in the Hanging Protocol 'Level' dropdown
    var DropDownItem = /** @class */ (function () {
        function DropDownItem(id, name) {
            this.name = name;
            this.id = id;
        }
        return DropDownItem;
    }());
    Models.DropDownItem = DropDownItem;
    var Settings3DOptions = /** @class */ (function () {
        function Settings3DOptions() {
            this.volumeType = 'Volume';
            this.lowResQuality = 0.5;
            this.isoThreshold = 50;
            this.showCrossLines = false;
            this.showClippingFrame = false;
            this.showVolumeBorder = true;
            this.showRotationCube = true;
            this.projectionMethod = 1;
            this.resizeFactor = 1;
            this.highResQuality = 1.2;
        }
        return Settings3DOptions;
    }());
    Models.Settings3DOptions = Settings3DOptions;
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/custom.d.ts" />
/// <reference path="Scopes.ts" />
/// <reference path="../Models/DataModels.ts" />
var Controllers;
(function (Controllers) {
    var UserQueueController = /** @class */ (function () {
        function UserQueueController($scope, eventService, optionsService, seriesDownloadQueueService, tabService, $timeout, $filter, dialogs, $translate, authenticationService) {
            var __this = this;
            var confirmation;
            var confirmationMessage;
            $translate('DIALOGS_CONFIRMATION_TITLE').then(function (translation) {
                confirmation = translation;
            });
            $translate('DELETE_QUEUE_VIEW_CONFIRMATION').then(function (translation) {
                confirmationMessage = translation;
            });
            $scope.tabId = '';
            $scope.filterQuery = {};
            $scope.filterQuery.status = DownloadStatus.All;
            $scope.filterQuery.name = '';
            $scope.filterQuery.server = '';
            $scope.auto = {};
            $scope.auto.refresh = true;
            $scope.getJobHeader = function (job) {
                var header = new Array();
                header.push("Status: " + __this.get_statusString(job.Status));
                if (job.SeriesInfo) {
                    header.push("Name: " + job.SeriesInfo.PatientName);
                    header.push("Series #: " + job.SeriesInfo.SeriesNumber);
                    header.push("Desc: " + job.SeriesInfo.SeriesDescription);
                }
                if (job.Server) {
                    header.push("Server: " + job.Server.AETitle);
                }
                return header.join(", ");
            };
            var deregister = $scope.$watch('tabId', function (newValue, oldValue) {
                tabService.set_tabData($scope.tabId, TabDataKeys.ViewController, __this);
                tabService.set_tabData($scope.tabId, TabDataKeys.Linked, true);
                deregister();
            });
            eventService.subscribe(EventNames.DownloadSeries, $.proxy(this.DownloadSeries, this));
            eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                if (data.args.currentTab.id == $scope.tabId) {
                    if (!__this._isLoaded) {
                        __this._isLoaded = true;
                        seriesDownloadQueueService.loadUserQueue().success(function (result) {
                            $scope.downloads = result;
                        }).error(function (error) {
                        });
                    }
                }
            });
            eventService.subscribe(EventNames.JobCreated, function (event, data) {
                data.args.job.open = true;
            });
            eventService.subscribe(EventNames.JobUpdated, function (event, data) {
                var index = $scope.downloads.map(function (x) { return x.Id; }).indexOf(data.args.job.Id);
                if (index != -1) {
                    var job = $scope.downloads[index];
                    job.Status = data.args.job.Status;
                    job.ErrorMessage = data.args.job.ErrorMessage;
                }
            });
            $scope.$watch('downloads', function (newValue, oldValue) {
                if (angular.isDefined(newValue)) {
                    var openedJobs = $.grep(newValue, function (e, index) {
                        return e.Open;
                    });
                    if (openedJobs.length > 0) {
                        if (openedJobs[0] != __this._openedJob) {
                            __this._openedJob = openedJobs[0];
                            __this.selectedJobChanged($scope, __this._openedJob);
                        }
                    }
                    else
                        __this._openedJob = null;
                }
            }, true);
            $scope.statusChanged = function (status) {
                var statusNum = parseInt(status);
                switch (statusNum) {
                    case DownloadStatus.Idle:
                    case DownloadStatus.Started:
                    case DownloadStatus.All:
                        $scope.canDeleteJob = false;
                        break;
                    default:
                        $scope.canDeleteJob = authenticationService.hasPermission(PermissionNames.CanDeleteDownloadInfo);
                        break;
                }
            };
            $scope.refreshedChanged = function (refresh) {
                seriesDownloadQueueService.autoRefresh(refresh);
            };
            $scope.deleteView = function () {
                var items = $filter('byJobInfo')($scope.downloads, $scope.filterQuery);
                if (items.length > 0) {
                    var dlg = dialogs.confirm(confirmation, confirmationMessage);
                    dlg.result.then(function (btn) {
                        var itemsToDelete = new Array();
                        var length = items.length;
                        for (var i = 0; i < length; i++) {
                            itemsToDelete.push(parseInt(items[i].Id));
                        }
                        seriesDownloadQueueService.deleteJobs(itemsToDelete).success(function () {
                            var length = itemsToDelete.length;
                            while (length--) {
                                var index = $scope.downloads.map(function (x) { return x.Id; }).indexOf(itemsToDelete[length].toString());
                                if (index != -1) {
                                    $scope.downloads.splice(index, 1);
                                }
                            }
                        }).
                            error(function (error) {
                        });
                    });
                }
            };
            $scope.viewSeries = function () {
                if (__this._openedJob) {
                    if (__this._openedJob.Status == DownloadStatus.Completed) {
                        var study = {
                            StudyInstanceUID: __this._openedJob.StudyInstanceUID,
                            PatientID: (__this._openedJob).SeriesInfo.PatientId
                        };
                        var series = {
                            InstanceUID: __this._openedJob.SeriesInstanceUID,
                            StudyInstanceUID: study.StudyInstanceUID,
                            Patient: {
                                ID: (__this._openedJob).SeriesInfo.PatientId,
                                Name: (__this._openedJob).SeriesInfo.PatientName
                            }
                        };
                        eventService.publish(EventNames.SeriesSelected, { study: study, series: series, remote: false });
                    }
                }
            };
            $scope.statusChanged($scope.filterQuery.status);
            $scope.refreshedChanged($scope.auto.refresh);
            this._seriesDownloadQueueService = seriesDownloadQueueService;
        }
        UserQueueController.prototype.get_statusString = function (status) {
            if (status == null) {
                return "Unknown";
            }
            switch (status) {
                case DownloadStatus.Idle:
                    return "Idle";
                case DownloadStatus.Started:
                    return "Started";
                case DownloadStatus.Completed:
                    return "Completed";
                case DownloadStatus.Error:
                    return "Error";
                case DownloadStatus.Aborted:
                    return "Aborted";
            }
            return "Unknown";
        };
        UserQueueController.prototype.DownloadSeries = function (event, data) {
            var extraInfo = new Models.SeriesExtraInformation();
            if (data.args.studyInfo) {
                if (data.args.studyInfo.Patient) {
                    extraInfo.PatientId = data.args.studyInfo.Patient.ID;
                    extraInfo.PatientName = data.args.studyInfo.Patient.Name;
                    data.args.seriesInfo.Patient = data.args.studyInfo.Patient;
                }
                extraInfo.StudyDescription = data.args.studyInfo.Description;
            }
            extraInfo.SeriesNumber = data.args.seriesInfo.Number;
            extraInfo.SeriesDescription = data.args.seriesInfo.Description;
            extraInfo.Modality = data.args.seriesInfo.Modality;
            this._seriesDownloadQueueService.downloadSeries(data.args.pacsClientInfo, data.args.clientAe, data.args.seriesInfo, extraInfo);
        };
        UserQueueController.prototype.selectedJobChanged = function ($scope, job) {
            if (job == null || job.Status != DownloadStatus.Completed) {
                $scope.canViewJob = false;
            }
            else
                $scope.canViewJob = true;
        };
        UserQueueController.$inject = ['$scope', 'eventService', 'optionsService', 'seriesDownloadQueueService', 'tabService', '$timeout', '$filter', 'dialogs', '$translate', 'authenticationService'];
        return UserQueueController;
    }());
    Controllers.UserQueueController = UserQueueController;
})(Controllers || (Controllers = {}));
filters.filter('byJobInfo', function () {
    return function (jobs, query) {
        if (angular.isDefined(jobs)) {
            var matches = $.grep(jobs, function (e, index) {
                return ((e.Status == query.status) || query.status == DownloadStatus.All) &&
                    (query.name.length == 0 || (e.SeriesInfo && angular.isDefined(e.SeriesInfo.PatientName) && e.SeriesInfo.PatientName.search(new RegExp(query.name, 'i')) != -1)) &&
                    (query.server.length == 0 || (angular.isDefined(e.Server) && e.Server.AETitle.search(new RegExp(query.server, 'i')) != -1));
            });
            return matches;
        }
    };
});
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var PermissionsManagementController = /** @class */ (function () {
        function PermissionsManagementController($scope, $modalInstance, authenticationService) {
            $scope.edit = {};
            $scope.canManageRoles = function () {
                return authenticationService.hasPermission(PermissionNames.CanManageRoles);
            };
            $scope.canManageUsers = function () {
                return authenticationService.hasPermission(PermissionNames.CanManageUsers);
            };
            $scope.ok = function () {
                $modalInstance.close('ok');
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isFormValid = function () {
                return true;
            };
            if ($scope.canManageUsers()) {
                $scope.edit.view = "NewUser";
            }
            else {
                $scope.edit.view = "NewRole";
            }
        }
        PermissionsManagementController.$inject = ['$scope', '$modalInstance', 'authenticationService'];
        return PermissionsManagementController;
    }());
    Controllers.PermissionsManagementController = PermissionsManagementController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var NewUserController = /** @class */ (function () {
        function NewUserController($scope, optionsService, authenticationService, dialogs, $translate) {
            var __this = this;
            $scope.username = '';
            $scope.password = '';
            $scope.confirmPassword = '';
            $scope.validateOnAd = false;
            $scope.validateOnIdP = false;
            $scope.createUser = $.proxy(this.createUser, this);
            this._authenticationService = authenticationService;
            this._scope = $scope;
            this._dialogs = dialogs;
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                __this._errorTitle = translation;
            });
        }
        NewUserController.prototype.createUser = function (username, password, validateOnAd, validateOnIdP) {
            var __this = this;
            var userType = 'classic';
            if (validateOnAd)
                userType = 'activedirectory';
            else if (validateOnIdP)
                userType = 'federatedIdP';
            this._authenticationService.createUser(username, password, userType)
                .success(function (result) {
                if (angular.isDefined(result.FaultType)) {
                    __this._dialogs.error(__this._errorTitle, result.Message);
                }
                else {
                    __this._dialogs.notify(__this._notifyTitle, "User created successfully.");
                }
            })
                .error(function (error) {
                if (angular.isDefined(error.FaultType)) {
                    __this._dialogs.error(__this._errorTitle, error.Message);
                }
                else
                    __this._dialogs.error(__this._errorTitle, error);
            });
        };
        NewUserController.$inject = ['$scope', 'optionsService', 'authenticationService', 'dialogs', '$translate'];
        return NewUserController;
    }());
    Controllers.NewUserController = NewUserController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UpdateRoleController = /** @class */ (function () {
        function UpdateRoleController($scope, optionsService, authenticationService, dialogs, $translate) {
            var __this = this;
            this._selectedIndex = 0;
            this._roleNameValid = false;
            $scope.role = null;
            $scope.selectedPermissions = new Array();
            $scope.deleteRole = $.proxy(this.deleteRole, this);
            $scope.roleChanged = $.proxy(this.roleChanged, this);
            $scope.updateRole = $.proxy(this.updateRole, this);
            $scope.isCurrentUserSelected = $.proxy(this.isCurrentUserSelected, this);
            $scope.showDropDown = $.proxy(this.showDropDown, this);
            $scope.populateDropDown = $.proxy(this.populateDropDown, this);
            $scope.roleSelected = $.proxy(this.roleSelected, this);
            $scope.roleName = '';
            $scope.disableFeaturesForFDA = $.proxy(this.disableFeaturesForFDA, this);
            this.registerDiv();
            document.addEventListener('mousedown', function (args) {
                if (!args.defaultPrevented)
                    __this.showDropDown(false);
            });
            $scope.keyPressed = function (args) {
                // it has to be a letter to be processed
                if (args.key && args.key.length > 1) {
                    if (args.key == "ArrowDown") {
                        args.preventDefault();
                        args.stopPropagation();
                        var parentDiv = document.getElementById("userNameList");
                        __this.setSelected(Math.min(parentDiv.children.length - 1, __this.getSelected() + 1));
                    }
                    else if (args.key == "ArrowUp") {
                        args.preventDefault();
                        args.stopPropagation();
                        __this.setSelected(Math.max(0, __this.getSelected() - 1));
                    }
                    else if (args.key == "Enter") {
                        args.preventDefault();
                        args.stopPropagation();
                        __this._scope.roleName = __this.getSelectedItem().RoleName;
                        __this._scope.role = __this.getSelectedItem().Role;
                        __this._roleNameValid = true;
                        __this.roleChanged(__this._scope.role);
                        __this.showDropDown(false);
                    }
                    else if (args.key == "Esc") {
                        __this.showDropDown(false);
                    }
                }
            };
            $scope.textChanged = function (event) {
                this.showDropDown(true);
                this.populateDropDown($scope.roleName);
            };
            this._authenticationService = authenticationService;
            this._dialogs = dialogs;
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                __this._errorTitle = translation;
            });
            authenticationService.getRoles().
                success(function (result) {
                __this._roles = result;
                $scope.roles = result;
                if ($scope.roles && $scope.roles.length > 0) {
                    $scope.role = $scope.roles[0];
                    $scope.roleName = $scope.role.Name;
                    __this.roleChanged($scope.role);
                }
            }).
                error(function (error) {
            });
            authenticationService.getPermissions().
                success(function (result) {
                $scope.permissions = result;
                __this.roleChanged($scope.role);
            }).
                error(function (error) {
            });
            this._scope = $scope;
        }
        UpdateRoleController.prototype.roleSelected = function () {
            return this._roleNameValid;
        };
        UpdateRoleController.prototype.getSelectedItem = function () {
            var parentDiv = document.getElementById("userNameList");
            return parentDiv.children.item(this._selectedIndex);
        };
        UpdateRoleController.prototype.setSelectedItem = function (value) {
            var parentDiv = document.getElementById("userNameList");
            var index = 0;
            var length = parentDiv.children.length;
            for (index = 0; index < length; index++) {
                if (parentDiv.children.item(index) == value) {
                    this.setSelected(index);
                    return;
                }
            }
        };
        UpdateRoleController.prototype.setSelected = function (value) {
            this._selectedIndex = value;
            var parentDiv = document.getElementById("userNameList");
            var index = 0;
            var length = parentDiv.children.length;
            var label;
            var div;
            for (index = 0; index < length; index++) {
                div = parentDiv.children.item(index);
                label = div.children.item(0);
                if (index == this._selectedIndex) {
                    label.className = "dropDownTextSelected";
                    var position = (div.offsetTop - parentDiv.scrollTop);
                    var maxAllowed = (parentDiv.clientHeight - div.clientHeight);
                    if (position < 0) {
                        parentDiv.scroll(0, div.offsetTop);
                    }
                    else if (position > maxAllowed) {
                        parentDiv.scroll(0, (div.offsetTop - maxAllowed));
                    }
                }
                else {
                    label.className = "dropDownText";
                }
            }
        };
        UpdateRoleController.prototype.getSelected = function () {
            return this._selectedIndex;
        };
        UpdateRoleController.prototype.populateDropDown = function (text) {
            var parentDiv = document.getElementById("userNameList");
            if (this._roles == null)
                return;
            if (this._roles.length == 0)
                return;
            parentDiv.innerHTML = "";
            var _this = this;
            this._roleNameValid = false;
            for (var _i = 0, _a = this._roles; _i < _a.length; _i++) {
                var u = _a[_i];
                var subStringIndex = u.Name.toLowerCase().indexOf(text.toLowerCase());
                if (u.Name.length == text.length) {
                    this._roleNameValid = true;
                }
                if (subStringIndex != -1) {
                    var div = document.createElement("div");
                    div.RoleName = u.Name;
                    div.Role = u;
                    div.className = "dropBoxItem";
                    div.addEventListener('click', function (args) {
                        _this._scope.roleName = this.RoleName;
                        _this._scope.role = this.Role;
                        _this._roleNameValid = true;
                        _this.roleChanged(_this._scope.role);
                        _this.showDropDown(false);
                    });
                    div.addEventListener('mousemove', function (args) {
                        _this.setSelectedItem(this);
                    });
                    var fullString = u.Name;
                    var firstString = fullString.substring(0, subStringIndex);
                    var highlightedString = fullString.substring(subStringIndex, subStringIndex + text.length);
                    var restofString = fullString.substring(subStringIndex + text.length);
                    div.innerHTML = "<label class='dropDownText'>" + firstString + "<span class='highlightString'>" + highlightedString + "</span>" + restofString + "</label>";
                    parentDiv.appendChild(div);
                }
            }
            this.setSelected(0);
        };
        UpdateRoleController.prototype.registerDiv = function () {
            var div = document.getElementById("userNameList");
            div.addEventListener('mousedown', function (args) {
                args.preventDefault();
            });
        };
        UpdateRoleController.prototype.showDropDown = function (show) {
            var div = document.getElementById("userNameList");
            if (div)
                div.style.visibility = show ? "visible" : "hidden";
        };
        UpdateRoleController.prototype.isCurrentUserSelected = function (currentUser) {
            var currentUserSelected = false;
            if (currentUser != null) {
                currentUserSelected = (currentUser == this._authenticationService.user);
            }
            return currentUserSelected;
        };
        UpdateRoleController.prototype.deleteRole = function (role) {
            var __this = this;
            this._authenticationService.deleteRole(role.Name)
                .success(function (result) {
                if (angular.isDefined(result.FaultType)) {
                    __this._dialogs.error(__this._errorTitle, result.Message);
                }
                else {
                    var index = __this._scope.roles.map(function (r) { return r.Name; }).indexOf(role.Name);
                    __this._dialogs.notify(__this._notifyTitle, "Role [" + role.Name + "] deleted successfully.");
                    if (index != -1) {
                        __this._scope.roles.splice(index, 1);
                        __this._scope.selectedPermissions.length = 0;
                    }
                }
            })
                .error(function (error) {
                __this._dialogs.error(__this._errorTitle, error);
            });
        };
        UpdateRoleController.prototype.copyPermissionsArray = function (targetRole, roles) {
            if (targetRole == null)
                return;
            targetRole.length = 0;
            if (roles != null) {
                var length = roles.length;
                for (var i = 0; i < length; i++) {
                    targetRole.push(roles[i]);
                }
            }
        };
        UpdateRoleController.prototype.roleChanged = function (role) {
            if (role == null)
                return;
            if (this._scope == null)
                return;
            this.copyPermissionsArray(this._scope.selectedPermissions, role.AssignedPermissions);
        };
        UpdateRoleController.prototype.disableFeaturesForFDA = function (permission) {
            var disable = false;
            if (VersionNumber.viewerType == "Medicore") {
                if (permission.toUpperCase().indexOf("PACS") != -1)
                    disable = true;
            }
            return disable;
        };
        UpdateRoleController.prototype.updateRole = function (role, permissions) {
            if (!this._roleNameValid)
                return;
            var __this = this;
            this._authenticationService.updateRolePermissions(role.Name, permissions).
                success(function (result) {
                if (angular.isDefined(result.FaultType)) {
                    __this._dialogs.error(__this._errorTitle, result.Message);
                }
                else {
                    __this.copyPermissionsArray(role.AssignedPermissions, permissions);
                    __this._dialogs.notify(__this._notifyTitle, "Role [" + role.Name + "] updated successfully.");
                }
            }).
                error(function (error) {
                __this._dialogs.error(__this._errorTitle, error);
            });
        };
        UpdateRoleController.$inject = ['$scope', 'optionsService', 'authenticationService', 'dialogs', '$translate'];
        return UpdateRoleController;
    }());
    Controllers.UpdateRoleController = UpdateRoleController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var NewRoleController = /** @class */ (function () {
        function NewRoleController($scope, optionsService, authenticationService, dialogs, $translate) {
            var __this = this;
            $scope.role = '';
            $scope.createRole = $.proxy(this.createRole, this);
            this._authenticationService = authenticationService;
            this._dialogs = dialogs;
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                __this._errorTitle = translation;
            });
        }
        NewRoleController.prototype.createRole = function (role, description) {
            var __this = this;
            this._authenticationService.createRole(role, description)
                .success(function (result) {
                if (angular.isDefined(result.FaultType)) {
                    __this._dialogs.error(__this._errorTitle, result.Message);
                }
                else {
                    __this._dialogs.notify(__this._notifyTitle, "Role [" + role + "] created successfully.");
                }
            })
                .error(function (error) {
                __this._dialogs.error(__this._errorTitle, error);
            });
        };
        NewRoleController.$inject = ['$scope', 'optionsService', 'authenticationService', 'dialogs', '$translate'];
        return NewRoleController;
    }());
    Controllers.NewRoleController = NewRoleController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var UpdateUserController = /** @class */ (function () {
        function UpdateUserController($scope, optionsService, authenticationService, dialogs, $translate, $timeout) {
            var __this = this;
            this._authenticationService = authenticationService;
            this._dialogs = dialogs;
            this._userPermissions = {};
            this._userRoles = {};
            this._timeout = $timeout;
            this._selectedIndex = 0;
            this._userNameValid = false;
            $scope.selectedPermissions = new Array();
            $scope.selectedRoles = new Array();
            $scope.password = '';
            $scope.confirmPassword = '';
            $scope.userName = '';
            $scope.deleteUser = $.proxy(this.deleteUser, this);
            $scope.isCurrentUserSelected = $.proxy(this.isCurrentUserSelected, this);
            $scope.userChanged = $.proxy(this.userChanged, this);
            $scope.resetPassword = $.proxy(this.resetPassword, this);
            $scope.updateUser = $.proxy(this.updateUser, this);
            $scope.userHasPermission = $.proxy(this.userHasPermission, this);
            $scope.showDropDown = $.proxy(this.showDropDown, this);
            $scope.populateDropDown = $.proxy(this.populateDropDown, this);
            $scope.userSelected = $.proxy(this.userSelected, this);
            this.registerDiv();
            document.addEventListener('mousedown', function (args) {
                if (!args.defaultPrevented)
                    __this.showDropDown(false);
            });
            $scope.keyPressed = function (args) {
                // it has to be a letter to be processed
                if (args.key && args.key.length > 1) {
                    if (args.key == "ArrowDown") {
                        args.preventDefault();
                        args.stopPropagation();
                        var parentDiv = document.getElementById("userNameList");
                        __this.setSelected(Math.min(parentDiv.children.length - 1, __this.getSelected() + 1));
                    }
                    else if (args.key == "ArrowUp") {
                        args.preventDefault();
                        args.stopPropagation();
                        __this.setSelected(Math.max(0, __this.getSelected() - 1));
                    }
                    else if (args.key == "Enter") {
                        args.preventDefault();
                        args.stopPropagation();
                        __this._scope.user =
                            __this._scope.userName = __this.getSelectedItem().UserName;
                        __this._userNameValid = true;
                        __this.userChanged(__this._scope.user);
                        __this.showDropDown(false);
                    }
                    else if (args.key == "Esc") {
                        __this.showDropDown(false);
                    }
                }
            };
            $scope.textChanged = function (event) {
                this.showDropDown(true);
                this.populateDropDown($scope.userName);
            };
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notifyTitle = translation;
            });
            $translate('DIALOGS_ERROR').then(function (translation) {
                __this._errorTitle = translation;
            });
            this._confirmDeleteUserTitle = "Confirm Delete";
            $translate('DIALOGS_CONFIRMATION_DELETE_USER_TITLE').then(function (translation) {
                this._confirmDeleteUserTitle = translation;
            }.bind(this));
            this._confirmDeleteUserMessage = "Are you sure you want to delete the currently selected user ({0})?";
            $translate('DIALOGS_CONFIRMATION_DELETE_USER_MESSAGE').then(function (translation) {
                this._confirmDeleteUserMessage = translation;
            }.bind(this));
            authenticationService.getAllUsers().
                success(function (result) {
                __this._users = result;
                $scope.usersInfo = {};
                $scope.users = [];
                if (result && result.length > 0) {
                    for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                        var u = result_1[_i];
                        if (u.UserType != "temp") {
                            if (u.UserName) {
                                $scope.usersInfo[u.UserName] = u;
                                $scope.users.push(u.UserName);
                            }
                            else {
                                $scope.usersInfo[u] = u;
                                $scope.users.push(u);
                            }
                        }
                    }
                }
                if ($scope.users && $scope.users.length > 0) {
                    $scope.user = $scope.users[0];
                }
                authenticationService.getRoles().
                    success(function (result) {
                    $scope.roles = result || [];
                    authenticationService.getPermissions().
                        success(function (result) {
                        $scope.permissions = result;
                        __this.userChanged($scope.user);
                    }).
                        error(function (error) {
                    });
                }).
                    error(function (error) {
                });
            }).
                error(function (error) {
            });
            $scope.canSetPermission = $.proxy(this.canSetPermission, this);
            $scope.disableFeaturesForFDA = $.proxy(this.disableFeaturesForFDA, this);
            this._scope = $scope;
        }
        UpdateUserController.prototype.userSelected = function () {
            return this._userNameValid;
        };
        UpdateUserController.prototype.getSelectedItem = function () {
            var parentDiv = document.getElementById("userNameList");
            return parentDiv.children.item(this._selectedIndex);
        };
        UpdateUserController.prototype.setSelectedItem = function (value) {
            var parentDiv = document.getElementById("userNameList");
            var index = 0;
            var length = parentDiv.children.length;
            for (index = 0; index < length; index++) {
                if (parentDiv.children.item(index) == value) {
                    this.setSelected(index);
                    return;
                }
            }
        };
        UpdateUserController.prototype.setSelected = function (value) {
            this._selectedIndex = value;
            var parentDiv = document.getElementById("userNameList");
            var index = 0;
            var length = parentDiv.children.length;
            var label;
            var div;
            for (index = 0; index < length; index++) {
                div = parentDiv.children.item(index);
                label = div.children.item(0);
                if (index == this._selectedIndex) {
                    label.className = "dropDownTextSelected";
                    var position = (div.offsetTop - parentDiv.scrollTop);
                    var maxAllowed = (parentDiv.clientHeight - div.clientHeight);
                    if (position < 0) {
                        parentDiv.scroll(0, div.offsetTop);
                    }
                    else if (position > maxAllowed) {
                        parentDiv.scroll(0, (div.offsetTop - maxAllowed));
                    }
                }
                else {
                    label.className = "dropDownText";
                }
            }
        };
        UpdateUserController.prototype.getSelected = function () {
            return this._selectedIndex;
        };
        UpdateUserController.prototype.populateDropDown = function (text) {
            var parentDiv = document.getElementById("userNameList");
            if (this._users == null)
                return;
            if (this._users.length == 0)
                return;
            parentDiv.innerHTML = "";
            var _this = this;
            this._userNameValid = false;
            for (var _i = 0, _a = this._users; _i < _a.length; _i++) {
                var u = _a[_i];
                var subStringIndex = u.UserName.toLowerCase().indexOf(text.toLowerCase());
                if (u.UserName.length == text.length) {
                    this._userNameValid = true;
                }
                if (u.UserType == "temp")
                    continue;
                if (subStringIndex != -1) {
                    var div = document.createElement("div");
                    div.UserName = u.UserName;
                    div.className = "dropBoxItem";
                    div.addEventListener('click', function (args) {
                        _this._scope.userName = this.UserName;
                        _this._userNameValid = true;
                        _this._scope.user = this.UserName;
                        _this.userChanged(_this._scope.user);
                        _this.showDropDown(false);
                    });
                    div.addEventListener('mousemove', function (args) {
                        _this.setSelectedItem(this);
                    });
                    var fullString = u.UserName;
                    var firstString = fullString.substring(0, subStringIndex);
                    var highlightedString = fullString.substring(subStringIndex, subStringIndex + text.length);
                    var restofString = fullString.substring(subStringIndex + text.length);
                    div.innerHTML = "<label class='dropDownText'>" + firstString + "<span class='highlightString'>" + highlightedString + "</span>" + restofString + "</label>";
                    parentDiv.appendChild(div);
                }
            }
            this.setSelected(0);
        };
        UpdateUserController.prototype.deleteUser = function (user) {
            var __this = this;
            var confirmationMessage = this._confirmDeleteUserMessage.format(user);
            var dlg = this._dialogs.confirm(this._confirmDeleteUserTitle, confirmationMessage);
            dlg.result.then(function (btn) {
                if (btn == "yes") {
                    __this._authenticationService.deleteUser(user)
                        .success(function (result) {
                        if (angular.isDefined(result.FaultType)) {
                            __this._dialogs.error(__this._errorTitle, result.Message);
                        }
                        else {
                            var index = __this._scope.users.map(function (r) { return r; }).indexOf(user);
                            __this._dialogs.notify(__this._notifyTitle, "User [" + user + "] deleted successfully.");
                            if (index != -1) {
                                __this._scope.users.splice(index, 1);
                                __this._scope.selectedPermissions.length = 0;
                                __this._scope.selectedRoles.length = 0;
                            }
                        }
                    })
                        .error(function (error) {
                        __this._dialogs.error(__this._errorTitle, error);
                    });
                }
            });
        };
        UpdateUserController.prototype.registerDiv = function () {
            var div = document.getElementById("userNameList");
            div.addEventListener('mousedown', function (args) {
                args.preventDefault();
            });
        };
        UpdateUserController.prototype.showDropDown = function (show) {
            var div = document.getElementById("userNameList");
            div.style.visibility = show ? "visible" : "hidden";
        };
        UpdateUserController.prototype.isCurrentUserSelected = function (currentUser) {
            var currentUserSelected = false;
            if (currentUser != null) {
                currentUserSelected = (currentUser == this._authenticationService.user);
            }
            return currentUserSelected;
        };
        UpdateUserController.prototype.userChanged = function (user) {
            var __this = this;
            this._scope.password = '';
            this._scope.confirmPassword = '';
            if (!angular.isDefined(this._userRoles[user])) {
                this._authenticationService.getUserRoles(user).
                    success(function (result) {
                    __this._scope.selectedRoles = result;
                    __this._userRoles[user] = angular.copy(__this._scope.selectedRoles);
                }).
                    error(function (error) {
                    __this._dialogs.error(__this._errorTitle, error);
                });
            }
            else {
                __this._scope.selectedRoles = this._userRoles[user];
            }
            if (!angular.isDefined(this._userPermissions[user])) {
                this._authenticationService.getUserPermissions(user).
                    success(function (result) {
                    __this._scope.selectedPermissions = result;
                }).
                    error(function (error) {
                    __this._dialogs.error(__this._errorTitle, error);
                });
            }
            else {
                __this._scope.selectedPermissions = this._userPermissions[user];
            }
        };
        UpdateUserController.prototype.resetPassword = function (user, password) {
            var __this = this;
            this._authenticationService.validatePassword(password).
                success(function (result) {
                if (result.length == 0) {
                    __this._authenticationService.resetPassword(user, password).
                        success(function (result) {
                        if (angular.isDefined(result.FaultType)) {
                            __this._dialogs.error(__this._errorTitle, result.Message);
                        }
                        else {
                            __this._dialogs.notify(__this._notifyTitle, "User [" + user + "] password reset successfully.");
                        }
                    }).
                        error(function (error) {
                        __this._dialogs.error(__this._errorTitle, error);
                    });
                }
                else {
                    __this._dialogs.error(__this._errorTitle, result);
                }
            }).
                error(function (error) {
                __this._dialogs.error(__this._errorTitle, error);
            });
        };
        UpdateUserController.prototype.disableFeaturesForFDA = function (permission) {
            var disable = false;
            if (VersionNumber.viewerType == "Medicore") {
                if (permission.toUpperCase().indexOf("PACS") != -1)
                    disable = true;
            }
            return disable;
        };
        UpdateUserController.prototype.canSetPermission = function (permission) {
            var length = this._scope.selectedRoles.length;
            for (var i = 0; i < length; i++) {
                var index = this._scope.roles.map(function (r) { return r.Name; }).indexOf(this._scope.selectedRoles[i]);
                if (index != -1) {
                    var role = this._scope.roles[index];
                    if (role.AssignedPermissions.indexOf(permission) != -1) {
                        return false;
                    }
                }
            }
            return true;
        };
        UpdateUserController.prototype.updateUser = function (user, roles, permissions) {
            if (!this._userNameValid)
                return;
            var length = this._scope.roles.length;
            var __this = this;
            for (var i = 0; i < length; i++) {
                var role = this._scope.roles[i].Name;
                var index = roles.map(function (r) { return r; }).indexOf(role);
                if (index != -1) {
                    __this.grantRole(user, role);
                }
                else {
                    __this.denyRole(user, role);
                }
            }
            length = this._scope.permissions.length;
            for (var i = 0; i < length; i++) {
                var permission = this._scope.permissions[i].Name;
                var index = permissions.map(function (p) { return p; }).indexOf(permission);
                if (index != -1) {
                    __this.grantPermission(user, permission);
                }
                else {
                    __this.denyPermission(user, permission);
                }
            }
            __this._dialogs.notify(__this._notifyTitle, "User [" + user + "] updated successfully.");
        };
        UpdateUserController.prototype.grantRole = function (user, role) {
            var __this = this;
            this._authenticationService.grantRole(user, role).
                success(function (result) {
                var index = __this._userRoles[user].indexOf(role);
                if (index == -1) {
                    __this._userRoles[user].push(role);
                }
            }).
                error(function (error) {
            });
        };
        UpdateUserController.prototype.denyRole = function (user, role) {
            var __this = this;
            this._authenticationService.denyRole(user, role).
                success(function (result) {
                var index = __this._userRoles[user].indexOf(role);
                if (index != -1) {
                    __this._userRoles[user].slice(index, 1);
                }
            }).
                error(function (error) {
            });
        };
        UpdateUserController.prototype.grantPermission = function (user, permission) {
            var __this = this;
            this._authenticationService.grantPermission(user, permission).
                success(function (result) {
                if (__this._userPermissions[user]) {
                    var index = __this._userPermissions[user].indexOf(permission);
                    if (index == -1) {
                        __this._userPermissions[user].push(permission);
                    }
                }
            }).
                error(function (error) {
            });
        };
        UpdateUserController.prototype.denyPermission = function (user, permission) {
            var __this = this;
            this._authenticationService.denyPermission(user, permission).
                success(function (result) {
                if (__this._userPermissions[user]) {
                    var index = __this._userPermissions[user].indexOf(permission);
                    if (index != -1) {
                        __this._userPermissions[user].slice(index, 1);
                    }
                }
            }).
                error(function (error) {
            });
        };
        UpdateUserController.prototype.userHasPermission = function (user, permission) {
            if (angular.isDefined(this._userPermissions[user])) {
                return this._userPermissions[user].indexOf(permission) != -1;
            }
            return false;
        };
        UpdateUserController.$inject = ['$scope', 'optionsService', 'authenticationService', 'dialogs', '$translate', '$timeout'];
        return UpdateUserController;
    }());
    Controllers.UpdateUserController = UpdateUserController;
})(Controllers || (Controllers = {}));
if (!String.prototype.format) {
    String.prototype.format = function () {
        var args = arguments;
        return this.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != 'undefined'
                ? args[number]
                : match;
        });
    };
}
commangular.command('OnSpyGlass', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SpyglassEffect = Spyglass.Default;
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.SpyGlass, buttonId, false);
                enumerateCell(tabService, function (cell) {
                    var command = cell.getCommand(MedicalViewerAction.SpyGlass);
                    CommandManager.RunCommand(cell, MedicalViewerAction.SpyGlass, buttonId);
                });
            }
        };
    }]);
commangular.command('OnSpyGlassInvert', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SpyglassEffect = Spyglass.Invert;
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.SpyGlass, buttonId, false);
                enumerateCell(tabService, function (cell) {
                    var command = cell.getCommand(MedicalViewerAction.SpyGlass);
                    CommandManager.RunCommand(cell, MedicalViewerAction.SpyGlass, buttonId);
                });
            }
        };
    }]);
commangular.command('OnSpyGlassEqualization', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SpyglassEffect = Spyglass.Equalization;
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.SpyGlass, buttonId, false);
                enumerateCell(tabService, function (cell) {
                    var command = cell.getCommand(MedicalViewerAction.SpyGlass);
                    CommandManager.RunCommand(cell, MedicalViewerAction.SpyGlass, buttonId);
                });
            }
        };
    }]);
commangular.command('OnSpyGlassCLAHE', ['toolbarService', 'tabService', 'buttonId', function (toolbarService, tabService, buttonId) {
        return {
            execute: function () {
                SpyglassEffect = Spyglass.CLAHE;
                SetCurrentInteractiveMode(toolbarService, tabService, MedicalViewerAction.SpyGlass, buttonId, false);
                enumerateCell(tabService, function (cell) {
                    var command = cell.getCommand(MedicalViewerAction.SpyGlass);
                    CommandManager.RunCommand(cell, MedicalViewerAction.SpyGlass, buttonId);
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var CalibrateRulerController = /** @class */ (function () {
        function CalibrateRulerController($scope, $modalInstance) {
            $scope.calibration = {};
            $scope.calibration.length = null;
            $scope.calibration.unit = 6;
            $scope.calibration.applyToAll = false;
            $scope.isValid = function () {
                return $scope.calibration.length != null && $scope.calibration.length.length > 0;
            };
            $scope.ok = function () {
                $modalInstance.close($scope.calibration);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        CalibrateRulerController.$inject = ['$scope', '$modalInstance'];
        return CalibrateRulerController;
    }());
    Controllers.CalibrateRulerController = CalibrateRulerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Annotations.Engine.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Annotations.Designers.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Annotations.Automation.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Annotations.Rendering.JavaScript.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Controls.d.ts" />
/// <reference path="../../lib/LEADTOOLS/Leadtools.Controls.Medical.d.ts" />
var OverflowManager = /** @class */ (function () {
    function OverflowManager(overflowId, loader, layout, tabService, tab, eventService, horizontal) {
        this._injectorService = angular.element(document.getElementById('app')).injector();
        this._overflowTag = $(overflowId);
        this._parent = this._overflowTag.find('.scroll-body-inner');
        if (this._parent.length == 0)
            this._parent = this._overflowTag;
        this._loader = loader;
        this._horizontal = angular.isDefined(horizontal) ? horizontal : true;
        this._overflowInstances = new Array();
        this._overflowInfo = {};
        this._selectedImg = null;
        this._layout = layout;
        this._tab = tab;
        this._tabService = tabService;
        this._eventService = eventService;
        this._dragDropBindings = {};
        this._commAngular = this._injectorService.get('$commangular');
        this.Initialize();
    }
    OverflowManager.prototype.isOverflowItemValid = function (seriesManagerService, seriesInstanceUID) {
        // we assume it's valid... if there is no information at all
        var valid = true;
        // if there is a currentloadingSeries, then we check if the series matches the seriesInstanceUID in question.
        if (seriesManagerService.currentLoadingSeries) {
            valid = false;
            if (seriesManagerService.currentLoadingSeries.InstanceUID == seriesInstanceUID)
                return true;
        }
        // if there is a structured display, then we check if there is any reference in the SeriesInstanceUID in the structured display.
        if (seriesManagerService.currentStructuredDisplay) {
            valid = false;
            if (seriesManagerService.currentStructuredDisplay.Series) {
                var index = 0;
                var length = seriesManagerService.currentStructuredDisplay.Series.length;
                for (index = 0; index < length; index++) {
                    if (seriesManagerService.currentStructuredDisplay.Series[index].SeriesInstanceUID == seriesInstanceUID)
                        return true;
                }
            }
        }
        return false;
    };
    OverflowManager.prototype.filterOutInvalidOverflow = function (seriesManagerService) {
        var index = 0;
        var length = this._overflowInstances.length;
        for (index = 0; index < length; index++) {
            var sopInstance = this._overflowInstances[index];
            var data = this._overflowInfo[sopInstance];
            if (!this.isOverflowItemValid(seriesManagerService, data.SeriesInstanceUID)) {
                var currentDiv = document.getElementById(data.SOPInstanceUID + "_parent");
                if (currentDiv != null) {
                    if (currentDiv.parentNode != null) {
                        currentDiv.parentNode.removeChild(currentDiv);
                    }
                }
            }
        }
    };
    OverflowManager.prototype.get_seriesInstanceUID = function () {
        return this._seriesInstanceUID;
    };
    OverflowManager.prototype.set_seriesInstanceUID = function (value) {
        this._seriesInstanceUID = value;
    };
    Object.defineProperty(OverflowManager.prototype, "horizontal", {
        get: function () {
            return this._horizontal;
        },
        set: function (value) {
            this._horizontal = value;
        },
        enumerable: false,
        configurable: true
    });
    OverflowManager.prototype.Initialize = function () {
        // not ready yet.
        if (!this._overflowTag[0])
            return;
        var position = lt.LTHelper.getElementStyle(this._overflowTag[0], 'position');
        this._overflowTag[0].style.border = "0px";
        this._overflowTag[0].style.padding = "0px";
        this._overflowTag[0].style.margin = "0px";
    };
    OverflowManager.prototype.swap = function (olddata, newData) {
        setTimeout(function () {
            parentDiv = document.getElementById(olddata.SOPInstanceUID + "_parent");
            this.removeInstance(olddata.SOPInstanceUID, true);
            parentDiv.id = newData.SOPInstanceUID + "_parent";
            parentDiv.data = newData;
            this.updateViewer(parentDiv, newData);
            this._overflowInfo[newData.SOPInstanceUID] = newData;
            this._overflowInstances.push(newData.SOPInstanceUID);
        }.bind(this), 500);
    };
    OverflowManager.prototype.add = function (data) {
        setTimeout(function () {
            var seriesManagerService = this._injectorService.get('seriesManagerService');
            // don't add any late 
            if (!this.isOverflowItemValid(seriesManagerService, data.SeriesInstanceUID))
                return;
            this._cellSize = this._horizontal ? this._overflowTag.height() * 0.90 : this._overflowTag.width() * 0.80;
            var parentDiv = $("<div style='position: relative; border: 0; background-color: black'></div>");
            var size = this._cellSize + "px";
            parentDiv.width(size);
            parentDiv.height(size);
            if (!this._horizontal) {
                parentDiv.css('margin-left', 'auto');
                parentDiv.css('margin-right', 'auto');
                parentDiv.css('margin-top', '5px');
                parentDiv.css('margin-bottom', '0px');
            }
            else {
                parentDiv.css('margin-left', '5px');
                parentDiv.css('margin-right', '0px');
                parentDiv.css('margin-bottom', 'auto');
            }
            parentDiv.attr('id', data.SOPInstanceUID + "_parent");
            parentDiv.data = data;
            this._parent.append(parentDiv);
            if (this.horizontal) {
                var optionsService = this._injectorService.get('optionsService');
                var overflowSize = optionsService.get(OptionNames.SeriesThumbnailWidth) * 2;
                var margin;
                if (overflowSize > 150)
                    overflowSize = 150;
                margin = overflowSize / 2 - this._cellSize / 2;
                parentDiv.css('margin-top', margin + 'px');
            }
            data.viewerTab = this._tab;
            data.tabService = this._tabService;
            this.CreateViewer(parentDiv[0], data);
            this._overflowInfo[data.SOPInstanceUID] = data;
            this._overflowInstances.push(data.SOPInstanceUID);
        }.bind(this), 500);
    };
    OverflowManager.prototype.addInstances = function (instances) {
        var length;
        instances = instances || new Array();
        length = instances.length;
        for (var i = 0; i < length; i++) {
            if (!this.hasInstance(instances[i].SOPInstanceUID)) {
                this.add(instances[i]);
            }
        }
    };
    OverflowManager.prototype.hasInstance = function (instanceUID) {
        var children = this._parent.find("#" + instanceUID);
        return children.length > 0;
    };
    OverflowManager.prototype.clear = function () {
        this._parent.empty();
        this._overflowInstances = new Array();
        this._overflowInfo = {};
    };
    OverflowManager.prototype.get_overflowInstances = function () {
        var instances = new Array();
        for (var i = 0; i < this._overflowInstances.length; i++) {
            if (angular.isDefined(this._overflowInstances[i])) {
                instances.push(this._overflowInfo[this._overflowInstances[i]]);
            }
        }
        return instances;
    };
    OverflowManager.prototype.updateViewer = function (parentDiv, data) {
        var imageElement = parentDiv.children[0];
        var optionsService = this._injectorService.get('optionsService');
        var authService = this._injectorService.get('authenticationService');
        var config = this._injectorService.get('app.config');
        var imageUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
        var dragDrop;
        var cell = data.parentCell;
        var elements = new Array();
        var viewer = data.parentViewer;
        imageUrl += '/GetImage?';
        imageUrl += 'auth=' + encodeURIComponent(authService.authenticationCode);
        imageUrl += '&instance=' + data.SOPInstanceUID;
        imageUrl += '&frame=0';
        imageUrl += '&mime=' + encodeURIComponent('image/jpeg');
        imageUrl += '&bp=24';
        imageUrl += '&qf=10';
        imageUrl += '&cx=' + Math.ceil(this._cellSize);
        imageUrl += '&cy=' + Math.ceil(this._cellSize);
        imageUrl += '&r=' + Date.now();
        imageElement.id = data.SOPInstanceUID;
        imageElement.data = data;
        imageElement.src = imageUrl;
        imageElement.alt = "loading...";
        imageElement.style.maxHeight = "100%";
        imageElement.style.maxWidth = "100%";
        imageElement.addEventListener("load", function () {
            imageElement.style.height = imageElement.naturalHeight + "px";
            imageElement.style.width = imageElement.naturalWidth + "px";
        });
    };
    OverflowManager.prototype.CreateViewer = function (parentDiv, data) {
        var imageElement = document.createElement('img');
        var optionsService = this._injectorService.get('optionsService');
        var authService = this._injectorService.get('authenticationService');
        var config = this._injectorService.get('app.config');
        var imageUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
        var dragDrop;
        var cell = data.parentCell;
        var elements = new Array();
        var viewer = data.parentViewer;
        var tabService = data.tabService;
        var tab = data.viewerTab;
        imageUrl += '/GetImage?';
        imageUrl += 'auth=' + encodeURIComponent(authService.authenticationCode);
        imageUrl += '&instance=' + data.SOPInstanceUID;
        imageUrl += '&frame=0';
        imageUrl += '&mime=' + encodeURIComponent('image/jpeg');
        imageUrl += '&bp=24';
        imageUrl += '&qf=10';
        imageUrl += '&cx=' + Math.ceil(this._cellSize);
        imageUrl += '&cy=' + Math.ceil(this._cellSize);
        imageUrl += '&r=' + Date.now();
        imageElement.setAttribute('id', data.SOPInstanceUID);
        imageElement.data = data;
        imageElement.src = imageUrl;
        imageElement.alt = "loading...";
        imageElement.style.maxHeight = "100%";
        imageElement.style.maxWidth = "100%";
        if (this._horizontal) {
            imageElement.style.display = 'block';
            imageElement.style.margin = 'auto';
        }
        if (cell != null) {
            for (var i = 0; i < cell.imageViewer.items.count; i++) {
                var subCell = (cell.imageViewer.items.item(i));
                $(subCell.overlayCanvas).data('subcell', subCell);
                elements.push(subCell.overlayCanvas);
            }
        }
        dragDrop = new DragDrop.DragDropBinding({
            sources: [imageElement],
            targets: elements,
            anchors: [],
            viewerTab: tab,
            tabService: tabService,
            onTargetUp: this.overlayItemDropped.bind(this),
            onMouseDown: this.onMouseDown.bind(this)
        });
        dragDrop.start();
        this._dragDropBindings[data.SOPInstanceUID] = dragDrop;
        parentDiv.appendChild(imageElement);
    };
    OverflowManager.prototype.overlayItemDropped = function (dragDropBinding, element, targets) {
        var cell = (($(targets[0]).data("cell")));
        var emptyCell = (($(targets[0]).data("emptyDiv")));
        var data = element.data;
        if (cell) {
            if (cell.frames) {
                if (cell.frames.get_count() != 0) {
                    this.swap(data, cell.frames.get_item(0).Instance);
                }
            }
            this._eventService.publish(EventNames.LoadFromOverflow, { SeriesInstanceUID: data.SeriesInstanceUID, SopInstanceUID: Array.isArray(data.SOPInstanceUID) ? data.SOPInstanceUID : [data.SOPInstanceUID], ImageBoxNumber: cell['displaySetNumber'], cell: cell });
        }
        else if (emptyCell) {
            this._eventService.publish(EventNames.LoadFromOverflow, { SeriesInstanceUID: data.SeriesInstanceUID, SopInstanceUID: Array.isArray(data.SOPInstanceUID) ? data.SOPInstanceUID : [data.SOPInstanceUID], ImageBoxNumber: emptyCell.position, cell: null });
            this.removeInstance(data.SOPInstanceUID);
        }
        /*
        var sopInstanceUID: string = element.id;
        var cell: lt.Controls.Medical.Cell = subcell.parentCell;
        var frameMapping = cell.framesMappingIndex;
        var isMapped = false;
        var index = cell.imageViewer.items.indexOf(subcell);

        if (frameMapping && frameMapping[index] != -1) {
            isMapped = true;
        }

        if (subcell.attachedFrame != null || isMapped) {
            var attachedFrame = subcell.attachedFrame;

            if (attachedFrame == null) {
                attachedFrame = cell.frames.item(frameMapping[index]);
            }

            this.onInstanceSwap(null, {
                sopInstanceUID: sopInstanceUID,
                cellFrame: attachedFrame,
                frame: (<any>attachedFrame).FrameIndex,
                instance: (<any>attachedFrame).Instance,
                metadata: (<any>attachedFrame).metadata,
                parentCell: cell,
                subCell: subcell
            });
        }
        else {
            this.onInstanceAdd(null, {
                sopInstanceUID: sopInstanceUID,
                parentCell: cell,
                subCell: subcell
            });
        }*/
    };
    OverflowManager.prototype.onMouseDown = function (dragDropBinding, element) {
        if (this._selectedImg != element) {
            this.selectImg(element, this._selectedImg);
        }
    };
    OverflowManager.prototype.selectImg = function (current, previous) {
        if (previous != null) {
            previous.style.border = '0px';
        }
        if (current != null) {
            current.style.border = '3px solid #5C880C';
            this._selectedImg = current;
        }
    };
    OverflowManager.prototype.onInstanceSwap = function (event, data) {
        var newInstanceData = this._overflowInfo[data.sopInstanceUID];
        var itemData = {
            frame: data.frame,
            instance: data,
            metadata: data.metadata,
            parentCell: data.parentCell
        };
        var cellFrame = Utils.findFirst(data.parentCell.frames.toArray(), function (frame) {
            if (frame.Instance) {
                return frame.Instance.SOPInstanceUID == data.sopInstanceUID;
            }
            return false;
        });
        if (cellFrame) {
            data.parentCell.imageViewer.beginUpdate();
            data.subCell.attachedFrame = cellFrame;
            data.subCell["isMapped"] = true;
            this.add(itemData);
            this.removeInstance(data.sopInstanceUID);
            data.parentCell.imageViewer.endUpdate();
            data.parentCell.onSizeChanged();
        }
    };
    OverflowManager.prototype.onInstanceAdd = function (event, data) {
        var newInstanceData = this._overflowInfo[data.sopInstanceUID];
        var cellFrame = Utils.findFirst(data.parentCell.frames.toArray(), function (frame) {
            if (frame.Instance) {
                return frame.Instance.SOPInstanceUID == data.sopInstanceUID;
            }
            return false;
        });
        if (cellFrame) {
            data.parentCell.imageViewer.beginUpdate();
            data.subCell["isMapped"] = true;
            data.subCell.attachedFrame = cellFrame;
            this.removeInstance(data.sopInstanceUID);
            data.parentCell.imageViewer.endUpdate();
            data.parentCell.onSizeChanged();
        }
    };
    OverflowManager.prototype.removeInstance = function (sopInstanceUID, keepItem) {
        var parentElement = document.getElementById(sopInstanceUID + "_parent");
        if (parentElement != null) {
            var index = this._overflowInstances.indexOf(sopInstanceUID);
            if (!keepItem)
                $(parentElement).remove();
            if (index != -1) {
                this._overflowInstances.splice(index, 1);
                delete this._overflowInfo[sopInstanceUID];
                delete this._dragDropBindings[sopInstanceUID];
                if (!keepItem) {
                    if (this._overflowInstances.length == 0) {
                        this.checkCanClose(parentElement);
                    }
                }
            }
        }
    };
    OverflowManager.prototype.checkCanClose = function (parent) {
        if (this._layout != null) {
            this._layout.api.closePane(this._layout.direction);
        }
    };
    OverflowManager.prototype.prepareCellFrame = function (cellFrame, instanceData) {
        var information = DicomHelper.GetDicomImageInformation(instanceData.metadata);
        cellFrame.set_instanceNumber(instanceData.instance.InstanceNumber);
        cellFrame.metadata = instanceData.metadata;
        cellFrame.Instance = instanceData.instance;
        cellFrame.FrameNumber = instanceData.frame + 1;
        cellFrame.FrameIndex = instanceData.frame;
        if (instanceData.frame == 0) {
            var width;
            var height;
            var currentIndex = instanceData.parentCell.frames.indexOf(cellFrame);
            var currentStackIndex = instanceData.parentCell.currentOffset;
            var seriesInstanceUID = instanceData.parentCell.get_seriesInstanceUID();
            cellFrame.set_information(information);
            cellFrame.set_imagePosition(information.position);
            cellFrame.set_imageType(information.imageType);
            cellFrame.set_lossyCompression(information.lossyImageCompression);
            cellFrame.isWaveForm = information.isWaveForm;
            width = information.get_width();
            height = information.get_height();
            cellFrame.set_width(width);
            cellFrame.set_height(height);
            cellFrame.set_rowSpacing(information.rowSpacing);
            cellFrame.set_columnSpacing(information.columnSpacing);
            cellFrame.originalSize = { width: information.get_width(), height: information.get_height() };
        }
        else {
            var information = DicomHelper.GetDicomImageInformation(instanceData.metadata);
            cellFrame.set_information(information);
            cellFrame.originalSize = { width: information.get_width(), height: information.get_height() };
            cellFrame.set_width(information.get_width());
            cellFrame.set_height(information.get_height());
            cellFrame.isWaveForm = information.isWaveForm;
        }
    };
    return OverflowManager;
}());
;
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../controls/OverflowManager.ts" />
var Controllers;
(function (Controllers) {
    var CompareViewController = /** @class */ (function () {
        function CompareViewController($scope, toolbarService, tabService) {
            var spacingSize = Utils.get_spacingSize();
            var deregister = null;
            var __this = this;
            $scope.layoutConfig = {
                autoBindCustomButtons: true,
                scrollToBookmarkOnLoad: false,
                applyDemoStyles: true,
                spacing_closed: spacingSize * 2,
                spacing_open: spacingSize * 2,
                livePaneResizing: false,
                west__size: 0,
                west__resizable: false,
                west__togglerLength_closed: 21,
                south__resizable: false,
                south__initHidden: true,
                south__togglerContent_open: "<span style='vertical-align:top; color:white; vertical-align:middle'>Overflow</span>",
                south__togglerLength_open: 64,
                south__togglerContent_closed: "<span style='vertical-align:top; color:white'>Overflow</span>",
                south__togglerLength_closed: 64,
                east__initHidden: true,
                east__resizable: false,
                east__size: 0,
                north__size: 0,
                north__initHidden: true,
                north__resizable: false,
                north__showOverflowOnHover: true
            };
            $scope.tabId = '';
            $scope.viewerId = UUID.generate();
            $scope.viewerapi = {};
            $scope.seriesList = new Array();
            this._scope = $scope;
            deregister = $scope.$watch('tabId', function (newValue, oldValue) {
                var series = tabService.get_tabData(newValue, TabDataKeys.CompareInstances);
                var grid = __this.getGrid(series.length);
                tabService.set_tabData($scope.tabId, TabDataKeys.ViewController, __this);
                tabService.set_tabData($scope.tabId, TabDataKeys.Linked, true);
                $scope.viewerConfig = new MedicalViewerConfig();
                $scope.viewerConfig.rows = grid.rows;
                $scope.viewerConfig.columns = grid.columns;
                $scope.viewerConfig.splitterSize = Utils.get_splitterSize();
                tabService.set_tabData(newValue, TabDataKeys.CompareInstances, null);
                $.each(series, function (index, value) {
                    var viewerSeries = new MedicalViewerSeries(value.InstanceUID, value.Patient.ID);
                    viewerSeries.forCompare = true;
                    $scope.seriesList.push(viewerSeries);
                });
            });
        }
        CompareViewController.prototype.getGrid = function (itemCount) {
            var rows = Math.ceil(Math.sqrt(itemCount));
            var columns = Math.round(Math.ceil(itemCount / rows));
            return { columns: columns, rows: rows };
        };
        CompareViewController.prototype.getViewer = function () {
            return this._scope.viewerapi.getMedicalViewer();
        };
        CompareViewController.$inject = ['$scope', 'toolbarService', 'tabService'];
        return CompareViewController;
    }());
    Controllers.CompareViewController = CompareViewController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var StudyLayoutController = /** @class */ (function () {
        function StudyLayoutController($scope, optionsService, $modalInstance, layout, templateService, dialogs, authenticationService) {
            this._$scope = $scope;
            var index;
            this._optionsService = optionsService;
            $scope.customStudyLayoutOptions = this.GetLayoutFromXMLFile(0);
            $scope.layout = layout;
            if (layout.custom != null) {
                index = $scope.customStudyLayoutOptions.map(function (x) { return x.Text; }).indexOf(layout.custom);
                if (index != -1) {
                    $scope.layout.custom = $scope.customStudyLayoutOptions[index];
                }
            }
            $scope.ok = function () {
                $modalInstance.close($scope.layout);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isRowValid = this.isRowValid.bind(this);
            $scope.getIsRowValidError = this.getIsRowValidError.bind(this);
            $scope.isColumnValid = this.isColumnValid.bind(this);
            $scope.getIsColumnValidError = this.getIsColumnValidError.bind(this);
            $scope.doHideCustomLayouts = this.doHideCustomLayouts.bind(this);
            $scope.isFormValid = this.isFormValid.bind(this);
            if (authenticationService.hasPermission(PermissionNames.CanViewTemplates)) {
                templateService.GetAllTemplates().success(function (templates) {
                    var selectedTemplates = null;
                    if (layout.custom != null) {
                        var selectedTemplates = $.grep(templates, function (template, index) {
                            return template.Id == layout.custom;
                        });
                    }
                    else {
                        templates = $.grep(templates, function (template, index) {
                            return (template.Availability == Models.TemplateAvailability.Study || template.Availability == Models.TemplateAvailability.SeriesAndStudy);
                        });
                    }
                    $scope.templates = templates;
                    $scope.layout = {
                        rows: layout.rows,
                        columns: layout.columns,
                        custom: null
                    };
                    if (angular.isDefined(selectedTemplates) && selectedTemplates != null && selectedTemplates.length > 0) {
                        $scope.layout.custom = selectedTemplates[0];
                    }
                }.bind(this))
                    .error(function (error) {
                    dialogs.error(this._errorMesssage + ": " + error);
                }.bind(this));
            }
        }
        StudyLayoutController.prototype.GetLayoutFromXMLFile = function (startIndex) {
            var request = new XMLHttpRequest();
            request.open('GET', 'StudyLayouts.xml', false);
            request.send();
            var xml = request.responseText;
            var doc = $.parseXML(xml);
            var layoutNode = doc.getElementsByTagName('Layout');
            var length = layoutNode.length - startIndex;
            var index = 0;
            var layout = [];
            var boxElement;
            var childIndex;
            var childsLength = 0;
            var attributes;
            var icon;
            var text;
            for (; index < length; index++) {
                layout[index] = [];
                childsLength = layoutNode[index + startIndex].childElementCount;
                boxElement = layoutNode[index + startIndex].firstElementChild;
                attributes = layoutNode[index + startIndex].attributes;
                layout[index]["Icon"] = attributes.getNamedItem("icon").value;
                layout[index]["Text"] = attributes.getNamedItem("text").value;
                for (childIndex = 0; childIndex < childsLength; childIndex++) {
                    layout[index][childIndex] = this.stringArrayToFloatArray(boxElement.textContent);
                    boxElement = boxElement.nextElementSibling;
                }
            }
            return layout;
        };
        StudyLayoutController.prototype.stringArrayToFloatArray = function (text) {
            var array = text.split(',');
            if (array == null) {
                return null;
            }
            if (!array.length) {
                return null;
            }
            var index;
            var result = new Array(array.length);
            for (index = 0; index < array.length; index++) {
                result[index] = parseFloat(array[index]);
            }
            return result;
        };
        StudyLayoutController.prototype.doHideCustomLayouts = function () {
            var hideCustomLayouts = this._optionsService.get(OptionNames.HideCustomLayouts);
            if (hideCustomLayouts == null) {
                hideCustomLayouts = true;
            }
            return hideCustomLayouts;
        };
        StudyLayoutController.prototype.isRowValid = function () {
            var errorMessage = this.getIsRowValidError();
            return (errorMessage == "");
        };
        StudyLayoutController.prototype.getIsRowValidError = function () {
            if (!$.isNumeric(this._$scope.layout.rows)) {
                return "Must be numeric";
            }
            if (this._$scope.layout.rows <= 0) {
                return "Must be greater than 0";
            }
            return "";
        };
        StudyLayoutController.prototype.isColumnValid = function () {
            var errorMessage = this.getIsColumnValidError();
            return (errorMessage == "");
        };
        StudyLayoutController.prototype.getIsColumnValidError = function () {
            if (!$.isNumeric(this._$scope.layout.columns)) {
                return "Must be numeric";
            }
            if (this._$scope.layout.columns <= 0) {
                return "Must be greater than 0";
            }
            return "";
        };
        StudyLayoutController.prototype.isFormValid = function () {
            return this.isRowValid() && this.isColumnValid();
        };
        StudyLayoutController.$inject = ['$scope', 'optionsService', '$modalInstance', 'layout', 'templateService', 'dialogs', 'authenticationService'];
        return StudyLayoutController;
    }());
    Controllers.StudyLayoutController = StudyLayoutController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Models;
(function (Models) {
    var ImageFrame = function () { };
    ImageFrame.prototype = {
        Instance: {},
        ImageElement: null,
        FrameIndex: 0,
        FrameNumber: 1,
        DicomData: null,
        CanvasData: null,
        DrawingCanvas: null,
        WLRenderer: null,
        ImageData: null,
        IsProcessing: false,
        DataReady: false,
        IsDirty: false,
        updateImageData: true,
        DataCanvasElement: null,
        DataImageElement: null,
        IPFunctionsData: null,
        IPFunctionsName: null
    };
    var FrameSavedProperties = function () { };
    FrameSavedProperties.prototype = {
        seriesPropertiesOffsetX: 0,
        seriesPropertiesOffsetY: 0,
        seriesPropertiesScale: 0,
        seriesPropertiesRotateAngle: 0,
        seriesPropertiesFlipped: 0,
        seriesPropertiesReversed: 0,
        framePropertiesOffsetX: 0,
        framePropertiesOffsetY: 0,
        framePropertiesScale: 0,
        framePropertiesSizeMode: 0,
        framePropertiesRotateAngle: 0,
        framePropertiesFlipped: 0,
        framePropertiesReversed: 0
    };
    var FramePresentationInfo = /** @class */ (function () {
        function FramePresentationInfo() {
            this._cineOptions = null;
            this._orientationOverlay = null;
            this._position = null;
            this._orientation = null;
            this._rowSpacing = 0;
            this._columnSpacing = 0;
            this._instanceNumber = 0;
            this._width = 0;
            this._height = 0;
            this._patientOrientation = null;
        }
        Object.defineProperty(FramePresentationInfo.prototype, "cineOptions", {
            get: function () {
                return this._cineOptions;
            },
            set: function (value) {
                this._cineOptions = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "orientationOverlay", {
            get: function () {
                return this._orientationOverlay;
            },
            set: function (value) {
                this._orientationOverlay = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (value) {
                this._position = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "orientation", {
            get: function () {
                return this._orientation;
            },
            set: function (value) {
                this._orientation = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "rowSpacing", {
            get: function () {
                return this._rowSpacing;
            },
            set: function (value) {
                this._rowSpacing = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "columnSpacing", {
            get: function () {
                return this._columnSpacing;
            },
            set: function (value) {
                this._columnSpacing = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "instanceNumber", {
            get: function () {
                return this._instanceNumber;
            },
            set: function (value) {
                this._instanceNumber = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (value) {
                this._height = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FramePresentationInfo.prototype, "patientOrientation", {
            get: function () {
                return this._patientOrientation;
            },
            set: function (value) {
                this._patientOrientation = value;
            },
            enumerable: false,
            configurable: true
        });
        return FramePresentationInfo;
    }());
    Models.FramePresentationInfo = FramePresentationInfo;
    ;
    var ImageProperties = function () {
        this.OriginalWindowLevelWidth = 0;
        this.OriginalWindowLevelCenter = 0;
        this.Reset();
    };
    ImageProperties.prototype = {
        Reset: function () {
            this.Flipped = false;
            this.Reversed = false;
            this.RotateAngle = 0;
            this.Inverted = false;
            this.WindowLevelWidth = this.OriginalWindowLevelWidth;
            this.WindowLevelCenter = this.OriginalWindowLevelCenter;
            this.OffsetX = 0;
            this.OffsetY = 0;
            this.Scale = 0;
            this.SizeMode = false;
            this.SetDirectly = false;
        },
        ResetScale: function (sizeMode) {
            this.OffsetX = 0;
            this.OffsetY = 0;
            this.Scale = 0;
            this.SizeMode = sizeMode;
        }
    };
    var ImageProcessingFunction = /** @class */ (function () {
        function ImageProcessingFunction() {
            this.Name = null;
            this.Parameters = null;
        }
        return ImageProcessingFunction;
    }());
    Models.ImageProcessingFunction = ImageProcessingFunction;
    ;
    var ImageSize = /** @class */ (function () {
        function ImageSize() {
            this.width = 0;
            this.height = 0;
            this.functions = {};
        }
        return ImageSize;
    }());
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="Models/ImageFrame.ts" />
var DicomTag;
(function (DicomTag) {
    // *****************************************************************************************************************************
    // *** 0002
    // *****************************************************************************************************************************
    DicomTag.FileMetaInformationGroupLength = "00020000";
    DicomTag.FileMetaInformationVersion = "00020001";
    DicomTag.MediaStorageSOPClassUID = "00020002";
    DicomTag.MediaStorageSOPInstanceUID = "00020003";
    DicomTag.TransferSyntaxUID = "00020010";
    DicomTag.ImplementationClassUID = "00020012";
    DicomTag.ImplementationVersionName = "00020013";
    DicomTag.SourceApplicationEntityTitle = "00020016";
    DicomTag.SendingApplicationEntityTitle = "00020017";
    DicomTag.ReceivingApplicationEntityTitle = "00020018";
    DicomTag.PrivateInformationCreatorUID = "00020100";
    DicomTag.PrivateInformation = "00020102";
    // *****************************************************************************************************************************
    // *** 0004
    // *****************************************************************************************************************************
    DicomTag.FileSetID = "00041130";
    DicomTag.FileSetDescriptorFileID = "00041141";
    DicomTag.SpecificCharacterSetOfFileSetDescriptorFile = "00041142";
    DicomTag.OffsetFirstRootDirectory = "00041200";
    DicomTag.OffsetLastRootDirectory = "00041202";
    DicomTag.FileSetConsistencyFlag = "00041212";
    DicomTag.DirectoryRecordSequence = "00041220";
    DicomTag.OffsetNextDirectory = "00041400";
    DicomTag.RecordInUseFlag = "00041410";
    DicomTag.OffsetChildDirectory = "00041420";
    DicomTag.DirectoryRecordType = "00041430";
    DicomTag.PrivateRecordUID = "00041432";
    DicomTag.ReferencedFileID = "00041500";
    DicomTag.MRDRDirectoryRecordOffset = "00041504"; // Retired
    DicomTag.ReferencedSOPClassUIDInFile = "00041510";
    DicomTag.ReferencedSOPInstanceUIDInFile = "00041511";
    DicomTag.ReferencedTransferSyntaxUIDInFile = "00041512";
    DicomTag.ReferencedRelatedGeneralSOPClassUIDInFile = "0004151A";
    DicomTag.NumberOfReferences = "00041600"; // Retired
    // *****************************************************************************************************************************
    // *** 0008
    // *****************************************************************************************************************************
    DicomTag.LengthToEnd = "00080001"; // Retired
    DicomTag.SpecificCharacterSet = "00080005";
    DicomTag.LanguageCodeSequence = "00080006";
    DicomTag.ImageType = "00080008";
    DicomTag.RecognitionCode = "00080010"; // Retired
    DicomTag.InstanceCreationDate = "00080012";
    DicomTag.InstanceCreationTime = "00080013";
    DicomTag.InstanceCreatorUID = "00080014";
    DicomTag.InstanceCoercionDateTime = "00080015";
    DicomTag.SOPClassUID = "00080016";
    DicomTag.SOPInstanceUID = "00080018";
    DicomTag.RelatedGeneralSOPClassUID = "0008001A";
    DicomTag.OriginalSpecializedSOPClassUID = "0008001B";
    DicomTag.StudyDate = "00080020";
    DicomTag.SeriesDate = "00080021";
    DicomTag.AcquisitionDate = "00080022";
    DicomTag.ContentDate = "00080023";
    DicomTag.OverlayDate = "00080024"; // Retired
    DicomTag.CurveDate = "00080025"; // Retired
    DicomTag.AcquisitionDateTime = "0008002A";
    DicomTag.StudyTime = "00080030";
    DicomTag.SeriesTime = "00080031";
    DicomTag.AcquisitionTime = "00080032";
    DicomTag.ContentTime = "00080033";
    DicomTag.OverlayTime = "00080034"; // Retired
    DicomTag.CurveTime = "00080035"; // Retired
    DicomTag.DataSetType = "00080040"; // Retired
    DicomTag.DataSetSubtype = "00080041"; // Retired
    DicomTag.NuclearMedicineSeriesType = "00080042"; // Retired
    DicomTag.AccessionNumber = "00080050";
    DicomTag.IssuerOfAccessionNumberSequence = "00080051";
    DicomTag.QueryRetrieveLevel = "00080052";
    DicomTag.QueryRetrieveView = "00080053";
    DicomTag.RetrieveAETitle = "00080054";
    DicomTag.InstanceAvailability = "00080056";
    DicomTag.FailedSOPInstanceUIDList = "00080058";
    DicomTag.Modality = "00080060";
    DicomTag.ModalitiesInStudy = "00080061";
    DicomTag.SOPClassesInStudy = "00080062";
    DicomTag.ConversionType = "00080064";
    DicomTag.PresentationIntentType = "00080068";
    DicomTag.Manufacturer = "00080070";
    DicomTag.InstitutionName = "00080080";
    DicomTag.InstitutionAddress = "00080081";
    DicomTag.InstitutionCodeSequence = "00080082";
    DicomTag.ReferringPhysicianName = "00080090";
    DicomTag.ReferringPhysicianAddress = "00080092";
    DicomTag.ReferringPhysicianTelephoneNumbers = "00080094";
    DicomTag.ReferringPhysicianIdentificationSequence = "00080096";
    DicomTag.ConsultingPhysicianName = "0008009C";
    DicomTag.ConsultingPhysicianIdentificationSequence = "0008009D";
    DicomTag.CodeValue = "00080100";
    DicomTag.ExtendedCodeValue = "00080101";
    DicomTag.CodingSchemeDesignator = "00080102";
    DicomTag.CodingSchemeVersion = "00080103";
    DicomTag.CodeMeaning = "00080104";
    DicomTag.MappingResource = "00080105";
    DicomTag.ContextGroupVersion = "00080106";
    DicomTag.ContextGroupLocalVersion = "00080107";
    DicomTag.ExtendedCodeMeaning = "00080108";
    DicomTag.ContextGroupExtensionFlag = "0008010B";
    DicomTag.CodingSchemeUID = "0008010C";
    DicomTag.ContextGroupExtensionCreatorUID = "0008010D";
    DicomTag.ContextIdentifier = "0008010F";
    DicomTag.CodingSchemeIdentificationSequence = "00080110";
    DicomTag.CodingSchemeRegistry = "00080112";
    DicomTag.CodingSchemeExternalID = "00080114";
    DicomTag.CodingSchemeName = "00080115";
    DicomTag.CodingSchemeResponsibleOrganization = "00080116";
    DicomTag.ContextUID = "00080117";
    DicomTag.MappingResourceUID = "00080118";
    DicomTag.LongCodeValue = "00080119";
    DicomTag.URNCodeValue = "00080120";
    DicomTag.EquivalentCodeSequence = "00080121";
    DicomTag.TimezoneOffsetFromUTC = "00080201";
    DicomTag.PrivateDataElementCharacteristicsSequence = "00080300";
    DicomTag.PrivateGroupReference = "00080301";
    DicomTag.PrivateCreatorReference = "00080302";
    DicomTag.BlockIdentifyingInformationStatus = "00080303";
    DicomTag.NonidentifyingPrivateElements = "00080304";
    DicomTag.DeidentificationActionSequence = "00080305";
    DicomTag.IdentifyingPrivateElements = "00080306";
    DicomTag.DeidentificationAction = "00080307";
    DicomTag.NetworkID = "00081000"; // Retired
    DicomTag.StationName = "00081010";
    DicomTag.StudyDescription = "00081030";
    DicomTag.ProcedureCodeSequence = "00081032";
    DicomTag.SeriesDescription = "0008103E";
    DicomTag.SeriesDescriptionCodeSequence = "0008103F";
    DicomTag.InstitutionalDepartmentName = "00081040";
    DicomTag.PhysicianOfRecord = "00081048";
    DicomTag.PhysicianOfRecordIdentificationSequence = "00081049";
    DicomTag.PerformingPhysicianName = "00081050";
    DicomTag.PerformingPhysicianIdentificationSequence = "00081052";
    DicomTag.NameOfPhysicianReadingStudy = "00081060";
    DicomTag.PhysicianReadingStudyIdentificationSequence = "00081062";
    DicomTag.OperatorName = "00081070";
    DicomTag.OperatorIdentificationSequence = "00081072";
    DicomTag.AdmittingDiagnosesDescription = "00081080";
    DicomTag.AdmittingDiagnosesCodeSequence = "00081084";
    DicomTag.ManufacturerModelName = "00081090";
    DicomTag.ReferencedResultsSequence = "00081100"; // Retired
    DicomTag.ReferencedStudySequence = "00081110";
    DicomTag.ReferencedPerformedProcedureStepSequence = "00081111";
    DicomTag.ReferencedSeriesSequence = "00081115";
    DicomTag.ReferencedPatientSequence = "00081120";
    DicomTag.ReferencedVisitSequence = "00081125";
    DicomTag.ReferencedOverlaySequence = "00081130"; // Retired
    DicomTag.ReferencedStereometricInstanceSequence = "00081134";
    DicomTag.ReferencedWaveformSequence = "0008113A";
    DicomTag.ReferencedImageSequence = "00081140";
    DicomTag.ReferencedCurveSequence = "00081145"; // Retired
    DicomTag.ReferencedInstanceSequence = "0008114A";
    DicomTag.ReferencedRealWorldValueMappingInstanceSequence = "0008114B";
    DicomTag.ReferencedSOPClassUID = "00081150";
    DicomTag.ReferencedSOPInstanceUID = "00081155";
    DicomTag.SOPClassesSupported = "0008115A";
    DicomTag.ReferencedFrameNumber = "00081160";
    DicomTag.SimpleFrameList = "00081161";
    DicomTag.CalculatedFrameList = "00081162";
    DicomTag.TimeRange = "00081163";
    DicomTag.FrameExtractionSequence = "00081164";
    DicomTag.MultiFrameSourceSOPInstanceUID = "00081167";
    DicomTag.RetrieveURL = "00081190";
    DicomTag.TransactionUID = "00081195";
    DicomTag.WarningReason = "00081196";
    DicomTag.FailureReason = "00081197";
    DicomTag.FailedSOPSequence = "00081198";
    DicomTag.ReferencedSOPSequence = "00081199";
    DicomTag.StudiesContainingOtherReferencedInstancesSequence = "00081200";
    DicomTag.RelatedSeriesSequence = "00081250";
    DicomTag.LossyImageCompressionRetired = "00082110"; // Retired
    DicomTag.DerivationDescription = "00082111";
    DicomTag.SourceImageSequence = "00082112";
    DicomTag.StageName = "00082120";
    DicomTag.StageNumber = "00082122";
    DicomTag.NumberOfStages = "00082124";
    DicomTag.ViewName = "00082127";
    DicomTag.ViewNumber = "00082128";
    DicomTag.NumberOfEventTimers = "00082129";
    DicomTag.NumberOfViewsInStage = "0008212A";
    DicomTag.EventElapsedTime = "00082130";
    DicomTag.EventTimerName = "00082132";
    DicomTag.EventTimerSequence = "00082133";
    DicomTag.EventTimeOffset = "00082134";
    DicomTag.EventCodeSequence = "00082135";
    DicomTag.StartTrim = "00082142";
    DicomTag.StopTrim = "00082143";
    DicomTag.RecommendedDisplayFrameRate = "00082144";
    DicomTag.TransducerPosition = "00082200"; // Retired
    DicomTag.TransducerOrientation = "00082204"; // Retired
    DicomTag.AnatomicStructure = "00082208"; // Retired
    DicomTag.AnatomicRegionSequence = "00082218";
    DicomTag.AnatomicRegionModifierSequence = "00082220";
    DicomTag.PrimaryAnatomicStructureSequence = "00082228";
    DicomTag.AnatomicStructureSpaceOrRegionSequence = "00082229";
    DicomTag.PrimaryAnatomicStructureModifierSequence = "00082230";
    DicomTag.TransducerPositionSequence = "00082240"; // Retired
    DicomTag.TransducerPositionModifierSequence = "00082242"; // Retired
    DicomTag.TransducerOrientationSequence = "00082244"; // Retired
    DicomTag.TransducerOrientationModifierSequence = "00082246"; // Retired
    DicomTag.AnatomicStructureSpaceOrRegionCodeSequenceTrial = "00082251"; // Retired
    DicomTag.AnatomicPortalOfEntranceCodeSequenceTrial = "00082253"; // Retired
    DicomTag.AnatomicApproachDirectionCodeSequenceTrial = "00082255"; // Retired
    DicomTag.AnatomicPerspectiveDescriptionTrial = "00082256"; // Retired
    DicomTag.AnatomicPerspectiveCodeSequenceTrial = "00082257"; // Retired
    DicomTag.AnatomicLocationOfExaminingInstrumentDescriptionTrial = "00082258"; // Retired
    DicomTag.AnatomicLocationOfExaminingInstrumentCodeSequenceTrial = "00082259"; // Retired
    DicomTag.AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial = "0008225A"; // Retired
    DicomTag.OnAxisBackgroundAnatomicStructureCodeSequenceTrial = "0008225C"; // Retired
    DicomTag.AlternateRepresentationSequence = "00083001";
    DicomTag.IrradiationEventUID = "00083010";
    DicomTag.SourceIrradiationEventSequence = "00083011";
    DicomTag.RadiopharmaceuticalAdministrationEventUID = "00083012";
    DicomTag.IdentifyingComments = "00084000"; // Retired
    DicomTag.FrameType = "00089007";
    DicomTag.ReferencedImageEvidenceSequence = "00089092";
    DicomTag.ReferencedRawDataSequence = "00089121";
    DicomTag.CreatorVersionUID = "00089123";
    DicomTag.DerivationImageSequence = "00089124";
    DicomTag.SourceImageEvidenceSequence = "00089154";
    DicomTag.PixelPresentation = "00089205";
    DicomTag.VolumetricProperties = "00089206";
    DicomTag.VolumeBasedCalculationTechnique = "00089207";
    DicomTag.ComplexImageComponent = "00089208";
    DicomTag.AcquisitionContrast = "00089209";
    DicomTag.DerivationCodeSequence = "00089215";
    DicomTag.ReferencedPresentationStateSequence = "00089237";
    DicomTag.ReferencedOtherPlaneSequence = "00089410";
    DicomTag.FrameDisplaySequence = "00089458";
    DicomTag.RecommendedDisplayFrameRateInFloat = "00089459";
    DicomTag.SkipFrameRangeFlag = "00089460";
    // *****************************************************************************************************************************
    // *** 0010
    // *****************************************************************************************************************************
    DicomTag.PatientName = "00100010";
    DicomTag.PatientID = "00100020";
    DicomTag.IssuerOfPatientID = "00100021";
    DicomTag.TypeOfPatientID = "00100022";
    DicomTag.IssuerOfPatientIDQualifiersSequence = "00100024";
    DicomTag.PatientBirthDate = "00100030";
    DicomTag.PatientBirthTime = "00100032";
    DicomTag.PatientSex = "00100040";
    DicomTag.PatientInsurancePlanCodeSequence = "00100050";
    DicomTag.PatientPrimaryLanguageCodeSequence = "00100101";
    DicomTag.PatientPrimaryLanguageModifierCodeSequence = "00100102";
    DicomTag.QualityControlSubject = "00100200";
    DicomTag.QualityControlSubjectTypeCodeSequence = "00100201";
    DicomTag.OtherPatientIDs = "00101000";
    DicomTag.OtherPatientNames = "00101001";
    DicomTag.OtherPatientIDsSequence = "00101002";
    DicomTag.PatientBirthName = "00101005";
    DicomTag.PatientAge = "00101010";
    DicomTag.PatientSize = "00101020";
    DicomTag.PatientSizeCodeSequence = "00101021";
    DicomTag.PatientWeight = "00101030";
    DicomTag.PatientAddress = "00101040";
    DicomTag.InsurancePlanIdentification = "00101050"; // Retired
    DicomTag.PatientMotherBirthName = "00101060";
    DicomTag.MilitaryRank = "00101080";
    DicomTag.BranchOfService = "00101081";
    DicomTag.MedicalRecordLocator = "00101090";
    DicomTag.ReferencedPatientPhotoSequence = "00101100";
    DicomTag.MedicalAlerts = "00102000";
    DicomTag.Allergies = "00102110";
    DicomTag.CountryOfResidence = "00102150";
    DicomTag.RegionOfResidence = "00102152";
    DicomTag.PatientTelephoneNumbers = "00102154";
    DicomTag.PatientTelecomInformation = "00102155";
    DicomTag.EthnicGroup = "00102160";
    DicomTag.Occupation = "00102180";
    DicomTag.SmokingStatus = "001021A0";
    DicomTag.AdditionalPatientHistory = "001021B0";
    DicomTag.PregnancyStatus = "001021C0";
    DicomTag.LastMenstrualDate = "001021D0";
    DicomTag.PatientReligiousPreference = "001021F0";
    DicomTag.PatientSpeciesDescription = "00102201";
    DicomTag.PatientSpeciesCodeSequence = "00102202";
    DicomTag.PatientSexNeutered = "00102203";
    DicomTag.AnatomicalOrientationType = "00102210";
    DicomTag.PatientBreedDescription = "00102292";
    DicomTag.PatientBreedCodeSequence = "00102293";
    DicomTag.BreedRegistrationSequence = "00102294";
    DicomTag.BreedRegistrationNumber = "00102295";
    DicomTag.BreedRegistryCodeSequence = "00102296";
    DicomTag.ResponsiblePerson = "00102297";
    DicomTag.ResponsiblePersonRole = "00102298";
    DicomTag.ResponsibleOrganization = "00102299";
    DicomTag.PatientComments = "00104000";
    DicomTag.ExaminedBodyThickness = "00109431";
    // *****************************************************************************************************************************
    // *** 0012
    // *****************************************************************************************************************************
    DicomTag.ClinicalTrialSponsorName = "00120010";
    DicomTag.ClinicalTrialProtocolID = "00120020";
    DicomTag.ClinicalTrialProtocolName = "00120021";
    DicomTag.ClinicalTrialSiteID = "00120030";
    DicomTag.ClinicalTrialSiteName = "00120031";
    DicomTag.ClinicalTrialSubjectID = "00120040";
    DicomTag.ClinicalTrialSubjectReadingID = "00120042";
    DicomTag.ClinicalTrialTimePointID = "00120050";
    DicomTag.ClinicalTrialTimePointDescription = "00120051";
    DicomTag.ClinicalTrialCoordinatingCenterName = "00120060";
    DicomTag.PatientIdentityRemoved = "00120062";
    DicomTag.DeIdentificationMethod = "00120063";
    DicomTag.DeIdentificationMethodCodeSequence = "00120064";
    DicomTag.ClinicalTrialSeriesID = "00120071";
    DicomTag.ClinicalTrialSeriesDescription = "00120072";
    DicomTag.ClinicalTrialProtocolEthicsCommitteeName = "00120081";
    DicomTag.ClinicalTrialProtocolEthicsCommitteeApprovalNumber = "00120082";
    DicomTag.ConsentForClinicalTrialUseSequence = "00120083";
    DicomTag.DistributionType = "00120084";
    DicomTag.ConsentForDistributionFlag = "00120085";
    // *****************************************************************************************************************************
    // *** 0014
    // *****************************************************************************************************************************
    DicomTag.CADFileFormat = "00140023"; // Retired
    DicomTag.ComponentReferenceSystem = "00140024"; // Retired
    DicomTag.ComponentManufacturingProcedure = "00140025";
    DicomTag.ComponentManufacturer = "00140028";
    DicomTag.MaterialThickness = "00140030";
    DicomTag.MaterialPipeDiameter = "00140032";
    DicomTag.MaterialIsolationDiameter = "00140034";
    DicomTag.MaterialGrade = "00140042";
    DicomTag.MaterialPropertiesDescription = "00140044";
    DicomTag.MaterialPropertiesFileFormat = "00140045"; // Retired
    DicomTag.MaterialNotes = "00140046";
    DicomTag.ComponentShape = "00140050";
    DicomTag.CurvatureType = "00140052";
    DicomTag.OuterDiameter = "00140054";
    DicomTag.InnerDiameter = "00140056";
    DicomTag.ActualEnvironmentalConditions = "00141010";
    DicomTag.ExpiryDate = "00141020";
    DicomTag.EnvironmentalConditions = "00141040";
    DicomTag.EvaluatorSequence = "00142002";
    DicomTag.EvaluatorNumber = "00142004";
    DicomTag.EvaluatorName = "00142006";
    DicomTag.EvaluationAttempt = "00142008";
    DicomTag.IndicationSequence = "00142012";
    DicomTag.IndicationNumber = "00142014";
    DicomTag.IndicationLabel = "00142016";
    DicomTag.IndicationDescription = "00142018";
    DicomTag.IndicationType = "0014201A";
    DicomTag.IndicationDisposition = "0014201C";
    DicomTag.IndicationROISequence = "0014201E";
    DicomTag.IndicationPhysicalPropertySequence = "00142030";
    DicomTag.PropertyLabel = "00142032";
    DicomTag.CoordinateSystemNumberOfAxes = "00142202";
    DicomTag.CoordinateSystemAxesSequence = "00142204";
    DicomTag.CoordinateSystemAxisDescription = "00142206";
    DicomTag.CoordinateSystemDataSetMapping = "00142208";
    DicomTag.CoordinateSystemAxisNumber = "0014220A";
    DicomTag.CoordinateSystemAxisType = "0014220C";
    DicomTag.CoordinateSystemAxisUnits = "0014220E";
    DicomTag.CoordinateSystemAxisValues = "00142210";
    DicomTag.CoordinateSystemTransformSequence = "00142220";
    DicomTag.TransformDescription = "00142222";
    DicomTag.TransformNumberOfAxes = "00142224";
    DicomTag.TransformOrderOfAxes = "00142226";
    DicomTag.TransformedAxisUnits = "00142228";
    DicomTag.CoordinateSystemTransformRotationAndScaleMatrix = "0014222A";
    DicomTag.CoordinateSystemTransformTranslationMatrix = "0014222C";
    DicomTag.InternalDetectorFrameTime = "00143011";
    DicomTag.NumberOfFramesIntegrated = "00143012";
    DicomTag.DetectorTemperatureSequence = "00143020";
    DicomTag.SensorName = "00143022";
    DicomTag.HorizontalOffsetOfSensor = "00143024";
    DicomTag.VerticalOffsetOfSensor = "00143026";
    DicomTag.SensorTemperature = "00143028";
    DicomTag.DarkCurrentSequence = "00143040";
    DicomTag.DarkCurrentCounts = "00143050";
    DicomTag.GainCorrectionReferenceSequence = "00143060";
    DicomTag.AirCounts = "00143070";
    DicomTag.KVUsedInGainCalibration = "00143071";
    DicomTag.MAUsedInGainCalibration = "00143072";
    DicomTag.NumberOfFramesUsedForIntegration = "00143073";
    DicomTag.FilterMaterialUsedInGainCalibration = "00143074";
    DicomTag.FilterThicknessUsedInGainCalibration = "00143075";
    DicomTag.DateOfGainCalibration = "00143076";
    DicomTag.TimeOfGainCalibration = "00143077";
    DicomTag.BadPixelImage = "00143080";
    DicomTag.CalibrationNotes = "00143099";
    DicomTag.PulserEquipmentSequence = "00144002";
    DicomTag.PulserType = "00144004";
    DicomTag.PulserNotes = "00144006";
    DicomTag.ReceiverEquipmentSequence = "00144008";
    DicomTag.AmplifierType = "0014400A";
    DicomTag.ReceiverNotes = "0014400C";
    DicomTag.PreAmplifierEquipmentSequence = "0014400E";
    DicomTag.PreAmplifierNotes = "0014400F";
    DicomTag.TransmitTransducerSequence = "00144010";
    DicomTag.ReceiveTransducerSequence = "00144011";
    DicomTag.NumberOfElements = "00144012";
    DicomTag.ElementShape = "00144013";
    DicomTag.ElementDimensionA = "00144014";
    DicomTag.ElementDimensionB = "00144015";
    DicomTag.ElementPitchA = "00144016";
    DicomTag.MeasuredBeamDimensionA = "00144017";
    DicomTag.MeasuredBeamDimensionB = "00144018";
    DicomTag.LocationOfMeasuredBeamDiameter = "00144019";
    DicomTag.NominalFrequency = "0014401A";
    DicomTag.MeasuredCenterFrequency = "0014401B";
    DicomTag.MeasuredBandwidth = "0014401C";
    DicomTag.ElementPitchB = "0014401D";
    DicomTag.PulserSettingsSequence = "00144020";
    DicomTag.PulseWidth = "00144022";
    DicomTag.ExcitationFrequency = "00144024";
    DicomTag.ModulationType = "00144026";
    DicomTag.Damping = "00144028";
    DicomTag.ReceiverSettingsSequence = "00144030";
    DicomTag.AcquiredSoundpathLength = "00144031";
    DicomTag.AcquisitionCompressionType = "00144032";
    DicomTag.AcquisitionSampleSize = "00144033";
    DicomTag.RectifierSmoothing = "00144034";
    DicomTag.DACSequence = "00144035";
    DicomTag.DACType = "00144036";
    DicomTag.DACGainPoints = "00144038";
    DicomTag.DACTimePoints = "0014403A";
    DicomTag.DACAmplitude = "0014403C";
    DicomTag.PreAmplifierSettingsSequence = "00144040";
    DicomTag.TransmitTransducerSettingsSequence = "00144050";
    DicomTag.ReceiveTransducerSettingsSequence = "00144051";
    DicomTag.IncidentAngle = "00144052";
    DicomTag.CouplingTechnique = "00144054";
    DicomTag.CouplingMedium = "00144056";
    DicomTag.CouplingVelocity = "00144057";
    DicomTag.ProbeCenterLocationX = "00144058";
    DicomTag.ProbeCenterLocationZ = "00144059";
    DicomTag.SoundPathLength = "0014405A";
    DicomTag.DelayLawIdentifier = "0014405C";
    DicomTag.GateSettingsSequence = "00144060";
    DicomTag.GateThreshold = "00144062";
    DicomTag.VelocityOfSound = "00144064";
    DicomTag.CalibrationSettingsSequence = "00144070";
    DicomTag.CalibrationProcedure = "00144072";
    DicomTag.ProcedureVersion = "00144074";
    DicomTag.ProcedureCreationDate = "00144076";
    DicomTag.ProcedureExpirationDate = "00144078";
    DicomTag.ProcedureLastModifiedDate = "0014407A";
    DicomTag.CalibrationTime = "0014407C";
    DicomTag.CalibrationDate = "0014407E";
    DicomTag.ProbeDriveEquipmentSequence = "00144080";
    DicomTag.DriveType = "00144081";
    DicomTag.ProbeDriveNotes = "00144082";
    DicomTag.DriveProbeSequence = "00144083";
    DicomTag.ProbeInductance = "00144084";
    DicomTag.ProbeResistance = "00144085";
    DicomTag.ReceiveProbeSequence = "00144086";
    DicomTag.ProbeDriveSettingsSequence = "00144087";
    DicomTag.BridgeResistors = "00144088";
    DicomTag.ProbeOrientationAngle = "00144089";
    DicomTag.UserSelectedGainY = "0014408B";
    DicomTag.UserSelectedPhase = "0014408C";
    DicomTag.UserSelectedOffsetX = "0014408D";
    DicomTag.UserSelectedOffsetY = "0014408E";
    DicomTag.ChannelSettingsSequence = "00144091";
    DicomTag.ChannelThreshold = "00144092";
    DicomTag.ScannerSettingsSequence = "0014409A";
    DicomTag.ScanProcedure = "0014409B";
    DicomTag.TranslationRateX = "0014409C";
    DicomTag.TranslationRateY = "0014409D";
    DicomTag.ChannelOverlap = "0014409F";
    DicomTag.ImageQualityIndicatorType = "001440A0";
    DicomTag.ImageQualityIndicatorMaterial = "001440A1";
    DicomTag.ImageQualityIndicatorSize = "001440A2";
    DicomTag.LINACEnergy = "00145002";
    DicomTag.LINACOutput = "00145004";
    DicomTag.ActiveAperture = "00145100";
    DicomTag.TotalAperture = "00145101";
    DicomTag.ApertureElevation = "00145102";
    DicomTag.MainLobeAngle = "00145103";
    DicomTag.MainRoofAngle = "00145104";
    DicomTag.ConnectorType = "00145105";
    DicomTag.WedgeModelNumber = "00145106";
    DicomTag.WedgeAngleFloat = "00145107";
    DicomTag.WedgeRoofAngle = "00145108";
    DicomTag.WedgeElement1Position = "00145109";
    DicomTag.WedgeMaterialVelocity = "0014510A";
    DicomTag.WedgeMaterial = "0014510B";
    DicomTag.WedgeOffsetZ = "0014510C";
    DicomTag.WedgeOriginOffsetX = "0014510D";
    DicomTag.WedgeTimeDelay = "0014510E";
    DicomTag.WedgeName = "0014510F";
    DicomTag.WedgeManufacturerName = "00145110";
    DicomTag.WedgeDescription = "00145111";
    DicomTag.NominalBeamAngle = "00145112";
    DicomTag.WedgeOffsetX = "00145113";
    DicomTag.WedgeOffsetY = "00145114";
    DicomTag.WedgeTotalLength = "00145115";
    DicomTag.WedgeInContactLength = "00145116";
    DicomTag.WedgeFrontGap = "00145117";
    DicomTag.WedgeTotalHeight = "00145118";
    DicomTag.WedgeFrontHeight = "00145119";
    DicomTag.WedgeRearHeight = "0014511A";
    DicomTag.WedgeTotalWidth = "0014511B";
    DicomTag.WedgeInContactWidth = "0014511C";
    DicomTag.WedgeChamferHeight = "0014511D";
    DicomTag.WedgeCurve = "0014511E";
    DicomTag.RadiusAlongTheWedge = "0014511F";
    // *****************************************************************************************************************************
    // *** 0018
    // *****************************************************************************************************************************
    DicomTag.ContrastBolusAgent = "00180010";
    DicomTag.ContrastBolusAgentSequence = "00180012";
    DicomTag.ContrastBolusT1Relaxivity = "00180013";
    DicomTag.ContrastBolusAdministrationRouteSequence = "00180014";
    DicomTag.BodyPartExamined = "00180015";
    DicomTag.ScanningSequence = "00180020";
    DicomTag.SequenceVariant = "00180021";
    DicomTag.ScanOptions = "00180022";
    DicomTag.MRAcquisitionType = "00180023";
    DicomTag.SequenceName = "00180024";
    DicomTag.AngioFlag = "00180025";
    DicomTag.InterventionDrugInformationSequence = "00180026";
    DicomTag.InterventionDrugStopTime = "00180027";
    DicomTag.InterventionDrugDose = "00180028";
    DicomTag.InterventionDrugCodeSequence = "00180029";
    DicomTag.AdditionalDrugSequence = "0018002A";
    DicomTag.Radionuclide = "00180030"; // Retired
    DicomTag.Radiopharmaceutical = "00180031";
    DicomTag.EnergyWindowCenterline = "00180032"; // Retired
    DicomTag.EnergyWindowTotalWidth = "00180033"; // Retired
    DicomTag.InterventionDrugName = "00180034";
    DicomTag.InterventionDrugStartTime = "00180035";
    DicomTag.InterventionSequence = "00180036";
    DicomTag.TherapyType = "00180037"; // Retired
    DicomTag.InterventionStatus = "00180038";
    DicomTag.TherapyDescription = "00180039"; // Retired
    DicomTag.InterventionDescription = "0018003A";
    DicomTag.CineRate = "00180040";
    DicomTag.InitialCineRunState = "00180042";
    DicomTag.SliceThickness = "00180050";
    DicomTag.KVP = "00180060";
    DicomTag.CountsAccumulated = "00180070";
    DicomTag.AcquisitionTerminationCondition = "00180071";
    DicomTag.EffectiveDuration = "00180072";
    DicomTag.AcquisitionStartCondition = "00180073";
    DicomTag.AcquisitionStartConditionData = "00180074";
    DicomTag.AcquisitionTerminationConditionData = "00180075";
    DicomTag.RepetitionTime = "00180080";
    DicomTag.EchoTime = "00180081";
    DicomTag.InversionTime = "00180082";
    DicomTag.NumberOfAverages = "00180083";
    DicomTag.ImagingFrequency = "00180084";
    DicomTag.ImagedNucleus = "00180085";
    DicomTag.EchoNumber = "00180086";
    DicomTag.MagneticFieldStrength = "00180087";
    DicomTag.SpacingBetweenSlices = "00180088";
    DicomTag.NumberOfPhaseEncodingSteps = "00180089";
    DicomTag.DataCollectionDiameter = "00180090";
    DicomTag.EchoTrainLength = "00180091";
    DicomTag.PercentSampling = "00180093";
    DicomTag.PercentPhaseFieldOfView = "00180094";
    DicomTag.PixelBandwidth = "00180095";
    DicomTag.DeviceSerialNumber = "00181000";
    DicomTag.DeviceUID = "00181002";
    DicomTag.DeviceID = "00181003";
    DicomTag.PlateID = "00181004";
    DicomTag.GeneratorID = "00181005";
    DicomTag.GridID = "00181006";
    DicomTag.CassetteID = "00181007";
    DicomTag.GantryID = "00181008";
    DicomTag.SecondaryCaptureDeviceID = "00181010";
    DicomTag.HardcopyCreationDeviceID = "00181011"; // Retired
    DicomTag.DateOfSecondaryCapture = "00181012";
    DicomTag.TimeOfSecondaryCapture = "00181014";
    DicomTag.SecondaryCaptureDeviceManufacturer = "00181016";
    DicomTag.HardcopyDeviceManufacturer = "00181017"; // Retired
    DicomTag.SecondaryCaptureDeviceManufacturerModelName = "00181018";
    DicomTag.SecondaryCaptureDeviceSoftwareVersions = "00181019";
    DicomTag.HardcopyDeviceSoftwareVersion = "0018101A"; // Retired
    DicomTag.HardcopyDeviceManufacturerModelName = "0018101B"; // Retired
    DicomTag.SoftwareVersion = "00181020";
    DicomTag.VideoImageFormatAcquired = "00181022";
    DicomTag.DigitalImageFormatAcquired = "00181023";
    DicomTag.ProtocolName = "00181030";
    DicomTag.ContrastBolusRoute = "00181040";
    DicomTag.ContrastBolusVolume = "00181041";
    DicomTag.ContrastBolusStartTime = "00181042";
    DicomTag.ContrastBolusStopTime = "00181043";
    DicomTag.ContrastBolusTotalDose = "00181044";
    DicomTag.SyringeCounts = "00181045";
    DicomTag.ContrastFlowRate = "00181046";
    DicomTag.ContrastFlowDuration = "00181047";
    DicomTag.ContrastBolusIngredient = "00181048";
    DicomTag.ContrastBolusIngredientConcentration = "00181049";
    DicomTag.SpatialResolution = "00181050";
    DicomTag.TriggerTime = "00181060";
    DicomTag.TriggerSourceOrType = "00181061";
    DicomTag.NominalInterval = "00181062";
    DicomTag.FrameTime = "00181063";
    DicomTag.CardiacFramingType = "00181064";
    DicomTag.FrameTimeVector = "00181065";
    DicomTag.FrameDelay = "00181066";
    DicomTag.ImageTriggerDelay = "00181067";
    DicomTag.MultiplexGroupTimeOffset = "00181068";
    DicomTag.TriggerTimeOffset = "00181069";
    DicomTag.SynchronizationTrigger = "0018106A";
    DicomTag.SynchronizationChannel = "0018106C";
    DicomTag.TriggerSamplePosition = "0018106E";
    DicomTag.RadiopharmaceuticalRoute = "00181070";
    DicomTag.RadiopharmaceuticalVolume = "00181071";
    DicomTag.RadiopharmaceuticalStartTime = "00181072";
    DicomTag.RadiopharmaceuticalStopTime = "00181073";
    DicomTag.RadionuclideTotalDose = "00181074";
    DicomTag.RadionuclideHalfLife = "00181075";
    DicomTag.RadionuclidePositronFraction = "00181076";
    DicomTag.RadiopharmaceuticalSpecificActivity = "00181077";
    DicomTag.RadiopharmaceuticalStartDateTime = "00181078";
    DicomTag.RadiopharmaceuticalStopDateTime = "00181079";
    DicomTag.BeatRejectionFlag = "00181080";
    DicomTag.LowRRValue = "00181081";
    DicomTag.HighRRValue = "00181082";
    DicomTag.IntervalsAcquired = "00181083";
    DicomTag.IntervalsRejected = "00181084";
    DicomTag.PVCRejection = "00181085";
    DicomTag.SkipBeats = "00181086";
    DicomTag.HeartRate = "00181088";
    DicomTag.CardiacNumberOfImages = "00181090";
    DicomTag.TriggerWindow = "00181094";
    DicomTag.ReconstructionDiameter = "00181100";
    DicomTag.DistanceSourceToDetector = "00181110";
    DicomTag.DistanceSourceToPatient = "00181111";
    DicomTag.EstimatedRadiographicMagnificationFactor = "00181114";
    DicomTag.GantryDetectorTilt = "00181120";
    DicomTag.GantryDetectorSlew = "00181121";
    DicomTag.TableHeight = "00181130";
    DicomTag.TableTraverse = "00181131";
    DicomTag.TableMotion = "00181134";
    DicomTag.TableVerticalIncrement = "00181135";
    DicomTag.TableLateralIncrement = "00181136";
    DicomTag.TableLongitudinalIncrement = "00181137";
    DicomTag.TableAngle = "00181138";
    DicomTag.TableType = "0018113A";
    DicomTag.RotationDirection = "00181140";
    DicomTag.AngularPosition = "00181141"; // Retired
    DicomTag.RadialPosition = "00181142";
    DicomTag.ScanArc = "00181143";
    DicomTag.AngularStep = "00181144";
    DicomTag.CenterOfRotationOffset = "00181145";
    DicomTag.RotationOffset = "00181146"; // Retired
    DicomTag.FieldOfViewShape = "00181147";
    DicomTag.FieldOfViewDimension = "00181149";
    DicomTag.ExposureTime = "00181150";
    DicomTag.XRayTubeCurrent = "00181151";
    DicomTag.Exposure = "00181152";
    DicomTag.ExposureInUAs = "00181153";
    DicomTag.AveragePulseWidth = "00181154";
    DicomTag.RadiationSetting = "00181155";
    DicomTag.RectificationType = "00181156";
    DicomTag.RadiationMode = "0018115A";
    DicomTag.ImageAndFluoroscopyAreaDoseProduct = "0018115E";
    DicomTag.FilterType = "00181160";
    DicomTag.TypeOfFilters = "00181161";
    DicomTag.IntensifierSize = "00181162";
    DicomTag.ImagerPixelSpacing = "00181164";
    DicomTag.Grid = "00181166";
    DicomTag.GeneratorPower = "00181170";
    DicomTag.CollimatorGridName = "00181180";
    DicomTag.CollimatorType = "00181181";
    DicomTag.FocalDistance = "00181182";
    DicomTag.XFocusCenter = "00181183";
    DicomTag.YFocusCenter = "00181184";
    DicomTag.FocalSpot = "00181190";
    DicomTag.AnodeTargetMaterial = "00181191";
    DicomTag.BodyPartThickness = "001811A0";
    DicomTag.CompressionForce = "001811A2";
    DicomTag.PaddleDescription = "001811A4";
    DicomTag.DateOfLastCalibration = "00181200";
    DicomTag.TimeOfLastCalibration = "00181201";
    DicomTag.DateTimeOfLastCalibration = "00181202";
    DicomTag.ConvolutionKernel = "00181210";
    DicomTag.UpperLowerPixelValues = "00181240"; // Retired
    DicomTag.ActualFrameDuration = "00181242";
    DicomTag.CountRate = "00181243";
    DicomTag.PreferredPlaybackSequencing = "00181244";
    DicomTag.ReceiveCoilName = "00181250";
    DicomTag.TransmitCoilName = "00181251";
    DicomTag.PlateType = "00181260";
    DicomTag.PhosphorType = "00181261";
    DicomTag.ScanVelocity = "00181300";
    DicomTag.WholeBodyTechnique = "00181301";
    DicomTag.ScanLength = "00181302";
    DicomTag.AcquisitionMatrix = "00181310";
    DicomTag.InPlanePhaseEncodingDirection = "00181312";
    DicomTag.FlipAngle = "00181314";
    DicomTag.VariableFlipAngleFlag = "00181315";
    DicomTag.SAR = "00181316";
    DicomTag.DBDt = "00181318";
    DicomTag.AcquisitionDeviceProcessingDescription = "00181400";
    DicomTag.AcquisitionDeviceProcessingCode = "00181401";
    DicomTag.CassetteOrientation = "00181402";
    DicomTag.CassetteSize = "00181403";
    DicomTag.ExposuresOnPlate = "00181404";
    DicomTag.RelativeXRayExposure = "00181405";
    DicomTag.ExposureIndex = "00181411";
    DicomTag.TargetExposureIndex = "00181412";
    DicomTag.DeviationIndex = "00181413";
    DicomTag.ColumnAngulation = "00181450";
    DicomTag.TomoLayerHeight = "00181460";
    DicomTag.TomoAngle = "00181470";
    DicomTag.TomoTime = "00181480";
    DicomTag.TomoType = "00181490";
    DicomTag.TomoClass = "00181491";
    DicomTag.NumberOfTomosynthesisSourceImages = "00181495";
    DicomTag.PositionerMotion = "00181500";
    DicomTag.PositionerType = "00181508";
    DicomTag.PositionerPrimaryAngle = "00181510";
    DicomTag.PositionerSecondaryAngle = "00181511";
    DicomTag.PositionerPrimaryAngleIncrement = "00181520";
    DicomTag.PositionerSecondaryAngleIncrement = "00181521";
    DicomTag.DetectorPrimaryAngle = "00181530";
    DicomTag.DetectorSecondaryAngle = "00181531";
    DicomTag.ShutterShape = "00181600";
    DicomTag.ShutterLeftVerticalEdge = "00181602";
    DicomTag.ShutterRightVerticalEdge = "00181604";
    DicomTag.ShutterUpperHorizontalEdge = "00181606";
    DicomTag.ShutterLowerHorizontalEdge = "00181608";
    DicomTag.CenterOfCircularShutter = "00181610";
    DicomTag.RadiusOfCircularShutter = "00181612";
    DicomTag.VerticesOfThePolygonalShutter = "00181620";
    DicomTag.ShutterPresentationValue = "00181622";
    DicomTag.ShutterOverlayGroup = "00181623";
    DicomTag.ShutterPresentationColorCIELabValue = "00181624";
    DicomTag.CollimatorShape = "00181700";
    DicomTag.CollimatorLeftVerticalEdge = "00181702";
    DicomTag.CollimatorRightVerticalEdge = "00181704";
    DicomTag.CollimatorUpperHorizontalEdge = "00181706";
    DicomTag.CollimatorLowerHorizontalEdge = "00181708";
    DicomTag.CenterOfCircularCollimator = "00181710";
    DicomTag.RadiusOfCircularCollimator = "00181712";
    DicomTag.VerticesOfThePolygonalCollimator = "00181720";
    DicomTag.AcquisitionTimeSynchronized = "00181800";
    DicomTag.TimeSource = "00181801";
    DicomTag.TimeDistributionProtocol = "00181802";
    DicomTag.NTPSourceAddress = "00181803";
    DicomTag.PageNumberVector = "00182001";
    DicomTag.FrameLabelVector = "00182002";
    DicomTag.FramePrimaryAngleVector = "00182003";
    DicomTag.FrameSecondaryAngleVector = "00182004";
    DicomTag.SliceLocationVector = "00182005";
    DicomTag.DisplayWindowLabelVector = "00182006";
    DicomTag.NominalScannedPixelSpacing = "00182010";
    DicomTag.DigitizingDeviceTransportDirection = "00182020";
    DicomTag.RotationOfScannedFilm = "00182030";
    DicomTag.BiopsyTargetSequence = "00182041";
    DicomTag.TargetUID = "00182042";
    DicomTag.LocalizingCursorPosition = "00182043";
    DicomTag.CalculatedTargetPosition = "00182044";
    DicomTag.TargetLabel = "00182045";
    DicomTag.DisplayedZValue = "00182046";
    DicomTag.IVUSAcquisition = "00183100";
    DicomTag.IVUSPullbackRate = "00183101";
    DicomTag.IVUSGatedRate = "00183102";
    DicomTag.IVUSPullbackStartFrameNumber = "00183103";
    DicomTag.IVUSPullbackStopFrameNumber = "00183104";
    DicomTag.LesionNumber = "00183105";
    DicomTag.AcquisitionComments = "00184000"; // Retired
    DicomTag.OutputPower = "00185000";
    DicomTag.TransducerData = "00185010";
    DicomTag.FocusDepth = "00185012";
    DicomTag.ProcessingFunction = "00185020";
    DicomTag.PostprocessingFunction = "00185021"; // Retired
    DicomTag.MechanicalIndex = "00185022";
    DicomTag.BoneThermalIndex = "00185024";
    DicomTag.CranialThermalIndex = "00185026";
    DicomTag.SoftTissueThermalIndex = "00185027";
    DicomTag.SoftTissueFocusThermalIndex = "00185028";
    DicomTag.SoftTissueSurfaceThermalIndex = "00185029";
    DicomTag.DynamicRange = "00185030"; // Retired
    DicomTag.TotalGain = "00185040"; // Retired
    DicomTag.DepthOfScanField = "00185050";
    DicomTag.PatientPosition = "00185100";
    DicomTag.ViewPosition = "00185101";
    DicomTag.ProjectionEponymousNameCodeSequence = "00185104";
    DicomTag.ImageTransformationMatrix = "00185210"; // Retired
    DicomTag.ImageTranslationVector = "00185212"; // Retired
    DicomTag.Sensitivity = "00186000";
    DicomTag.SequenceOfUltrasoundRegions = "00186011";
    DicomTag.RegionSpatialFormat = "00186012";
    DicomTag.RegionDataType = "00186014";
    DicomTag.RegionFlags = "00186016";
    DicomTag.RegionLocationMinX0 = "00186018";
    DicomTag.RegionLocationMinY0 = "0018601A";
    DicomTag.RegionLocationMaxX1 = "0018601C";
    DicomTag.RegionLocationMaxY1 = "0018601E";
    DicomTag.ReferencePixelX0 = "00186020";
    DicomTag.ReferencePixelY0 = "00186022";
    DicomTag.PhysicalUnitsXDirection = "00186024";
    DicomTag.PhysicalUnitsYDirection = "00186026";
    DicomTag.ReferencePixelPhysicalValueX = "00186028";
    DicomTag.ReferencePixelPhysicalValueY = "0018602A";
    DicomTag.PhysicalDeltaX = "0018602C";
    DicomTag.PhysicalDeltaY = "0018602E";
    DicomTag.TransducerFrequency = "00186030";
    DicomTag.TransducerType = "00186031";
    DicomTag.PulseRepetitionFrequency = "00186032";
    DicomTag.DopplerCorrectionAngle = "00186034";
    DicomTag.SteeringAngle = "00186036";
    DicomTag.DopplerSampleVolumeXPositionRetired = "00186038"; // Retired
    DicomTag.DopplerSampleVolumeXPosition = "00186039";
    DicomTag.DopplerSampleVolumeYPositionRetired = "0018603A"; // Retired
    DicomTag.DopplerSampleVolumeYPosition = "0018603B";
    DicomTag.TMLinePositionX0Retired = "0018603C"; // Retired
    DicomTag.TMLinePositionX0 = "0018603D";
    DicomTag.TMLinePositionY0Retired = "0018603E"; // Retired
    DicomTag.TMLinePositionY0 = "0018603F";
    DicomTag.TMLinePositionX1Retired = "00186040"; // Retired
    DicomTag.TMLinePositionX1 = "00186041";
    DicomTag.TMLinePositionY1Retired = "00186042"; // Retired
    DicomTag.TMLinePositionY1 = "00186043";
    DicomTag.PixelComponentOrganization = "00186044";
    DicomTag.PixelComponentMask = "00186046";
    DicomTag.PixelComponentRangeStart = "00186048";
    DicomTag.PixelComponentRangeStop = "0018604A";
    DicomTag.PixelComponentPhysicalUnits = "0018604C";
    DicomTag.PixelComponentDataType = "0018604E";
    DicomTag.NumberOfTableBreakPoints = "00186050";
    DicomTag.TableOfXBreakPoints = "00186052";
    DicomTag.TableOfYBreakPoints = "00186054";
    DicomTag.NumberOfTableEntries = "00186056";
    DicomTag.TableOfPixelValues = "00186058";
    DicomTag.TableOfParameterValues = "0018605A";
    DicomTag.RWaveTimeVector = "00186060";
    DicomTag.DetectorConditionsNominalFlag = "00187000";
    DicomTag.DetectorTemperature = "00187001";
    DicomTag.DetectorType = "00187004";
    DicomTag.DetectorConfiguration = "00187005";
    DicomTag.DetectorDescription = "00187006";
    DicomTag.DetectorMode = "00187008";
    DicomTag.DetectorID = "0018700A";
    DicomTag.DateOfLastDetectorCalibration = "0018700C";
    DicomTag.TimeOfLastDetectorCalibration = "0018700E";
    DicomTag.ExposuresOnDetectorSinceLastCalibration = "00187010";
    DicomTag.ExposuresOnDetectorSinceManufactured = "00187011";
    DicomTag.DetectorTimeSinceLastExposure = "00187012";
    DicomTag.DetectorActiveTime = "00187014";
    DicomTag.DetectorActivationOffsetFromExposure = "00187016";
    DicomTag.DetectorBinning = "0018701A";
    DicomTag.DetectorElementPhysicalSize = "00187020";
    DicomTag.DetectorElementSpacing = "00187022";
    DicomTag.DetectorActiveShape = "00187024";
    DicomTag.DetectorActiveDimension = "00187026";
    DicomTag.DetectorActiveOrigin = "00187028";
    DicomTag.DetectorManufacturerName = "0018702A";
    DicomTag.DetectorManufacturerModelName = "0018702B";
    DicomTag.FieldOfViewOrigin = "00187030";
    DicomTag.FieldOfViewRotation = "00187032";
    DicomTag.FieldOfViewHorizontalFlip = "00187034";
    DicomTag.PixelDataAreaOriginRelativeToFOV = "00187036";
    DicomTag.PixelDataAreaRotationAngleRelativeToFOV = "00187038";
    DicomTag.GridAbsorbingMaterial = "00187040";
    DicomTag.GridSpacingMaterial = "00187041";
    DicomTag.GridThickness = "00187042";
    DicomTag.GridPitch = "00187044";
    DicomTag.GridAspectRatio = "00187046";
    DicomTag.GridPeriod = "00187048";
    DicomTag.GridFocalDistance = "0018704C";
    DicomTag.FilterMaterial = "00187050";
    DicomTag.FilterThicknessMinimum = "00187052";
    DicomTag.FilterThicknessMaximum = "00187054";
    DicomTag.FilterBeamPathLengthMinimum = "00187056";
    DicomTag.FilterBeamPathLengthMaximum = "00187058";
    DicomTag.ExposureControlMode = "00187060";
    DicomTag.ExposureControlModeDescription = "00187062";
    DicomTag.ExposureStatus = "00187064";
    DicomTag.PhototimerSetting = "00187065";
    DicomTag.ExposureTimeInUS = "00188150";
    DicomTag.XRayTubeCurrentInUA = "00188151";
    DicomTag.ContentQualification = "00189004";
    DicomTag.PulseSequenceName = "00189005";
    DicomTag.MRImagingModifierSequence = "00189006";
    DicomTag.EchoPulseSequence = "00189008";
    DicomTag.InversionRecovery = "00189009";
    DicomTag.FlowCompensation = "00189010";
    DicomTag.MultipleSpinEcho = "00189011";
    DicomTag.MultiPlanarExcitation = "00189012";
    DicomTag.PhaseContrast = "00189014";
    DicomTag.TimeOfFlightContrast = "00189015";
    DicomTag.Spoiling = "00189016";
    DicomTag.SteadyStatePulseSequence = "00189017";
    DicomTag.EchoPlanarPulseSequence = "00189018";
    DicomTag.TagAngleFirstAxis = "00189019";
    DicomTag.MagnetizationTransfer = "00189020";
    DicomTag.T2Preparation = "00189021";
    DicomTag.BloodSignalNulling = "00189022";
    DicomTag.SaturationRecovery = "00189024";
    DicomTag.SpectrallySelectedSuppression = "00189025";
    DicomTag.SpectrallySelectedExcitation = "00189026";
    DicomTag.SpatialPreSaturation = "00189027";
    DicomTag.Tagging = "00189028";
    DicomTag.OversamplingPhase = "00189029";
    DicomTag.TagSpacingFirstDimension = "00189030";
    DicomTag.GeometryOfKSpaceTraversal = "00189032";
    DicomTag.SegmentedKSpaceTraversal = "00189033";
    DicomTag.RectilinearPhaseEncodeReordering = "00189034";
    DicomTag.TagThickness = "00189035";
    DicomTag.PartialFourierDirection = "00189036";
    DicomTag.CardiacSynchronizationTechnique = "00189037";
    DicomTag.ReceiveCoilManufacturerName = "00189041";
    DicomTag.MRReceiveCoilSequence = "00189042";
    DicomTag.ReceiveCoilType = "00189043";
    DicomTag.QuadratureReceiveCoil = "00189044";
    DicomTag.MultiCoilDefinitionSequence = "00189045";
    DicomTag.MultiCoilConfiguration = "00189046";
    DicomTag.MultiCoilElementName = "00189047";
    DicomTag.MultiCoilElementUsed = "00189048";
    DicomTag.MRTransmitCoilSequence = "00189049";
    DicomTag.TransmitCoilManufacturerName = "00189050";
    DicomTag.TransmitCoilType = "00189051";
    DicomTag.SpectralWidth = "00189052";
    DicomTag.ChemicalShiftReference = "00189053";
    DicomTag.VolumeLocalizationTechnique = "00189054";
    DicomTag.MRAcquisitionFrequencyEncodingSteps = "00189058";
    DicomTag.DeCoupling = "00189059";
    DicomTag.DeCoupledNucleus = "00189060";
    DicomTag.DeCouplingFrequency = "00189061";
    DicomTag.DeCouplingMethod = "00189062";
    DicomTag.DeCouplingChemicalShiftReference = "00189063";
    DicomTag.KSpaceFiltering = "00189064";
    DicomTag.TimeDomainFiltering = "00189065";
    DicomTag.NumberOfZeroFills = "00189066";
    DicomTag.BaselineCorrection = "00189067";
    DicomTag.ParallelReductionFactorInPlane = "00189069";
    DicomTag.CardiacRRIntervalSpecified = "00189070";
    DicomTag.AcquisitionDuration = "00189073";
    DicomTag.FrameAcquisitionDateTime = "00189074";
    DicomTag.DiffusionDirectionality = "00189075";
    DicomTag.DiffusionGradientDirectionSequence = "00189076";
    DicomTag.ParallelAcquisition = "00189077";
    DicomTag.ParallelAcquisitionTechnique = "00189078";
    DicomTag.InversionTimes = "00189079";
    DicomTag.MetaboliteMapDescription = "00189080";
    DicomTag.PartialFourier = "00189081";
    DicomTag.EffectiveEchoTime = "00189082";
    DicomTag.MetaboliteMapCodeSequence = "00189083";
    DicomTag.ChemicalShiftSequence = "00189084";
    DicomTag.CardiacSignalSource = "00189085";
    DicomTag.DiffusionBValue = "00189087";
    DicomTag.DiffusionGradientOrientation = "00189089";
    DicomTag.VelocityEncodingDirection = "00189090";
    DicomTag.VelocityEncodingMinimumValue = "00189091";
    DicomTag.VelocityEncodingAcquisitionSequence = "00189092";
    DicomTag.NumberOfKSpaceTrajectories = "00189093";
    DicomTag.CoverageOfKSpace = "00189094";
    DicomTag.SpectroscopyAcquisitionPhaseRows = "00189095";
    DicomTag.ParallelReductionFactorInPlaneRetired = "00189096"; // Retired
    DicomTag.TransmitterFrequency = "00189098";
    DicomTag.ResonantNucleus = "00189100";
    DicomTag.FrequencyCorrection = "00189101";
    DicomTag.MRSpectroscopyFOVGeometrySequence = "00189103";
    DicomTag.SlabThickness = "00189104";
    DicomTag.SlabOrientation = "00189105";
    DicomTag.MidSlabPosition = "00189106";
    DicomTag.MRSpatialSaturationSequence = "00189107";
    DicomTag.MRTimingAndRelatedParametersSequence = "00189112";
    DicomTag.MREchoSequence = "00189114";
    DicomTag.MRModifierSequence = "00189115";
    DicomTag.MRDiffusionSequence = "00189117";
    DicomTag.CardiacSynchronizationSequence = "00189118";
    DicomTag.MRAveragesSequence = "00189119";
    DicomTag.MRFOVGeometrySequence = "00189125";
    DicomTag.VolumeLocalizationSequence = "00189126";
    DicomTag.SpectroscopyAcquisitionDataColumns = "00189127";
    DicomTag.DiffusionAnisotropyType = "00189147";
    DicomTag.FrameReferenceDateTime = "00189151";
    DicomTag.MRMetaboliteMapSequence = "00189152";
    DicomTag.ParallelReductionFactorOutOfPlane = "00189155";
    DicomTag.SpectroscopyAcquisitionOutOfPlanePhaseSteps = "00189159";
    DicomTag.BulkMotionStatus = "00189166"; // Retired
    DicomTag.ParallelReductionFactorSecondInPlane = "00189168";
    DicomTag.CardiacBeatRejectionTechnique = "00189169";
    DicomTag.RespiratoryMotionCompensationTechnique = "00189170";
    DicomTag.RespiratorySignalSource = "00189171";
    DicomTag.BulkMotionCompensationTechnique = "00189172";
    DicomTag.BulkMotionSignalSource = "00189173";
    DicomTag.ApplicableSafetyStandardAgency = "00189174";
    DicomTag.ApplicableSafetyStandardDescription = "00189175";
    DicomTag.OperatingModeSequence = "00189176";
    DicomTag.OperatingModeType = "00189177";
    DicomTag.OperatingMode = "00189178";
    DicomTag.SpecificAbsorptionRateDefinition = "00189179";
    DicomTag.GradientOutputType = "00189180";
    DicomTag.SpecificAbsorptionRateValue = "00189181";
    DicomTag.GradientOutput = "00189182";
    DicomTag.FlowCompensationDirection = "00189183";
    DicomTag.TaggingDelay = "00189184";
    DicomTag.RespiratoryMotionCompensationTechniqueDescription = "00189185";
    DicomTag.RespiratorySignalSourceID = "00189186";
    DicomTag.ChemicalShiftMinimumIntegrationLimitInHz = "00189195"; // Retired
    DicomTag.ChemicalShiftMaximumIntegrationLimitInHz = "00189196"; // Retired
    DicomTag.MRVelocityEncodingSequence = "00189197";
    DicomTag.FirstOrderPhaseCorrection = "00189198";
    DicomTag.WaterReferencedPhaseCorrection = "00189199";
    DicomTag.MRSpectroscopyAcquisitionType = "00189200";
    DicomTag.RespiratoryCyclePosition = "00189214";
    DicomTag.VelocityEncodingMaximumValue = "00189217";
    DicomTag.TagSpacingSecondDimension = "00189218";
    DicomTag.TagAngleSecondAxis = "00189219";
    DicomTag.FrameAcquisitionDuration = "00189220";
    DicomTag.MRImageFrameTypeSequence = "00189226";
    DicomTag.MRSpectroscopyFrameTypeSequence = "00189227";
    DicomTag.MRAcquisitionPhaseEncodingStepsInPlane = "00189231";
    DicomTag.MRAcquisitionPhaseEncodingStepsOutOfPlane = "00189232";
    DicomTag.SpectroscopyAcquisitionPhaseColumns = "00189234";
    DicomTag.CardiacCyclePosition = "00189236";
    DicomTag.SpecificAbsorptionRateSequence = "00189239";
    DicomTag.RFEchoTrainLength = "00189240";
    DicomTag.GradientEchoTrainLength = "00189241";
    DicomTag.ArterialSpinLabelingContrast = "00189250";
    DicomTag.MRArterialSpinLabelingSequence = "00189251";
    DicomTag.ASLTechniqueDescription = "00189252";
    DicomTag.ASLSlabNumber = "00189253";
    DicomTag.ASLSlabThickness = "00189254";
    DicomTag.ASLSlabOrientation = "00189255";
    DicomTag.ASLMidSlabPosition = "00189256";
    DicomTag.ASLContext = "00189257";
    DicomTag.ASLPulseTrainDuration = "00189258";
    DicomTag.ASLCrusherFlag = "00189259";
    DicomTag.ASLCrusherFlowLimit = "0018925A";
    DicomTag.ASLCrusherDescription = "0018925B";
    DicomTag.ASLBolusCutOffFlag = "0018925C";
    DicomTag.ASLBolusCutOffTimingSequence = "0018925D";
    DicomTag.ASLBolusCutOffTechnique = "0018925E";
    DicomTag.ASLBolusCutOffDelayTime = "0018925F";
    DicomTag.ASLSlabSequence = "00189260";
    DicomTag.ChemicalShiftMinimumIntegrationLimitInPpm = "00189295";
    DicomTag.ChemicalShiftMaximumIntegrationLimitInPpm = "00189296";
    DicomTag.WaterReferenceAcquisition = "00189297";
    DicomTag.EchoPeakPosition = "00189298";
    DicomTag.CTAcquisitionTypeSequence = "00189301";
    DicomTag.AcquisitionType = "00189302";
    DicomTag.TubeAngle = "00189303";
    DicomTag.CTAcquisitionDetailsSequence = "00189304";
    DicomTag.RevolutionTime = "00189305";
    DicomTag.SingleCollimationWidth = "00189306";
    DicomTag.TotalCollimationWidth = "00189307";
    DicomTag.CTTableDynamicsSequence = "00189308";
    DicomTag.TableSpeed = "00189309";
    DicomTag.TableFeedPerRotation = "00189310";
    DicomTag.SpiralPitchFactor = "00189311";
    DicomTag.CTGeometrySequence = "00189312";
    DicomTag.DataCollectionCenterPatient = "00189313";
    DicomTag.CTReconstructionSequence = "00189314";
    DicomTag.ReconstructionAlgorithm = "00189315";
    DicomTag.ConvolutionKernelGroup = "00189316";
    DicomTag.ReconstructionFieldOfView = "00189317";
    DicomTag.ReconstructionTargetCenterPatient = "00189318";
    DicomTag.ReconstructionAngle = "00189319";
    DicomTag.ImageFilter = "00189320";
    DicomTag.CTExposureSequence = "00189321";
    DicomTag.ReconstructionPixelSpacing = "00189322";
    DicomTag.ExposureModulationType = "00189323";
    DicomTag.EstimatedDoseSaving = "00189324";
    DicomTag.CTXRayDetailsSequence = "00189325";
    DicomTag.CTPositionSequence = "00189326";
    DicomTag.TablePosition = "00189327";
    DicomTag.ExposureTimeInMs = "00189328";
    DicomTag.CTImageFrameTypeSequence = "00189329";
    DicomTag.XRayTubeCurrentInMA = "00189330";
    DicomTag.ExposureInMAs = "00189332";
    DicomTag.ConstantVolumeFlag = "00189333";
    DicomTag.FluoroscopyFlag = "00189334";
    DicomTag.DistanceSourceToDataCollectionCenter = "00189335";
    DicomTag.ContrastBolusAgentNumber = "00189337";
    DicomTag.ContrastBolusIngredientCodeSequence = "00189338";
    DicomTag.ContrastAdministrationProfileSequence = "00189340";
    DicomTag.ContrastBolusUsageSequence = "00189341";
    DicomTag.ContrastBolusAgentAdministered = "00189342";
    DicomTag.ContrastBolusAgentDetected = "00189343";
    DicomTag.ContrastBolusAgentPhase = "00189344";
    DicomTag.CTDIvol = "00189345";
    DicomTag.CTDIPhantomTypeCodeSequence = "00189346";
    DicomTag.CalciumScoringMassFactorPatient = "00189351";
    DicomTag.CalciumScoringMassFactorDevice = "00189352";
    DicomTag.EnergyWeightingFactor = "00189353";
    DicomTag.CTAdditionalXRaySourceSequence = "00189360";
    DicomTag.ProjectionPixelCalibrationSequence = "00189401";
    DicomTag.DistanceSourceToIsocenter = "00189402";
    DicomTag.DistanceObjectToTableTop = "00189403";
    DicomTag.ObjectPixelSpacingInCenterOfBeam = "00189404";
    DicomTag.PositionerPositionSequence = "00189405";
    DicomTag.TablePositionSequence = "00189406";
    DicomTag.CollimatorShapeSequence = "00189407";
    DicomTag.PlanesInAcquisition = "00189410";
    DicomTag.XAXRFFrameCharacteristicsSequence = "00189412";
    DicomTag.FrameAcquisitionSequence = "00189417";
    DicomTag.XRayReceptorType = "00189420";
    DicomTag.AcquisitionProtocolName = "00189423";
    DicomTag.AcquisitionProtocolDescription = "00189424";
    DicomTag.ContrastBolusIngredientOpaque = "00189425";
    DicomTag.DistanceReceptorPlaneToDetectorHousing = "00189426";
    DicomTag.IntensifierActiveShape = "00189427";
    DicomTag.IntensifierActiveDimension = "00189428";
    DicomTag.PhysicalDetectorSize = "00189429";
    DicomTag.PositionOfIsocenterProjection = "00189430";
    DicomTag.FieldOfViewSequence = "00189432";
    DicomTag.FieldOfViewDescription = "00189433";
    DicomTag.ExposureControlSensingRegionsSequence = "00189434";
    DicomTag.ExposureControlSensingRegionShape = "00189435";
    DicomTag.ExposureControlSensingRegionLeftVerticalEdge = "00189436";
    DicomTag.ExposureControlSensingRegionRightVerticalEdge = "00189437";
    DicomTag.ExposureControlSensingRegionUpperHorizontalEdge = "00189438";
    DicomTag.ExposureControlSensingRegionLowerHorizontalEdge = "00189439";
    DicomTag.CenterOfCircularExposureControlSensingRegion = "00189440";
    DicomTag.RadiusOfCircularExposureControlSensingRegion = "00189441";
    DicomTag.VerticesOfThePolygonalExposureControlSensingRegion = "00189442";
    DicomTag.ColumnAngulationPatient = "00189447";
    DicomTag.BeamAngle = "00189449";
    DicomTag.FrameDetectorParametersSequence = "00189451";
    DicomTag.CalculatedAnatomyThickness = "00189452";
    DicomTag.CalibrationSequence = "00189455";
    DicomTag.ObjectThicknessSequence = "00189456";
    DicomTag.PlaneIdentification = "00189457";
    DicomTag.FieldOfViewDimensionInFloat = "00189461";
    DicomTag.IsocenterReferenceSystemSequence = "00189462";
    DicomTag.PositionerIsocenterPrimaryAngle = "00189463";
    DicomTag.PositionerIsocenterSecondaryAngle = "00189464";
    DicomTag.PositionerIsocenterDetectorRotationAngle = "00189465";
    DicomTag.TableXPositionToIsocenter = "00189466";
    DicomTag.TableYPositionToIsocenter = "00189467";
    DicomTag.TableZPositionToIsocenter = "00189468";
    DicomTag.TableHorizontalRotationAngle = "00189469";
    DicomTag.TableHeadTiltAngle = "00189470";
    DicomTag.TableCradleTiltAngle = "00189471";
    DicomTag.FrameDisplayShutterSequence = "00189472";
    DicomTag.AcquiredImageAreaDoseProduct = "00189473";
    DicomTag.CArmPositionerTabletopRelationship = "00189474";
    DicomTag.XRayGeometrySequence = "00189476";
    DicomTag.IrradiationEventIdentificationSequence = "00189477";
    DicomTag.XRay3DFrameTypeSequence = "00189504";
    DicomTag.ContributingSourcesSequence = "00189506";
    DicomTag.XRay3DAcquisitionSequence = "00189507";
    DicomTag.PrimaryPositionerScanArc = "00189508";
    DicomTag.SecondaryPositionerScanArc = "00189509";
    DicomTag.PrimaryPositionerScanStartAngle = "00189510";
    DicomTag.SecondaryPositionerScanStartAngle = "00189511";
    DicomTag.PrimaryPositionerIncrement = "00189514";
    DicomTag.SecondaryPositionerIncrement = "00189515";
    DicomTag.StartAcquisitionDateTime = "00189516";
    DicomTag.EndAcquisitionDateTime = "00189517";
    DicomTag.PrimaryPositionerIncrementSign = "00189518";
    DicomTag.SecondaryPositionerIncrementSign = "00189519";
    DicomTag.ApplicationName = "00189524";
    DicomTag.ApplicationVersion = "00189525";
    DicomTag.ApplicationManufacturer = "00189526";
    DicomTag.AlgorithmType = "00189527";
    DicomTag.AlgorithmDescription = "00189528";
    DicomTag.XRay3DReconstructionSequence = "00189530";
    DicomTag.ReconstructionDescription = "00189531";
    DicomTag.PerProjectionAcquisitionSequence = "00189538";
    DicomTag.DetectorPositionSequence = "00189541";
    DicomTag.XRayAcquisitionDoseSequence = "00189542";
    DicomTag.XRaySourceIsocenterPrimaryAngle = "00189543";
    DicomTag.XRaySourceIsocenterSecondaryAngle = "00189544";
    DicomTag.BreastSupportIsocenterPrimaryAngle = "00189545";
    DicomTag.BreastSupportIsocenterSecondaryAngle = "00189546";
    DicomTag.BreastSupportXPositionToIsocenter = "00189547";
    DicomTag.BreastSupportYPositionToIsocenter = "00189548";
    DicomTag.BreastSupportZPositionToIsocenter = "00189549";
    DicomTag.DetectorIsocenterPrimaryAngle = "00189550";
    DicomTag.DetectorIsocenterSecondaryAngle = "00189551";
    DicomTag.DetectorXPositionToIsocenter = "00189552";
    DicomTag.DetectorYPositionToIsocenter = "00189553";
    DicomTag.DetectorZPositionToIsocenter = "00189554";
    DicomTag.XRayGridSequence = "00189555";
    DicomTag.XRayFilterSequence = "00189556";
    DicomTag.DetectorActiveAreaTLHCPosition = "00189557";
    DicomTag.DetectorActiveAreaOrientation = "00189558";
    DicomTag.PositionerPrimaryAngleDirection = "00189559";
    DicomTag.DiffusionBMatrixSequence = "00189601";
    DicomTag.DiffusionBValueXX = "00189602";
    DicomTag.DiffusionBValueXY = "00189603";
    DicomTag.DiffusionBValueXZ = "00189604";
    DicomTag.DiffusionBValueYY = "00189605";
    DicomTag.DiffusionBValueYZ = "00189606";
    DicomTag.DiffusionBValueZZ = "00189607";
    DicomTag.DecayCorrectionDateTime = "00189701";
    DicomTag.StartDensityThreshold = "00189715";
    DicomTag.StartRelativeDensityDifferenceThreshold = "00189716";
    DicomTag.StartCardiacTriggerCountThreshold = "00189717";
    DicomTag.StartRespiratoryTriggerCountThreshold = "00189718";
    DicomTag.TerminationCountsThreshold = "00189719";
    DicomTag.TerminationDensityThreshold = "00189720";
    DicomTag.TerminationRelativeDensityThreshold = "00189721";
    DicomTag.TerminationTimeThreshold = "00189722";
    DicomTag.TerminationCardiacTriggerCountThreshold = "00189723";
    DicomTag.TerminationRespiratoryTriggerCountThreshold = "00189724";
    DicomTag.DetectorGeometry = "00189725";
    DicomTag.TransverseDetectorSeparation = "00189726";
    DicomTag.AxialDetectorDimension = "00189727";
    DicomTag.RadiopharmaceuticalAgentNumber = "00189729";
    DicomTag.PETFrameAcquisitionSequence = "00189732";
    DicomTag.PETDetectorMotionDetailsSequence = "00189733";
    DicomTag.PETTableDynamicsSequence = "00189734";
    DicomTag.PETPositionSequence = "00189735";
    DicomTag.PETFrameCorrectionFactorsSequence = "00189736";
    DicomTag.RadiopharmaceuticalUsageSequence = "00189737";
    DicomTag.AttenuationCorrectionSource = "00189738";
    DicomTag.NumberOfIterations = "00189739";
    DicomTag.NumberOfSubsets = "00189740";
    DicomTag.PETReconstructionSequence = "00189749";
    DicomTag.PETFrameTypeSequence = "00189751";
    DicomTag.TimeOfFlightInformationUsed = "00189755";
    DicomTag.ReconstructionType = "00189756";
    DicomTag.DecayCorrected = "00189758";
    DicomTag.AttenuationCorrected = "00189759";
    DicomTag.ScatterCorrected = "00189760";
    DicomTag.DeadTimeCorrected = "00189761";
    DicomTag.GantryMotionCorrected = "00189762";
    DicomTag.PatientMotionCorrected = "00189763";
    DicomTag.CountLossNormalizationCorrected = "00189764";
    DicomTag.RandomsCorrected = "00189765";
    DicomTag.NonUniformRadialSamplingCorrected = "00189766";
    DicomTag.SensitivityCalibrated = "00189767";
    DicomTag.DetectorNormalizationCorrection = "00189768";
    DicomTag.IterativeReconstructionMethod = "00189769";
    DicomTag.AttenuationCorrectionTemporalRelationship = "00189770";
    DicomTag.PatientPhysiologicalStateSequence = "00189771";
    DicomTag.PatientPhysiologicalStateCodeSequence = "00189772";
    DicomTag.DepthOfFocus = "00189801";
    DicomTag.ExcludedIntervalsSequence = "00189803";
    DicomTag.ExclusionStartDateTime = "00189804";
    DicomTag.ExclusionDuration = "00189805";
    DicomTag.USImageDescriptionSequence = "00189806";
    DicomTag.ImageDataTypeSequence = "00189807";
    DicomTag.DataType = "00189808";
    DicomTag.TransducerScanPatternCodeSequence = "00189809";
    DicomTag.AliasedDataType = "0018980B";
    DicomTag.PositionMeasuringDeviceUsed = "0018980C";
    DicomTag.TransducerGeometryCodeSequence = "0018980D";
    DicomTag.TransducerBeamSteeringCodeSequence = "0018980E";
    DicomTag.TransducerApplicationCodeSequence = "0018980F";
    DicomTag.ZeroVelocityPixelValue = "00189810";
    DicomTag.ContributingEquipmentSequence = "0018A001";
    DicomTag.ContributionDateTime = "0018A002";
    DicomTag.ContributionDescription = "0018A003";
    // *****************************************************************************************************************************
    // *** 0020
    // *****************************************************************************************************************************
    DicomTag.StudyInstanceUID = "0020000D";
    DicomTag.SeriesInstanceUID = "0020000E";
    DicomTag.StudyID = "00200010";
    DicomTag.SeriesNumber = "00200011";
    DicomTag.AcquisitionNumber = "00200012";
    DicomTag.InstanceNumber = "00200013";
    DicomTag.IsotopeNumber = "00200014"; // Retired
    DicomTag.PhaseNumber = "00200015"; // Retired
    DicomTag.IntervalNumber = "00200016"; // Retired
    DicomTag.TimeSlotNumber = "00200017"; // Retired
    DicomTag.AngleNumber = "00200018"; // Retired
    DicomTag.ItemNumber = "00200019";
    DicomTag.PatientOrientation = "00200020";
    DicomTag.OverlayNumber = "00200022"; // Retired
    DicomTag.CurveNumber = "00200024"; // Retired
    DicomTag.LUTNumber = "00200026"; // Retired
    DicomTag.ImagePosition = "00200030"; // Retired
    DicomTag.ImagePositionPatient = "00200032";
    DicomTag.ImageOrientation = "00200035"; // Retired
    DicomTag.ImageOrientationPatient = "00200037";
    DicomTag.Location = "00200050"; // Retired
    DicomTag.FrameOfReferenceUID = "00200052";
    DicomTag.Laterality = "00200060";
    DicomTag.ImageLaterality = "00200062";
    DicomTag.ImageGeometryType = "00200070"; // Retired
    DicomTag.MaskingImage = "00200080"; // Retired
    DicomTag.ReportNumber = "002000AA"; // Retired
    DicomTag.TemporalPositionIdentifier = "00200100";
    DicomTag.NumberOfTemporalPositions = "00200105";
    DicomTag.TemporalResolution = "00200110";
    DicomTag.SynchronizationFrameOfReferenceUID = "00200200";
    DicomTag.SOPInstanceUIDOfConcatenationSource = "00200242";
    DicomTag.SeriesInStudy = "00201000"; // Retired
    DicomTag.AcquisitionsInSeries = "00201001"; // Retired
    DicomTag.ImagesInAcquisition = "00201002";
    DicomTag.ImagesInSeries = "00201003"; // Retired
    DicomTag.AcquisitionsInStudy = "00201004"; // Retired
    DicomTag.ImagesInStudy = "00201005"; // Retired
    DicomTag.Reference = "00201020"; // Retired
    DicomTag.PositionReferenceIndicator = "00201040";
    DicomTag.SliceLocation = "00201041";
    DicomTag.OtherStudyNumbers = "00201070"; // Retired
    DicomTag.NumberOfPatientRelatedStudies = "00201200";
    DicomTag.NumberOfPatientRelatedSeries = "00201202";
    DicomTag.NumberOfPatientRelatedInstances = "00201204";
    DicomTag.NumberOfStudyRelatedSeries = "00201206";
    DicomTag.NumberOfStudyRelatedInstances = "00201208";
    DicomTag.NumberOfSeriesRelatedInstances = "00201209";
    DicomTag.SourceImageIDs = "00203100"; // Retired
    DicomTag.ModifyingDeviceID = "00203401"; // Retired
    DicomTag.ModifiedImageID = "00203402"; // Retired
    DicomTag.ModifiedImageDate = "00203403"; // Retired
    DicomTag.ModifyingDeviceManufacturer = "00203404"; // Retired
    DicomTag.ModifiedImageTime = "00203405"; // Retired
    DicomTag.ModifiedImageDescription = "00203406"; // Retired
    DicomTag.ImageComments = "00204000";
    DicomTag.OriginalImageIdentification = "00205000"; // Retired
    DicomTag.OriginalImageIdentificationNomenclature = "00205002"; // Retired
    DicomTag.StackID = "00209056";
    DicomTag.InStackPositionNumber = "00209057";
    DicomTag.FrameAnatomySequence = "00209071";
    DicomTag.FrameLaterality = "00209072";
    DicomTag.FrameContentSequence = "00209111";
    DicomTag.PlanePositionSequence = "00209113";
    DicomTag.PlaneOrientationSequence = "00209116";
    DicomTag.TemporalPositionIndex = "00209128";
    DicomTag.NominalCardiacTriggerDelayTime = "00209153";
    DicomTag.NominalCardiacTriggerTimePriorToRPeak = "00209154";
    DicomTag.ActualCardiacTriggerTimePriorToRPeak = "00209155";
    DicomTag.FrameAcquisitionNumber = "00209156";
    DicomTag.DimensionIndexValues = "00209157";
    DicomTag.FrameComments = "00209158";
    DicomTag.ConcatenationUID = "00209161";
    DicomTag.InConcatenationNumber = "00209162";
    DicomTag.InConcatenationTotalNumber = "00209163";
    DicomTag.DimensionOrganizationUID = "00209164";
    DicomTag.DimensionIndexPointer = "00209165";
    DicomTag.FunctionalGroupPointer = "00209167";
    DicomTag.UnassignedSharedConvertedAttributesSequence = "00209170";
    DicomTag.UnassignedPerFrameConvertedAttributesSequence = "00209171";
    DicomTag.ConversionSourceAttributesSequence = "00209172";
    DicomTag.DimensionIndexPrivateCreator = "00209213";
    DicomTag.DimensionOrganizationSequence = "00209221";
    DicomTag.DimensionIndexSequence = "00209222";
    DicomTag.ConcatenationFrameOffsetNumber = "00209228";
    DicomTag.FunctionalGroupPrivateCreator = "00209238";
    DicomTag.NominalPercentageOfCardiacPhase = "00209241";
    DicomTag.NominalPercentageOfRespiratoryPhase = "00209245";
    DicomTag.StartingRespiratoryAmplitude = "00209246";
    DicomTag.StartingRespiratoryPhase = "00209247";
    DicomTag.EndingRespiratoryAmplitude = "00209248";
    DicomTag.EndingRespiratoryPhase = "00209249";
    DicomTag.RespiratoryTriggerType = "00209250";
    DicomTag.RRIntervalTimeNominal = "00209251";
    DicomTag.ActualCardiacTriggerDelayTime = "00209252";
    DicomTag.RespiratorySynchronizationSequence = "00209253";
    DicomTag.RespiratoryIntervalTime = "00209254";
    DicomTag.NominalRespiratoryTriggerDelayTime = "00209255";
    DicomTag.RespiratoryTriggerDelayThreshold = "00209256";
    DicomTag.ActualRespiratoryTriggerDelayTime = "00209257";
    DicomTag.ImagePositionVolume = "00209301";
    DicomTag.ImageOrientationVolume = "00209302";
    DicomTag.UltrasoundAcquisitionGeometry = "00209307";
    DicomTag.ApexPosition = "00209308";
    DicomTag.VolumeToTransducerMappingMatrix = "00209309";
    DicomTag.VolumeToTableMappingMatrix = "0020930A";
    DicomTag.VolumeToTransducerRelationship = "0020930B";
    DicomTag.PatientFrameOfReferenceSource = "0020930C";
    DicomTag.TemporalPositionTimeOffset = "0020930D";
    DicomTag.PlanePositionVolumeSequence = "0020930E";
    DicomTag.PlaneOrientationVolumeSequence = "0020930F";
    DicomTag.TemporalPositionSequence = "00209310";
    DicomTag.DimensionOrganizationType = "00209311";
    DicomTag.VolumeFrameOfReferenceUID = "00209312";
    DicomTag.TableFrameOfReferenceUID = "00209313";
    DicomTag.DimensionDescriptionLabel = "00209421";
    DicomTag.PatientOrientationInFrameSequence = "00209450";
    DicomTag.FrameLabel = "00209453";
    DicomTag.AcquisitionIndex = "00209518";
    DicomTag.ContributingSOPInstancesReferenceSequence = "00209529";
    DicomTag.ReconstructionIndex = "00209536";
    // *****************************************************************************************************************************
    // *** 0022
    // *****************************************************************************************************************************
    DicomTag.LightPathFilterPassThroughWavelength = "00220001";
    DicomTag.LightPathFilterPassBand = "00220002";
    DicomTag.ImagePathFilterPassThroughWavelength = "00220003";
    DicomTag.ImagePathFilterPassBand = "00220004";
    DicomTag.PatientEyeMovementCommanded = "00220005";
    DicomTag.PatientEyeMovementCommandCodeSequence = "00220006";
    DicomTag.SphericalLensPower = "00220007";
    DicomTag.CylinderLensPower = "00220008";
    DicomTag.CylinderAxis = "00220009";
    DicomTag.EmmetropicMagnification = "0022000A";
    DicomTag.IntraOcularPressure = "0022000B";
    DicomTag.HorizontalFieldOfView = "0022000C";
    DicomTag.PupilDilated = "0022000D";
    DicomTag.DegreeOfDilation = "0022000E";
    DicomTag.StereoBaselineAngle = "00220010";
    DicomTag.StereoBaselineDisplacement = "00220011";
    DicomTag.StereoHorizontalPixelOffset = "00220012";
    DicomTag.StereoVerticalPixelOffset = "00220013";
    DicomTag.StereoRotation = "00220014";
    DicomTag.AcquisitionDeviceTypeCodeSequence = "00220015";
    DicomTag.IlluminationTypeCodeSequence = "00220016";
    DicomTag.LightPathFilterTypeStackCodeSequence = "00220017";
    DicomTag.ImagePathFilterTypeStackCodeSequence = "00220018";
    DicomTag.LensesCodeSequence = "00220019";
    DicomTag.ChannelDescriptionCodeSequence = "0022001A";
    DicomTag.RefractiveStateSequence = "0022001B";
    DicomTag.MydriaticAgentCodeSequence = "0022001C";
    DicomTag.RelativeImagePositionCodeSequence = "0022001D";
    DicomTag.CameraAngleOfView = "0022001E";
    DicomTag.StereoPairsSequence = "00220020";
    DicomTag.LeftImageSequence = "00220021";
    DicomTag.RightImageSequence = "00220022";
    DicomTag.StereoPairsPresent = "00220028";
    DicomTag.AxialLengthOfTheEye = "00220030";
    DicomTag.OphthalmicFrameLocationSequence = "00220031";
    DicomTag.ReferenceCoordinates = "00220032";
    DicomTag.DepthSpatialResolution = "00220035";
    DicomTag.MaximumDepthDistortion = "00220036";
    DicomTag.AlongScanSpatialResolution = "00220037";
    DicomTag.MaximumAlongScanDistortion = "00220038";
    DicomTag.OphthalmicImageOrientation = "00220039";
    DicomTag.DepthOfTransverseImage = "00220041";
    DicomTag.MydriaticAgentConcentrationUnitsSequence = "00220042";
    DicomTag.AcrossScanSpatialResolution = "00220048";
    DicomTag.MaximumAcrossScanDistortion = "00220049";
    DicomTag.MydriaticAgentConcentration = "0022004E";
    DicomTag.IlluminationWaveLength = "00220055";
    DicomTag.IlluminationPower = "00220056";
    DicomTag.IlluminationBandwidth = "00220057";
    DicomTag.MydriaticAgentSequence = "00220058";
    DicomTag.OphthalmicAxialMeasurementsRightEyeSequence = "00221007";
    DicomTag.OphthalmicAxialMeasurementsLeftEyeSequence = "00221008";
    DicomTag.OphthalmicAxialMeasurementsDeviceType = "00221009";
    DicomTag.OphthalmicAxialLengthMeasurementsType = "00221010";
    DicomTag.OphthalmicAxialLengthSequence = "00221012";
    DicomTag.OphthalmicAxialLength = "00221019";
    DicomTag.LensStatusCodeSequence = "00221024";
    DicomTag.VitreousStatusCodeSequence = "00221025";
    DicomTag.IOLFormulaCodeSequence = "00221028";
    DicomTag.IOLFormulaDetail = "00221029";
    DicomTag.KeratometerIndex = "00221033";
    DicomTag.SourceOfOphthalmicAxialLengthCodeSequence = "00221035";
    DicomTag.TargetRefraction = "00221037";
    DicomTag.RefractiveProcedureOccurred = "00221039";
    DicomTag.RefractiveSurgeryTypeCodeSequence = "00221040";
    DicomTag.OphthalmicUltrasoundMethodCodeSequence = "00221044";
    DicomTag.OphthalmicAxialLengthMeasurementsSequence = "00221050";
    DicomTag.IOLPower = "00221053";
    DicomTag.PredictedRefractiveError = "00221054";
    DicomTag.OphthalmicAxialLengthVelocity = "00221059";
    DicomTag.LensStatusDescription = "00221065";
    DicomTag.VitreousStatusDescription = "00221066";
    DicomTag.IOLPowerSequence = "00221090";
    DicomTag.LensConstantSequence = "00221092";
    DicomTag.IOLManufacturer = "00221093";
    DicomTag.LensConstantDescription = "00221094"; // Retired
    DicomTag.ImplantName = "00221095";
    DicomTag.KeratometryMeasurementTypeCodeSequence = "00221096";
    DicomTag.ImplantPartNumber = "00221097";
    DicomTag.ReferencedOphthalmicAxialMeasurementsSequence = "00221100";
    DicomTag.OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence = "00221101";
    DicomTag.RefractiveErrorBeforeRefractiveSurgeryCodeSequence = "00221103";
    DicomTag.IOLPowerForExactEmmetropia = "00221121";
    DicomTag.IOLPowerForExactTargetRefraction = "00221122";
    DicomTag.AnteriorChamberDepthDefinitionCodeSequence = "00221125";
    DicomTag.LensThicknessSequence = "00221127";
    DicomTag.AnteriorChamberDepthSequence = "00221128";
    DicomTag.LensThickness = "00221130";
    DicomTag.AnteriorChamberDepth = "00221131";
    DicomTag.SourceOfLensThicknessDataCodeSequence = "00221132";
    DicomTag.SourceOfAnteriorChamberDepthDataCodeSequence = "00221133";
    DicomTag.SourceOfRefractiveMeasurementsSequence = "00221134";
    DicomTag.SourceOfRefractiveMeasurementsCodeSequence = "00221135";
    DicomTag.OphthalmicAxialLengthMeasurementModified = "00221140";
    DicomTag.OphthalmicAxialLengthDataSourceCodeSequence = "00221150";
    DicomTag.OphthalmicAxialLengthAcquisitionMethodCodeSequence = "00221153"; // Retired
    DicomTag.SignalToNoiseRatio = "00221155";
    DicomTag.OphthalmicAxialLengthDataSourceDescription = "00221159";
    DicomTag.OphthalmicAxialLengthMeasurementsTotalLengthSequence = "00221210";
    DicomTag.OphthalmicAxialLengthMeasurementsSegmentalLengthSequence = "00221211";
    DicomTag.OphthalmicAxialLengthMeasurementsLengthSummationSequence = "00221212";
    DicomTag.UltrasoundOphthalmicAxialLengthMeasurementsSequence = "00221220";
    DicomTag.OpticalOphthalmicAxialLengthMeasurementsSequence = "00221225";
    DicomTag.UltrasoundSelectedOphthalmicAxialLengthSequence = "00221230";
    DicomTag.OphthalmicAxialLengthSelectionMethodCodeSequence = "00221250";
    DicomTag.OpticalSelectedOphthalmicAxialLengthSequence = "00221255";
    DicomTag.SelectedSegmentalOphthalmicAxialLengthSequence = "00221257";
    DicomTag.SelectedTotalOphthalmicAxialLengthSequence = "00221260";
    DicomTag.OphthalmicAxialLengthQualityMetricSequence = "00221262";
    DicomTag.OphthalmicAxialLengthQualityMetricTypeCodeSequence = "00221265"; // Retired
    DicomTag.OphthalmicAxialLengthQualityMetricTypeDescription = "00221273"; // Retired
    DicomTag.IntraocularLensCalculationsRightEyeSequence = "00221300";
    DicomTag.IntraocularLensCalculationsLeftEyeSequence = "00221310";
    DicomTag.ReferencedOphthalmicAxialLengthMeasurementQCImageSequence = "00221330";
    DicomTag.OphthalmicMappingDeviceType = "00221415";
    DicomTag.AcquisitionMethodCodeSequence = "00221420";
    DicomTag.AcquisitionMethodAlgorithmSequence = "00221423";
    DicomTag.OphthalmicThicknessMapTypeCodeSequence = "00221436";
    DicomTag.OphthalmicThicknessMappingNormalsSequence = "00221443";
    DicomTag.RetinalThicknessDefinitionCodeSequence = "00221445";
    DicomTag.PixelValueMappingToCodedConceptSequence = "00221450";
    DicomTag.MappedPixelValue = "00221452";
    DicomTag.PixelValueMappingExplanation = "00221454";
    DicomTag.OphthalmicThicknessMapQualityThresholdSequence = "00221458";
    DicomTag.OphthalmicThicknessMapThresholdQualityRating = "00221460";
    DicomTag.AnatomicStructureReferencePoint = "00221463";
    DicomTag.RegistrationToLocalizerSequence = "00221465";
    DicomTag.RegisteredLocalizerUnits = "00221466";
    DicomTag.RegisteredLocalizerTopLeftHandCorner = "00221467";
    DicomTag.RegisteredLocalizerBottomRightHandCorner = "00221468";
    DicomTag.OphthalmicThicknessMapQualityRatingSequence = "00221470";
    DicomTag.RelevantOPTAttributesSequence = "00221472";
    DicomTag.TransformationMethodCodeSequence = "00221512";
    DicomTag.TransformationAlgorithmSequence = "00221513";
    DicomTag.OphthalmicAxialLengthMethod = "00221515";
    DicomTag.OphthalmicFOV = "00221517";
    DicomTag.TwoDimensionalToThreeDimensionalMapSequence = "00221518";
    DicomTag.WideFieldOphthalmicPhotographyQualityRatingSequence = "00221525";
    DicomTag.WideFieldOphthalmicPhotographyQualityThresholdSequence = "00221526";
    DicomTag.WideFieldOphthalmicPhotographyThresholdQualityRating = "00221527";
    DicomTag.XCoordinatesCenterPixelViewAngle = "00221528";
    DicomTag.YCoordinatesCenterPixelViewAngle = "00221529";
    DicomTag.NumberOfMapPoints = "00221530";
    DicomTag.TwoDimensionalToThreeDimensionalMapData = "00221531";
    // *****************************************************************************************************************************
    // *** 0024
    // *****************************************************************************************************************************
    DicomTag.VisualFieldHorizontalExtent = "00240010";
    DicomTag.VisualFieldVerticalExtent = "00240011";
    DicomTag.VisualFieldShape = "00240012";
    DicomTag.ScreeningTestModeCodeSequence = "00240016";
    DicomTag.MaximumStimulusLuminance = "00240018";
    DicomTag.BackgroundLuminance = "00240020";
    DicomTag.StimulusColorCodeSequence = "00240021";
    DicomTag.BackgroundIlluminationColorCodeSequence = "00240024";
    DicomTag.StimulusArea = "00240025";
    DicomTag.StimulusPresentationTime = "00240028";
    DicomTag.FixationSequence = "00240032";
    DicomTag.FixationMonitoringCodeSequence = "00240033";
    DicomTag.VisualFieldCatchTrialSequence = "00240034";
    DicomTag.FixationCheckedQuantity = "00240035";
    DicomTag.PatientNotProperlyFixatedQuantity = "00240036";
    DicomTag.PresentedVisualStimuliDataFlag = "00240037";
    DicomTag.NumberOfVisualStimuli = "00240038";
    DicomTag.ExcessiveFixationLossesDataFlag = "00240039";
    DicomTag.ExcessiveFixationLosses = "00240040";
    DicomTag.StimuliRetestingQuantity = "00240042";
    DicomTag.CommentsOnPatientPerformanceOfVisualField = "00240044";
    DicomTag.FalseNegativesEstimateFlag = "00240045";
    DicomTag.FalseNegativesEstimate = "00240046";
    DicomTag.NegativeCatchTrialsQuantity = "00240048";
    DicomTag.FalseNegativesQuantity = "00240050";
    DicomTag.ExcessiveFalseNegativesDataFlag = "00240051";
    DicomTag.ExcessiveFalseNegatives = "00240052";
    DicomTag.FalsePositivesEstimateFlag = "00240053";
    DicomTag.FalsePositivesEstimate = "00240054";
    DicomTag.CatchTrialsDataFlag = "00240055";
    DicomTag.PositiveCatchTrialsQuantity = "00240056";
    DicomTag.TestPointNormalsDataFlag = "00240057";
    DicomTag.TestPointNormalsSequence = "00240058";
    DicomTag.GlobalDeviationProbabilityNormalsFlag = "00240059";
    DicomTag.FalsePositivesQuantity = "00240060";
    DicomTag.ExcessiveFalsePositivesDataFlag = "00240061";
    DicomTag.ExcessiveFalsePositives = "00240062";
    DicomTag.VisualFieldTestNormalsFlag = "00240063";
    DicomTag.ResultsNormalsSequence = "00240064";
    DicomTag.AgeCorrectedSensitivityDeviationAlgorithmSequence = "00240065";
    DicomTag.GlobalDeviationFromNormal = "00240066";
    DicomTag.GeneralizedDefectSensitivityDeviationAlgorithmSequence = "00240067";
    DicomTag.LocalizedDeviationFromNormal = "00240068";
    DicomTag.PatientReliabilityIndicator = "00240069";
    DicomTag.VisualFieldMeanSensitivity = "00240070";
    DicomTag.GlobalDeviationProbability = "00240071";
    DicomTag.LocalDeviationProbabilityNormalsFlag = "00240072";
    DicomTag.LocalizedDeviationProbability = "00240073";
    DicomTag.ShortTermFluctuationCalculated = "00240074";
    DicomTag.ShortTermFluctuation = "00240075";
    DicomTag.ShortTermFluctuationProbabilityCalculated = "00240076";
    DicomTag.ShortTermFluctuationProbability = "00240077";
    DicomTag.CorrectedLocalizedDeviationFromNormalCalculated = "00240078";
    DicomTag.CorrectedLocalizedDeviationFromNormal = "00240079";
    DicomTag.CorrectedLocalizedDeviationFromNormalProbabilityCalculated = "00240080";
    DicomTag.CorrectedLocalizedDeviationFromNormalProbability = "00240081";
    DicomTag.GlobalDeviationProbabilitySequence = "00240083";
    DicomTag.LocalizedDeviationProbabilitySequence = "00240085";
    DicomTag.FovealSensitivityMeasured = "00240086";
    DicomTag.FovealSensitivity = "00240087";
    DicomTag.VisualFieldTestDuration = "00240088";
    DicomTag.VisualFieldTestPointSequence = "00240089";
    DicomTag.VisualFieldTestPointXCoordinate = "00240090";
    DicomTag.VisualFieldTestPointYCoordinate = "00240091";
    DicomTag.AgeCorrectedSensitivityDeviationValue = "00240092";
    DicomTag.StimulusResults = "00240093";
    DicomTag.SensitivityValue = "00240094";
    DicomTag.RetestStimulusSeen = "00240095";
    DicomTag.RetestSensitivityValue = "00240096";
    DicomTag.VisualFieldTestPointNormalsSequence = "00240097";
    DicomTag.QuantifiedDefect = "00240098";
    DicomTag.AgeCorrectedSensitivityDeviationProbabilityValue = "00240100";
    DicomTag.GeneralizedDefectCorrectedSensitivityDeviationFlag = "00240102";
    DicomTag.GeneralizedDefectCorrectedSensitivityDeviationValue = "00240103";
    DicomTag.GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue = "00240104";
    DicomTag.MinimumSensitivityValue = "00240105";
    DicomTag.BlindSpotLocalized = "00240106";
    DicomTag.BlindSpotXCoordinate = "00240107";
    DicomTag.BlindSpotYCoordinate = "00240108";
    DicomTag.VisualAcuityMeasurementSequence = "00240110";
    DicomTag.RefractiveParametersUsedOnPatientSequence = "00240112";
    DicomTag.MeasurementLaterality = "00240113";
    DicomTag.OphthalmicPatientClinicalInformationLeftEyeSequence = "00240114";
    DicomTag.OphthalmicPatientClinicalInformationRightEyeSequence = "00240115";
    DicomTag.FovealPointNormativeDataFlag = "00240117";
    DicomTag.FovealPointProbabilityValue = "00240118";
    DicomTag.ScreeningBaselineMeasured = "00240120";
    DicomTag.ScreeningBaselineMeasuredSequence = "00240122";
    DicomTag.ScreeningBaselineType = "00240124";
    DicomTag.ScreeningBaselineValue = "00240126";
    DicomTag.AlgorithmSource = "00240202";
    DicomTag.DataSetName = "00240306";
    DicomTag.DataSetVersion = "00240307";
    DicomTag.DataSetSource = "00240308";
    DicomTag.DataSetDescription = "00240309";
    DicomTag.VisualFieldTestReliabilityGlobalIndexSequence = "00240317";
    DicomTag.VisualFieldGlobalResultsIndexSequence = "00240320";
    DicomTag.DataObservationSequence = "00240325";
    DicomTag.IndexNormalsFlag = "00240338";
    DicomTag.IndexProbability = "00240341";
    DicomTag.IndexProbabilitySequence = "00240344";
    // *****************************************************************************************************************************
    // *** 0028
    // *****************************************************************************************************************************
    DicomTag.SamplesPerPixel = "00280002";
    DicomTag.SamplesPerPixelUsed = "00280003";
    DicomTag.PhotometricInterpretation = "00280004";
    DicomTag.ImageDimensions = "00280005"; // Retired
    DicomTag.PlanarConfiguration = "00280006";
    DicomTag.NumberOfFrames = "00280008";
    DicomTag.FrameIncrementPointer = "00280009";
    DicomTag.FrameDimensionPointer = "0028000A";
    DicomTag.Rows = "00280010";
    DicomTag.Columns = "00280011";
    DicomTag.Planes = "00280012"; // Retired
    DicomTag.UltrasoundColorDataPresent = "00280014";
    DicomTag.PixelSpacing = "00280030";
    DicomTag.ZoomFactor = "00280031";
    DicomTag.ZoomCenter = "00280032";
    DicomTag.PixelAspectRatio = "00280034";
    DicomTag.ImageFormat = "00280040"; // Retired
    DicomTag.ManipulatedImage = "00280050"; // Retired
    DicomTag.CorrectedImage = "00280051";
    DicomTag.CompressionRecognitionCode = "0028005F"; // Retired
    DicomTag.CompressionCode = "00280060"; // Retired
    DicomTag.CompressionOriginator = "00280061"; // Retired
    DicomTag.CompressionLabel = "00280062"; // Retired
    DicomTag.CompressionDescription = "00280063"; // Retired
    DicomTag.CompressionSequence = "00280065"; // Retired
    DicomTag.CompressionStepPointers = "00280066"; // Retired
    DicomTag.RepeatInterval = "00280068"; // Retired
    DicomTag.BitsGrouped = "00280069"; // Retired
    DicomTag.PerimeterTable = "00280070"; // Retired
    DicomTag.PerimeterValue = "00280071"; // Retired
    DicomTag.PredictorRows = "00280080"; // Retired
    DicomTag.PredictorColumns = "00280081"; // Retired
    DicomTag.PredictorConstants = "00280082"; // Retired
    DicomTag.BlockedPixels = "00280090"; // Retired
    DicomTag.BlockRows = "00280091"; // Retired
    DicomTag.BlockColumns = "00280092"; // Retired
    DicomTag.RowOverlap = "00280093"; // Retired
    DicomTag.ColumnOverlap = "00280094"; // Retired
    DicomTag.BitsAllocated = "00280100";
    DicomTag.BitsStored = "00280101";
    DicomTag.HighBit = "00280102";
    DicomTag.PixelRepresentation = "00280103";
    DicomTag.SmallestValidPixelValue = "00280104"; // Retired
    DicomTag.LargestValidPixelValue = "00280105"; // Retired
    DicomTag.SmallestImagePixelValue = "00280106";
    DicomTag.LargestImagePixelValue = "00280107";
    DicomTag.SmallestPixelValueInSeries = "00280108";
    DicomTag.LargestPixelValueInSeries = "00280109";
    DicomTag.SmallestImagePixelValueInPlane = "00280110"; // Retired
    DicomTag.LargestImagePixelValueInPlane = "00280111"; // Retired
    DicomTag.PixelPaddingValue = "00280120";
    DicomTag.PixelPaddingRangeLimit = "00280121";
    DicomTag.FloatPixelPaddingValue = "00280122";
    DicomTag.DoubleFloatPixelPaddingValue = "00280123";
    DicomTag.FloatPixelPaddingRangeLimit = "00280124";
    DicomTag.DoubleFloatPixelPaddingRangeLimit = "00280125";
    DicomTag.ImageLocation = "00280200"; // Retired
    DicomTag.QualityControlImage = "00280300";
    DicomTag.BurnedInAnnotation = "00280301";
    DicomTag.RecognizableVisualFeatures = "00280302";
    DicomTag.LongitudinalTemporalInformationModified = "00280303";
    DicomTag.ReferencedColorPaletteInstanceUID = "00280304";
    DicomTag.TransformLabel = "00280400"; // Retired
    DicomTag.TransformVersionNumber = "00280401"; // Retired
    DicomTag.NumberOfTransformSteps = "00280402"; // Retired
    DicomTag.SequenceOfCompressedData = "00280403"; // Retired
    DicomTag.DetailsOfCoefficients = "00280404"; // Retired
    DicomTag.RowsForNthOrderCoefficients = "00280400"; // Retired
    DicomTag.ColumnsForNthOrderCoefficients = "00280401"; // Retired
    DicomTag.CoefficientCoding = "00280402"; // Retired
    DicomTag.CoefficientCodingPointers = "00280403"; // Retired
    DicomTag.DCTLabel = "00280700"; // Retired
    DicomTag.DataBlockDescription = "00280701"; // Retired
    DicomTag.DataBlock = "00280702"; // Retired
    DicomTag.NormalizationFactorFormat = "00280710"; // Retired
    DicomTag.ZonalMapNumberFormat = "00280720"; // Retired
    DicomTag.ZonalMapLocation = "00280721"; // Retired
    DicomTag.ZonalMapFormat = "00280722"; // Retired
    DicomTag.AdaptiveMapFormat = "00280730"; // Retired
    DicomTag.CodeNumberFormat = "00280740"; // Retired
    DicomTag.CodeLabel = "00280800"; // Retired
    DicomTag.NumberOfTables = "00280802"; // Retired
    DicomTag.CodeTableLocation = "00280803"; // Retired
    DicomTag.BitsForCodeWord = "00280804"; // Retired
    DicomTag.ImageDataLocation = "00280808"; // Retired
    DicomTag.PixelSpacingCalibrationType = "00280A02";
    DicomTag.PixelSpacingCalibrationDescription = "00280A04";
    DicomTag.PixelIntensityRelationship = "00281040";
    DicomTag.PixelIntensityRelationshipSign = "00281041";
    DicomTag.WindowCenter = "00281050";
    DicomTag.WindowWidth = "00281051";
    DicomTag.RescaleIntercept = "00281052";
    DicomTag.RescaleSlope = "00281053";
    DicomTag.RescaleType = "00281054";
    DicomTag.WindowCenterWidthExplanation = "00281055";
    DicomTag.VOILUTFunction = "00281056";
    DicomTag.GrayScale = "00281080"; // Retired
    DicomTag.RecommendedViewingMode = "00281090";
    DicomTag.GrayLookupTableDescriptor = "00281100"; // Retired
    DicomTag.RedPaletteColorLookupTableDescriptor = "00281101";
    DicomTag.GreenPaletteColorLookupTableDescriptor = "00281102";
    DicomTag.BluePaletteColorLookupTableDescriptor = "00281103";
    DicomTag.AlphaPaletteColorLookupTableDescriptor = "00281104";
    DicomTag.LargeRedPaletteColorLookupTableDescriptor = "00281111"; // Retired
    DicomTag.LargeGreenPaletteColorLookupTableDescriptor = "00281112"; // Retired
    DicomTag.LargeBluePaletteColorLookupTableDescriptor = "00281113"; // Retired
    DicomTag.PaletteColorLookupTableUID = "00281199";
    DicomTag.GrayLookupTableData = "00281200"; // Retired
    DicomTag.RedPaletteColorLookupTableData = "00281201";
    DicomTag.GreenPaletteColorLookupTableData = "00281202";
    DicomTag.BluePaletteColorLookupTableData = "00281203";
    DicomTag.AlphaPaletteColorLookupTableData = "00281204";
    DicomTag.LargeRedPaletteColorLookupTableData = "00281211"; // Retired
    DicomTag.LargeGreenPaletteColorLookupTableData = "00281212"; // Retired
    DicomTag.LargeBluePaletteColorLookupTableData = "00281213"; // Retired
    DicomTag.LargePaletteColorLookupTableUID = "00281214"; // Retired
    DicomTag.SegmentedRedPaletteColorLookupTableData = "00281221";
    DicomTag.SegmentedGreenPaletteColorLookupTableData = "00281222";
    DicomTag.SegmentedBluePaletteColorLookupTableData = "00281223";
    DicomTag.BreastImplantPresent = "00281300";
    DicomTag.PartialView = "00281350";
    DicomTag.PartialViewDescription = "00281351";
    DicomTag.PartialViewCodeSequence = "00281352";
    DicomTag.SpatialLocationsPreserved = "0028135A";
    DicomTag.DataFrameAssignmentSequence = "00281401";
    DicomTag.DataPathAssignment = "00281402";
    DicomTag.BitsMappedToColorLookupTable = "00281403";
    DicomTag.BlendingLUT1Sequence = "00281404";
    DicomTag.BlendingLUT1TransferFunction = "00281405";
    DicomTag.BlendingWeightConstant = "00281406";
    DicomTag.BlendingLookupTableDescriptor = "00281407";
    DicomTag.BlendingLookupTableData = "00281408";
    DicomTag.EnhancedPaletteColorLookupTableSequence = "0028140B";
    DicomTag.BlendingLUT2Sequence = "0028140C";
    DicomTag.BlendingLUT2TransferFunction = "0028140D";
    DicomTag.DataPathID = "0028140E";
    DicomTag.RGBLUTTransferFunction = "0028140F";
    DicomTag.AlphaLUTTransferFunction = "00281410";
    DicomTag.ICCProfile = "00282000";
    DicomTag.LossyImageCompression = "00282110";
    DicomTag.LossyImageCompressionRatio = "00282112";
    DicomTag.LossyImageCompressionMethod = "00282114";
    DicomTag.ModalityLUTSequence = "00283000";
    DicomTag.LUTDescriptor = "00283002";
    DicomTag.LUTExplanation = "00283003";
    DicomTag.ModalityLUTType = "00283004";
    DicomTag.LUTData = "00283006";
    DicomTag.VOILUTSequence = "00283010";
    DicomTag.SoftcopyVOILUTSequence = "00283110";
    DicomTag.ImagePresentationComments = "00284000"; // Retired
    DicomTag.BiPlaneAcquisitionSequence = "00285000"; // Retired
    DicomTag.RepresentativeFrameNumber = "00286010";
    DicomTag.FrameNumbersOfInterestFOI = "00286020";
    DicomTag.FrameOfInterestDescription = "00286022";
    DicomTag.FrameOfInterestType = "00286023";
    DicomTag.MaskPointer = "00286030"; // Retired
    DicomTag.RWavePointer = "00286040";
    DicomTag.MaskSubtractionSequence = "00286100";
    DicomTag.MaskOperation = "00286101";
    DicomTag.ApplicableFrameRange = "00286102";
    DicomTag.MaskFrameNumbers = "00286110";
    DicomTag.ContrastFrameAveraging = "00286112";
    DicomTag.MaskSubPixelShift = "00286114";
    DicomTag.TIDOffset = "00286120";
    DicomTag.MaskOperationExplanation = "00286190";
    DicomTag.EquipmentAdministratorSequence = "00287000";
    DicomTag.NumberOfDisplaySubsystems = "00287001";
    DicomTag.CurrentConfigurationID = "00287002";
    DicomTag.DisplaySubsystemID = "00287003";
    DicomTag.DisplaySubsystemName = "00287004";
    DicomTag.DisplaySubsystemDescription = "00287005";
    DicomTag.SystemStatus = "00287006";
    DicomTag.SystemStatusComment = "00287007";
    DicomTag.TargetLuminanceCharacteristicsSequence = "00287008";
    DicomTag.LuminanceCharacteristicsID = "00287009";
    DicomTag.DisplaySubsystemConfigurationSequence = "0028700A";
    DicomTag.ConfigurationID = "0028700B";
    DicomTag.ConfigurationName = "0028700C";
    DicomTag.ConfigurationDescription = "0028700D";
    DicomTag.ReferencedTargetLuminanceCharacteristicsID = "0028700E";
    DicomTag.QAResultsSequence = "0028700F";
    DicomTag.DisplaySubsystemQAResultsSequence = "00287010";
    DicomTag.ConfigurationQAResultsSequence = "00287011";
    DicomTag.MeasurementEquipmentSequence = "00287012";
    DicomTag.MeasurementFunctions = "00287013";
    DicomTag.MeasurementEquipmentType = "00287014";
    DicomTag.VisualEvaluationResultSequence = "00287015";
    DicomTag.DisplayCalibrationResultSequence = "00287016";
    DicomTag.DDLValue = "00287017";
    DicomTag.CIExyWhitePoint = "00287018";
    DicomTag.DisplayFunctionType = "00287019";
    DicomTag.GammaValue = "0028701A";
    DicomTag.NumberOfLuminancePoints = "0028701B";
    DicomTag.LuminanceResponseSequence = "0028701C";
    DicomTag.TargetMinimumLuminance = "0028701D";
    DicomTag.TargetMaximumLuminance = "0028701E";
    DicomTag.LuminanceValue = "0028701F";
    DicomTag.LuminanceResponseDescription = "00287020";
    DicomTag.WhitePointFlag = "00287021";
    DicomTag.DisplayDeviceTypeCodeSequence = "00287022";
    DicomTag.DisplaySubsystemSequence = "00287023";
    DicomTag.LuminanceResultSequence = "00287024";
    DicomTag.AmbientLightValueSource = "00287025";
    DicomTag.MeasuredCharacteristics = "00287026";
    DicomTag.LuminanceUniformityResultSequence = "00287027";
    DicomTag.VisualEvaluationTestSequence = "00287028";
    DicomTag.TestResult = "00287029";
    DicomTag.TestResultComment = "0028702A";
    DicomTag.TestImageValidation = "0028702B";
    DicomTag.TestPatternCodeSequence = "0028702C";
    DicomTag.MeasurementPatternCodeSequence = "0028702D";
    DicomTag.VisualEvaluationMethodCodeSequence = "0028702E";
    DicomTag.PixelDataProviderURL = "00287FE0";
    DicomTag.DataPointRows = "00289001";
    DicomTag.DataPointColumns = "00289002";
    DicomTag.SignalDomainColumns = "00289003";
    DicomTag.LargestMonochromePixelValue = "00289099"; // Retired
    DicomTag.DataRepresentation = "00289108";
    DicomTag.PixelMeasuresSequence = "00289110";
    DicomTag.FrameVOILUTSequence = "00289132";
    DicomTag.PixelValueTransformationSequence = "00289145";
    DicomTag.SignalDomainRows = "00289235";
    DicomTag.DisplayFilterPercentage = "00289411";
    DicomTag.FramePixelShiftSequence = "00289415";
    DicomTag.SubtractionItemID = "00289416";
    DicomTag.PixelIntensityRelationshipLUTSequence = "00289422";
    DicomTag.FramePixelDataPropertiesSequence = "00289443";
    DicomTag.GeometricalProperties = "00289444";
    DicomTag.GeometricMaximumDistortion = "00289445";
    DicomTag.ImageProcessingApplied = "00289446";
    DicomTag.MaskSelectionMode = "00289454";
    DicomTag.LUTFunction = "00289474";
    DicomTag.MaskVisibilityPercentage = "00289478";
    DicomTag.PixelShiftSequence = "00289501";
    DicomTag.RegionPixelShiftSequence = "00289502";
    DicomTag.VerticesOfTheRegion = "00289503";
    DicomTag.MultiFramePresentationSequence = "00289505";
    DicomTag.PixelShiftFrameRange = "00289506";
    DicomTag.LUTFrameRange = "00289507";
    DicomTag.ImageToEquipmentMappingMatrix = "00289520";
    DicomTag.EquipmentCoordinateSystemIdentification = "00289537";
    // *****************************************************************************************************************************
    // *** 0032
    // *****************************************************************************************************************************
    DicomTag.StudyStatusID = "0032000A"; // Retired
    DicomTag.StudyPriorityID = "0032000C"; // Retired
    DicomTag.StudyIDIssuer = "00320012"; // Retired
    DicomTag.StudyVerifiedDate = "00320032"; // Retired
    DicomTag.StudyVerifiedTime = "00320033"; // Retired
    DicomTag.StudyReadDate = "00320034"; // Retired
    DicomTag.StudyReadTime = "00320035"; // Retired
    DicomTag.ScheduledStudyStartDate = "00321000"; // Retired
    DicomTag.ScheduledStudyStartTime = "00321001"; // Retired
    DicomTag.ScheduledStudyStopDate = "00321010"; // Retired
    DicomTag.ScheduledStudyStopTime = "00321011"; // Retired
    DicomTag.ScheduledStudyLocation = "00321020"; // Retired
    DicomTag.ScheduledStudyLocationAETitle = "00321021"; // Retired
    DicomTag.ReasonForStudy = "00321030"; // Retired
    DicomTag.RequestingPhysicianIdentificationSequence = "00321031";
    DicomTag.RequestingPhysician = "00321032";
    DicomTag.RequestingService = "00321033";
    DicomTag.RequestingServiceCodeSequence = "00321034";
    DicomTag.StudyArrivalDate = "00321040"; // Retired
    DicomTag.StudyArrivalTime = "00321041"; // Retired
    DicomTag.StudyCompletionDate = "00321050"; // Retired
    DicomTag.StudyCompletionTime = "00321051"; // Retired
    DicomTag.StudyComponentStatusID = "00321055"; // Retired
    DicomTag.RequestedProcedureDescription = "00321060";
    DicomTag.RequestedProcedureCodeSequence = "00321064";
    DicomTag.RequestedContrastAgent = "00321070";
    DicomTag.StudyComments = "00324000"; // Retired
    // *****************************************************************************************************************************
    // *** 0038
    // *****************************************************************************************************************************
    DicomTag.ReferencedPatientAliasSequence = "00380004";
    DicomTag.VisitStatusID = "00380008";
    DicomTag.AdmissionID = "00380010";
    DicomTag.IssuerOfAdmissionID = "00380011"; // Retired
    DicomTag.IssuerOfAdmissionIDSequence = "00380014";
    DicomTag.RouteOfAdmissions = "00380016";
    DicomTag.ScheduledAdmissionDate = "0038001A"; // Retired
    DicomTag.ScheduledAdmissionTime = "0038001B"; // Retired
    DicomTag.ScheduledDischargeDate = "0038001C"; // Retired
    DicomTag.ScheduledDischargeTime = "0038001D"; // Retired
    DicomTag.ScheduledPatientInstitutionResidence = "0038001E"; // Retired
    DicomTag.AdmittingDate = "00380020";
    DicomTag.AdmittingTime = "00380021";
    DicomTag.DischargeDate = "00380030"; // Retired
    DicomTag.DischargeTime = "00380032"; // Retired
    DicomTag.DischargeDiagnosisDescription = "00380040"; // Retired
    DicomTag.DischargeDiagnosisCodeSequence = "00380044"; // Retired
    DicomTag.SpecialNeeds = "00380050";
    DicomTag.ServiceEpisodeID = "00380060";
    DicomTag.IssuerOfServiceEpisodeID = "00380061"; // Retired
    DicomTag.ServiceEpisodeDescription = "00380062";
    DicomTag.IssuerOfServiceEpisodeIDSequence = "00380064";
    DicomTag.PertinentDocumentsSequence = "00380100";
    DicomTag.PertinentResourcesSequence = "00380101";
    DicomTag.ResourceDescription = "00380102";
    DicomTag.CurrentPatientLocation = "00380300";
    DicomTag.PatientInstitutionResidence = "00380400";
    DicomTag.PatientState = "00380500";
    DicomTag.PatientClinicalTrialParticipationSequence = "00380502";
    DicomTag.VisitComments = "00384000";
    // *****************************************************************************************************************************
    // *** 003A
    // *****************************************************************************************************************************
    DicomTag.WaveformOriginality = "003A0004";
    DicomTag.NumberOfWaveformChannels = "003A0005";
    DicomTag.NumberOfWaveformSamples = "003A0010";
    DicomTag.SamplingFrequency = "003A001A";
    DicomTag.MultiplexGroupLabel = "003A0020";
    DicomTag.ChannelDefinitionSequence = "003A0200";
    DicomTag.WaveformChannelNumber = "003A0202";
    DicomTag.ChannelLabel = "003A0203";
    DicomTag.ChannelStatus = "003A0205";
    DicomTag.ChannelSourceSequence = "003A0208";
    DicomTag.ChannelSourceModifiersSequence = "003A0209";
    DicomTag.SourceWaveformSequence = "003A020A";
    DicomTag.ChannelDerivationDescription = "003A020C";
    DicomTag.ChannelSensitivity = "003A0210";
    DicomTag.ChannelSensitivityUnitsSequence = "003A0211";
    DicomTag.ChannelSensitivityCorrectionFactor = "003A0212";
    DicomTag.ChannelBaseline = "003A0213";
    DicomTag.ChannelTimeSkew = "003A0214";
    DicomTag.ChannelSampleSkew = "003A0215";
    DicomTag.ChannelOffset = "003A0218";
    DicomTag.WaveformBitsStored = "003A021A";
    DicomTag.FilterLowFrequency = "003A0220";
    DicomTag.FilterHighFrequency = "003A0221";
    DicomTag.NotchFilterFrequency = "003A0222";
    DicomTag.NotchFilterBandwidth = "003A0223";
    DicomTag.WaveformDataDisplayScale = "003A0230";
    DicomTag.WaveformDisplayBackgroundCIELabValue = "003A0231";
    DicomTag.WaveformPresentationGroupSequence = "003A0240";
    DicomTag.PresentationGroupNumber = "003A0241";
    DicomTag.ChannelDisplaySequence = "003A0242";
    DicomTag.ChannelRecommendedDisplayCIELabValue = "003A0244";
    DicomTag.ChannelPosition = "003A0245";
    DicomTag.DisplayShadingFlag = "003A0246";
    DicomTag.FractionalChannelDisplayScale = "003A0247";
    DicomTag.AbsoluteChannelDisplayScale = "003A0248";
    DicomTag.MultiplexedAudioChannelsDescriptionCodeSequence = "003A0300";
    DicomTag.ChannelIdentificationCode = "003A0301";
    DicomTag.ChannelMode = "003A0302";
    // *****************************************************************************************************************************
    // *** 0040
    // *****************************************************************************************************************************
    DicomTag.ScheduledStationAETitle = "00400001";
    DicomTag.ScheduledProcedureStepStartDate = "00400002";
    DicomTag.ScheduledProcedureStepStartTime = "00400003";
    DicomTag.ScheduledProcedureStepEndDate = "00400004";
    DicomTag.ScheduledProcedureStepEndTime = "00400005";
    DicomTag.ScheduledPerformingPhysicianName = "00400006";
    DicomTag.ScheduledProcedureStepDescription = "00400007";
    DicomTag.ScheduledProtocolCodeSequence = "00400008";
    DicomTag.ScheduledProcedureStepID = "00400009";
    DicomTag.StageCodeSequence = "0040000A";
    DicomTag.ScheduledPerformingPhysicianIdentificationSequence = "0040000B";
    DicomTag.ScheduledStationName = "00400010";
    DicomTag.ScheduledProcedureStepLocation = "00400011";
    DicomTag.PreMedication = "00400012";
    DicomTag.ScheduledProcedureStepStatus = "00400020";
    DicomTag.OrderPlacerIdentifierSequence = "00400026";
    DicomTag.OrderFillerIdentifierSequence = "00400027";
    DicomTag.LocalNamespaceEntityID = "00400031";
    DicomTag.UniversalEntityID = "00400032";
    DicomTag.UniversalEntityIDType = "00400033";
    DicomTag.IdentifierTypeCode = "00400035";
    DicomTag.AssigningFacilitySequence = "00400036";
    DicomTag.AssigningJurisdictionCodeSequence = "00400039";
    DicomTag.AssigningAgencyOrDepartmentCodeSequence = "0040003A";
    DicomTag.ScheduledProcedureStepSequence = "00400100";
    DicomTag.ReferencedNonImageCompositeSOPInstanceSequence = "00400220";
    DicomTag.PerformedStationAETitle = "00400241";
    DicomTag.PerformedStationName = "00400242";
    DicomTag.PerformedLocation = "00400243";
    DicomTag.PerformedProcedureStepStartDate = "00400244";
    DicomTag.PerformedProcedureStepStartTime = "00400245";
    DicomTag.PerformedProcedureStepEndDate = "00400250";
    DicomTag.PerformedProcedureStepEndTime = "00400251";
    DicomTag.PerformedProcedureStepStatus = "00400252";
    DicomTag.PerformedProcedureStepID = "00400253";
    DicomTag.PerformedProcedureStepDescription = "00400254";
    DicomTag.PerformedProcedureTypeDescription = "00400255";
    DicomTag.PerformedProtocolCodeSequence = "00400260";
    DicomTag.PerformedProtocolType = "00400261";
    DicomTag.ScheduledStepAttributesSequence = "00400270";
    DicomTag.RequestAttributesSequence = "00400275";
    DicomTag.CommentsOnThePerformedProcedureStep = "00400280";
    DicomTag.PerformedProcedureStepDiscontinuationReasonCodeSequence = "00400281";
    DicomTag.QuantitySequence = "00400293";
    DicomTag.Quantity = "00400294";
    DicomTag.MeasuringUnitsSequence = "00400295";
    DicomTag.BillingItemSequence = "00400296";
    DicomTag.TotalTimeOfFluoroscopy = "00400300";
    DicomTag.TotalNumberOfExposures = "00400301";
    DicomTag.EntranceDose = "00400302";
    DicomTag.ExposedArea = "00400303";
    DicomTag.DistanceSourceToEntrance = "00400306";
    DicomTag.DistanceSourceToSupport = "00400307"; // Retired
    DicomTag.ExposureDoseSequence = "0040030E";
    DicomTag.CommentsOnRadiationDose = "00400310";
    DicomTag.XRayOutput = "00400312";
    DicomTag.HalfValueLayer = "00400314";
    DicomTag.OrganDose = "00400316";
    DicomTag.OrganExposed = "00400318";
    DicomTag.BillingProcedureStepSequence = "00400320";
    DicomTag.FilmConsumptionSequence = "00400321";
    DicomTag.BillingSuppliesAndDevicesSequence = "00400324";
    DicomTag.ReferencedProcedureStepSequence = "00400330"; // Retired
    DicomTag.PerformedSeriesSequence = "00400340";
    DicomTag.CommentsOnTheScheduledProcedureStep = "00400400";
    DicomTag.ProtocolContextSequence = "00400440";
    DicomTag.ContentItemModifierSequence = "00400441";
    DicomTag.ScheduledSpecimenSequence = "00400500";
    DicomTag.SpecimenAccessionNumber = "0040050A"; // Retired
    DicomTag.ContainerIdentifier = "00400512";
    DicomTag.IssuerOfTheContainerIdentifierSequence = "00400513";
    DicomTag.AlternateContainerIdentifierSequence = "00400515";
    DicomTag.ContainerTypeCodeSequence = "00400518";
    DicomTag.ContainerDescription = "0040051A";
    DicomTag.ContainerComponentSequence = "00400520";
    DicomTag.SpecimenSequence = "00400550"; // Retired
    DicomTag.SpecimenIdentifier = "00400551";
    DicomTag.SpecimenDescriptionSequenceTrial = "00400552"; // Retired
    DicomTag.SpecimenDescriptionTrial = "00400553"; // Retired
    DicomTag.SpecimenUID = "00400554";
    DicomTag.AcquisitionContextSequence = "00400555";
    DicomTag.AcquisitionContextDescription = "00400556";
    DicomTag.SpecimenDescriptionSequence = "00400560";
    DicomTag.IssuerOfTheSpecimenIdentifierSequence = "00400562";
    DicomTag.SpecimenTypeCodeSequence = "0040059A";
    DicomTag.SpecimenShortDescription = "00400600";
    DicomTag.SpecimenDetailedDescription = "00400602";
    DicomTag.SpecimenPreparationSequence = "00400610";
    DicomTag.SpecimenPreparationStepContentItemSequence = "00400612";
    DicomTag.SpecimenLocalizationContentItemSequence = "00400620";
    DicomTag.SlideIdentifier = "004006FA"; // Retired
    DicomTag.ImageCenterPointCoordinatesSequence = "0040071A";
    DicomTag.XOffsetInSlideCoordinateSystem = "0040072A";
    DicomTag.YOffsetInSlideCoordinateSystem = "0040073A";
    DicomTag.ZOffsetInSlideCoordinateSystem = "0040074A";
    DicomTag.PixelSpacingSequence = "004008D8"; // Retired
    DicomTag.CoordinateSystemAxisCodeSequence = "004008DA"; // Retired
    DicomTag.MeasurementUnitsCodeSequence = "004008EA";
    DicomTag.VitalStainCodeSequenceTrial = "004009F8"; // Retired
    DicomTag.RequestedProcedureID = "00401001";
    DicomTag.ReasonForTheRequestedProcedure = "00401002";
    DicomTag.RequestedProcedurePriority = "00401003";
    DicomTag.PatientTransportArrangements = "00401004";
    DicomTag.RequestedProcedureLocation = "00401005";
    DicomTag.PlacerOrderNumberProcedure = "00401006"; // Retired
    DicomTag.FillerOrderNumberProcedure = "00401007"; // Retired
    DicomTag.ConfidentialityCode = "00401008";
    DicomTag.ReportingPriority = "00401009";
    DicomTag.ReasonForRequestedProcedureCodeSequence = "0040100A";
    DicomTag.NamesOfIntendedRecipientsOfResults = "00401010";
    DicomTag.IntendedRecipientsOfResultsIdentificationSequence = "00401011";
    DicomTag.ReasonForPerformedProcedureCodeSequence = "00401012";
    DicomTag.RequestedProcedureDescriptionTrial = "00401060"; // Retired
    DicomTag.PersonIdentificationCodeSequence = "00401101";
    DicomTag.PersonAddress = "00401102";
    DicomTag.PersonTelephoneNumbers = "00401103";
    DicomTag.PersonTelecomInformation = "00401104";
    DicomTag.RequestedProcedureComments = "00401400";
    DicomTag.ReasonForTheImagingServiceRequest = "00402001"; // Retired
    DicomTag.IssueDateOfImagingServiceRequest = "00402004";
    DicomTag.IssueTimeOfImagingServiceRequest = "00402005";
    DicomTag.PlacerOrderNumberImagingServiceRequestRetired = "00402006"; // Retired
    DicomTag.FillerOrderNumberImagingServiceRequestRetired = "00402007"; // Retired
    DicomTag.OrderEnteredBy = "00402008";
    DicomTag.OrderEntererLocation = "00402009";
    DicomTag.OrderCallbackPhoneNumber = "00402010";
    DicomTag.OrderCallbackTelecomInformation = "00402011";
    DicomTag.PlacerOrderNumberImagingServiceRequest = "00402016";
    DicomTag.FillerOrderNumberImagingServiceRequest = "00402017";
    DicomTag.ImagingServiceRequestComments = "00402400";
    DicomTag.ConfidentialityConstraintOnPatientDataDescription = "00403001";
    DicomTag.GeneralPurposeScheduledProcedureStepStatus = "00404001"; // Retired
    DicomTag.GeneralPurposePerformedProcedureStepStatus = "00404002"; // Retired
    DicomTag.GeneralPurposeScheduledProcedureStepPriority = "00404003"; // Retired
    DicomTag.ScheduledProcessingApplicationsCodeSequence = "00404004"; // Retired
    DicomTag.ScheduledProcedureStepStartDateTime = "00404005";
    DicomTag.MultipleCopiesFlag = "00404006"; // Retired
    DicomTag.PerformedProcessingApplicationsCodeSequence = "00404007";
    DicomTag.HumanPerformerCodeSequence = "00404009";
    DicomTag.ScheduledProcedureStepModificationDateTime = "00404010";
    DicomTag.ExpectedCompletionDateTime = "00404011";
    DicomTag.ResultingGeneralPurposePerformedProcedureStepsSequence = "00404015"; // Retired
    DicomTag.ReferencedGeneralPurposeScheduledProcedureStepSequence = "00404016"; // Retired
    DicomTag.ScheduledWorkitemCodeSequence = "00404018";
    DicomTag.PerformedWorkitemCodeSequence = "00404019";
    DicomTag.InputAvailabilityFlag = "00404020";
    DicomTag.InputInformationSequence = "00404021";
    DicomTag.RelevantInformationSequence = "00404022"; // Retired
    DicomTag.ReferencedGeneralPurposeScheduledProcedureStepTransactionUID = "00404023"; // Retired
    DicomTag.ScheduledStationNameCodeSequence = "00404025";
    DicomTag.ScheduledStationClassCodeSequence = "00404026";
    DicomTag.ScheduledStationGeographicLocationCodeSequence = "00404027";
    DicomTag.PerformedStationNameCodeSequence = "00404028";
    DicomTag.PerformedStationClassCodeSequence = "00404029";
    DicomTag.PerformedStationGeographicLocationCodeSequence = "00404030";
    DicomTag.RequestedSubsequentWorkitemCodeSequence = "00404031"; // Retired
    DicomTag.NonDICOMOutputCodeSequence = "00404032"; // Retired
    DicomTag.OutputInformationSequence = "00404033";
    DicomTag.ScheduledHumanPerformersSequence = "00404034";
    DicomTag.ActualHumanPerformersSequence = "00404035";
    DicomTag.HumanPerformerOrganization = "00404036";
    DicomTag.HumanPerformerName = "00404037";
    DicomTag.RawDataHandling = "00404040";
    DicomTag.InputReadinessState = "00404041";
    DicomTag.PerformedProcedureStepStartDateTime = "00404050";
    DicomTag.PerformedProcedureStepEndDateTime = "00404051";
    DicomTag.ProcedureStepCancellationDateTime = "00404052";
    DicomTag.EntranceDoseInMGy = "00408302";
    DicomTag.ParametricMapFrameTypeSequence = "00409092";
    DicomTag.ReferencedImageRealWorldValueMappingSequence = "00409094";
    DicomTag.RealWorldValueMappingSequence = "00409096";
    DicomTag.PixelValueMappingCodeSequence = "00409098";
    DicomTag.LUTLabel = "00409210";
    DicomTag.RealWorldValueLastValueMapped = "00409211";
    DicomTag.RealWorldValueLUTData = "00409212";
    DicomTag.RealWorldValueFirstValueMapped = "00409216";
    DicomTag.QuantityDefinitionSequence = "00409220";
    DicomTag.RealWorldValueIntercept = "00409224";
    DicomTag.RealWorldValueSlope = "00409225";
    DicomTag.FindingsFlagTrial = "0040A007"; // Retired
    DicomTag.RelationshipType = "0040A010";
    DicomTag.FindingsSequenceTrial = "0040A020"; // Retired
    DicomTag.FindingsGroupUIDTrial = "0040A021"; // Retired
    DicomTag.ReferencedFindingsGroupUIDTrial = "0040A022"; // Retired
    DicomTag.FindingsGroupRecordingDateTrial = "0040A023"; // Retired
    DicomTag.FindingsGroupRecordingTimeTrial = "0040A024"; // Retired
    DicomTag.FindingsSourceCategoryCodeSequenceTrial = "0040A026"; // Retired
    DicomTag.VerifyingOrganization = "0040A027";
    DicomTag.DocumentingOrganizationIdentifierCodeSequenceTrial = "0040A028"; // Retired
    DicomTag.VerificationDateTime = "0040A030";
    DicomTag.ObservationDateTime = "0040A032";
    DicomTag.ValueType = "0040A040";
    DicomTag.ConceptNameCodeSequence = "0040A043";
    DicomTag.MeasurementPrecisionDescriptionTrial = "0040A047"; // Retired
    DicomTag.ContinuityOfContent = "0040A050";
    DicomTag.UrgencyOrPriorityAlertsTrial = "0040A057"; // Retired
    DicomTag.SequencingIndicatorTrial = "0040A060"; // Retired
    DicomTag.DocumentIdentifierCodeSequenceTrial = "0040A066"; // Retired
    DicomTag.DocumentAuthorTrial = "0040A067"; // Retired
    DicomTag.DocumentAuthorIdentifierCodeSequenceTrial = "0040A068"; // Retired
    DicomTag.IdentifierCodeSequenceTrial = "0040A070"; // Retired
    DicomTag.VerifyingObserverSequence = "0040A073";
    DicomTag.ObjectBinaryIdentifierTrial = "0040A074"; // Retired
    DicomTag.VerifyingObserverName = "0040A075";
    DicomTag.DocumentingObserverIdentifierCodeSequenceTrial = "0040A076"; // Retired
    DicomTag.AuthorObserverSequence = "0040A078";
    DicomTag.ParticipantSequence = "0040A07A";
    DicomTag.CustodialOrganizationSequence = "0040A07C";
    DicomTag.ParticipationType = "0040A080";
    DicomTag.ParticipationDateTime = "0040A082";
    DicomTag.ObserverType = "0040A084";
    DicomTag.ProcedureIdentifierCodeSequenceTrial = "0040A085"; // Retired
    DicomTag.VerifyingObserverIdentificationCodeSequence = "0040A088";
    DicomTag.ObjectDirectoryBinaryIdentifierTrial = "0040A089"; // Retired
    DicomTag.EquivalentCDADocumentSequence = "0040A090"; // Retired
    DicomTag.ReferencedWaveformChannels = "0040A0B0";
    DicomTag.DateOfDocumentOrVerbalTransactionTrial = "0040A110"; // Retired
    DicomTag.TimeOfDocumentCreationOrVerbalTransactionTrial = "0040A112"; // Retired
    DicomTag.DateTime = "0040A120";
    DicomTag.Date = "0040A121";
    DicomTag.Time = "0040A122";
    DicomTag.PersonName = "0040A123";
    DicomTag.UID = "0040A124";
    DicomTag.ReportStatusIDTrial = "0040A125"; // Retired
    DicomTag.TemporalRangeType = "0040A130";
    DicomTag.ReferencedSamplePositions = "0040A132";
    DicomTag.ReferencedFrameNumbers = "0040A136";
    DicomTag.ReferencedTimeOffsets = "0040A138";
    DicomTag.ReferencedDateTime = "0040A13A";
    DicomTag.TextValue = "0040A160";
    DicomTag.FloatingPointValue = "0040A161";
    DicomTag.RationalNumeratorValue = "0040A162";
    DicomTag.RationalDenominatorValue = "0040A163";
    DicomTag.ObservationCategoryCodeSequenceTrial = "0040A167"; // Retired
    DicomTag.ConceptCodeSequence = "0040A168";
    DicomTag.BibliographicCitationTrial = "0040A16A"; // Retired
    DicomTag.PurposeOfReferenceCodeSequence = "0040A170";
    DicomTag.ObservationUID = "0040A171";
    DicomTag.ReferencedObservationUIDTrial = "0040A172"; // Retired
    DicomTag.ReferencedObservationClassTrial = "0040A173"; // Retired
    DicomTag.ReferencedObjectObservationClassTrial = "0040A174"; // Retired
    DicomTag.AnnotationGroupNumber = "0040A180";
    DicomTag.ObservationDateTrial = "0040A192"; // Retired
    DicomTag.ObservationTimeTrial = "0040A193"; // Retired
    DicomTag.MeasurementAutomationTrial = "0040A194"; // Retired
    DicomTag.ModifierCodeSequence = "0040A195";
    DicomTag.IdentificationDescriptionTrial = "0040A224"; // Retired
    DicomTag.CoordinatesSetGeometricTypeTrial = "0040A290"; // Retired
    DicomTag.AlgorithmCodeSequenceTrial = "0040A296"; // Retired
    DicomTag.AlgorithmDescriptionTrial = "0040A297"; // Retired
    DicomTag.PixelCoordinatesSetTrial = "0040A29A"; // Retired
    DicomTag.MeasuredValueSequence = "0040A300";
    DicomTag.NumericValueQualifierCodeSequence = "0040A301";
    DicomTag.CurrentObserverTrial = "0040A307"; // Retired
    DicomTag.NumericValue = "0040A30A";
    DicomTag.ReferencedAccessionSequenceTrial = "0040A313"; // Retired
    DicomTag.ReportStatusCommentTrial = "0040A33A"; // Retired
    DicomTag.ProcedureContextSequenceTrial = "0040A340"; // Retired
    DicomTag.VerbalSourceTrial = "0040A352"; // Retired
    DicomTag.AddressTrial = "0040A353"; // Retired
    DicomTag.TelephoneNumberTrial = "0040A354"; // Retired
    DicomTag.VerbalSourceIdentifierCodeSequenceTrial = "0040A358"; // Retired
    DicomTag.PredecessorDocumentsSequence = "0040A360";
    DicomTag.ReferencedRequestSequence = "0040A370";
    DicomTag.PerformedProcedureCodeSequence = "0040A372";
    DicomTag.CurrentRequestedProcedureEvidenceSequence = "0040A375";
    DicomTag.ReportDetailSequenceTrial = "0040A380"; // Retired
    DicomTag.PertinentOtherEvidenceSequence = "0040A385";
    DicomTag.HL7StructuredDocumentReferenceSequence = "0040A390";
    DicomTag.ObservationSubjectUIDTrial = "0040A402"; // Retired
    DicomTag.ObservationSubjectClassTrial = "0040A403"; // Retired
    DicomTag.ObservationSubjectTypeCodeSequenceTrial = "0040A404"; // Retired
    DicomTag.CompletionFlag = "0040A491";
    DicomTag.CompletionFlagDescription = "0040A492";
    DicomTag.VerificationFlag = "0040A493";
    DicomTag.ArchiveRequested = "0040A494";
    DicomTag.PreliminaryFlag = "0040A496";
    DicomTag.ContentTemplateSequence = "0040A504";
    DicomTag.IdenticalDocumentsSequence = "0040A525";
    DicomTag.ObservationSubjectContextFlagTrial = "0040A600"; // Retired
    DicomTag.ObserverContextFlagTrial = "0040A601"; // Retired
    DicomTag.ProcedureContextFlagTrial = "0040A603"; // Retired
    DicomTag.ContentSequence = "0040A730";
    DicomTag.RelationshipSequenceTrial = "0040A731"; // Retired
    DicomTag.RelationshipTypeCodeSequenceTrial = "0040A732"; // Retired
    DicomTag.LanguageCodeSequenceTrial = "0040A744"; // Retired
    DicomTag.UniformResourceLocatorTrial = "0040A992"; // Retired
    DicomTag.WaveformAnnotationSequence = "0040B020";
    DicomTag.TemplateIdentifier = "0040DB00";
    DicomTag.TemplateVersion = "0040DB06"; // Retired
    DicomTag.TemplateLocalVersion = "0040DB07"; // Retired
    DicomTag.TemplateExtensionFlag = "0040DB0B"; // Retired
    DicomTag.TemplateExtensionOrganizationUID = "0040DB0C"; // Retired
    DicomTag.TemplateExtensionCreatorUID = "0040DB0D"; // Retired
    DicomTag.ReferencedContentItemIdentifier = "0040DB73";
    DicomTag.HL7InstanceIdentifier = "0040E001";
    DicomTag.HL7DocumentEffectiveTime = "0040E004";
    DicomTag.HL7DocumentTypeCodeSequence = "0040E006";
    DicomTag.DocumentClassCodeSequence = "0040E008";
    DicomTag.RetrieveURI = "0040E010";
    DicomTag.RetrieveLocationUID = "0040E011";
    DicomTag.TypeOfInstances = "0040E020";
    DicomTag.DICOMRetrievalSequence = "0040E021";
    DicomTag.DICOMMediaRetrievalSequence = "0040E022";
    DicomTag.WADORetrievalSequence = "0040E023";
    DicomTag.XDSRetrievalSequence = "0040E024";
    DicomTag.WADORSRetrievalSequence = "0040E025";
    DicomTag.RepositoryUniqueID = "0040E030";
    DicomTag.HomeCommunityID = "0040E031";
    // *****************************************************************************************************************************
    // *** 0042
    // *****************************************************************************************************************************
    DicomTag.DocumentTitle = "00420010";
    DicomTag.EncapsulatedDocument = "00420011";
    DicomTag.MIMETypeOfEncapsulatedDocument = "00420012";
    DicomTag.SourceInstanceSequence = "00420013";
    DicomTag.ListOfMIMETypes = "00420014";
    // *****************************************************************************************************************************
    // *** 0044
    // *****************************************************************************************************************************
    DicomTag.ProductPackageIdentifier = "00440001";
    DicomTag.SubstanceAdministrationApproval = "00440002";
    DicomTag.ApprovalStatusFurtherDescription = "00440003";
    DicomTag.ApprovalStatusDateTime = "00440004";
    DicomTag.ProductTypeCodeSequence = "00440007";
    DicomTag.ProductName = "00440008";
    DicomTag.ProductDescription = "00440009";
    DicomTag.ProductLotIdentifier = "0044000A";
    DicomTag.ProductExpirationDateTime = "0044000B";
    DicomTag.SubstanceAdministrationDateTime = "00440010";
    DicomTag.SubstanceAdministrationNotes = "00440011";
    DicomTag.SubstanceAdministrationDeviceID = "00440012";
    DicomTag.ProductParameterSequence = "00440013";
    DicomTag.SubstanceAdministrationParameterSequence = "00440019";
    // *****************************************************************************************************************************
    // *** 0046
    // *****************************************************************************************************************************
    DicomTag.LensDescription = "00460012";
    DicomTag.RightLensSequence = "00460014";
    DicomTag.LeftLensSequence = "00460015";
    DicomTag.UnspecifiedLateralityLensSequence = "00460016";
    DicomTag.CylinderSequence = "00460018";
    DicomTag.PrismSequence = "00460028";
    DicomTag.HorizontalPrismPower = "00460030";
    DicomTag.HorizontalPrismBase = "00460032";
    DicomTag.VerticalPrismPower = "00460034";
    DicomTag.VerticalPrismBase = "00460036";
    DicomTag.LensSegmentType = "00460038";
    DicomTag.OpticalTransmittance = "00460040";
    DicomTag.ChannelWidth = "00460042";
    DicomTag.PupilSize = "00460044";
    DicomTag.CornealSize = "00460046";
    DicomTag.AutorefractionRightEyeSequence = "00460050";
    DicomTag.AutorefractionLeftEyeSequence = "00460052";
    DicomTag.DistancePupillaryDistance = "00460060";
    DicomTag.NearPupillaryDistance = "00460062";
    DicomTag.IntermediatePupillaryDistance = "00460063";
    DicomTag.OtherPupillaryDistance = "00460064";
    DicomTag.KeratometryRightEyeSequence = "00460070";
    DicomTag.KeratometryLeftEyeSequence = "00460071";
    DicomTag.SteepKeratometricAxisSequence = "00460074";
    DicomTag.RadiusOfCurvature = "00460075";
    DicomTag.KeratometricPower = "00460076";
    DicomTag.KeratometricAxis = "00460077";
    DicomTag.FlatKeratometricAxisSequence = "00460080";
    DicomTag.BackgroundColor = "00460092";
    DicomTag.Optotype = "00460094";
    DicomTag.OptotypePresentation = "00460095";
    DicomTag.SubjectiveRefractionRightEyeSequence = "00460097";
    DicomTag.SubjectiveRefractionLeftEyeSequence = "00460098";
    DicomTag.AddNearSequence = "00460100";
    DicomTag.AddIntermediateSequence = "00460101";
    DicomTag.AddOtherSequence = "00460102";
    DicomTag.AddPower = "00460104";
    DicomTag.ViewingDistance = "00460106";
    DicomTag.VisualAcuityTypeCodeSequence = "00460121";
    DicomTag.VisualAcuityRightEyeSequence = "00460122";
    DicomTag.VisualAcuityLeftEyeSequence = "00460123";
    DicomTag.VisualAcuityBothEyesOpenSequence = "00460124";
    DicomTag.ViewingDistanceType = "00460125";
    DicomTag.VisualAcuityModifiers = "00460135";
    DicomTag.DecimalVisualAcuity = "00460137";
    DicomTag.OptotypeDetailedDefinition = "00460139";
    DicomTag.ReferencedRefractiveMeasurementsSequence = "00460145";
    DicomTag.SpherePower = "00460146";
    DicomTag.CylinderPower = "00460147";
    DicomTag.CornealTopographySurface = "00460201";
    DicomTag.CornealVertexLocation = "00460202";
    DicomTag.PupilCentroidXCoordinate = "00460203";
    DicomTag.PupilCentroidYCoordinate = "00460204";
    DicomTag.EquivalentPupilRadius = "00460205";
    DicomTag.CornealTopographyMapTypeCodeSequence = "00460207";
    DicomTag.VerticesOfTheOutlineOfPupil = "00460208";
    DicomTag.CornealTopographyMappingNormalsSequence = "00460210";
    DicomTag.MaximumCornealCurvatureSequence = "00460211";
    DicomTag.MaximumCornealCurvature = "00460212";
    DicomTag.MaximumCornealCurvatureLocation = "00460213";
    DicomTag.MinimumKeratometricSequence = "00460215";
    DicomTag.SimulatedKeratometricCylinderSequence = "00460218";
    DicomTag.AverageCornealPower = "00460220";
    DicomTag.CornealISValue = "00460224";
    DicomTag.AnalyzedArea = "00460227";
    DicomTag.SurfaceRegularityIndex = "00460230";
    DicomTag.SurfaceAsymmetryIndex = "00460232";
    DicomTag.CornealEccentricityIndex = "00460234";
    DicomTag.KeratoconusPredictionIndex = "00460236";
    DicomTag.DecimalPotentialVisualAcuity = "00460238";
    DicomTag.CornealTopographyMapQualityEvaluation = "00460242";
    DicomTag.SourceImageCornealProcessedDataSequence = "00460244";
    DicomTag.CornealPointLocation = "00460247";
    DicomTag.CornealPointEstimated = "00460248";
    DicomTag.AxialPower = "00460249";
    DicomTag.TangentialPower = "00460250";
    DicomTag.RefractivePower = "00460251";
    DicomTag.RelativeElevation = "00460252";
    DicomTag.CornealWavefront = "00460253";
    // *****************************************************************************************************************************
    // *** 0048
    // *****************************************************************************************************************************
    DicomTag.ImagedVolumeWidth = "00480001";
    DicomTag.ImagedVolumeHeight = "00480002";
    DicomTag.ImagedVolumeDepth = "00480003";
    DicomTag.TotalPixelMatrixColumns = "00480006";
    DicomTag.TotalPixelMatrixRows = "00480007";
    DicomTag.TotalPixelMatrixOriginSequence = "00480008";
    DicomTag.SpecimenLabelInImage = "00480010";
    DicomTag.FocusMethod = "00480011";
    DicomTag.ExtendedDepthOfField = "00480012";
    DicomTag.NumberOfFocalPlanes = "00480013";
    DicomTag.DistanceBetweenFocalPlanes = "00480014";
    DicomTag.RecommendedAbsentPixelCIELabValue = "00480015";
    DicomTag.IlluminatorTypeCodeSequence = "00480100";
    DicomTag.ImageOrientationSlide = "00480102";
    DicomTag.OpticalPathSequence = "00480105";
    DicomTag.OpticalPathIdentifier = "00480106";
    DicomTag.OpticalPathDescription = "00480107";
    DicomTag.IlluminationColorCodeSequence = "00480108";
    DicomTag.SpecimenReferenceSequence = "00480110";
    DicomTag.CondenserLensPower = "00480111";
    DicomTag.ObjectiveLensPower = "00480112";
    DicomTag.ObjectiveLensNumericalAperture = "00480113";
    DicomTag.PaletteColorLookupTableSequence = "00480120";
    DicomTag.ReferencedImageNavigationSequence = "00480200";
    DicomTag.TopLeftHandCornerOfLocalizerArea = "00480201";
    DicomTag.BottomRightHandCornerOfLocalizerArea = "00480202";
    DicomTag.OpticalPathIdentificationSequence = "00480207";
    DicomTag.PlanePositionSlideSequence = "0048021A";
    DicomTag.ColumnPositionInTotalImagePixelMatrix = "0048021E";
    DicomTag.RowPositionInTotalImagePixelMatrix = "0048021F";
    DicomTag.PixelOriginInterpretation = "00480301";
    // *****************************************************************************************************************************
    // *** 0050
    // *****************************************************************************************************************************
    DicomTag.CalibrationImage = "00500004";
    DicomTag.DeviceSequence = "00500010";
    DicomTag.ContainerComponentTypeCodeSequence = "00500012";
    DicomTag.ContainerComponentThickness = "00500013";
    DicomTag.DeviceLength = "00500014";
    DicomTag.ContainerComponentWidth = "00500015";
    DicomTag.DeviceDiameter = "00500016";
    DicomTag.DeviceDiameterUnits = "00500017";
    DicomTag.DeviceVolume = "00500018";
    DicomTag.IntermarkerDistance = "00500019";
    DicomTag.ContainerComponentMaterial = "0050001A";
    DicomTag.ContainerComponentID = "0050001B";
    DicomTag.ContainerComponentLength = "0050001C";
    DicomTag.ContainerComponentDiameter = "0050001D";
    DicomTag.ContainerComponentDescription = "0050001E";
    DicomTag.DeviceDescription = "00500020";
    // *****************************************************************************************************************************
    // *** 0052
    // *****************************************************************************************************************************
    DicomTag.ContrastBolusIngredientPercentByVolume = "00520001";
    DicomTag.OCTFocalDistance = "00520002";
    DicomTag.BeamSpotSize = "00520003";
    DicomTag.EffectiveRefractiveIndex = "00520004";
    DicomTag.OCTAcquisitionDomain = "00520006";
    DicomTag.OCTOpticalCenterWavelength = "00520007";
    DicomTag.AxialResolution = "00520008";
    DicomTag.RangingDepth = "00520009";
    DicomTag.ALineRate = "00520011";
    DicomTag.ALinesPerFrame = "00520012";
    DicomTag.CatheterRotationalRate = "00520013";
    DicomTag.ALinePixelSpacing = "00520014";
    DicomTag.ModeOfPercutaneousAccessSequence = "00520016";
    DicomTag.IntravascularOCTFrameTypeSequence = "00520025";
    DicomTag.OCTZOffsetApplied = "00520026";
    DicomTag.IntravascularFrameContentSequence = "00520027";
    DicomTag.IntravascularLongitudinalDistance = "00520028";
    DicomTag.IntravascularOCTFrameContentSequence = "00520029";
    DicomTag.OCTZOffsetCorrection = "00520030";
    DicomTag.CatheterDirectionOfRotation = "00520031";
    DicomTag.SeamLineLocation = "00520033";
    DicomTag.FirstALineLocation = "00520034";
    DicomTag.SeamLineIndex = "00520036";
    DicomTag.NumberOfPaddedALines = "00520038";
    DicomTag.InterpolationType = "00520039";
    DicomTag.RefractiveIndexApplied = "0052003A";
    // *****************************************************************************************************************************
    // *** 0054
    // *****************************************************************************************************************************
    DicomTag.EnergyWindowVector = "00540010";
    DicomTag.NumberOfEnergyWindows = "00540011";
    DicomTag.EnergyWindowInformationSequence = "00540012";
    DicomTag.EnergyWindowRangeSequence = "00540013";
    DicomTag.EnergyWindowLowerLimit = "00540014";
    DicomTag.EnergyWindowUpperLimit = "00540015";
    DicomTag.RadiopharmaceuticalInformationSequence = "00540016";
    DicomTag.ResidualSyringeCounts = "00540017";
    DicomTag.EnergyWindowName = "00540018";
    DicomTag.DetectorVector = "00540020";
    DicomTag.NumberOfDetectors = "00540021";
    DicomTag.DetectorInformationSequence = "00540022";
    DicomTag.PhaseVector = "00540030";
    DicomTag.NumberOfPhases = "00540031";
    DicomTag.PhaseInformationSequence = "00540032";
    DicomTag.NumberOfFramesInPhase = "00540033";
    DicomTag.PhaseDelay = "00540036";
    DicomTag.PauseBetweenFrames = "00540038";
    DicomTag.PhaseDescription = "00540039";
    DicomTag.RotationVector = "00540050";
    DicomTag.NumberOfRotations = "00540051";
    DicomTag.RotationInformationSequence = "00540052";
    DicomTag.NumberOfFramesInRotation = "00540053";
    DicomTag.RRIntervalVector = "00540060";
    DicomTag.NumberOfRRIntervals = "00540061";
    DicomTag.GatedInformationSequence = "00540062";
    DicomTag.DataInformationSequence = "00540063";
    DicomTag.TimeSlotVector = "00540070";
    DicomTag.NumberOfTimeSlots = "00540071";
    DicomTag.TimeSlotInformationSequence = "00540072";
    DicomTag.TimeSlotTime = "00540073";
    DicomTag.SliceVector = "00540080";
    DicomTag.NumberOfSlices = "00540081";
    DicomTag.AngularViewVector = "00540090";
    DicomTag.TimeSliceVector = "00540100";
    DicomTag.NumberOfTimeSlices = "00540101";
    DicomTag.StartAngle = "00540200";
    DicomTag.TypeOfDetectorMotion = "00540202";
    DicomTag.TriggerVector = "00540210";
    DicomTag.NumberOfTriggersInPhase = "00540211";
    DicomTag.ViewCodeSequence = "00540220";
    DicomTag.ViewModifierCodeSequence = "00540222";
    DicomTag.RadionuclideCodeSequence = "00540300";
    DicomTag.AdministrationRouteCodeSequence = "00540302";
    DicomTag.RadiopharmaceuticalCodeSequence = "00540304";
    DicomTag.CalibrationDataSequence = "00540306";
    DicomTag.EnergyWindowNumber = "00540308";
    DicomTag.ImageID = "00540400";
    DicomTag.PatientOrientationCodeSequence = "00540410";
    DicomTag.PatientOrientationModifierCodeSequence = "00540412";
    DicomTag.PatientGantryRelationshipCodeSequence = "00540414";
    DicomTag.SliceProgressionDirection = "00540500";
    DicomTag.ScanProgressionDirection = "00540501";
    DicomTag.SeriesType = "00541000";
    DicomTag.Units = "00541001";
    DicomTag.CountsSource = "00541002";
    DicomTag.ReprojectionMethod = "00541004";
    DicomTag.SUVType = "00541006";
    DicomTag.RandomsCorrectionMethod = "00541100";
    DicomTag.AttenuationCorrectionMethod = "00541101";
    DicomTag.DecayCorrection = "00541102";
    DicomTag.ReconstructionMethod = "00541103";
    DicomTag.DetectorLinesOfResponseUsed = "00541104";
    DicomTag.ScatterCorrectionMethod = "00541105";
    DicomTag.AxialAcceptance = "00541200";
    DicomTag.AxialMash = "00541201";
    DicomTag.TransverseMash = "00541202";
    DicomTag.DetectorElementSize = "00541203";
    DicomTag.CoincidenceWindowWidth = "00541210";
    DicomTag.SecondaryCountsType = "00541220";
    DicomTag.FrameReferenceTime = "00541300";
    DicomTag.PrimaryPromptsCountsAccumulated = "00541310";
    DicomTag.SecondaryCountsAccumulated = "00541311";
    DicomTag.SliceSensitivityFactor = "00541320";
    DicomTag.DecayFactor = "00541321";
    DicomTag.DoseCalibrationFactor = "00541322";
    DicomTag.ScatterFractionFactor = "00541323";
    DicomTag.DeadTimeFactor = "00541324";
    DicomTag.ImageIndex = "00541330";
    DicomTag.CountsIncluded = "00541400"; // Retired
    DicomTag.DeadTimeCorrectionFlag = "00541401"; // Retired
    // *****************************************************************************************************************************
    // *** 0060
    // *****************************************************************************************************************************
    DicomTag.HistogramSequence = "00603000";
    DicomTag.HistogramNumberOfBins = "00603002";
    DicomTag.HistogramFirstBinValue = "00603004";
    DicomTag.HistogramLastBinValue = "00603006";
    DicomTag.HistogramBinWidth = "00603008";
    DicomTag.HistogramExplanation = "00603010";
    DicomTag.HistogramData = "00603020";
    // *****************************************************************************************************************************
    // *** 0062
    // *****************************************************************************************************************************
    DicomTag.SegmentationType = "00620001";
    DicomTag.SegmentSequence = "00620002";
    DicomTag.SegmentedPropertyCategoryCodeSequence = "00620003";
    DicomTag.SegmentNumber = "00620004";
    DicomTag.SegmentLabel = "00620005";
    DicomTag.SegmentDescription = "00620006";
    DicomTag.SegmentAlgorithmType = "00620008";
    DicomTag.SegmentAlgorithmName = "00620009";
    DicomTag.SegmentIdentificationSequence = "0062000A";
    DicomTag.ReferencedSegmentNumber = "0062000B";
    DicomTag.RecommendedDisplayGrayscaleValue = "0062000C";
    DicomTag.RecommendedDisplayCIELabValue = "0062000D";
    DicomTag.MaximumFractionalValue = "0062000E";
    DicomTag.SegmentedPropertyTypeCodeSequence = "0062000F";
    DicomTag.SegmentationFractionalType = "00620010";
    DicomTag.SegmentedPropertyTypeModifierCodeSequence = "00620011";
    DicomTag.UsedSegmentsSequence = "00620012";
    // *****************************************************************************************************************************
    // *** 0064
    // *****************************************************************************************************************************
    DicomTag.DeformableRegistrationSequence = "00640002";
    DicomTag.SourceFrameOfReferenceUID = "00640003";
    DicomTag.DeformableRegistrationGridSequence = "00640005";
    DicomTag.GridDimensions = "00640007";
    DicomTag.GridResolution = "00640008";
    DicomTag.VectorGridData = "00640009";
    DicomTag.PreDeformationMatrixRegistrationSequence = "0064000F";
    DicomTag.PostDeformationMatrixRegistrationSequence = "00640010";
    // *****************************************************************************************************************************
    // *** 0066
    // *****************************************************************************************************************************
    DicomTag.NumberOfSurfaces = "00660001";
    DicomTag.SurfaceSequence = "00660002";
    DicomTag.SurfaceNumber = "00660003";
    DicomTag.SurfaceComments = "00660004";
    DicomTag.SurfaceProcessing = "00660009";
    DicomTag.SurfaceProcessingRatio = "0066000A";
    DicomTag.SurfaceProcessingDescription = "0066000B";
    DicomTag.RecommendedPresentationOpacity = "0066000C";
    DicomTag.RecommendedPresentationType = "0066000D";
    DicomTag.FiniteVolume = "0066000E";
    DicomTag.Manifold = "00660010";
    DicomTag.SurfacePointsSequence = "00660011";
    DicomTag.SurfacePointsNormalsSequence = "00660012";
    DicomTag.SurfaceMeshPrimitivesSequence = "00660013";
    DicomTag.NumberOfSurfacePoints = "00660015";
    DicomTag.PointCoordinatesData = "00660016";
    DicomTag.PointPositionAccuracy = "00660017";
    DicomTag.MeanPointDistance = "00660018";
    DicomTag.MaximumPointDistance = "00660019";
    DicomTag.PointsBoundingBoxCoordinates = "0066001A";
    DicomTag.AxisOfRotation = "0066001B";
    DicomTag.CenterOfRotation = "0066001C";
    DicomTag.NumberOfVectors = "0066001E";
    DicomTag.VectorDimensionality = "0066001F";
    DicomTag.VectorAccuracy = "00660020";
    DicomTag.VectorCoordinateData = "00660021";
    DicomTag.TrianglePointIndexList = "00660023";
    DicomTag.EdgePointIndexList = "00660024";
    DicomTag.VertexPointIndexList = "00660025";
    DicomTag.TriangleStripSequence = "00660026";
    DicomTag.TriangleFanSequence = "00660027";
    DicomTag.LineSequence = "00660028";
    DicomTag.PrimitivePointIndexList = "00660029";
    DicomTag.SurfaceCount = "0066002A";
    DicomTag.ReferencedSurfaceSequence = "0066002B";
    DicomTag.ReferencedSurfaceNumber = "0066002C";
    DicomTag.SegmentSurfaceGenerationAlgorithmIdentificationSequence = "0066002D";
    DicomTag.SegmentSurfaceSourceInstanceSequence = "0066002E";
    DicomTag.AlgorithmFamilyCodeSequence = "0066002F";
    DicomTag.AlgorithmNameCodeSequence = "00660030";
    DicomTag.AlgorithmVersion = "00660031";
    DicomTag.AlgorithmParameters = "00660032";
    DicomTag.FacetSequence = "00660034";
    DicomTag.SurfaceProcessingAlgorithmIdentificationSequence = "00660035";
    DicomTag.AlgorithmName = "00660036";
    DicomTag.RecommendedPointRadius = "00660037";
    DicomTag.RecommendedLineThickness = "00660038";
    DicomTag.LongPrimitivePointIndexList = "00660040";
    DicomTag.LongTrianglePointIndexList = "00660041";
    DicomTag.LongEdgePointIndexList = "00660042";
    DicomTag.LongVertexPointIndexList = "00660043";
    // *****************************************************************************************************************************
    // *** 0068
    // *****************************************************************************************************************************
    DicomTag.ImplantSize = "00686210";
    DicomTag.ImplantTemplateVersion = "00686221";
    DicomTag.ReplacedImplantTemplateSequence = "00686222";
    DicomTag.ImplantType = "00686223";
    DicomTag.DerivationImplantTemplateSequence = "00686224";
    DicomTag.OriginalImplantTemplateSequence = "00686225";
    DicomTag.EffectiveDateTime = "00686226";
    DicomTag.ImplantTargetAnatomySequence = "00686230";
    DicomTag.InformationFromManufacturerSequence = "00686260";
    DicomTag.NotificationFromManufacturerSequence = "00686265";
    DicomTag.InformationIssueDateTime = "00686270";
    DicomTag.InformationSummary = "00686280";
    DicomTag.ImplantRegulatoryDisapprovalCodeSequence = "006862A0";
    DicomTag.OverallTemplateSpatialTolerance = "006862A5";
    DicomTag.HPGLDocumentSequence = "006862C0";
    DicomTag.HPGLDocumentID = "006862D0";
    DicomTag.HPGLDocumentLabel = "006862D5";
    DicomTag.ViewOrientationCodeSequence = "006862E0";
    DicomTag.ViewOrientationModifier = "006862F0";
    DicomTag.HPGLDocumentScaling = "006862F2";
    DicomTag.HPGLDocument = "00686300";
    DicomTag.HPGLContourPenNumber = "00686310";
    DicomTag.HPGLPenSequence = "00686320";
    DicomTag.HPGLPenNumber = "00686330";
    DicomTag.HPGLPenLabel = "00686340";
    DicomTag.HPGLPenDescription = "00686345";
    DicomTag.RecommendedRotationPoint = "00686346";
    DicomTag.BoundingRectangle = "00686347";
    DicomTag.ImplantTemplate3DModelSurfaceNumber = "00686350";
    DicomTag.SurfaceModelDescriptionSequence = "00686360";
    DicomTag.SurfaceModelLabel = "00686380";
    DicomTag.SurfaceModelScalingFactor = "00686390";
    DicomTag.MaterialsCodeSequence = "006863A0";
    DicomTag.CoatingMaterialsCodeSequence = "006863A4";
    DicomTag.ImplantTypeCodeSequence = "006863A8";
    DicomTag.FixationMethodCodeSequence = "006863AC";
    DicomTag.MatingFeatureSetsSequence = "006863B0";
    DicomTag.MatingFeatureSetID = "006863C0";
    DicomTag.MatingFeatureSetLabel = "006863D0";
    DicomTag.MatingFeatureSequence = "006863E0";
    DicomTag.MatingFeatureID = "006863F0";
    DicomTag.MatingFeatureDegreeOfFreedomSequence = "00686400";
    DicomTag.DegreeOfFreedomID = "00686410";
    DicomTag.DegreeOfFreedomType = "00686420";
    DicomTag.TwoDMatingFeatureCoordinatesSequence = "00686430";
    DicomTag.ReferencedHPGLDocumentID = "00686440";
    DicomTag.TwoDMatingPoint = "00686450";
    DicomTag.TwoDMatingAxes = "00686460";
    DicomTag.TwoDDegreeOfFreedomSequence = "00686470";
    DicomTag.ThreeDDegreeOfFreedomAxis = "00686490";
    DicomTag.RangeOfFreedom = "006864A0";
    DicomTag.ThreeDMatingPoint = "006864C0";
    DicomTag.ThreeDMatingAxes = "006864D0";
    DicomTag.TwoDDegreeOfFreedomAxis = "006864F0";
    DicomTag.PlanningLandmarkPointSequence = "00686500";
    DicomTag.PlanningLandmarkLineSequence = "00686510";
    DicomTag.PlanningLandmarkPlaneSequence = "00686520";
    DicomTag.PlanningLandmarkID = "00686530";
    DicomTag.PlanningLandmarkDescription = "00686540";
    DicomTag.PlanningLandmarkIdentificationCodeSequence = "00686545";
    DicomTag.TwoDPointCoordinatesSequence = "00686550";
    DicomTag.TwoDPointCoordinates = "00686560";
    DicomTag.ThreeDPointCoordinates = "00686590";
    DicomTag.TwoDLineCoordinatesSequence = "006865A0";
    DicomTag.TwoDLineCoordinates = "006865B0";
    DicomTag.ThreeDLineCoordinates = "006865D0";
    DicomTag.TwoDPlaneCoordinatesSequence = "006865E0";
    DicomTag.TwoDPlaneIntersection = "006865F0";
    DicomTag.ThreeDPlaneOrigin = "00686610";
    DicomTag.ThreeDPlaneNormal = "00686620";
    // *****************************************************************************************************************************
    // *** 0070
    // *****************************************************************************************************************************
    DicomTag.GraphicAnnotationSequence = "00700001";
    DicomTag.GraphicLayer = "00700002";
    DicomTag.BoundingBoxAnnotationUnits = "00700003";
    DicomTag.AnchorPointAnnotationUnits = "00700004";
    DicomTag.GraphicAnnotationUnits = "00700005";
    DicomTag.UnformattedTextValue = "00700006";
    DicomTag.TextObjectSequence = "00700008";
    DicomTag.GraphicObjectSequence = "00700009";
    DicomTag.BoundingBoxTopLeftHandCorner = "00700010";
    DicomTag.BoundingBoxBottomRightHandCorner = "00700011";
    DicomTag.BoundingBoxTextHorizontalJustification = "00700012";
    DicomTag.AnchorPoint = "00700014";
    DicomTag.AnchorPointVisibility = "00700015";
    DicomTag.GraphicDimensions = "00700020";
    DicomTag.NumberOfGraphicPoints = "00700021";
    DicomTag.GraphicData = "00700022";
    DicomTag.GraphicType = "00700023";
    DicomTag.GraphicFilled = "00700024";
    DicomTag.ImageRotationRetired = "00700040"; // Retired
    DicomTag.ImageHorizontalFlip = "00700041";
    DicomTag.ImageRotation = "00700042";
    DicomTag.DisplayedAreaTopLeftHandCornerTrial = "00700050"; // Retired
    DicomTag.DisplayedAreaBottomRightHandCornerTrial = "00700051"; // Retired
    DicomTag.DisplayedAreaTopLeftHandCorner = "00700052";
    DicomTag.DisplayedAreaBottomRightHandCorner = "00700053";
    DicomTag.DisplayedAreaSelectionSequence = "0070005A";
    DicomTag.GraphicLayerSequence = "00700060";
    DicomTag.GraphicLayerOrder = "00700062";
    DicomTag.GraphicLayerRecommendedDisplayGrayscaleValue = "00700066";
    DicomTag.GraphicLayerRecommendedDisplayRGBValue = "00700067"; // Retired
    DicomTag.GraphicLayerDescription = "00700068";
    DicomTag.ContentLabel = "00700080";
    DicomTag.ContentDescription = "00700081";
    DicomTag.PresentationCreationDate = "00700082";
    DicomTag.PresentationCreationTime = "00700083";
    DicomTag.ContentCreatorName = "00700084";
    DicomTag.ContentCreatorIdentificationCodeSequence = "00700086";
    DicomTag.AlternateContentDescriptionSequence = "00700087";
    DicomTag.PresentationSizeMode = "00700100";
    DicomTag.PresentationPixelSpacing = "00700101";
    DicomTag.PresentationPixelAspectRatio = "00700102";
    DicomTag.PresentationPixelMagnificationRatio = "00700103";
    DicomTag.GraphicGroupLabel = "00700207";
    DicomTag.GraphicGroupDescription = "00700208";
    DicomTag.CompoundGraphicSequence = "00700209";
    DicomTag.CompoundGraphicInstanceID = "00700226";
    DicomTag.FontName = "00700227";
    DicomTag.FontNameType = "00700228";
    DicomTag.CSSFontName = "00700229";
    DicomTag.RotationAngle = "00700230";
    DicomTag.TextStyleSequence = "00700231";
    DicomTag.LineStyleSequence = "00700232";
    DicomTag.FillStyleSequence = "00700233";
    DicomTag.GraphicGroupSequence = "00700234";
    DicomTag.TextColorCIELabValue = "00700241";
    DicomTag.HorizontalAlignment = "00700242";
    DicomTag.VerticalAlignment = "00700243";
    DicomTag.ShadowStyle = "00700244";
    DicomTag.ShadowOffsetX = "00700245";
    DicomTag.ShadowOffsetY = "00700246";
    DicomTag.ShadowColorCIELabValue = "00700247";
    DicomTag.Underlined = "00700248";
    DicomTag.Bold = "00700249";
    DicomTag.Italic = "00700250";
    DicomTag.PatternOnColorCIELabValue = "00700251";
    DicomTag.PatternOffColorCIELabValue = "00700252";
    DicomTag.LineThickness = "00700253";
    DicomTag.LineDashingStyle = "00700254";
    DicomTag.LinePattern = "00700255";
    DicomTag.FillPattern = "00700256";
    DicomTag.FillMode = "00700257";
    DicomTag.ShadowOpacity = "00700258";
    DicomTag.GapLength = "00700261";
    DicomTag.DiameterOfVisibility = "00700262";
    DicomTag.RotationPoint = "00700273";
    DicomTag.TickAlignment = "00700274";
    DicomTag.ShowTickLabel = "00700278";
    DicomTag.TickLabelAlignment = "00700279";
    DicomTag.CompoundGraphicUnits = "00700282";
    DicomTag.PatternOnOpacity = "00700284";
    DicomTag.PatternOffOpacity = "00700285";
    DicomTag.MajorTicksSequence = "00700287";
    DicomTag.TickPosition = "00700288";
    DicomTag.TickLabel = "00700289";
    DicomTag.CompoundGraphicType = "00700294";
    DicomTag.GraphicGroupID = "00700295";
    DicomTag.ShapeType = "00700306";
    DicomTag.RegistrationSequence = "00700308";
    DicomTag.MatrixRegistrationSequence = "00700309";
    DicomTag.MatrixSequence = "0070030A";
    DicomTag.FrameOfReferenceTransformationMatrixType = "0070030C";
    DicomTag.RegistrationTypeCodeSequence = "0070030D";
    DicomTag.FiducialDescription = "0070030F";
    DicomTag.FiducialIdentifier = "00700310";
    DicomTag.FiducialIdentifierCodeSequence = "00700311";
    DicomTag.ContourUncertaintyRadius = "00700312";
    DicomTag.UsedFiducialsSequence = "00700314";
    DicomTag.GraphicCoordinatesDataSequence = "00700318";
    DicomTag.FiducialUID = "0070031A";
    DicomTag.FiducialSetSequence = "0070031C";
    DicomTag.FiducialSequence = "0070031E";
    DicomTag.GraphicLayerRecommendedDisplayCIELabValue = "00700401";
    DicomTag.BlendingSequence = "00700402";
    DicomTag.RelativeOpacity = "00700403";
    DicomTag.ReferencedSpatialRegistrationSequence = "00700404";
    DicomTag.BlendingPosition = "00700405";
    // *****************************************************************************************************************************
    // *** 0072
    // *****************************************************************************************************************************
    DicomTag.HangingProtocolName = "00720002";
    DicomTag.HangingProtocolDescription = "00720004";
    DicomTag.HangingProtocolLevel = "00720006";
    DicomTag.HangingProtocolCreator = "00720008";
    DicomTag.HangingProtocolCreationDateTime = "0072000A";
    DicomTag.HangingProtocolDefinitionSequence = "0072000C";
    DicomTag.HangingProtocolUserIdentificationCodeSequence = "0072000E";
    DicomTag.HangingProtocolUserGroupName = "00720010";
    DicomTag.SourceHangingProtocolSequence = "00720012";
    DicomTag.NumberOfPriorsReferenced = "00720014";
    DicomTag.ImageSetsSequence = "00720020";
    DicomTag.ImageSetSelectorSequence = "00720022";
    DicomTag.ImageSetSelectorUsageFlag = "00720024";
    DicomTag.SelectorAttribute = "00720026";
    DicomTag.SelectorValueNumber = "00720028";
    DicomTag.TimeBasedImageSetsSequence = "00720030";
    DicomTag.ImageSetNumber = "00720032";
    DicomTag.ImageSetSelectorCategory = "00720034";
    DicomTag.RelativeTime = "00720038";
    DicomTag.RelativeTimeUnits = "0072003A";
    DicomTag.AbstractPriorValue = "0072003C";
    DicomTag.AbstractPriorCodeSequence = "0072003E";
    DicomTag.ImageSetLabel = "00720040";
    DicomTag.SelectorAttributeVR = "00720050";
    DicomTag.SelectorSequencePointer = "00720052";
    DicomTag.SelectorSequencePointerPrivateCreator = "00720054";
    DicomTag.SelectorAttributePrivateCreator = "00720056";
    DicomTag.SelectorATValue = "00720060";
    DicomTag.SelectorCSValue = "00720062";
    DicomTag.SelectorISValue = "00720064";
    DicomTag.SelectorLOValue = "00720066";
    DicomTag.SelectorLTValue = "00720068";
    DicomTag.SelectorPNValue = "0072006A";
    DicomTag.SelectorSHValue = "0072006C";
    DicomTag.SelectorSTValue = "0072006E";
    DicomTag.SelectorUTValue = "00720070";
    DicomTag.SelectorDSValue = "00720072";
    DicomTag.SelectorFDValue = "00720074";
    DicomTag.SelectorFLValue = "00720076";
    DicomTag.SelectorULValue = "00720078";
    DicomTag.SelectorUSValue = "0072007A";
    DicomTag.SelectorSLValue = "0072007C";
    DicomTag.SelectorSSValue = "0072007E";
    DicomTag.SelectorUIValue = "0072007F";
    DicomTag.SelectorCodeSequenceValue = "00720080";
    DicomTag.NumberOfScreens = "00720100";
    DicomTag.NominalScreenDefinitionSequence = "00720102";
    DicomTag.NumberOfVerticalPixels = "00720104";
    DicomTag.NumberOfHorizontalPixels = "00720106";
    DicomTag.DisplayEnvironmentSpatialPosition = "00720108";
    DicomTag.ScreenMinimumGrayscaleBitDepth = "0072010A";
    DicomTag.ScreenMinimumColorBitDepth = "0072010C";
    DicomTag.ApplicationMaximumRepaintTime = "0072010E";
    DicomTag.DisplaySetsSequence = "00720200";
    DicomTag.DisplaySetNumber = "00720202";
    DicomTag.DisplaySetLabel = "00720203";
    DicomTag.DisplaySetPresentationGroup = "00720204";
    DicomTag.DisplaySetPresentationGroupDescription = "00720206";
    DicomTag.PartialDataDisplayHandling = "00720208";
    DicomTag.SynchronizedScrollingSequence = "00720210";
    DicomTag.DisplaySetScrollingGroup = "00720212";
    DicomTag.NavigationIndicatorSequence = "00720214";
    DicomTag.NavigationDisplaySet = "00720216";
    DicomTag.ReferenceDisplaySets = "00720218";
    DicomTag.ImageBoxesSequence = "00720300";
    DicomTag.ImageBoxNumber = "00720302";
    DicomTag.ImageBoxLayoutType = "00720304";
    DicomTag.ImageBoxTileHorizontalDimension = "00720306";
    DicomTag.ImageBoxTileVerticalDimension = "00720308";
    DicomTag.ImageBoxScrollDirection = "00720310";
    DicomTag.ImageBoxSmallScrollType = "00720312";
    DicomTag.ImageBoxSmallScrollAmount = "00720314";
    DicomTag.ImageBoxLargeScrollType = "00720316";
    DicomTag.ImageBoxLargeScrollAmount = "00720318";
    DicomTag.ImageBoxOverlapPriority = "00720320";
    DicomTag.CineRelativeToRealTime = "00720330";
    DicomTag.FilterOperationsSequence = "00720400";
    DicomTag.FilterByCategory = "00720402";
    DicomTag.FilterByAttributePresence = "00720404";
    DicomTag.FilterByOperator = "00720406";
    DicomTag.StructuredDisplayBackgroundCIELabValue = "00720420";
    DicomTag.EmptyImageBoxCIELabValue = "00720421";
    DicomTag.StructuredDisplayImageBoxSequence = "00720422";
    DicomTag.StructuredDisplayTextBoxSequence = "00720424";
    DicomTag.ReferencedFirstFrameSequence = "00720427";
    DicomTag.ImageBoxSynchronizationSequence = "00720430";
    DicomTag.SynchronizedImageBoxList = "00720432";
    DicomTag.TypeOfSynchronization = "00720434";
    DicomTag.BlendingOperationType = "00720500";
    DicomTag.ReformattingOperationType = "00720510";
    DicomTag.ReformattingThickness = "00720512";
    DicomTag.ReformattingInterval = "00720514";
    DicomTag.ReformattingOperationInitialViewDirection = "00720516";
    DicomTag.ThreeDRenderingType = "00720520";
    DicomTag.SortingOperationsSequence = "00720600";
    DicomTag.SortByCategory = "00720602";
    DicomTag.SortingDirection = "00720604";
    DicomTag.DisplaySetPatientOrientation = "00720700";
    DicomTag.VOIType = "00720702";
    DicomTag.PseudoColorType = "00720704";
    DicomTag.PseudoColorPaletteInstanceReferenceSequence = "00720705";
    DicomTag.ShowGrayscaleInverted = "00720706";
    DicomTag.ShowImageTrueSizeFlag = "00720710";
    DicomTag.ShowGraphicAnnotationFlag = "00720712";
    DicomTag.ShowPatientDemographicsFlag = "00720714";
    DicomTag.ShowAcquisitionTechniquesFlag = "00720716";
    DicomTag.DisplaySetHorizontalJustification = "00720717";
    DicomTag.DisplaySetVerticalJustification = "00720718";
    // *****************************************************************************************************************************
    // *** 0074
    // *****************************************************************************************************************************
    DicomTag.ContinuationStartMeterset = "00740120";
    DicomTag.ContinuationEndMeterset = "00740121";
    DicomTag.ProcedureStepState = "00741000";
    DicomTag.ProcedureStepProgressInformationSequence = "00741002";
    DicomTag.ProcedureStepProgress = "00741004";
    DicomTag.ProcedureStepProgressDescription = "00741006";
    DicomTag.ProcedureStepCommunicationsURISequence = "00741008";
    DicomTag.ContactURI = "0074100A";
    DicomTag.ContactDisplayName = "0074100C";
    DicomTag.ProcedureStepDiscontinuationReasonCodeSequence = "0074100E";
    DicomTag.BeamTaskSequence = "00741020";
    DicomTag.BeamTaskType = "00741022";
    DicomTag.BeamOrderIndexTrial = "00741024"; // Retired
    DicomTag.AutosequenceFlag = "00741025";
    DicomTag.TableTopVerticalAdjustedPosition = "00741026";
    DicomTag.TableTopLongitudinalAdjustedPosition = "00741027";
    DicomTag.TableTopLateralAdjustedPosition = "00741028";
    DicomTag.PatientSupportAdjustedAngle = "0074102A";
    DicomTag.TableTopEccentricAdjustedAngle = "0074102B";
    DicomTag.TableTopPitchAdjustedAngle = "0074102C";
    DicomTag.TableTopRollAdjustedAngle = "0074102D";
    DicomTag.DeliveryVerificationImageSequence = "00741030";
    DicomTag.VerificationImageTiming = "00741032";
    DicomTag.DoubleExposureFlag = "00741034";
    DicomTag.DoubleExposureOrdering = "00741036";
    DicomTag.DoubleExposureMetersetTrial = "00741038"; // Retired
    DicomTag.DoubleExposureFieldDeltaTrial = "0074103A"; // Retired
    DicomTag.RelatedReferenceRTImageSequence = "00741040";
    DicomTag.GeneralMachineVerificationSequence = "00741042";
    DicomTag.ConventionalMachineVerificationSequence = "00741044";
    DicomTag.IonMachineVerificationSequence = "00741046";
    DicomTag.FailedAttributesSequence = "00741048";
    DicomTag.OverriddenAttributesSequence = "0074104A";
    DicomTag.ConventionalControlPointVerificationSequence = "0074104C";
    DicomTag.IonControlPointVerificationSequence = "0074104E";
    DicomTag.AttributeOccurrenceSequence = "00741050";
    DicomTag.AttributeOccurrencePointer = "00741052";
    DicomTag.AttributeItemSelector = "00741054";
    DicomTag.AttributeOccurrencePrivateCreator = "00741056";
    DicomTag.SelectorSequencePointerItems = "00741057";
    DicomTag.ScheduledProcedureStepPriority = "00741200";
    DicomTag.WorklistLabel = "00741202";
    DicomTag.ProcedureStepLabel = "00741204";
    DicomTag.ScheduledProcessingParametersSequence = "00741210";
    DicomTag.PerformedProcessingParametersSequence = "00741212";
    DicomTag.UnifiedProcedureStepPerformedProcedureSequence = "00741216";
    DicomTag.RelatedProcedureStepSequence = "00741220"; // Retired
    DicomTag.ProcedureStepRelationshipType = "00741222"; // Retired
    DicomTag.ReplacedProcedureStepSequence = "00741224";
    DicomTag.DeletionLock = "00741230";
    DicomTag.ReceivingAE = "00741234";
    DicomTag.RequestingAE = "00741236";
    DicomTag.ReasonForCancellation = "00741238";
    DicomTag.SCPStatus = "00741242";
    DicomTag.SubscriptionListStatus = "00741244";
    DicomTag.UnifiedProcedureStepListStatus = "00741246";
    DicomTag.BeamOrderIndex = "00741324";
    DicomTag.DoubleExposureMeterset = "00741338";
    DicomTag.DoubleExposureFieldDelta = "0074133A";
    // *****************************************************************************************************************************
    // *** 0076
    // *****************************************************************************************************************************
    DicomTag.ImplantAssemblyTemplateName = "00760001";
    DicomTag.ImplantAssemblyTemplateIssuer = "00760003";
    DicomTag.ImplantAssemblyTemplateVersion = "00760006";
    DicomTag.ReplacedImplantAssemblyTemplateSequence = "00760008";
    DicomTag.ImplantAssemblyTemplateType = "0076000A";
    DicomTag.OriginalImplantAssemblyTemplateSequence = "0076000C";
    DicomTag.DerivationImplantAssemblyTemplateSequence = "0076000E";
    DicomTag.ImplantAssemblyTemplateTargetAnatomySequence = "00760010";
    DicomTag.ProcedureTypeCodeSequence = "00760020";
    DicomTag.SurgicalTechnique = "00760030";
    DicomTag.ComponentTypesSequence = "00760032";
    DicomTag.ComponentTypeCodeSequence = "00760034";
    DicomTag.ExclusiveComponentType = "00760036";
    DicomTag.MandatoryComponentType = "00760038";
    DicomTag.ComponentSequence = "00760040";
    DicomTag.ComponentID = "00760055";
    DicomTag.ComponentAssemblySequence = "00760060";
    DicomTag.Component1ReferencedID = "00760070";
    DicomTag.Component1ReferencedMatingFeatureSetID = "00760080";
    DicomTag.Component1ReferencedMatingFeatureID = "00760090";
    DicomTag.Component2ReferencedID = "007600A0";
    DicomTag.Component2ReferencedMatingFeatureSetID = "007600B0";
    DicomTag.Component2ReferencedMatingFeatureID = "007600C0";
    // *****************************************************************************************************************************
    // *** 0078
    // *****************************************************************************************************************************
    DicomTag.ImplantTemplateGroupName = "00780001";
    DicomTag.ImplantTemplateGroupDescription = "00780010";
    DicomTag.ImplantTemplateGroupIssuer = "00780020";
    DicomTag.ImplantTemplateGroupVersion = "00780024";
    DicomTag.ReplacedImplantTemplateGroupSequence = "00780026";
    DicomTag.ImplantTemplateGroupTargetAnatomySequence = "00780028";
    DicomTag.ImplantTemplateGroupMembersSequence = "0078002A";
    DicomTag.ImplantTemplateGroupMemberID = "0078002E";
    DicomTag.ThreeDImplantTemplateGroupMemberMatchingPoint = "00780050";
    DicomTag.ThreeDImplantTemplateGroupMemberMatchingAxes = "00780060";
    DicomTag.ImplantTemplateGroupMemberMatching2DCoordinatesSequence = "00780070";
    DicomTag.TwoDImplantTemplateGroupMemberMatchingPoint = "00780090";
    DicomTag.TwoDImplantTemplateGroupMemberMatchingAxes = "007800A0";
    DicomTag.ImplantTemplateGroupVariationDimensionSequence = "007800B0";
    DicomTag.ImplantTemplateGroupVariationDimensionName = "007800B2";
    DicomTag.ImplantTemplateGroupVariationDimensionRankSequence = "007800B4";
    DicomTag.ReferencedImplantTemplateGroupMemberID = "007800B6";
    DicomTag.ImplantTemplateGroupVariationDimensionRank = "007800B8";
    // *****************************************************************************************************************************
    // *** 0080
    // *****************************************************************************************************************************
    DicomTag.SurfaceScanAcquisitionTypeCodeSequence = "00800001";
    DicomTag.SurfaceScanModeCodeSequence = "00800002";
    DicomTag.RegistrationMethodCodeSequence = "00800003";
    DicomTag.ShotDurationTime = "00800004";
    DicomTag.ShotOffsetTime = "00800005";
    DicomTag.SurfacePointPresentationValueData = "00800006";
    DicomTag.SurfacePointColorCIELabValueData = "00800007";
    DicomTag.UVMappingSequence = "00800008";
    DicomTag.TextureLabel = "00800009";
    DicomTag.UValueData = "00800010";
    DicomTag.VValueData = "00800011";
    DicomTag.ReferencedTextureSequence = "00800012";
    DicomTag.ReferencedSurfaceDataSequence = "00800013";
    // *****************************************************************************************************************************
    // *** 0088
    // *****************************************************************************************************************************
    DicomTag.StorageMediaFileSetID = "00880130";
    DicomTag.StorageMediaFileSetUID = "00880140";
    DicomTag.IconImageSequence = "00880200";
    DicomTag.TopicTitle = "00880904"; // Retired
    DicomTag.TopicSubject = "00880906"; // Retired
    DicomTag.TopicAuthor = "00880910"; // Retired
    DicomTag.TopicKeywords = "00880912"; // Retired
    // *****************************************************************************************************************************
    // *** 0100
    // *****************************************************************************************************************************
    DicomTag.SOPInstanceStatus = "01000410";
    DicomTag.SOPAuthorizationDateTime = "01000420";
    DicomTag.SOPAuthorizationComment = "01000424";
    DicomTag.AuthorizationEquipmentCertificationNumber = "01000426";
    // *****************************************************************************************************************************
    // *** 0400
    // *****************************************************************************************************************************
    DicomTag.MACIDNumber = "04000005";
    DicomTag.MACCalculationTransferSyntaxUID = "04000010";
    DicomTag.MACAlgorithm = "04000015";
    DicomTag.DataElementsSigned = "04000020";
    DicomTag.DigitalSignatureUID = "04000100";
    DicomTag.DigitalSignatureDateTime = "04000105";
    DicomTag.CertificateType = "04000110";
    DicomTag.CertificateOfSigner = "04000115";
    DicomTag.Signature = "04000120";
    DicomTag.CertifiedTimestampType = "04000305";
    DicomTag.CertifiedTimestamp = "04000310";
    DicomTag.DigitalSignaturePurposeCodeSequence = "04000401";
    DicomTag.ReferencedDigitalSignatureSequence = "04000402";
    DicomTag.ReferencedSOPInstanceMACSequence = "04000403";
    DicomTag.MAC = "04000404";
    DicomTag.EncryptedAttributesSequence = "04000500";
    DicomTag.EncryptedContentTransferSyntaxUID = "04000510";
    DicomTag.EncryptedContent = "04000520";
    DicomTag.ModifiedAttributesSequence = "04000550";
    DicomTag.OriginalAttributesSequence = "04000561";
    DicomTag.AttributeModificationDateTime = "04000562";
    DicomTag.ModifyingSystem = "04000563";
    DicomTag.SourceOfPreviousValues = "04000564";
    DicomTag.ReasonForTheAttributeModification = "04000565";
    // *****************************************************************************************************************************
    // *** 1000
    // *****************************************************************************************************************************
    DicomTag.EscapeTriplet = "10000000"; // Retired
    DicomTag.RunLengthTriplet = "10000001"; // Retired
    DicomTag.HuffmanTableSize = "10000002"; // Retired
    DicomTag.HuffmanTableTriplet = "10000003"; // Retired
    DicomTag.ShiftTableSize = "10000004"; // Retired
    DicomTag.ShiftTableTriplet = "10000005"; // Retired
    // *****************************************************************************************************************************
    // *** 1010
    // *****************************************************************************************************************************
    DicomTag.ZonalMap = "10100000"; // Retired
    // *****************************************************************************************************************************
    // *** 2000
    // *****************************************************************************************************************************
    DicomTag.NumberOfCopies = "20000010";
    DicomTag.PrinterConfigurationSequence = "2000001E";
    DicomTag.PrintPriority = "20000020";
    DicomTag.MediumType = "20000030";
    DicomTag.FilmDestination = "20000040";
    DicomTag.FilmSessionLabel = "20000050";
    DicomTag.MemoryAllocation = "20000060";
    DicomTag.MaximumMemoryAllocation = "20000061";
    DicomTag.ColorImagePrintingFlag = "20000062"; // Retired
    DicomTag.CollationFlag = "20000063"; // Retired
    DicomTag.AnnotationFlag = "20000065"; // Retired
    DicomTag.ImageOverlayFlag = "20000067"; // Retired
    DicomTag.PresentationLUTFlag = "20000069"; // Retired
    DicomTag.ImageBoxPresentationLUTFlag = "2000006A"; // Retired
    DicomTag.MemoryBitDepth = "200000A0";
    DicomTag.PrintingBitDepth = "200000A1";
    DicomTag.MediaInstalledSequence = "200000A2";
    DicomTag.OtherMediaAvailableSequence = "200000A4";
    DicomTag.SupportedImageDisplayFormatsSequence = "200000A8";
    DicomTag.ReferencedFilmBoxSequence = "20000500";
    DicomTag.ReferencedStoredPrintSequence = "20000510"; // Retired
    // *****************************************************************************************************************************
    // *** 2010
    // *****************************************************************************************************************************
    DicomTag.ImageDisplayFormat = "20100010";
    DicomTag.AnnotationDisplayFormatID = "20100030";
    DicomTag.FilmOrientation = "20100040";
    DicomTag.FilmSizeID = "20100050";
    DicomTag.PrinterResolutionID = "20100052";
    DicomTag.DefaultPrinterResolutionID = "20100054";
    DicomTag.MagnificationType = "20100060";
    DicomTag.SmoothingType = "20100080";
    DicomTag.DefaultMagnificationType = "201000A6";
    DicomTag.OtherMagnificationTypesAvailable = "201000A7";
    DicomTag.DefaultSmoothingType = "201000A8";
    DicomTag.OtherSmoothingTypesAvailable = "201000A9";
    DicomTag.BorderDensity = "20100100";
    DicomTag.EmptyImageDensity = "20100110";
    DicomTag.MinDensity = "20100120";
    DicomTag.MaxDensity = "20100130";
    DicomTag.Trim = "20100140";
    DicomTag.ConfigurationInformation = "20100150";
    DicomTag.ConfigurationInformationDescription = "20100152";
    DicomTag.MaximumCollatedFilms = "20100154";
    DicomTag.Illumination = "2010015E";
    DicomTag.ReflectedAmbientLight = "20100160";
    DicomTag.PrinterPixelSpacing = "20100376";
    DicomTag.ReferencedFilmSessionSequence = "20100500";
    DicomTag.ReferencedImageBoxSequence = "20100510";
    DicomTag.ReferencedBasicAnnotationBoxSequence = "20100520";
    // *****************************************************************************************************************************
    // *** 2020
    // *****************************************************************************************************************************
    DicomTag.ImageBoxPosition = "20200010";
    DicomTag.Polarity = "20200020";
    DicomTag.RequestedImageSize = "20200030";
    DicomTag.RequestedDecimateCropBehavior = "20200040";
    DicomTag.RequestedResolutionID = "20200050";
    DicomTag.RequestedImageSizeFlag = "202000A0";
    DicomTag.DecimateCropResult = "202000A2";
    DicomTag.BasicGrayscaleImageSequence = "20200110";
    DicomTag.BasicColorImageSequence = "20200111";
    DicomTag.ReferencedImageOverlayBoxSequence = "20200130"; // Retired
    DicomTag.ReferencedVOILUTBoxSequence = "20200140"; // Retired
    // *****************************************************************************************************************************
    // *** 2030
    // *****************************************************************************************************************************
    DicomTag.AnnotationPosition = "20300010";
    DicomTag.TextString = "20300020";
    // *****************************************************************************************************************************
    // *** 2040
    // *****************************************************************************************************************************
    DicomTag.ReferencedOverlayPlaneSequence = "20400010"; // Retired
    DicomTag.ReferencedOverlayPlaneGroups = "20400011"; // Retired
    DicomTag.OverlayPixelDataSequence = "20400020"; // Retired
    DicomTag.OverlayMagnificationType = "20400060"; // Retired
    DicomTag.OverlaySmoothingType = "20400070"; // Retired
    DicomTag.OverlayOrImageMagnification = "20400072"; // Retired
    DicomTag.MagnifyToNumberOfColumns = "20400074"; // Retired
    DicomTag.OverlayForegroundDensity = "20400080"; // Retired
    DicomTag.OverlayBackgroundDensity = "20400082"; // Retired
    DicomTag.OverlayMode = "20400090"; // Retired
    DicomTag.ThresholdDensity = "20400100"; // Retired
    DicomTag.ReferencedImageBoxSequenceRetired = "20400500"; // Retired
    // *****************************************************************************************************************************
    // *** 2050
    // *****************************************************************************************************************************
    DicomTag.PresentationLUTSequence = "20500010";
    DicomTag.PresentationLUTShape = "20500020";
    DicomTag.ReferencedPresentationLUTSequence = "20500500";
    // *****************************************************************************************************************************
    // *** 2100
    // *****************************************************************************************************************************
    DicomTag.PrintJobID = "21000010"; // Retired
    DicomTag.ExecutionStatus = "21000020";
    DicomTag.ExecutionStatusInfo = "21000030";
    DicomTag.CreationDate = "21000040";
    DicomTag.CreationTime = "21000050";
    DicomTag.Originator = "21000070";
    DicomTag.DestinationAE = "21000140"; // Retired
    DicomTag.OwnerID = "21000160";
    DicomTag.NumberOfFilms = "21000170";
    DicomTag.ReferencedPrintJobSequencePullStoredPrint = "21000500"; // Retired
    // *****************************************************************************************************************************
    // *** 2110
    // *****************************************************************************************************************************
    DicomTag.PrinterStatus = "21100010";
    DicomTag.PrinterStatusInfo = "21100020";
    DicomTag.PrinterName = "21100030";
    DicomTag.PrintQueueID = "21100099"; // Retired
    // *****************************************************************************************************************************
    // *** 2120
    // *****************************************************************************************************************************
    DicomTag.QueueStatus = "21200010"; // Retired
    DicomTag.PrintJobDescriptionSequence = "21200050"; // Retired
    DicomTag.ReferencedPrintJobSequence = "21200070"; // Retired
    // *****************************************************************************************************************************
    // *** 2130
    // *****************************************************************************************************************************
    DicomTag.PrintManagementCapabilitiesSequence = "21300010"; // Retired
    DicomTag.PrinterCharacteristicsSequence = "21300015"; // Retired
    DicomTag.FilmBoxContentSequence = "21300030"; // Retired
    DicomTag.ImageBoxContentSequence = "21300040"; // Retired
    DicomTag.AnnotationContentSequence = "21300050"; // Retired
    DicomTag.ImageOverlayBoxContentSequence = "21300060"; // Retired
    DicomTag.PresentationLUTContentSequence = "21300080"; // Retired
    DicomTag.ProposedStudySequence = "213000A0"; // Retired
    DicomTag.OriginalImageSequence = "213000C0"; // Retired
    // *****************************************************************************************************************************
    // *** 2200
    // *****************************************************************************************************************************
    DicomTag.LabelUsingInformationExtractedFromInstances = "22000001";
    DicomTag.LabelText = "22000002";
    DicomTag.LabelStyleSelection = "22000003";
    DicomTag.MediaDisposition = "22000004";
    DicomTag.BarcodeValue = "22000005";
    DicomTag.BarcodeSymbology = "22000006";
    DicomTag.AllowMediaSplitting = "22000007";
    DicomTag.IncludeNonDICOMObjects = "22000008";
    DicomTag.IncludeDisplayApplication = "22000009";
    DicomTag.PreserveCompositeInstancesAfterMediaCreation = "2200000A";
    DicomTag.TotalNumberOfPiecesOfMediaCreated = "2200000B";
    DicomTag.RequestedMediaApplicationProfile = "2200000C";
    DicomTag.ReferencedStorageMediaSequence = "2200000D";
    DicomTag.FailureAttributes = "2200000E";
    DicomTag.AllowLossyCompression = "2200000F";
    DicomTag.RequestPriority = "22000020";
    // *****************************************************************************************************************************
    // *** 3002
    // *****************************************************************************************************************************
    DicomTag.RTImageLabel = "30020002";
    DicomTag.RTImageName = "30020003";
    DicomTag.RTImageDescription = "30020004";
    DicomTag.ReportedValuesOrigin = "3002000A";
    DicomTag.RTImagePlane = "3002000C";
    DicomTag.XRayImageReceptorTranslation = "3002000D";
    DicomTag.XRayImageReceptorAngle = "3002000E";
    DicomTag.RTImageOrientation = "30020010";
    DicomTag.ImagePlanePixelSpacing = "30020011";
    DicomTag.RTImagePosition = "30020012";
    DicomTag.RadiationMachineName = "30020020";
    DicomTag.RadiationMachineSAD = "30020022";
    DicomTag.RadiationMachineSSD = "30020024";
    DicomTag.RTImageSID = "30020026";
    DicomTag.SourceToReferenceObjectDistance = "30020028";
    DicomTag.FractionNumber = "30020029";
    DicomTag.ExposureSequence = "30020030";
    DicomTag.MetersetExposure = "30020032";
    DicomTag.DiaphragmPosition = "30020034";
    DicomTag.FluenceMapSequence = "30020040";
    DicomTag.FluenceDataSource = "30020041";
    DicomTag.FluenceDataScale = "30020042";
    DicomTag.PrimaryFluenceModeSequence = "30020050";
    DicomTag.FluenceMode = "30020051";
    DicomTag.FluenceModeID = "30020052";
    // *****************************************************************************************************************************
    // *** 3004
    // *****************************************************************************************************************************
    DicomTag.DVHType = "30040001";
    DicomTag.DoseUnits = "30040002";
    DicomTag.DoseType = "30040004";
    DicomTag.SpatialTransformOfDose = "30040005";
    DicomTag.DoseComment = "30040006";
    DicomTag.NormalizationPoint = "30040008";
    DicomTag.DoseSummationType = "3004000A";
    DicomTag.GridFrameOffsetVector = "3004000C";
    DicomTag.DoseGridScaling = "3004000E";
    DicomTag.RTDoseROISequence = "30040010";
    DicomTag.DoseValue = "30040012";
    DicomTag.TissueHeterogeneityCorrection = "30040014";
    DicomTag.DVHNormalizationPoint = "30040040";
    DicomTag.DVHNormalizationDoseValue = "30040042";
    DicomTag.DVHSequence = "30040050";
    DicomTag.DVHDoseScaling = "30040052";
    DicomTag.DVHVolumeUnits = "30040054";
    DicomTag.DVHNumberOfBins = "30040056";
    DicomTag.DVHData = "30040058";
    DicomTag.DVHReferencedROISequence = "30040060";
    DicomTag.DVHROIContributionType = "30040062";
    DicomTag.DVHMinimumDose = "30040070";
    DicomTag.DVHMaximumDose = "30040072";
    DicomTag.DVHMeanDose = "30040074";
    // *****************************************************************************************************************************
    // *** 3006
    // *****************************************************************************************************************************
    DicomTag.StructureSetLabel = "30060002";
    DicomTag.StructureSetName = "30060004";
    DicomTag.StructureSetDescription = "30060006";
    DicomTag.StructureSetDate = "30060008";
    DicomTag.StructureSetTime = "30060009";
    DicomTag.ReferencedFrameOfReferenceSequence = "30060010";
    DicomTag.RTReferencedStudySequence = "30060012";
    DicomTag.RTReferencedSeriesSequence = "30060014";
    DicomTag.ContourImageSequence = "30060016";
    DicomTag.PredecessorStructureSetSequence = "30060018";
    DicomTag.StructureSetROISequence = "30060020";
    DicomTag.ROINumber = "30060022";
    DicomTag.ReferencedFrameOfReferenceUID = "30060024";
    DicomTag.ROIName = "30060026";
    DicomTag.ROIDescription = "30060028";
    DicomTag.ROIDisplayColor = "3006002A";
    DicomTag.ROIVolume = "3006002C";
    DicomTag.RTRelatedROISequence = "30060030";
    DicomTag.RTROIRelationship = "30060033";
    DicomTag.ROIGenerationAlgorithm = "30060036";
    DicomTag.ROIGenerationDescription = "30060038";
    DicomTag.ROIContourSequence = "30060039";
    DicomTag.ContourSequence = "30060040";
    DicomTag.ContourGeometricType = "30060042";
    DicomTag.ContourSlabThickness = "30060044";
    DicomTag.ContourOffsetVector = "30060045";
    DicomTag.NumberOfContourPoints = "30060046";
    DicomTag.ContourNumber = "30060048";
    DicomTag.AttachedContours = "30060049";
    DicomTag.ContourData = "30060050";
    DicomTag.RTROIObservationsSequence = "30060080";
    DicomTag.ObservationNumber = "30060082";
    DicomTag.ReferencedROINumber = "30060084";
    DicomTag.ROIObservationLabel = "30060085";
    DicomTag.RTROIIdentificationCodeSequence = "30060086";
    DicomTag.ROIObservationDescription = "30060088";
    DicomTag.RelatedRTROIObservationsSequence = "300600A0";
    DicomTag.RTROIInterpretedType = "300600A4";
    DicomTag.ROIInterpreter = "300600A6";
    DicomTag.ROIPhysicalPropertiesSequence = "300600B0";
    DicomTag.ROIPhysicalProperty = "300600B2";
    DicomTag.ROIPhysicalPropertyValue = "300600B4";
    DicomTag.ROIElementalCompositionSequence = "300600B6";
    DicomTag.ROIElementalCompositionAtomicNumber = "300600B7";
    DicomTag.ROIElementalCompositionAtomicMassFraction = "300600B8";
    DicomTag.AdditionalRTROIIdentificationCodeSequence = "300600B9";
    DicomTag.FrameOfReferenceRelationshipSequence = "300600C0"; // Retired
    DicomTag.RelatedFrameOfReferenceUID = "300600C2"; // Retired
    DicomTag.FrameOfReferenceTransformationType = "300600C4"; // Retired
    DicomTag.FrameOfReferenceTransformationMatrix = "300600C6";
    DicomTag.FrameOfReferenceTransformationComment = "300600C8";
    // *****************************************************************************************************************************
    // *** 3008
    // *****************************************************************************************************************************
    DicomTag.MeasuredDoseReferenceSequence = "30080010";
    DicomTag.MeasuredDoseDescription = "30080012";
    DicomTag.MeasuredDoseType = "30080014";
    DicomTag.MeasuredDoseValue = "30080016";
    DicomTag.TreatmentSessionBeamSequence = "30080020";
    DicomTag.TreatmentSessionIonBeamSequence = "30080021";
    DicomTag.CurrentFractionNumber = "30080022";
    DicomTag.TreatmentControlPointDate = "30080024";
    DicomTag.TreatmentControlPointTime = "30080025";
    DicomTag.TreatmentTerminationStatus = "3008002A";
    DicomTag.TreatmentTerminationCode = "3008002B";
    DicomTag.TreatmentVerificationStatus = "3008002C";
    DicomTag.ReferencedTreatmentRecordSequence = "30080030";
    DicomTag.SpecifiedPrimaryMeterset = "30080032";
    DicomTag.SpecifiedSecondaryMeterset = "30080033";
    DicomTag.DeliveredPrimaryMeterset = "30080036";
    DicomTag.DeliveredSecondaryMeterset = "30080037";
    DicomTag.SpecifiedTreatmentTime = "3008003A";
    DicomTag.DeliveredTreatmentTime = "3008003B";
    DicomTag.ControlPointDeliverySequence = "30080040";
    DicomTag.IonControlPointDeliverySequence = "30080041";
    DicomTag.SpecifiedMeterset = "30080042";
    DicomTag.DeliveredMeterset = "30080044";
    DicomTag.MetersetRateSet = "30080045";
    DicomTag.MetersetRateDelivered = "30080046";
    DicomTag.ScanSpotMetersetsDelivered = "30080047";
    DicomTag.DoseRateDelivered = "30080048";
    DicomTag.TreatmentSummaryCalculatedDoseReferenceSequence = "30080050";
    DicomTag.CumulativeDoseToDoseReference = "30080052";
    DicomTag.FirstTreatmentDate = "30080054";
    DicomTag.MostRecentTreatmentDate = "30080056";
    DicomTag.NumberOfFractionsDelivered = "3008005A";
    DicomTag.OverrideSequence = "30080060";
    DicomTag.ParameterSequencePointer = "30080061";
    DicomTag.OverrideParameterPointer = "30080062";
    DicomTag.ParameterItemIndex = "30080063";
    DicomTag.MeasuredDoseReferenceNumber = "30080064";
    DicomTag.ParameterPointer = "30080065";
    DicomTag.OverrideReason = "30080066";
    DicomTag.CorrectedParameterSequence = "30080068";
    DicomTag.CorrectionValue = "3008006A";
    DicomTag.CalculatedDoseReferenceSequence = "30080070";
    DicomTag.CalculatedDoseReferenceNumber = "30080072";
    DicomTag.CalculatedDoseReferenceDescription = "30080074";
    DicomTag.CalculatedDoseReferenceDoseValue = "30080076";
    DicomTag.StartMeterset = "30080078";
    DicomTag.EndMeterset = "3008007A";
    DicomTag.ReferencedMeasuredDoseReferenceSequence = "30080080";
    DicomTag.ReferencedMeasuredDoseReferenceNumber = "30080082";
    DicomTag.ReferencedCalculatedDoseReferenceSequence = "30080090";
    DicomTag.ReferencedCalculatedDoseReferenceNumber = "30080092";
    DicomTag.BeamLimitingDeviceLeafPairsSequence = "300800A0";
    DicomTag.RecordedWedgeSequence = "300800B0";
    DicomTag.RecordedCompensatorSequence = "300800C0";
    DicomTag.RecordedBlockSequence = "300800D0";
    DicomTag.TreatmentSummaryMeasuredDoseReferenceSequence = "300800E0";
    DicomTag.RecordedSnoutSequence = "300800F0";
    DicomTag.RecordedRangeShifterSequence = "300800F2";
    DicomTag.RecordedLateralSpreadingDeviceSequence = "300800F4";
    DicomTag.RecordedRangeModulatorSequence = "300800F6";
    DicomTag.RecordedSourceSequence = "30080100";
    DicomTag.SourceSerialNumber = "30080105";
    DicomTag.TreatmentSessionApplicationSetupSequence = "30080110";
    DicomTag.ApplicationSetupCheck = "30080116";
    DicomTag.RecordedBrachyAccessoryDeviceSequence = "30080120";
    DicomTag.ReferencedBrachyAccessoryDeviceNumber = "30080122";
    DicomTag.RecordedChannelSequence = "30080130";
    DicomTag.SpecifiedChannelTotalTime = "30080132";
    DicomTag.DeliveredChannelTotalTime = "30080134";
    DicomTag.SpecifiedNumberOfPulses = "30080136";
    DicomTag.DeliveredNumberOfPulses = "30080138";
    DicomTag.SpecifiedPulseRepetitionInterval = "3008013A";
    DicomTag.DeliveredPulseRepetitionInterval = "3008013C";
    DicomTag.RecordedSourceApplicatorSequence = "30080140";
    DicomTag.ReferencedSourceApplicatorNumber = "30080142";
    DicomTag.RecordedChannelShieldSequence = "30080150";
    DicomTag.ReferencedChannelShieldNumber = "30080152";
    DicomTag.BrachyControlPointDeliveredSequence = "30080160";
    DicomTag.SafePositionExitDate = "30080162";
    DicomTag.SafePositionExitTime = "30080164";
    DicomTag.SafePositionReturnDate = "30080166";
    DicomTag.SafePositionReturnTime = "30080168";
    DicomTag.PulseSpecificBrachyControlPointDeliveredSequence = "30080171";
    DicomTag.PulseNumber = "30080172";
    DicomTag.BrachyPulseControlPointDeliveredSequence = "30080173";
    DicomTag.CurrentTreatmentStatus = "30080200";
    DicomTag.TreatmentStatusComment = "30080202";
    DicomTag.FractionGroupSummarySequence = "30080220";
    DicomTag.ReferencedFractionNumber = "30080223";
    DicomTag.FractionGroupType = "30080224";
    DicomTag.BeamStopperPosition = "30080230";
    DicomTag.FractionStatusSummarySequence = "30080240";
    DicomTag.TreatmentDate = "30080250";
    DicomTag.TreatmentTime = "30080251";
    // *****************************************************************************************************************************
    // *** 300A
    // *****************************************************************************************************************************
    DicomTag.RTPlanLabel = "300A0002";
    DicomTag.RTPlanName = "300A0003";
    DicomTag.RTPlanDescription = "300A0004";
    DicomTag.RTPlanDate = "300A0006";
    DicomTag.RTPlanTime = "300A0007";
    DicomTag.TreatmentProtocols = "300A0009";
    DicomTag.PlanIntent = "300A000A";
    DicomTag.TreatmentSites = "300A000B";
    DicomTag.RTPlanGeometry = "300A000C";
    DicomTag.PrescriptionDescription = "300A000E";
    DicomTag.DoseReferenceSequence = "300A0010";
    DicomTag.DoseReferenceNumber = "300A0012";
    DicomTag.DoseReferenceUID = "300A0013";
    DicomTag.DoseReferenceStructureType = "300A0014";
    DicomTag.NominalBeamEnergyUnit = "300A0015";
    DicomTag.DoseReferenceDescription = "300A0016";
    DicomTag.DoseReferencePointCoordinates = "300A0018";
    DicomTag.NominalPriorDose = "300A001A";
    DicomTag.DoseReferenceType = "300A0020";
    DicomTag.ConstraintWeight = "300A0021";
    DicomTag.DeliveryWarningDose = "300A0022";
    DicomTag.DeliveryMaximumDose = "300A0023";
    DicomTag.TargetMinimumDose = "300A0025";
    DicomTag.TargetPrescriptionDose = "300A0026";
    DicomTag.TargetMaximumDose = "300A0027";
    DicomTag.TargetUnderdoseVolumeFraction = "300A0028";
    DicomTag.OrganAtRiskFullVolumeDose = "300A002A";
    DicomTag.OrganAtRiskLimitDose = "300A002B";
    DicomTag.OrganAtRiskMaximumDose = "300A002C";
    DicomTag.OrganAtRiskOverdoseVolumeFraction = "300A002D";
    DicomTag.ToleranceTableSequence = "300A0040";
    DicomTag.ToleranceTableNumber = "300A0042";
    DicomTag.ToleranceTableLabel = "300A0043";
    DicomTag.GantryAngleTolerance = "300A0044";
    DicomTag.BeamLimitingDeviceAngleTolerance = "300A0046";
    DicomTag.BeamLimitingDeviceToleranceSequence = "300A0048";
    DicomTag.BeamLimitingDevicePositionTolerance = "300A004A";
    DicomTag.SnoutPositionTolerance = "300A004B";
    DicomTag.PatientSupportAngleTolerance = "300A004C";
    DicomTag.TableTopEccentricAngleTolerance = "300A004E";
    DicomTag.TableTopPitchAngleTolerance = "300A004F";
    DicomTag.TableTopRollAngleTolerance = "300A0050";
    DicomTag.TableTopVerticalPositionTolerance = "300A0051";
    DicomTag.TableTopLongitudinalPositionTolerance = "300A0052";
    DicomTag.TableTopLateralPositionTolerance = "300A0053";
    DicomTag.RTPlanRelationship = "300A0055";
    DicomTag.FractionGroupSequence = "300A0070";
    DicomTag.FractionGroupNumber = "300A0071";
    DicomTag.FractionGroupDescription = "300A0072";
    DicomTag.NumberOfFractionsPlanned = "300A0078";
    DicomTag.NumberOfFractionPatternDigitsPerDay = "300A0079";
    DicomTag.RepeatFractionCycleLength = "300A007A";
    DicomTag.FractionPattern = "300A007B";
    DicomTag.NumberOfBeams = "300A0080";
    DicomTag.BeamDoseSpecificationPoint = "300A0082";
    DicomTag.BeamDose = "300A0084";
    DicomTag.BeamMeterset = "300A0086";
    DicomTag.BeamDosePointDepth = "300A0088"; // Retired
    DicomTag.BeamDosePointEquivalentDepth = "300A0089"; // Retired
    DicomTag.BeamDosePointSSD = "300A008A"; // Retired
    DicomTag.BeamDoseMeaning = "300A008B";
    DicomTag.BeamDoseVerificationControlPointSequence = "300A008C";
    DicomTag.AverageBeamDosePointDepth = "300A008D";
    DicomTag.AverageBeamDosePointEquivalentDepth = "300A008E";
    DicomTag.AverageBeamDosePointSSD = "300A008F";
    DicomTag.NumberOfBrachyApplicationSetups = "300A00A0";
    DicomTag.BrachyApplicationSetupDoseSpecificationPoint = "300A00A2";
    DicomTag.BrachyApplicationSetupDose = "300A00A4";
    DicomTag.BeamSequence = "300A00B0";
    DicomTag.TreatmentMachineName = "300A00B2";
    DicomTag.PrimaryDosimeterUnit = "300A00B3";
    DicomTag.SourceAxisDistance = "300A00B4";
    DicomTag.BeamLimitingDeviceSequence = "300A00B6";
    DicomTag.RTBeamLimitingDeviceType = "300A00B8";
    DicomTag.SourceToBeamLimitingDeviceDistance = "300A00BA";
    DicomTag.IsocenterToBeamLimitingDeviceDistance = "300A00BB";
    DicomTag.NumberOfLeafJawPairs = "300A00BC";
    DicomTag.LeafPositionBoundaries = "300A00BE";
    DicomTag.BeamNumber = "300A00C0";
    DicomTag.BeamName = "300A00C2";
    DicomTag.BeamDescription = "300A00C3";
    DicomTag.BeamType = "300A00C4";
    DicomTag.BeamDeliveryDurationLimit = "300A00C5";
    DicomTag.RadiationType = "300A00C6";
    DicomTag.HighDoseTechniqueType = "300A00C7";
    DicomTag.ReferenceImageNumber = "300A00C8";
    DicomTag.PlannedVerificationImageSequence = "300A00CA";
    DicomTag.ImagingDeviceSpecificAcquisitionParameters = "300A00CC";
    DicomTag.TreatmentDeliveryType = "300A00CE";
    DicomTag.NumberOfWedges = "300A00D0";
    DicomTag.WedgeSequence = "300A00D1";
    DicomTag.WedgeNumber = "300A00D2";
    DicomTag.WedgeType = "300A00D3";
    DicomTag.WedgeID = "300A00D4";
    DicomTag.WedgeAngle = "300A00D5";
    DicomTag.WedgeFactor = "300A00D6";
    DicomTag.TotalWedgeTrayWaterEquivalentThickness = "300A00D7";
    DicomTag.WedgeOrientation = "300A00D8";
    DicomTag.IsocenterToWedgeTrayDistance = "300A00D9";
    DicomTag.SourceToWedgeTrayDistance = "300A00DA";
    DicomTag.WedgeThinEdgePosition = "300A00DB";
    DicomTag.BolusID = "300A00DC";
    DicomTag.BolusDescription = "300A00DD";
    DicomTag.EffectiveWedgeAngle = "300A00DE";
    DicomTag.NumberOfCompensators = "300A00E0";
    DicomTag.MaterialID = "300A00E1";
    DicomTag.TotalCompensatorTrayFactor = "300A00E2";
    DicomTag.CompensatorSequence = "300A00E3";
    DicomTag.CompensatorNumber = "300A00E4";
    DicomTag.CompensatorID = "300A00E5";
    DicomTag.SourceToCompensatorTrayDistance = "300A00E6";
    DicomTag.CompensatorRows = "300A00E7";
    DicomTag.CompensatorColumns = "300A00E8";
    DicomTag.CompensatorPixelSpacing = "300A00E9";
    DicomTag.CompensatorPosition = "300A00EA";
    DicomTag.CompensatorTransmissionData = "300A00EB";
    DicomTag.CompensatorThicknessData = "300A00EC";
    DicomTag.NumberOfBoli = "300A00ED";
    DicomTag.CompensatorType = "300A00EE";
    DicomTag.CompensatorTrayID = "300A00EF";
    DicomTag.NumberOfBlocks = "300A00F0";
    DicomTag.TotalBlockTrayFactor = "300A00F2";
    DicomTag.TotalBlockTrayWaterEquivalentThickness = "300A00F3";
    DicomTag.BlockSequence = "300A00F4";
    DicomTag.BlockTrayID = "300A00F5";
    DicomTag.SourceToBlockTrayDistance = "300A00F6";
    DicomTag.IsocenterToBlockTrayDistance = "300A00F7";
    DicomTag.BlockType = "300A00F8";
    DicomTag.AccessoryCode = "300A00F9";
    DicomTag.BlockDivergence = "300A00FA";
    DicomTag.BlockMountingPosition = "300A00FB";
    DicomTag.BlockNumber = "300A00FC";
    DicomTag.BlockName = "300A00FE";
    DicomTag.BlockThickness = "300A0100";
    DicomTag.BlockTransmission = "300A0102";
    DicomTag.BlockNumberOfPoints = "300A0104";
    DicomTag.BlockData = "300A0106";
    DicomTag.ApplicatorSequence = "300A0107";
    DicomTag.ApplicatorID = "300A0108";
    DicomTag.ApplicatorType = "300A0109";
    DicomTag.ApplicatorDescription = "300A010A";
    DicomTag.CumulativeDoseReferenceCoefficient = "300A010C";
    DicomTag.FinalCumulativeMetersetWeight = "300A010E";
    DicomTag.NumberOfControlPoints = "300A0110";
    DicomTag.ControlPointSequence = "300A0111";
    DicomTag.ControlPointIndex = "300A0112";
    DicomTag.NominalBeamEnergy = "300A0114";
    DicomTag.DoseRateSet = "300A0115";
    DicomTag.WedgePositionSequence = "300A0116";
    DicomTag.WedgePosition = "300A0118";
    DicomTag.BeamLimitingDevicePositionSequence = "300A011A";
    DicomTag.LeafJawPositions = "300A011C";
    DicomTag.GantryAngle = "300A011E";
    DicomTag.GantryRotationDirection = "300A011F";
    DicomTag.BeamLimitingDeviceAngle = "300A0120";
    DicomTag.BeamLimitingDeviceRotationDirection = "300A0121";
    DicomTag.PatientSupportAngle = "300A0122";
    DicomTag.PatientSupportRotationDirection = "300A0123";
    DicomTag.TableTopEccentricAxisDistance = "300A0124";
    DicomTag.TableTopEccentricAngle = "300A0125";
    DicomTag.TableTopEccentricRotationDirection = "300A0126";
    DicomTag.TableTopVerticalPosition = "300A0128";
    DicomTag.TableTopLongitudinalPosition = "300A0129";
    DicomTag.TableTopLateralPosition = "300A012A";
    DicomTag.IsocenterPosition = "300A012C";
    DicomTag.SurfaceEntryPoint = "300A012E";
    DicomTag.SourceToSurfaceDistance = "300A0130";
    DicomTag.AverageBeamDosePointSourceToExternalContourSurfaceDistance = "300A0131";
    DicomTag.SourceToExternalContourDistance = "300A0132";
    DicomTag.ExternalContourEntryPoint = "300A0133";
    DicomTag.CumulativeMetersetWeight = "300A0134";
    DicomTag.TableTopPitchAngle = "300A0140";
    DicomTag.TableTopPitchRotationDirection = "300A0142";
    DicomTag.TableTopRollAngle = "300A0144";
    DicomTag.TableTopRollRotationDirection = "300A0146";
    DicomTag.HeadFixationAngle = "300A0148";
    DicomTag.GantryPitchAngle = "300A014A";
    DicomTag.GantryPitchRotationDirection = "300A014C";
    DicomTag.GantryPitchAngleTolerance = "300A014E";
    DicomTag.PatientSetupSequence = "300A0180";
    DicomTag.PatientSetupNumber = "300A0182";
    DicomTag.PatientSetupLabel = "300A0183";
    DicomTag.PatientAdditionalPosition = "300A0184";
    DicomTag.FixationDeviceSequence = "300A0190";
    DicomTag.FixationDeviceType = "300A0192";
    DicomTag.FixationDeviceLabel = "300A0194";
    DicomTag.FixationDeviceDescription = "300A0196";
    DicomTag.FixationDevicePosition = "300A0198";
    DicomTag.FixationDevicePitchAngle = "300A0199";
    DicomTag.FixationDeviceRollAngle = "300A019A";
    DicomTag.ShieldingDeviceSequence = "300A01A0";
    DicomTag.ShieldingDeviceType = "300A01A2";
    DicomTag.ShieldingDeviceLabel = "300A01A4";
    DicomTag.ShieldingDeviceDescription = "300A01A6";
    DicomTag.ShieldingDevicePosition = "300A01A8";
    DicomTag.SetupTechnique = "300A01B0";
    DicomTag.SetupTechniqueDescription = "300A01B2";
    DicomTag.SetupDeviceSequence = "300A01B4";
    DicomTag.SetupDeviceType = "300A01B6";
    DicomTag.SetupDeviceLabel = "300A01B8";
    DicomTag.SetupDeviceDescription = "300A01BA";
    DicomTag.SetupDeviceParameter = "300A01BC";
    DicomTag.SetupReferenceDescription = "300A01D0";
    DicomTag.TableTopVerticalSetupDisplacement = "300A01D2";
    DicomTag.TableTopLongitudinalSetupDisplacement = "300A01D4";
    DicomTag.TableTopLateralSetupDisplacement = "300A01D6";
    DicomTag.BrachyTreatmentTechnique = "300A0200";
    DicomTag.BrachyTreatmentType = "300A0202";
    DicomTag.TreatmentMachineSequence = "300A0206";
    DicomTag.SourceSequence = "300A0210";
    DicomTag.SourceNumber = "300A0212";
    DicomTag.SourceType = "300A0214";
    DicomTag.SourceManufacturer = "300A0216";
    DicomTag.ActiveSourceDiameter = "300A0218";
    DicomTag.ActiveSourceLength = "300A021A";
    DicomTag.SourceModelID = "300A021B";
    DicomTag.SourceDescription = "300A021C";
    DicomTag.SourceEncapsulationNominalThickness = "300A0222";
    DicomTag.SourceEncapsulationNominalTransmission = "300A0224";
    DicomTag.SourceIsotopeName = "300A0226";
    DicomTag.SourceIsotopeHalfLife = "300A0228";
    DicomTag.SourceStrengthUnits = "300A0229";
    DicomTag.ReferenceAirKermaRate = "300A022A";
    DicomTag.SourceStrength = "300A022B";
    DicomTag.SourceStrengthReferenceDate = "300A022C";
    DicomTag.SourceStrengthReferenceTime = "300A022E";
    DicomTag.ApplicationSetupSequence = "300A0230";
    DicomTag.ApplicationSetupType = "300A0232";
    DicomTag.ApplicationSetupNumber = "300A0234";
    DicomTag.ApplicationSetupName = "300A0236";
    DicomTag.ApplicationSetupManufacturer = "300A0238";
    DicomTag.TemplateNumber = "300A0240";
    DicomTag.TemplateType = "300A0242";
    DicomTag.TemplateName = "300A0244";
    DicomTag.TotalReferenceAirKerma = "300A0250";
    DicomTag.BrachyAccessoryDeviceSequence = "300A0260";
    DicomTag.BrachyAccessoryDeviceNumber = "300A0262";
    DicomTag.BrachyAccessoryDeviceID = "300A0263";
    DicomTag.BrachyAccessoryDeviceType = "300A0264";
    DicomTag.BrachyAccessoryDeviceName = "300A0266";
    DicomTag.BrachyAccessoryDeviceNominalThickness = "300A026A";
    DicomTag.BrachyAccessoryDeviceNominalTransmission = "300A026C";
    DicomTag.ChannelSequence = "300A0280";
    DicomTag.ChannelNumber = "300A0282";
    DicomTag.ChannelLength = "300A0284";
    DicomTag.ChannelTotalTime = "300A0286";
    DicomTag.SourceMovementType = "300A0288";
    DicomTag.NumberOfPulses = "300A028A";
    DicomTag.PulseRepetitionInterval = "300A028C";
    DicomTag.SourceApplicatorNumber = "300A0290";
    DicomTag.SourceApplicatorID = "300A0291";
    DicomTag.SourceApplicatorType = "300A0292";
    DicomTag.SourceApplicatorName = "300A0294";
    DicomTag.SourceApplicatorLength = "300A0296";
    DicomTag.SourceApplicatorManufacturer = "300A0298";
    DicomTag.SourceApplicatorWallNominalThickness = "300A029C";
    DicomTag.SourceApplicatorWallNominalTransmission = "300A029E";
    DicomTag.SourceApplicatorStepSize = "300A02A0";
    DicomTag.TransferTubeNumber = "300A02A2";
    DicomTag.TransferTubeLength = "300A02A4";
    DicomTag.ChannelShieldSequence = "300A02B0";
    DicomTag.ChannelShieldNumber = "300A02B2";
    DicomTag.ChannelShieldID = "300A02B3";
    DicomTag.ChannelShieldName = "300A02B4";
    DicomTag.ChannelShieldNominalThickness = "300A02B8";
    DicomTag.ChannelShieldNominalTransmission = "300A02BA";
    DicomTag.FinalCumulativeTimeWeight = "300A02C8";
    DicomTag.BrachyControlPointSequence = "300A02D0";
    DicomTag.ControlPointRelativePosition = "300A02D2";
    DicomTag.ControlPoint3DPosition = "300A02D4";
    DicomTag.CumulativeTimeWeight = "300A02D6";
    DicomTag.CompensatorDivergence = "300A02E0";
    DicomTag.CompensatorMountingPosition = "300A02E1";
    DicomTag.SourceToCompensatorDistance = "300A02E2";
    DicomTag.TotalCompensatorTrayWaterEquivalentThickness = "300A02E3";
    DicomTag.IsocenterToCompensatorTrayDistance = "300A02E4";
    DicomTag.CompensatorColumnOffset = "300A02E5";
    DicomTag.IsocenterToCompensatorDistances = "300A02E6";
    DicomTag.CompensatorRelativeStoppingPowerRatio = "300A02E7";
    DicomTag.CompensatorMillingToolDiameter = "300A02E8";
    DicomTag.IonRangeCompensatorSequence = "300A02EA";
    DicomTag.CompensatorDescription = "300A02EB";
    DicomTag.RadiationMassNumber = "300A0302";
    DicomTag.RadiationAtomicNumber = "300A0304";
    DicomTag.RadiationChargeState = "300A0306";
    DicomTag.ScanMode = "300A0308";
    DicomTag.VirtualSourceAxisDistances = "300A030A";
    DicomTag.SnoutSequence = "300A030C";
    DicomTag.SnoutPosition = "300A030D";
    DicomTag.SnoutID = "300A030F";
    DicomTag.NumberOfRangeShifters = "300A0312";
    DicomTag.RangeShifterSequence = "300A0314";
    DicomTag.RangeShifterNumber = "300A0316";
    DicomTag.RangeShifterID = "300A0318";
    DicomTag.RangeShifterType = "300A0320";
    DicomTag.RangeShifterDescription = "300A0322";
    DicomTag.NumberOfLateralSpreadingDevices = "300A0330";
    DicomTag.LateralSpreadingDeviceSequence = "300A0332";
    DicomTag.LateralSpreadingDeviceNumber = "300A0334";
    DicomTag.LateralSpreadingDeviceID = "300A0336";
    DicomTag.LateralSpreadingDeviceType = "300A0338";
    DicomTag.LateralSpreadingDeviceDescription = "300A033A";
    DicomTag.LateralSpreadingDeviceWaterEquivalentThickness = "300A033C";
    DicomTag.NumberOfRangeModulators = "300A0340";
    DicomTag.RangeModulatorSequence = "300A0342";
    DicomTag.RangeModulatorNumber = "300A0344";
    DicomTag.RangeModulatorID = "300A0346";
    DicomTag.RangeModulatorType = "300A0348";
    DicomTag.RangeModulatorDescription = "300A034A";
    DicomTag.BeamCurrentModulationID = "300A034C";
    DicomTag.PatientSupportType = "300A0350";
    DicomTag.PatientSupportID = "300A0352";
    DicomTag.PatientSupportAccessoryCode = "300A0354";
    DicomTag.FixationLightAzimuthalAngle = "300A0356";
    DicomTag.FixationLightPolarAngle = "300A0358";
    DicomTag.MetersetRate = "300A035A";
    DicomTag.RangeShifterSettingsSequence = "300A0360";
    DicomTag.RangeShifterSetting = "300A0362";
    DicomTag.IsocenterToRangeShifterDistance = "300A0364";
    DicomTag.RangeShifterWaterEquivalentThickness = "300A0366";
    DicomTag.LateralSpreadingDeviceSettingsSequence = "300A0370";
    DicomTag.LateralSpreadingDeviceSetting = "300A0372";
    DicomTag.IsocenterToLateralSpreadingDeviceDistance = "300A0374";
    DicomTag.RangeModulatorSettingsSequence = "300A0380";
    DicomTag.RangeModulatorGatingStartValue = "300A0382";
    DicomTag.RangeModulatorGatingStopValue = "300A0384";
    DicomTag.RangeModulatorGatingStartWaterEquivalentThickness = "300A0386";
    DicomTag.RangeModulatorGatingStopWaterEquivalentThickness = "300A0388";
    DicomTag.IsocenterToRangeModulatorDistance = "300A038A";
    DicomTag.ScanSpotTuneID = "300A0390";
    DicomTag.NumberOfScanSpotPositions = "300A0392";
    DicomTag.ScanSpotPositionMap = "300A0394";
    DicomTag.ScanSpotMetersetWeights = "300A0396";
    DicomTag.ScanningSpotSize = "300A0398";
    DicomTag.NumberOfPaintings = "300A039A";
    DicomTag.IonToleranceTableSequence = "300A03A0";
    DicomTag.IonBeamSequence = "300A03A2";
    DicomTag.IonBeamLimitingDeviceSequence = "300A03A4";
    DicomTag.IonBlockSequence = "300A03A6";
    DicomTag.IonControlPointSequence = "300A03A8";
    DicomTag.IonWedgeSequence = "300A03AA";
    DicomTag.IonWedgePositionSequence = "300A03AC";
    DicomTag.ReferencedSetupImageSequence = "300A0401";
    DicomTag.SetupImageComment = "300A0402";
    DicomTag.MotionSynchronizationSequence = "300A0410";
    DicomTag.ControlPointOrientation = "300A0412";
    DicomTag.GeneralAccessorySequence = "300A0420";
    DicomTag.GeneralAccessoryID = "300A0421";
    DicomTag.GeneralAccessoryDescription = "300A0422";
    DicomTag.GeneralAccessoryType = "300A0423";
    DicomTag.GeneralAccessoryNumber = "300A0424";
    DicomTag.SourceToGeneralAccessoryDistance = "300A0425";
    DicomTag.ApplicatorGeometrySequence = "300A0431";
    DicomTag.ApplicatorApertureShape = "300A0432";
    DicomTag.ApplicatorOpening = "300A0433";
    DicomTag.ApplicatorOpeningX = "300A0434";
    DicomTag.ApplicatorOpeningY = "300A0435";
    DicomTag.SourceToApplicatorMountingPositionDistance = "300A0436";
    DicomTag.NumberOfBlockSlabItems = "300A0440";
    DicomTag.BlockSlabSequence = "300A0441";
    DicomTag.BlockSlabThickness = "300A0442";
    DicomTag.BlockSlabNumber = "300A0443";
    DicomTag.DeviceMotionControlSequence = "300A0450";
    DicomTag.DeviceMotionExecutionMode = "300A0451";
    DicomTag.DeviceMotionObservationMode = "300A0452";
    DicomTag.DeviceMotionParameterCodeSequence = "300A0453";
    // *****************************************************************************************************************************
    // *** 300C
    // *****************************************************************************************************************************
    DicomTag.ReferencedRTPlanSequence = "300C0002";
    DicomTag.ReferencedBeamSequence = "300C0004";
    DicomTag.ReferencedBeamNumber = "300C0006";
    DicomTag.ReferencedReferenceImageNumber = "300C0007";
    DicomTag.StartCumulativeMetersetWeight = "300C0008";
    DicomTag.EndCumulativeMetersetWeight = "300C0009";
    DicomTag.ReferencedBrachyApplicationSetupSequence = "300C000A";
    DicomTag.ReferencedBrachyApplicationSetupNumber = "300C000C";
    DicomTag.ReferencedSourceNumber = "300C000E";
    DicomTag.ReferencedFractionGroupSequence = "300C0020";
    DicomTag.ReferencedFractionGroupNumber = "300C0022";
    DicomTag.ReferencedVerificationImageSequence = "300C0040";
    DicomTag.ReferencedReferenceImageSequence = "300C0042";
    DicomTag.ReferencedDoseReferenceSequence = "300C0050";
    DicomTag.ReferencedDoseReferenceNumber = "300C0051";
    DicomTag.BrachyReferencedDoseReferenceSequence = "300C0055";
    DicomTag.ReferencedStructureSetSequence = "300C0060";
    DicomTag.ReferencedPatientSetupNumber = "300C006A";
    DicomTag.ReferencedDoseSequence = "300C0080";
    DicomTag.ReferencedToleranceTableNumber = "300C00A0";
    DicomTag.ReferencedBolusSequence = "300C00B0";
    DicomTag.ReferencedWedgeNumber = "300C00C0";
    DicomTag.ReferencedCompensatorNumber = "300C00D0";
    DicomTag.ReferencedBlockNumber = "300C00E0";
    DicomTag.ReferencedControlPointIndex = "300C00F0";
    DicomTag.ReferencedControlPointSequence = "300C00F2";
    DicomTag.ReferencedStartControlPointIndex = "300C00F4";
    DicomTag.ReferencedStopControlPointIndex = "300C00F6";
    DicomTag.ReferencedRangeShifterNumber = "300C0100";
    DicomTag.ReferencedLateralSpreadingDeviceNumber = "300C0102";
    DicomTag.ReferencedRangeModulatorNumber = "300C0104";
    DicomTag.OmittedBeamTaskSequence = "300C0111";
    DicomTag.ReasonForOmission = "300C0112";
    DicomTag.ReasonForOmissionDescription = "300C0113";
    // *****************************************************************************************************************************
    // *** 300E
    // *****************************************************************************************************************************
    DicomTag.ApprovalStatus = "300E0002";
    DicomTag.ReviewDate = "300E0004";
    DicomTag.ReviewTime = "300E0005";
    DicomTag.ReviewerName = "300E0008";
    // *****************************************************************************************************************************
    // *** 4000
    // *****************************************************************************************************************************
    DicomTag.Arbitrary = "40000010"; // Retired
    DicomTag.TextComments = "40004000"; // Retired
    // *****************************************************************************************************************************
    // *** 4008
    // *****************************************************************************************************************************
    DicomTag.ResultsID = "40080040"; // Retired
    DicomTag.ResultsIDIssuer = "40080042"; // Retired
    DicomTag.ReferencedInterpretationSequence = "40080050"; // Retired
    DicomTag.ReportProductionStatusTrial = "400800FF"; // Retired
    DicomTag.InterpretationRecordedDate = "40080100"; // Retired
    DicomTag.InterpretationRecordedTime = "40080101"; // Retired
    DicomTag.InterpretationRecorder = "40080102"; // Retired
    DicomTag.ReferenceToRecordedSound = "40080103"; // Retired
    DicomTag.InterpretationTranscriptionDate = "40080108"; // Retired
    DicomTag.InterpretationTranscriptionTime = "40080109"; // Retired
    DicomTag.InterpretationTranscriber = "4008010A"; // Retired
    DicomTag.InterpretationText = "4008010B"; // Retired
    DicomTag.InterpretationAuthor = "4008010C"; // Retired
    DicomTag.InterpretationApproverSequence = "40080111"; // Retired
    DicomTag.InterpretationApprovalDate = "40080112"; // Retired
    DicomTag.InterpretationApprovalTime = "40080113"; // Retired
    DicomTag.PhysicianApprovingInterpretation = "40080114"; // Retired
    DicomTag.InterpretationDiagnosisDescription = "40080115"; // Retired
    DicomTag.InterpretationDiagnosisCodeSequence = "40080117"; // Retired
    DicomTag.ResultsDistributionListSequence = "40080118"; // Retired
    DicomTag.DistributionName = "40080119"; // Retired
    DicomTag.DistributionAddress = "4008011A"; // Retired
    DicomTag.InterpretationID = "40080200"; // Retired
    DicomTag.InterpretationIDIssuer = "40080202"; // Retired
    DicomTag.InterpretationTypeID = "40080210"; // Retired
    DicomTag.InterpretationStatusID = "40080212"; // Retired
    DicomTag.Impressions = "40080300"; // Retired
    DicomTag.ResultsComments = "40084000"; // Retired
    // *****************************************************************************************************************************
    // *** 4010
    // *****************************************************************************************************************************
    DicomTag.LowEnergyDetectors = "40100001";
    DicomTag.HighEnergyDetectors = "40100002";
    DicomTag.DetectorGeometrySequence = "40100004";
    DicomTag.ThreatROIVoxelSequence = "40101001";
    DicomTag.ThreatROIBase = "40101004";
    DicomTag.ThreatROIExtents = "40101005";
    DicomTag.ThreatROIBitmap = "40101006";
    DicomTag.RouteSegmentID = "40101007";
    DicomTag.GantryType = "40101008";
    DicomTag.OOIOwnerType = "40101009";
    DicomTag.RouteSegmentSequence = "4010100A";
    DicomTag.PotentialThreatObjectID = "40101010";
    DicomTag.ThreatSequence = "40101011";
    DicomTag.ThreatCategory = "40101012";
    DicomTag.ThreatCategoryDescription = "40101013";
    DicomTag.ATDAbilityAssessment = "40101014";
    DicomTag.ATDAssessmentFlag = "40101015";
    DicomTag.ATDAssessmentProbability = "40101016";
    DicomTag.Mass = "40101017";
    DicomTag.Density = "40101018";
    DicomTag.ZEffective = "40101019";
    DicomTag.BoardingPassID = "4010101A";
    DicomTag.CenterOfMass = "4010101B";
    DicomTag.CenterOfPTO = "4010101C";
    DicomTag.BoundingPolygon = "4010101D";
    DicomTag.RouteSegmentStartLocationID = "4010101E";
    DicomTag.RouteSegmentEndLocationID = "4010101F";
    DicomTag.RouteSegmentLocationIDType = "40101020";
    DicomTag.AbortReason = "40101021";
    DicomTag.VolumeOfPTO = "40101023";
    DicomTag.AbortFlag = "40101024";
    DicomTag.RouteSegmentStartTime = "40101025";
    DicomTag.RouteSegmentEndTime = "40101026";
    DicomTag.TDRType = "40101027";
    DicomTag.InternationalRouteSegment = "40101028";
    DicomTag.ThreatDetectionAlgorithmAndVersion = "40101029";
    DicomTag.AssignedLocation = "4010102A";
    DicomTag.AlarmDecisionTime = "4010102B";
    DicomTag.AlarmDecision = "40101031";
    DicomTag.NumberOfTotalObjects = "40101033";
    DicomTag.NumberOfAlarmObjects = "40101034";
    DicomTag.PTORepresentationSequence = "40101037";
    DicomTag.ATDAssessmentSequence = "40101038";
    DicomTag.TIPType = "40101039";
    DicomTag.DICOSVersion = "4010103A";
    DicomTag.OOIOwnerCreationTime = "40101041";
    DicomTag.OOIType = "40101042";
    DicomTag.OOISize = "40101043";
    DicomTag.AcquisitionStatus = "40101044";
    DicomTag.BasisMaterialsCodeSequence = "40101045";
    DicomTag.PhantomType = "40101046";
    DicomTag.OOIOwnerSequence = "40101047";
    DicomTag.ScanType = "40101048";
    DicomTag.ItineraryID = "40101051";
    DicomTag.ItineraryIDType = "40101052";
    DicomTag.ItineraryIDAssigningAuthority = "40101053";
    DicomTag.RouteID = "40101054";
    DicomTag.RouteIDAssigningAuthority = "40101055";
    DicomTag.InboundArrivalType = "40101056";
    DicomTag.CarrierID = "40101058";
    DicomTag.CarrierIDAssigningAuthority = "40101059";
    DicomTag.SourceOrientation = "40101060";
    DicomTag.SourcePosition = "40101061";
    DicomTag.BeltHeight = "40101062";
    DicomTag.AlgorithmRoutingCodeSequence = "40101064";
    DicomTag.TransportClassification = "40101067";
    DicomTag.OOITypeDescriptor = "40101068";
    DicomTag.TotalProcessingTime = "40101069";
    DicomTag.DetectorCalibrationData = "4010106C";
    DicomTag.AdditionalScreeningPerformed = "4010106D";
    DicomTag.AdditionalInspectionSelectionCriteria = "4010106E";
    DicomTag.AdditionalInspectionMethodSequence = "4010106F";
    DicomTag.AITDeviceType = "40101070";
    DicomTag.QRMeasurementsSequence = "40101071";
    DicomTag.TargetMaterialSequence = "40101072";
    DicomTag.SNRThreshold = "40101073";
    DicomTag.ImageScaleRepresentation = "40101075";
    DicomTag.ReferencedPTOSequence = "40101076";
    DicomTag.ReferencedTDRInstanceSequence = "40101077";
    DicomTag.PTOLocationDescription = "40101078";
    DicomTag.AnomalyLocatorIndicatorSequence = "40101079";
    DicomTag.AnomalyLocatorIndicator = "4010107A";
    DicomTag.PTORegionSequence = "4010107B";
    DicomTag.InspectionSelectionCriteria = "4010107C";
    DicomTag.SecondaryInspectionMethodSequence = "4010107D";
    DicomTag.PRCSToRCSOrientation = "4010107E";
    // *****************************************************************************************************************************
    // *** 4FFE
    // *****************************************************************************************************************************
    DicomTag.MACParametersSequence = "4FFE0001";
    // *****************************************************************************************************************************
    // *** 50xx
    // *****************************************************************************************************************************
    DicomTag.CurveDimensions = "50000005"; // Retired
    DicomTag.NumberOfPoints = "50000010"; // Retired
    DicomTag.TypeOfData = "50000020"; // Retired
    DicomTag.CurveDescription = "50000022"; // Retired
    DicomTag.AxisUnits = "50000030"; // Retired
    DicomTag.AxisLabels = "50000040"; // Retired
    DicomTag.DataValueRepresentation = "50000103"; // Retired
    DicomTag.MinimumCoordinateValue = "50000104"; // Retired
    DicomTag.MaximumCoordinateValue = "50000105"; // Retired
    DicomTag.CurveRange = "50000106"; // Retired
    DicomTag.CurveDataDescriptor = "50000110"; // Retired
    DicomTag.CoordinateStartValue = "50000112"; // Retired
    DicomTag.CoordinateStepValue = "50000114"; // Retired
    DicomTag.CurveActivationLayer = "50001001"; // Retired
    DicomTag.AudioType = "50002000"; // Retired
    DicomTag.AudioSampleFormat = "50002002"; // Retired
    DicomTag.NumberOfChannels = "50002004"; // Retired
    DicomTag.NumberOfSamples = "50002006"; // Retired
    DicomTag.SampleRate = "50002008"; // Retired
    DicomTag.TotalTime = "5000200A"; // Retired
    DicomTag.AudioSampleData = "5000200C"; // Retired
    DicomTag.AudioComments = "5000200E"; // Retired
    DicomTag.CurveLabel = "50002500"; // Retired
    DicomTag.CurveReferencedOverlaySequence = "50002600"; // Retired
    DicomTag.CurveReferencedOverlayGroup = "50002610"; // Retired
    DicomTag.CurveData = "50003000"; // Retired
    // *****************************************************************************************************************************
    // *** 5200
    // *****************************************************************************************************************************
    DicomTag.SharedFunctionalGroupsSequence = "52009229";
    DicomTag.PerFrameFunctionalGroupsSequence = "52009230";
    // *****************************************************************************************************************************
    // *** 5400
    // *****************************************************************************************************************************
    DicomTag.WaveformSequence = "54000100";
    DicomTag.ChannelMinimumValue = "54000110";
    DicomTag.ChannelMaximumValue = "54000112";
    DicomTag.WaveformBitsAllocated = "54001004";
    DicomTag.WaveformSampleInterpretation = "54001006";
    DicomTag.WaveformPaddingValue = "5400100A";
    DicomTag.WaveformData = "54001010";
    // *****************************************************************************************************************************
    // *** 5600
    // *****************************************************************************************************************************
    DicomTag.FirstOrderPhaseCorrectionAngle = "56000010";
    DicomTag.SpectroscopyData = "56000020";
    // *****************************************************************************************************************************
    // *** 60xx
    // *****************************************************************************************************************************
    DicomTag.OverlayRows = "60000010";
    DicomTag.OverlayColumns = "60000011";
    DicomTag.OverlayPlanes = "60000012"; // Retired
    DicomTag.NumberOfFramesInOverlay = "60000015";
    DicomTag.OverlayDescription = "60000022";
    DicomTag.OverlayType = "60000040";
    DicomTag.OverlaySubtype = "60000045";
    DicomTag.OverlayOrigin = "60000050";
    DicomTag.ImageFrameOrigin = "60000051";
    DicomTag.OverlayPlaneOrigin = "60000052"; // Retired
    DicomTag.OverlayCompressionCode = "60000060"; // Retired
    DicomTag.OverlayCompressionOriginator = "60000061"; // Retired
    DicomTag.OverlayCompressionLabel = "60000062"; // Retired
    DicomTag.OverlayCompressionDescription = "60000063"; // Retired
    DicomTag.OverlayCompressionStepPointers = "60000066"; // Retired
    DicomTag.OverlayRepeatInterval = "60000068"; // Retired
    DicomTag.OverlayBitsGrouped = "60000069"; // Retired
    DicomTag.OverlayBitsAllocated = "60000100";
    DicomTag.OverlayBitPosition = "60000102";
    DicomTag.OverlayFormat = "60000110"; // Retired
    DicomTag.OverlayLocation = "60000200"; // Retired
    DicomTag.OverlayCodeLabel = "60000800"; // Retired
    DicomTag.OverlayNumberOfTables = "60000802"; // Retired
    DicomTag.OverlayCodeTableLocation = "60000803"; // Retired
    DicomTag.OverlayBitsForCodeWord = "60000804"; // Retired
    DicomTag.OverlayActivationLayer = "60001001";
    DicomTag.OverlayDescriptorGray = "60001100"; // Retired
    DicomTag.OverlayDescriptorRed = "60001101"; // Retired
    DicomTag.OverlayDescriptorGreen = "60001102"; // Retired
    DicomTag.OverlayDescriptorBlue = "60001103"; // Retired
    DicomTag.OverlaysGray = "60001200"; // Retired
    DicomTag.OverlaysRed = "60001201"; // Retired
    DicomTag.OverlaysGreen = "60001202"; // Retired
    DicomTag.OverlaysBlue = "60001203"; // Retired
    DicomTag.ROIArea = "60001301";
    DicomTag.ROIMean = "60001302";
    DicomTag.ROIStandardDeviation = "60001303";
    DicomTag.OverlayLabel = "60001500";
    DicomTag.OverlayData = "60003000";
    DicomTag.OverlayComments = "60004000"; // Retired
    // *****************************************************************************************************************************
    // *** 7FE0
    // *****************************************************************************************************************************
    DicomTag.FloatPixelData = "7FE00008";
    DicomTag.DoubleFloatPixelData = "7FE00009";
    DicomTag.PixelData = "7FE00010";
    DicomTag.CoefficientsSDVN = "7FE00020"; // Retired
    DicomTag.CoefficientsSDHN = "7FE00030"; // Retired
    DicomTag.CoefficientsSDDN = "7FE00040"; // Retired
    // *****************************************************************************************************************************
    // *** 7Fxx
    // *****************************************************************************************************************************
    DicomTag.VariablePixelData = "7F000010"; // Retired
    DicomTag.VariableNextDataGroup = "7F000011"; // Retired
    DicomTag.VariableCoefficientsSDVN = "7F000020"; // Retired
    DicomTag.VariableCoefficientsSDHN = "7F000030"; // Retired
    DicomTag.VariableCoefficientsSDDN = "7F000040"; // Retired
    // *****************************************************************************************************************************
    // *** FFFA
    // *****************************************************************************************************************************
    DicomTag.DigitalSignaturesSequence = "FFFAFFFA";
    // *****************************************************************************************************************************
    // *** FFFC
    // *****************************************************************************************************************************
    DicomTag.DataSetTrailingPadding = "FFFCFFFC";
    // *****************************************************************************************************************************
    // *** FFFE
    // *****************************************************************************************************************************
    DicomTag.Item = "FFFEE000";
    DicomTag.ItemDelimitationItem = "FFFEE00D";
    DicomTag.SequenceDelimitationItem = "FFFEE0DD";
})(DicomTag || (DicomTag = {}));
var DicomHelper = /** @class */ (function () {
    function DicomHelper() {
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    ////   function Name: PreparePresentationInformation                                     
    ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    ////                                                                                              ///
    ///    Converts the raw presentation information retrieved from the proxy into values that can    ///
    ///    be handled easily in the medical viewer.                                                   ///
    ////                                                                                              ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    DicomHelper.supportWindowLevel = function (cell, index) {
        if (cell.supportWindowLevel)
            return cell.supportWindowLevel(index);
        else
            return true;
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    ////   function Name: PreparePresentationInformation                                     
    ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    ////                                                                                              ///
    ///    Converts the raw presentation information retrieved from the proxy into values that can    ///
    ///    be handled easily in the medical viewer.                                                   ///
    ////                                                                                              ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    DicomHelper.PreparePresentationInformation = function (presentationInformationRaw, pageIndex) {
        var frameInfo = new Models.FramePresentationInfo();
        frameInfo.orientation = null;
        frameInfo.width = 100;
        frameInfo.height = 100;
        frameInfo.position = [1, 1, 1];
        frameInfo.instanceNumber = 1;
        frameInfo.rowSpacing = 0;
        frameInfo.columnSpacing = 0;
        //if (frameInfo.orientation != null)
        //    frameInfo.orientationOverlay = new lt.Controls.Medical.OrientationLetters(frameInfo.orientation);
        frameInfo.cineOptions = presentationInformationRaw.Cine;
        if (presentationInformationRaw == null)
            return frameInfo;
        if (presentationInformationRaw.PagesPresentationInfo.length <= pageIndex)
            return frameInfo;
        var pageInfo = presentationInformationRaw.PagesPresentationInfo[pageIndex];
        if (pageInfo == null)
            return frameInfo;
        // create orientation array.
        if (pageInfo.ImageOrientationPatientArray != null) {
            frameInfo.orientation = pageInfo.ImageOrientationPatientArray;
        }
        else if (pageInfo.PatientOrientation != null) {
            frameInfo.patientOrientation = pageInfo.PatientOrientation;
            // we removed this, since if there is no orientation value present, we don't render the orientation overlay.
            // default value, when there is no orientation information available.
            //frameInfo.orientation = [1, 0, 0, 0, 1, 0];
        }
        // get the width and height.
        if (null != pageInfo.Width)
            frameInfo.width = pageInfo.Width[0];
        if (null != pageInfo.Height)
            frameInfo.height = pageInfo.Height[0];
        // get the image position.
        if (pageInfo.ImagePositionPatientArray != null) {
            frameInfo.position = pageInfo.ImagePositionPatientArray;
        }
        else {
            // default value, when there is no position information available.
            frameInfo.position = [1, 1, 1];
        }
        // get the instance number.
        if (null != presentationInformationRaw.InstanceNumber)
            frameInfo.instanceNumber = parseInt(presentationInformationRaw.InstanceNumber);
        // get the row spacing and columns spacing.
        if (pageInfo.PixelSpacingPatientArray != null) {
            if (pageInfo.PixelSpacingPatientArray.length == 2) {
                var values = pageInfo.PixelSpacingPatientArray;
                frameInfo.rowSpacing = parseFloat(values[0]);
                frameInfo.columnSpacing = parseFloat(values[1]);
            }
        }
        // create the orientation object that is used to render the orientation letters on the viewer.
        //if (frameInfo.orientation != null)
        //     frameInfo.orientationOverlay = new lt.Controls.Medical._orientationLetters(frameInfo.orientation);
        // else
        //    if (frameInfo.patientOrientation != null) {
        //         {
        //             var orientation = frameInfo.patientOrientation;
        //             frameInfo.orientationOverlay = new lt.Controls.Medical._orientationLetters([0, 1, 0, 0, 1, 0]);
        //             frameInfo.orientationOverlay.setProjectionRadiographOrientation(orientation);
        //         }
        //     }
        return frameInfo;
    };
    DicomHelper.GetBitsPerPixel = function (dicomDataSet) {
        var samplesPerPixelTag = DicomHelper.getDicomTag(dicomDataSet, DicomTag.SamplesPerPixel);
        var bitsAllocatedTag = DicomHelper.getDicomTag(dicomDataSet, DicomTag.BitsAllocated);
        var bpp;
        if (samplesPerPixelTag != null && samplesPerPixelTag.Value.length > 0) {
            bpp = parseInt(DicomHelper.GetTagText(samplesPerPixelTag), 10);
        }
        return bpp * parseInt(DicomHelper.GetTagText(bitsAllocatedTag), 10);
    };
    DicomHelper.GetTagText = function (tag) {
        if (!tag)
            return '';
        if (tag.Value && tag.Value.length > 0)
            return tag.Value.join("\\");
        return '';
    };
    DicomHelper.TagExists = function (metadata, tagNumber) {
        var tag = metadata[tagNumber];
        var noExists = (typeof tag === "undefined");
        return !noExists;
    };
    DicomHelper.IsDicomImage = function (metadata) {
        var imageTags = [
            DicomTag.Columns,
            DicomTag.Rows,
            DicomTag.BitsAllocated,
            DicomTag.BitsStored
        ];
        var len = imageTags.length;
        for (var i = 0; i < len; i++) {
            if (!this.TagExists(metadata, imageTags[i]))
                return false;
        }
        return true;
    };
    DicomHelper.GetTagTextValue = function (metadata, tag) {
        var tagId = this.findTag(metadata, tag);
        if (null != tagId && tagId.Value && tagId.Value.length > 0) {
            return DicomHelper.GetTagText(tagId);
        }
    };
    DicomHelper.GetDicomImageInformation = function (metadata, frameIndex) {
        var imageInfo = new lt.Controls.Medical.DICOMImageInformation();
        var imageWidthTag = metadata[DicomTag.Columns];
        var imageHeightTag = metadata[DicomTag.Rows];
        var windowWidthTag = metadata[DicomTag.WindowWidth];
        var windowCenterTag = metadata[DicomTag.WindowCenter];
        var smallestTag = metadata[DicomTag.SmallestImagePixelValue]; //Smallest Image Pixel Value
        var largestTag = metadata[DicomTag.LargestImagePixelValue]; //Largest Image Pixel Value
        var hightBitTag = metadata[DicomTag.HighBit]; //hight bit
        var bitsStoredTag = metadata[DicomTag.BitsStored]; //bit Stored
        var interceptTag = this.findTag(metadata, DicomTag.RescaleIntercept); //Rescale Intercept
        var SlopeTag = this.findTag(metadata, DicomTag.RescaleSlope); //Rescale Slope
        var viewPosition = this.findTag(metadata, DicomTag.ViewPosition);
        var patientOrientationTag = this.findTag(metadata, "00200020"); //Paitent orientation, this is just incase the image orientation is not present
        var orientationTag = this.findTag(metadata, "00200037"); //Image Patient Orientation.
        var positionTag = this.findTag(metadata, "00200032"); //Image Patient Position.
        var frameOfReferenceUID = metadata["00200052"]; //Frame of reference UID
        var voiLutSequence = metadata["00283010"]; //VOI LUT Sequence
        var waveFormSequence = metadata["54000100"]; //Wave Form Sequence
        var imageTypeTag = metadata["00080008"]; //Image Type
        var lossyImageCompressionTag = metadata["00282110"]; //The Lossy Image Compression 
        var lutDescriptor = null;
        var lutData = null;
        if (voiLutSequence && voiLutSequence.Value && voiLutSequence.Value.length > 0) {
            var seqItem = voiLutSequence.Value[0];
            if (seqItem && !$.isEmptyObject(seqItem)) {
                lutDescriptor = seqItem['00283002']; //LUT Descriptor
                lutData = seqItem['00283006']; //LUT Data
            }
        }
        var signedTag = metadata["00280103"]; //Pixel Representation
        var mimeType = metadata["00420012"]; //Imager Pixel Spacing
        var photometricInterpretationTag = metadata["00280004"]; //Photometric Interpretation
        var imagerPixelSpacingTag = metadata["00181164"]; //Imager Pixel Spacing
        var pixelSpacingTag = this.findTag(metadata, "00280030"); //Pixel Spacing
        var nominalScannedPixelSpacingTag = metadata["00182010"]; //Nominal Scanned Pixel Spacing
        var detectorElementSpacingTag = metadata["00187022"]; //Detector Element Spacing
        var perFrameArray = metadata[DicomTag.PerFrameFunctionalGroupsSequence];
        var width;
        var height;
        var bpp = 1;
        var bitsStored = 0;
        var highBit;
        var lowBit = 0;
        var signed = false;
        if (imageWidthTag && imageWidthTag.Value.length) {
            width = DicomHelper.GetTagText(imageWidthTag);
        }
        else {
            width = 0;
        }
        if (imageHeightTag && imageHeightTag.Value.length) {
            height = DicomHelper.GetTagText(imageHeightTag);
        }
        else {
            height = 0;
        }
        bpp = DicomHelper.GetBitsPerPixel(metadata);
        if (null != bitsStoredTag && bitsStoredTag.Value && bitsStoredTag.Value.length > 0) {
            bitsStored = parseInt(DicomHelper.GetTagText(bitsStoredTag), 10);
        }
        else {
            bitsStored = bpp;
        }
        if (perFrameArray != null && perFrameArray.Value && perFrameArray.Value.length > 0) {
            var perFrameItem = perFrameArray.Value[frameIndex];
            if (perFrameItem != null) {
                if (perFrameItem[DicomTag.PlanePositionSequence]) {
                    var positionItem = perFrameItem[DicomTag.PlanePositionSequence].Value[0];
                    if (positionItem != null) {
                        positionTag = positionItem[DicomTag.ImagePositionPatient];
                    }
                    if (perFrameItem[DicomTag.PlaneOrientationSequence]) {
                        var orientationItem = perFrameItem[DicomTag.PlaneOrientationSequence].Value[0];
                        if (orientationItem != null) {
                            orientationTag = orientationItem[DicomTag.ImageOrientationPatient];
                        }
                    }
                }
            }
        }
        imageInfo.set_width(parseInt(width, 10));
        imageInfo.set_height(parseInt(height, 10));
        imageInfo.set_bitsPerPixel(bpp);
        if (hightBitTag != null && hightBitTag.Value && hightBitTag.Value.length > 0) {
            highBit = parseInt(DicomHelper.GetTagText(hightBitTag), 10);
            lowBit = highBit - bitsStored + 1;
        }
        else {
            highBit = bpp - 1;
            imageInfo.set_lowBit(0);
        }
        if (viewPosition != null && viewPosition.Value && viewPosition.Value.length > 0) {
            imageInfo.viewPosition = DicomHelper.GetTagText(viewPosition);
        }
        imageInfo.set_highBit(highBit);
        imageInfo.set_lowBit(lowBit);
        var interceptValue = 0;
        if (interceptTag && interceptTag.Value && interceptTag.Value.length > 0) {
            interceptValue = parseFloat(DicomHelper.GetTagText(interceptTag));
            imageInfo.set_modalityIntercept(interceptValue);
        }
        else {
            imageInfo.set_modalityIntercept(0);
        }
        if (null != SlopeTag && SlopeTag.Value && SlopeTag.Value.length > 0) {
            var slope = parseFloat(DicomHelper.GetTagText(SlopeTag));
            imageInfo.set_modalitySlope(slope == 0 ? 1 : slope);
        }
        else {
            imageInfo.set_modalitySlope(1);
        }
        if (lutData != null && lutData.Value && lutData.Value.length) {
            var lutDescValues = DicomHelper.GetTagText(lutDescriptor).split("\\");
            imageInfo.set_firstStoredPixelValueMapped(lutDescValues[1] | 0);
            var myArray = DicomHelper.GetTagText(lutData).split("\\");
            for (var i = myArray.length; i--;)
                myArray[i] = myArray[i] | 0;
            imageInfo.set_lutDescriptor(myArray);
        }
        if (signedTag != null && signedTag.Value && signedTag.Value.length) {
            signed = (parseInt(DicomHelper.GetTagText(signedTag), 10) === 1) ? true : false;
            imageInfo.set_signed(signed);
        }
        else {
            imageInfo.set_signed(false);
        }
        var offset = 0; //(signed === true) ? 1 << highBit : 0;
        var mask = ((1 << bitsStored) - 1);
        var minValue = 0;
        if (smallestTag != null && smallestTag.Value && smallestTag.Value.length) {
            var smallestPixel = parseInt(DicomHelper.GetTagText(smallestTag), 10);
            if (smallestPixel < 0) {
                if (smallestPixel > offset) {
                    minValue = 0;
                }
                else {
                    minValue = smallestPixel + offset;
                }
            }
            else {
                minValue = Math.min(smallestPixel + offset, mask);
            }
        }
        else {
            minValue = 0;
        }
        imageInfo.set_minValue(minValue);
        var maxValue = -1;
        if (largestTag != null && largestTag.Value && largestTag.Value.length) {
            var largestPixel = parseInt(DicomHelper.GetTagText(largestTag), 10);
            if (largestPixel < 0) {
                if (largestPixel > offset) {
                    maxValue = 0;
                }
                else {
                    maxValue = (largestPixel + offset);
                }
            }
            else {
                maxValue = Math.min(largestPixel + offset, mask);
            }
        }
        else {
            maxValue = 0;
        }
        imageInfo.set_maxValue(maxValue);
        if (windowWidthTag == null)
            windowWidthTag = this.findTag(metadata, DicomTag.WindowWidth);
        if (null != windowWidthTag && windowWidthTag.Value && windowWidthTag.Value.length > 0) {
            imageInfo.set_windowWidth(windowWidthTag.Value[0] >> 0);
        }
        else {
            imageInfo.set_windowWidth(0);
        }
        if (windowCenterTag == null)
            windowCenterTag = this.findTag(metadata, DicomTag.WindowCenter);
        if (null != windowCenterTag && windowCenterTag.Value && windowCenterTag.Value.length > 0) {
            imageInfo.set_windowCenter(windowCenterTag.Value[0] >> 0);
        }
        else {
            imageInfo.set_windowCenter(0);
        }
        if (null != mimeType && mimeType.Value && mimeType.Value.length > 0) {
            imageInfo.set_photometricInterpretation("RGB");
        }
        else {
            if (null != photometricInterpretationTag && photometricInterpretationTag.Value && photometricInterpretationTag.Value.length > 0) {
                imageInfo.set_photometricInterpretation(DicomHelper.GetTagText(photometricInterpretationTag));
            }
            else {
                imageInfo.set_photometricInterpretation("MONOCHROME2");
            }
        }
        var spacing = null;
        var spacingType = null;
        if (null != nominalScannedPixelSpacingTag && nominalScannedPixelSpacingTag.Value && nominalScannedPixelSpacingTag.Value.length > 0) {
            spacing = DicomHelper.GetTagText(nominalScannedPixelSpacingTag);
            spacingType = "detector";
        }
        if (null != imagerPixelSpacingTag && imagerPixelSpacingTag.Value && imagerPixelSpacingTag.Value.length > 0) {
            spacing = DicomHelper.GetTagText(imagerPixelSpacingTag);
            spacingType = "detector";
        }
        if (null != pixelSpacingTag && pixelSpacingTag.Value && pixelSpacingTag.Value.length > 0) {
            spacing = DicomHelper.GetTagText(pixelSpacingTag);
            spacingType = "calibrated";
            var pixelSpacingCalibrationTypeTag = metadata["00280A02"]; //Pixel Spacing Calibration Type
            if (null != pixelSpacingCalibrationTypeTag && pixelSpacingCalibrationTypeTag.Value && pixelSpacingCalibrationTypeTag.Value.length > 0) {
                spacingType = DicomHelper.GetTagText(pixelSpacingCalibrationTypeTag);
            }
        }
        if (null != spacing) {
            var values = spacing.split('\\');
            imageInfo.rowSpacing = parseFloat(values[0]);
            imageInfo.columnSpacing = parseFloat(values[1]);
            imageInfo.spacingType = spacingType;
        }
        else {
            imageInfo.rowSpacing = 0;
            imageInfo.columnSpacing = 0;
        }
        if (null != orientationTag && orientationTag.Value && orientationTag.Value.length > 0) {
            var orientation = DicomHelper.GetTagText(orientationTag); // getElementsByTagName("Image Orientation (Patient)"); // textContent;
            var values = orientation.split('\\');
            if (values.length == 6)
                imageInfo.orientation = values;
        }
        else if (null != patientOrientationTag && patientOrientationTag.Value && patientOrientationTag.Value.length > 0) {
            var orientation = DicomHelper.GetTagText(patientOrientationTag);
            var values = orientation.split('\\');
            if (values.length == 6)
                imageInfo.orientation = values;
        }
        if (null != positionTag && positionTag.Value && positionTag.Value.length > 0) {
            var position = DicomHelper.GetTagText(positionTag);
            var values = position.split('\\');
            imageInfo.position = values;
        }
        else
            imageInfo.position = [1, 1, 1];
        if (frameOfReferenceUID != null && frameOfReferenceUID.Value && frameOfReferenceUID.Value.length > 0) {
            imageInfo.frameOfReferenceUID = DicomHelper.GetTagText(frameOfReferenceUID);
        }
        else
            imageInfo.frameOfReferenceUID = "";
        imageInfo.isWaveForm = angular.isDefined(waveFormSequence) && waveFormSequence.Value.length != 0;
        if (imageInfo.isWaveForm) {
            imageInfo.set_photometricInterpretation("RGB");
            imageInfo.backGroundColor = "0xffffff";
        }
        if (null != imageTypeTag && imageTypeTag.Value && imageTypeTag.Value.length > 0) {
            var imageType = DicomHelper.GetTagText(imageTypeTag);
            var values = imageType.split('\\');
            imageInfo.imageType = values;
        }
        else
            imageInfo.imageType = "unknown";
        if (null != lossyImageCompressionTag) {
            var lossyImageCompression = DicomHelper.GetTagText(lossyImageCompressionTag);
            if (lossyImageCompression == "01") {
                imageInfo.lossyImageCompression = true;
            }
            else {
                imageInfo.lossyImageCompression = false;
            }
        }
        else
            imageInfo.lossyImageCompression = false;
        return imageInfo;
    };
    DicomHelper.getDicomTag = function (metadata, tag) {
        var data = metadata[tag];
        return data;
    };
    DicomHelper.findTag = function (dicom, tag) {
        for (var key in dicom) {
            if (dicom[key].vr != 'SQ') {
                if (key == tag) {
                    return dicom[key];
                }
            }
            else {
                if (dicom[key].Value && dicom[key].Value.length > 0) {
                    var length = dicom[key].Value.length;
                    for (var index = 0; index < length; index++) {
                        var value = this.findTag(dicom[key].Value[0], tag);
                        if (value != null)
                            return value;
                    }
                }
            }
        }
        return null;
    };
    DicomHelper.getDicomTagValue = function (metadata, tag, index) {
        if (!metadata)
            return null;
        if (DicomTag.PatientName == tag)
            return DicomHelper.getPatientName(metadata, DicomTag.PatientName);
        var dcmTag = this.getDicomTag(metadata, tag);
        index = index || 0;
        if (dcmTag != undefined && dcmTag.Value) {
            if (index < dcmTag.Value.length) {
                var value = dcmTag.Value[index];
                if (dcmTag.vr == 'DA') {
                    if (value) {
                        var DateJS = (new Date(DicomHelper.parseDicomDate(value)));
                        // Modify date by adding the difference in time.
                        if (DateJS.getTimezoneOffset)
                            DateJS.addMinutes(DateJS.getTimezoneOffset());
                        value = DateJS;
                    }
                }
                if (dcmTag.vr == 'TM') {
                    if (value) {
                        var DateJS = Date.today().at(DicomHelper.parseDicomTime(value));
                        value = DateJS;
                    }
                }
                return value;
            }
        }
        if (dcmTag) {
            return '-';
        }
        return undefined;
    };
    DicomHelper.cloneDicomTagValue = function (metadata, tag) {
        var retValue = "";
        retValue = DicomHelper.getConvertValue(metadata[tag]);
        return retValue;
    };
    DicomHelper.getStudyDateTime = function (metadata, ignoreStudyTime) {
        var studyDateJS = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyDate);
        var studyTimeJS = DicomHelper.getDicomTagValue(metadata, DicomTag.StudyTime);
        if (studyTimeJS != null && !ignoreStudyTime) {
            studyDateJS.addHours(studyTimeJS.getHours());
            studyDateJS.addMinutes(studyTimeJS.getMinutes());
            studyDateJS.addSeconds(studyTimeJS.getSeconds());
        }
        return studyDateJS;
    };
    DicomHelper.getStudyDateTimeString = function (metadata, ignoreStudyTime, includeParenthesis) {
        var studyDateTimeJS = this.getStudyDateTime(metadata, ignoreStudyTime);
        var studyDateString = "";
        if (studyDateTimeJS != null) {
            if (studyDateTimeJS.getMonth() == 0 && studyDateTimeJS.getDay() == 0 && studyDateTimeJS.getFullYear() == 0) {
                studyDateString = studyDateTimeJS.toString("yyyy-MMM-dd");
            }
            else {
                studyDateString = studyDateTimeJS.toString("yyyy-MMM-dd HH:mm");
            }
            if (includeParenthesis) {
                if (studyDateString.length > 0) {
                    studyDateString = "(" + studyDateString + ")";
                }
            }
        }
        return studyDateString;
    };
    DicomHelper.get_TagValue = function (metadata, tag, index) {
        var dcmTag = this.getDicomTag(metadata, tag);
        index = index || 0;
        if (dcmTag != undefined && dcmTag.Value) {
            if (index < dcmTag.Value.length)
                return dcmTag.Value[index];
        }
        if (dcmTag) {
            return '';
        }
        return undefined;
    };
    DicomHelper.get_allValues = function (metadata, tag) {
        var dcmTag = this.getDicomTag(metadata, tag);
        var values = new Array();
        if (dcmTag != undefined && dcmTag.Value) {
            for (var i = 0; i < dcmTag.Value.length; i++) {
                var value = dcmTag.Value[i];
                if (dcmTag.vr == 'DA') {
                    if (value) {
                        var DateJS = (new Date(DicomHelper.parseDicomDate(value)));
                        value = DateJS;
                    }
                }
                if (dcmTag.vr == 'TM') {
                    if (value) {
                        var DateJS = Date.today().at(DicomHelper.parseDicomTime(value));
                        value = DateJS;
                    }
                }
                values.push(value);
            }
        }
        return values;
    };
    DicomHelper.getConvertValue = function (dcmTag) {
        if (dcmTag != undefined && dcmTag.Value) {
            if (dcmTag.Value.length)
                return dcmTag.Value.join('\\');
        }
        return undefined;
    };
    DicomHelper.getStringIfAvailable = function (tag, para) {
        if ((tag != null) && (tag != ""))
            return para ? "=" + tag : tag;
        return "";
    };
    DicomHelper.getPatientName = function (metadata, tag, index) {
        var dcmTag = this.getDicomTag(metadata, tag);
        var output = "";
        index = index || 0;
        if (dcmTag != undefined && dcmTag.Value) {
            if (index < dcmTag.Value.length) {
                output += this.getStringIfAvailable(dcmTag.Value[index].Alphabetic, false);
                output += this.getStringIfAvailable(dcmTag.Value[index].Ideographic, true);
                output += this.getStringIfAvailable(dcmTag.Value[index].Phonetic, true);
            }
        }
        return output;
    };
    DicomHelper.getPatientNameFromTag = function (dcmTag, index) {
        index = index || 0;
        if (dcmTag != undefined && dcmTag.Value) {
            if (index < dcmTag.Value.length)
                return dcmTag.Value[index].Alphabetic;
        }
        return undefined;
    };
    DicomHelper.parseDicomDate = function (dateString) {
        if (!dateString)
            return "";
        if (dateString.length == 8) {
            var year = dateString.substring(0, 4);
            var month = dateString.substring(4, 6);
            var day = dateString.substring(6);
            return month + "/" + day + "/" + year; //new Date(year, month - 1, day).toDateString();
        }
        else {
            return dateString;
        }
    };
    DicomHelper.parseDicomTime = function (timeString) {
        if (timeString.indexOf(':') != -1) {
            timeString = timeString.replace(new RegExp(':', 'g'), '');
        }
        if (timeString.length >= 6) {
            var hour = parseInt(timeString.substring(0, 2));
            var minutes = timeString.substring(2, 4);
            var seconds = timeString.substring(4, 6);
            hour = hour % 12;
            hour = hour ? hour : 12; // the hour '0' should be '12'
            var ampm = hour >= 12 ? 'PM' : 'AM';
            return hour + ":" + minutes + ":" + seconds + " " + ampm;
        }
        return timeString;
    };
    DicomHelper.getCodeSequenceList = function (metadata, tagList, itemNumberList) {
        var list = new Array();
        var tagArray = tagList.split("\\");
        for (var i = 0; i < tagArray.length; i++) {
            tagArray[i] = tagArray[i].replace(':', '');
        }
        var itemNumberArray = [];
        var itemNumber = null;
        if (itemNumberList != null) {
            itemNumberArray = itemNumberList.split("\\");
            var itemNumberArrayCount = itemNumberArray.length;
            for (var i = 0; i < itemNumberArrayCount; i++) {
                itemNumberArray[i] = parseInt(itemNumberArray[i]);
            }
            itemNumber = itemNumberArray[itemNumberArrayCount - 1];
        }
        var sequence = metadata[tagArray[0]];
        // tagArray and itemNumberArray must have the same number of items
        if (tagArray.length == itemNumberArray.length) {
            // Only enter this loop if more than one tag in tagArray
            for (var i = 1; i < tagArray.length; i++) {
                var index = itemNumberArray[i] - 1;
                var tag = tagArray[i];
                sequence = sequence.Value[index][tag];
            }
        }
        if (sequence && sequence.Value && sequence.Value.length > 0) {
            if (itemNumber != null) {
                if (itemNumber <= sequence.Value.length) {
                    var sequenceItem = sequence.Value[itemNumber - 1];
                    var codeSequence = this.get_CodeSequence(sequenceItem);
                    var invalid = ((!codeSequence.CodeMeaning || codeSequence.CodeMeaning.length == 0) || (!codeSequence.CodeValue || codeSequence.CodeValue.length == 0));
                    if (!invalid) {
                        list.push(codeSequence);
                    }
                }
            }
            else {
                for (var i = 0; i < sequence.Value.length; i++) {
                    var sequenceItem = sequence.Value[i];
                    var codeSequence = this.get_CodeSequence(sequenceItem);
                    if ((!codeSequence.CodeMeaning || codeSequence.CodeMeaning.length == 0) || (!codeSequence.CodeValue || codeSequence.CodeValue.length == 0))
                        continue;
                    list.push(codeSequence);
                }
            }
        }
        return list;
    };
    DicomHelper.get_CodeSequence = function (sequenceItem) {
        var codeSequence = new Models.CodeSequence();
        codeSequence.CodeValue = sequenceItem[DicomTag.CodeValue] && sequenceItem[DicomTag.CodeValue].Value ? sequenceItem[DicomTag.CodeValue].Value[0] : '';
        codeSequence.CodeMeaning = sequenceItem[DicomTag.CodeMeaning] && sequenceItem[DicomTag.CodeMeaning].Value ? sequenceItem[DicomTag.CodeMeaning].Value[0] : '';
        codeSequence.CodeSchemeDesignator = sequenceItem[DicomTag.CodingSchemeDesignator] && sequenceItem[DicomTag.CodingSchemeDesignator].Value ? sequenceItem[DicomTag.CodingSchemeDesignator].Value[0] : '';
        codeSequence.CodingSchemeVersion = sequenceItem[DicomTag.CodingSchemeVersion] && sequenceItem[DicomTag.CodingSchemeVersion].Vale ? sequenceItem[DicomTag.CodingSchemeVersion].Value[0] : '';
        return codeSequence;
    };
    return DicomHelper;
}());
;
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('leadAudio', ["eventService", "$timeout", function (eventService, $timeout) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                uiType: "=",
                audioSource: "=",
            },
            templateUrl: 'views/templates/AudioPlayer.html',
            link: function (scope, elem, attr) {
                scope.$watch('uiType', function (newValue, oldValue) {
                    if (newValue) {
                        switch (newValue) {
                            case 'playback':
                                buildPlaybackUI(scope);
                                break;
                            case 'download':
                                buildDownloadUI();
                                break;
                            case 'none':
                                buildNoAudioUI();
                                break;
                            case 'wait':
                                buildWaitUI();
                                break;
                        }
                    }
                });
                scope.$watch('audioSource', function (newValue, oldValue) {
                    if (newValue) {
                        if (scope.uiType == 'playback') {
                            var player = document.getElementById("WaveformBasicAudioPlayer");
                            var source = player.lastChild;
                            if (source) {
                                source.src = scope.audioSource;
                                if (source['controls'])
                                    source['controls'] = true;
                            }
                        }
                        else if (scope.uiType == 'download') {
                            var WaveformBasicAudioPlayerDownloadLink = document.getElementById("WaveformBasicAudioPlayerDownloadLink");
                            WaveformBasicAudioPlayerDownloadLink.href = scope.audioSource; //_objectRetrieveProxy.BuildAudioUrl(_frame.Instance.SOPInstanceUID, 0, 'audio/wav');
                        }
                    }
                });
                function buildPlaybackUI(scope) {
                    var waveformBasicAudioDlg = document.getElementById("WaveformBasicAudioDiv");
                    var WaveformBasicAudioPlayerDownloadLinkTable = document.getElementById("WaveformBasicAudioPlayerDownloadLinkTable");
                    var WaveformBasicAudioPlayerDownloadLink = document.getElementById("WaveformBasicAudioPlayerDownloadLink");
                    var WaveformBasicAudioPlayerNoAudio = document.getElementById("WaveformBasicAudioPlayerNoAudio");
                    var WaveformBasicAudioPlayerWait = document.getElementById("WaveformBasicAudioPlayerWait");
                    var player = document.getElementById("WaveformBasicAudioPlayer");
                    var canPlayWAVE = !!player.canPlayType && player.canPlayType('audio/wav') != "";
                    var canPlay = !!canPlayWAVE;
                    if (canPlay) {
                        waveformBasicAudioDlg.style.display = 'inherit';
                        player.style.display = 'inherit';
                        WaveformBasicAudioPlayerNoAudio.style.display = 'none';
                        WaveformBasicAudioPlayerDownloadLinkTable.style.display = 'none';
                        WaveformBasicAudioPlayerWait.style.display = 'none';
                        removeAllChildren(player);
                        var audioSrc;
                        audioSrc = document.createElement('source');
                        audioSrc.type = 'audio/wav';
                        player.appendChild(audioSrc);
                    }
                    else {
                        scope.uiType = 'download';
                        scope.$apply();
                    }
                }
                function buildDownloadUI() {
                    var waveformBasicAudioDlg = document.getElementById("WaveformBasicAudioDiv");
                    var WaveformBasicAudioPlayerDownloadLinkTable = document.getElementById("WaveformBasicAudioPlayerDownloadLinkTable");
                    var WaveformBasicAudioPlayerDownloadLink = document.getElementById("WaveformBasicAudioPlayerDownloadLink");
                    var WaveformBasicAudioPlayerNoAudio = document.getElementById("WaveformBasicAudioPlayerNoAudio");
                    var WaveformBasicAudioPlayerWait = document.getElementById("WaveformBasicAudioPlayerWait");
                    var player = document.getElementById("WaveformBasicAudioPlayer");
                    waveformBasicAudioDlg.style.backgroundColor = '#FFFFFF';
                    player.style.display = 'none';
                    WaveformBasicAudioPlayerNoAudio.style.display = 'none';
                    waveformBasicAudioDlg.style.display = 'inherit';
                    WaveformBasicAudioPlayerDownloadLinkTable.style.display = 'inherit';
                    WaveformBasicAudioPlayerWait.style.display = 'none';
                }
                function buildNoAudioUI() {
                    var waveformBasicAudioDlg = document.getElementById("WaveformBasicAudioDiv");
                    var WaveformBasicAudioPlayerDownloadLinkTable = document.getElementById("WaveformBasicAudioPlayerDownloadLinkTable");
                    var WaveformBasicAudioPlayerDownloadLink = document.getElementById("WaveformBasicAudioPlayerDownloadLink");
                    var WaveformBasicAudioPlayerNoAudio = document.getElementById("WaveformBasicAudioPlayerNoAudio");
                    var WaveformBasicAudioPlayerWait = document.getElementById("WaveformBasicAudioPlayerWait");
                    var player = document.getElementById("WaveformBasicAudioPlayer");
                    waveformBasicAudioDlg.style.display = 'inherit';
                    waveformBasicAudioDlg.style.backgroundColor = '#FFFFFF';
                    player.style.display = 'none';
                    WaveformBasicAudioPlayerNoAudio.style.display = 'inherit';
                    WaveformBasicAudioPlayerDownloadLinkTable.style.display = 'none';
                    WaveformBasicAudioPlayerWait.style.display = 'none';
                }
                function buildWaitUI() {
                    var waveformBasicAudioDlg = document.getElementById("WaveformBasicAudioDiv");
                    var WaveformBasicAudioPlayerDownloadLinkTable = document.getElementById("WaveformBasicAudioPlayerDownloadLinkTable");
                    var WaveformBasicAudioPlayerDownloadLink = document.getElementById("WaveformBasicAudioPlayerDownloadLink");
                    var WaveformBasicAudioPlayerNoAudio = document.getElementById("WaveformBasicAudioPlayerNoAudio");
                    var WaveformBasicAudioPlayerWait = document.getElementById("WaveformBasicAudioPlayerWait");
                    var player = document.getElementById("WaveformBasicAudioPlayer");
                    waveformBasicAudioDlg.style.display = 'inherit';
                    waveformBasicAudioDlg.style.backgroundColor = '#FFFFFF';
                    player.style.display = 'none';
                    WaveformBasicAudioPlayerNoAudio.style.display = 'none';
                    WaveformBasicAudioPlayerDownloadLinkTable.style.display = 'none';
                    WaveformBasicAudioPlayerWait.style.display = 'inherit';
                }
                function removeAllChildren(element) {
                    try {
                        while (element.hasChildNodes()) {
                            element.removeChild(element.lastChild);
                        }
                    }
                    catch (ex) {
                        //some browsers report error when item is not found, ignored here
                    }
                }
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
//
// This directive makes the modal dialog window draggable
//
directives.directive('modalWindow', ["$timeout", function ($timeout) {
        return {
            restrict: 'EA',
            link: function (scope, elem, attr) {
                if (lt.LTHelper.device != lt.LTDevice.mobile) {
                    $(elem).children().first().draggable({
                        handle: ".modal-header"
                    });
                }
                $timeout(function () {
                    var e = elem.find('[autofocus]');
                    e.focus();
                    if (e.is('input')) {
                        e.click();
                    }
                }, 600);
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('verticalSlider', ["eventService", "$timeout", function (eventService, $timeout) {
        return {
            restrict: 'AE',
            scope: {
                'sliderSteps': "=",
                'sliderPosition': "=",
                'positionChanged': '&'
            },
            link: function (scope, elem, attr) {
                var slider = new InteractiveVerticalSlider($(elem)[0], 1);
                scope.$watch("sliderSteps", function (value) {
                    if (angular.isDefined(value)) {
                        slider.updateSteps(value);
                    }
                });
                $(elem).parent().resize(function (e, data) {
                    sizeToParent($(elem), $(elem).parent());
                });
                scope.$watch("sliderPosition", function (value) {
                    if (angular.isDefined(value)) {
                        slider.set_currentStep(value);
                    }
                });
                function sizeToParent($elem, $parent) {
                    var position = $elem.position();
                    $elem.height($parent.height() - position.top);
                    slider.setupSlider();
                }
                slider.add_stepChanged(OnStepChanged);
                function OnStepChanged(sender, e) {
                    var position = e.get_newIndex() - 1;
                    if (position != scope.sliderPosition) {
                        scope.sliderPosition = position;
                        scope.positionChanged({ position: position });
                    }
                }
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('leadImageProcessing', ["eventService", "$timeout", function (eventService, $timeout) {
        return {
            restrict: 'A',
            scope: {
                frame: '=',
                api: '=',
            },
            link: function (scope, elem, attr) {
                if (angular.isDefined(scope.frame)) {
                    var scaleCanvas = document.createElement('canvas');
                    var oldCanvas = scope.frame.getPreviewCanvas();
                    var viewerImg = document.createElement('img');
                    var previewCanvas = document.getElementById('ipPreviewCanvas');
                    var previewContext = previewCanvas.getContext('2d');
                    var viewerBackCanvas = document.createElement('canvas');
                    scope.api = scope.api || {};
                    scope.api.applyIPCommand = function (command, arguments1) {
                        var ip = new lt.ImageProcessing();
                        var context = scaleCanvas.getContext('2d');
                        var imageData = context.getImageData(0, 0, scaleCanvas.width, scaleCanvas.height);
                        ip.set_jsFilePath(_jsFileCoreColorPath);
                        ip.set_command(command);
                        if (arguments1 != null) {
                            for (var key in arguments1) {
                                if (arguments1.hasOwnProperty(key)) {
                                    ip.get_arguments()[key] = arguments1[key];
                                }
                            }
                        }
                        ip.set_imageData(imageData);
                        ip.add_completed(function (sender, event) {
                            previewContext.putImageData(event.get_imageData(), 0, 0);
                        });
                        ip.run();
                    };
                    scaleCanvas.width = 128;
                    scaleCanvas.height = 128;
                    viewerBackCanvas.width = oldCanvas.width;
                    viewerBackCanvas.height = oldCanvas.height;
                    var context = viewerBackCanvas.getContext('2d');
                    context.fillStyle = '#0';
                    context.fillRect(0, 0, oldCanvas.width, oldCanvas.height);
                    context.drawImage(oldCanvas, 0, 0);
                    viewerImg.onload = function () {
                        var scaleContext = scaleCanvas.getContext("2d");
                        var scaleFacor = 1;
                        var xPos = 0;
                        var yPos = 0;
                        scaleContext.fillStyle = "white";
                        scaleContext.fillRect(0, 0, scaleCanvas.width, scaleCanvas.height);
                        if (viewerBackCanvas.width > viewerBackCanvas.height) {
                            scaleFacor = 128 / viewerBackCanvas.width;
                            yPos = (128 - viewerBackCanvas.height * scaleFacor) / 2;
                        }
                        else {
                            scaleFacor = 128 / viewerBackCanvas.height;
                            xPos = (128 - viewerBackCanvas.width * scaleFacor) / 2;
                        }
                        scaleContext.scale(scaleFacor, scaleFacor);
                        scaleContext.drawImage(viewerImg, xPos * (1 / scaleFacor), yPos * (1 / scaleFacor));
                        scaleContext.scale(1 / scaleFacor, 1 / scaleFacor);
                        previewContext.putImageData(scaleContext.getImageData(0, 0, scaleCanvas.width, scaleCanvas.height), 0, 0);
                        viewerImg = null;
                    };
                    viewerImg.src = viewerBackCanvas.toDataURL("image/png");
                }
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var TimeLineState;
(function (TimeLineState) {
    TimeLineState.Start = "start";
    TimeLineState.QueryTimeLine = "querytimeline";
    TimeLineState.LoadThumbs = "loadthumbs";
    TimeLineState.ErrorReport = "error";
    TimeLineState.SuccessReport = "success";
    TimeLineState.End = "end";
})(TimeLineState || (TimeLineState = {}));
var TimeLineTransition;
(function (TimeLineTransition) {
    TimeLineTransition.Success = "success";
    TimeLineTransition.Failure = "failure";
    TimeLineTransition.Aborted = "aborted";
})(TimeLineTransition || (TimeLineTransition = {}));
directives.directive('studyTimeline', ["eventService", "$timeout", "queryArchiveService", "seriesManagerService", "authenticationService", "dataService", "optionsService", function (eventService, $timeout, queryArchiveService, seriesManagerService, authenticationService, dataService, optionsService) {
        return {
            replace: true,
            template: '<div></div>',
            scope: {
                retrieveUrl: '=',
                api: '=',
                replaceCell: '&',
                appendCell: '&'
            },
            link: function (scope, elem, attr) {
                var timelineState = TimeLineState.Start;
                var thumbnailDiv = angular.element('<div/>');
                var scrollStartPosX;
                var scrollStartPosY;
                var currentStudyInstanceUID;
                var currentPatientID;
                var dateFormat = optionsService.get(OptionNames.DateFormat);
                elem.append(thumbnailDiv);
                sizeToParent($(elem), $(elem).parent());
                $(elem).parent().resize(function (e, data) {
                    sizeToParent($(elem), $(elem).parent());
                });
                function sizeToParent($elem, $parent) {
                    $elem.width($parent.width());
                    $elem.height($parent.height());
                }
                scope.api = scope.api || {};
                scope.api.toggle = function (studyInstanceUID, patientID, hide) {
                    var isVisible;
                    currentPatientID = patientID;
                    currentStudyInstanceUID = studyInstanceUID;
                    isVisible = !hide;
                    if (isVisible) {
                        sizeToParent($(elem), $(elem).parent());
                        transitionState(TimeLineTransition.Aborted, "");
                        restart();
                        transitionState(TimeLineTransition.Success, "");
                    }
                    else {
                        transitionState(TimeLineTransition.Aborted, "");
                    }
                };
                scope.api.refresh = function (patientID, studyInstanceUID, seriesInstanceUID) {
                    var isVisible = elem.is(':visible');
                    if ((studyInstanceUID == currentStudyInstanceUID) || (patientID == currentPatientID)) {
                        if (isVisible) {
                            hilightSeries(seriesInstanceUID);
                        }
                        return;
                    }
                    if (isVisible) {
                        currentStudyInstanceUID = studyInstanceUID;
                        currentPatientID = patientID;
                        transitionState(TimeLineTransition.Aborted, "");
                        restart();
                        transitionState(TimeLineTransition.Success, "");
                    }
                };
                function restart() {
                    timelineState = TimeLineState.Start;
                }
                function transitionState(transition, extraInfo) {
                    if (transition == TimeLineTransition.Aborted) {
                        timelineState = TimeLineState.End;
                        clearThumbnails();
                        return;
                    }
                    if (timelineState == TimeLineState.End) {
                        return;
                    }
                    if (timelineState == TimeLineState.Start) {
                        timelineState = TimeLineState.QueryTimeLine;
                        queryStudyTimeLine();
                    }
                    else if (timelineState == TimeLineState.QueryTimeLine) {
                        if (transition = TimeLineTransition.Success) {
                            timelineState = TimeLineState.LoadThumbs;
                            loadThumbnails(extraInfo);
                        }
                    }
                }
                function clearThumbnails() {
                    thumbnailDiv.empty();
                }
                // we created a sort array of the series from the newest series to the oldest one.
                function sortSeries(inputSeries) {
                    // create the output structure
                    var newArrangedSeries = {};
                    newArrangedSeries.Series = [];
                    newArrangedSeries.Instances = [];
                    var series = inputSeries.Series;
                    var instances = inputSeries.Instances;
                    // the series is empty... I don't know what else to tell you.
                    if (series.length == 0)
                        return newArrangedSeries;
                    // if for some reason the series doesn't have a date, then just return the original series, cause it can't be sorted.
                    if (!series[0].Date)
                        return inputSeries;
                    // a quick test to see if the date can be parsed into a "Date" class.
                    try {
                        Date.parse(series[0].Date);
                    }
                    catch (err) {
                        // the date value is invalid, or cannot be parsed by this tool, just return the original series.
                        return inputSeries;
                    }
                    try {
                        // we loop through the series and find the newest date value, then remove it from array and search for the next newest value... and so on.
                        while (series.length != 0) {
                            var index = 0;
                            var length = series.length;
                            var currentDate;
                            var minimumDate = new Date(series[0].Date);
                            var minimumDateSeriesIndex = 0;
                            for (index = 0; index < length; index++) {
                                currentDate = new Date(series[index].Date);
                                if (currentDate > minimumDate) {
                                    minimumDate = currentDate;
                                    minimumDateSeriesIndex = index;
                                }
                            }
                            newArrangedSeries.Series.add(series[minimumDateSeriesIndex]);
                            newArrangedSeries.Instances.add(instances[minimumDateSeriesIndex]);
                            // the newest series date has been added to the arragned list, now remove it from the inputSeries, so we can search for the next newest one.
                            series.removeAt(minimumDateSeriesIndex);
                            instances.removeAt(minimumDateSeriesIndex);
                        }
                    }
                    catch (err) {
                        // some unknown error happened, the Sort failed.... move on.
                        return inputSeries;
                    }
                    // this contains the series sorted from the newest to oldest, the way studytimeline is intended to be.
                    return newArrangedSeries;
                }
                function queryStudyTimeLine() {
                    var query = new Models.QueryOptions();
                    if (currentPatientID != "")
                        query.PatientsOptions.PatientID = currentPatientID;
                    queryArchiveService.ElectStudyTimeLineInstances(query).success(function (data, status) {
                        data = sortSeries(data);
                        // clear the series.
                        dataService.clearSeries();
                        for (var i = 0; i < data.Series.length; i++) {
                            var series = dataService.get_Series(data.Series[i].SeriesInstanceUID);
                            if (series == null) {
                                dataService.add_series(data.Series[i]);
                            }
                        }
                        transitionState(TimeLineTransition.Success, data);
                    }).error(function (error) {
                        transitionState(TimeLineTransition.Failure, error);
                    });
                }
                function loadThumbnails(data) {
                    var totalHeight = $(elem).height();
                    var cellHeight = totalHeight * (80 / 100);
                    var thumbDim = 100;
                    var cellTitleHeight;
                    var cellThumbHeight;
                    var cellThumbWidth;
                    var framesLength = data.Instances.length;
                    var seriesLength = data.Series.length;
                    var table;
                    var tr;
                    var td;
                    var position;
                    clearThumbnails();
                    if (cellHeight < 60) {
                        thumbDim = 50;
                    }
                    // subtract 10 for the horizontal scrollbar
                    cellHeight -= 10;
                    cellHeight = cellHeight - 5;
                    cellTitleHeight = cellHeight / 6;
                    cellThumbHeight = cellHeight - cellTitleHeight;
                    cellThumbWidth = Math.max(cellTitleHeight, 100);
                    if (seriesLength != framesLength) {
                        throw new Error("Instances length differ from series length");
                    }
                    position = lt.LTHelper.getElementStyle(thumbnailDiv[0], 'position');
                    if (position != 'relative') {
                        thumbnailDiv[0].style.position = 'relative';
                    }
                    if (lt.LTHelper.supportsTouch) {
                        thumbnailDiv[0].style.overflow = 'hidden';
                    }
                    else {
                        thumbnailDiv[0].style.overflow = 'auto';
                        thumbnailDiv[0].style.overflowY = 'hidden';
                    }
                    touchScroll(thumbnailDiv[0]);
                    thumbnailDiv[0].style.border = "0px";
                    thumbnailDiv[0].style.padding = "0px";
                    thumbnailDiv[0].style.padding = "0px";
                    thumbnailDiv[0].style.margin = "0px";
                    table = document.createElement('table');
                    table.id = "table_" + UUID.generate();
                    table.border = "0px";
                    table.cellSpacing = "0px";
                    table.cellPadding = "0px";
                    table.width = "100%";
                    table.style.width = '100%';
                    table.style.height = '100%';
                    table.style.padding = "0px";
                    table.style.margin = "0px";
                    table.style.borderCollapse = 'separate';
                    table.className = 'timeLineTable';
                    tr = document.createElement('tr');
                    for (var instanceIndex = 0; instanceIndex < framesLength; instanceIndex++) {
                        var frame = seriesManagerService.get_activeCellFrame();
                        if (!frame)
                            continue;
                        if (angular.isDefined(frame.Instance)) {
                            var td = document.createElement('td');
                            var process;
                            tr.appendChild(td);
                            td.setAttribute('align', 'center');
                            $(td).css('width', cellThumbWidth + "px");
                            td.className = "timeLineCellClass";
                            process = createThumbnailProcess(td, data, instanceIndex, thumbDim, cellHeight, cellTitleHeight, cellThumbWidth, cellThumbHeight);
                            setTimeout(process, 5 * instanceIndex);
                        }
                    }
                    td = document.createElement('td');
                    $(td).css('width', '100%');
                    tr.appendChild(td);
                    table.appendChild(tr);
                    //tr = document.createElement('tr');
                    //tr.style.height = "20px";
                    //table.appendChild(tr);
                    thumbnailDiv.append(table);
                }
                var _studytimeline_timer_event = null;
                var _studytimeline_timer_event_handeled = false;
                var _lastSelectedElement = null;
                function createThumbnailProcess(td, studyTimelineInfo, idx, thumbDim, cellHeight, cellTitleHeight, cellThumbWidth, cellThumbHeight) {
                    var frame = seriesManagerService.get_activeCellFrame();
                    var currentSeriesInstanceUID = frame.Instance.SeriesInstanceUID;
                    return function () {
                        var imageUrl;
                        //var image = studyTimelineInfo.Instances[idx].MRTIImageInfo;
                        var cx = Math.floor(cellHeight);
                        var imageUrl = scope.retrieveUrl;
                        imageUrl += '/GetImage?';
                        imageUrl += 'auth=' + encodeURIComponent(authenticationService.authenticationCode);
                        imageUrl += '&instance=' + studyTimelineInfo.Instances[idx].SOPInstanceUID;
                        imageUrl += '&frame=0';
                        imageUrl += '&mime=' + encodeURIComponent('image/jpeg');
                        imageUrl += '&bp=24';
                        imageUrl += '&qf=10';
                        imageUrl += '&cx=' + cx;
                        imageUrl += '&cy=' + cx;
                        td.setAttribute('SeriesInstanceUID', studyTimelineInfo.Instances[idx].SeriesInstanceUID);
                        var imageElement = document.createElement('img');
                        imageElement.setAttribute('id', 'img_' + idx.toString());
                        imageElement.src = imageUrl;
                        imageElement.alt = "loading...";
                        imageElement.title = studyTimelineInfo.Series[idx].Description || studyTimelineInfo.Series[idx].Modality;
                        var thumbSeriesInstanceUID = studyTimelineInfo.Series[idx].InstanceUID;
                        if (thumbSeriesInstanceUID == currentSeriesInstanceUID) {
                            td.style.border = '3px solid #5C880C';
                            _lastSelectedElement = td;
                        }
                        else {
                            td.style.border = '3px solid #000000';
                        }
                        imageElement.style.maxHeight = "100%";
                        imageElement.style.maxWidth = "100%";
                        imageElement.setAttribute('SeriesInstanceUID', studyTimelineInfo.Instances[idx].SeriesInstanceUID);
                        imageElement.addEventListener('touchstart', function (e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            else
                                event.returnValue = false;
                            _studytimeline_timer_event_handeled = false;
                            window.clearInterval(_studytimeline_timer_event);
                            _studytimeline_timer_event = window.setInterval(function (tmr_event) {
                                _studytimeline_timer_event_handeled = true;
                                window.clearInterval(_studytimeline_timer_event);
                                appendCell(e.target);
                            }, 1000);
                        }, false);
                        imageElement.addEventListener('touchend', function (e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            else
                                event.returnValue = false;
                            window.clearInterval(_studytimeline_timer_event);
                            if (!_studytimeline_timer_event_handeled) {
                                _studytimeline_timer_event_handeled = true;
                                replaceActiveCell(e.target);
                            }
                        });
                        imageElement.addEventListener('MSGestureHold', function (e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            else
                                event.returnValue = false;
                            appendCell(e.target);
                        }, false);
                        imageElement.addEventListener("contextmenu", function (e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            else
                                event.returnValue = false;
                            appendCell(e.target);
                        }, false);
                        imageElement.addEventListener('click', function (e) {
                            replaceActiveCell(e.target);
                        }, false);
                        {
                            var divThumb = document.createElement('div');
                            divThumb.appendChild(imageElement);
                            var ahref = document.createElement('div');
                            ahref.href = "#";
                            ahref.setAttribute('SeriesInstanceUID', studyTimelineInfo.Instances[idx].SeriesInstanceUID);
                            ahref.setAttribute('draggable', 'true');
                            ahref.appendChild(divThumb);
                            ahref.addEventListener("dragstart", function (e) {
                                e.dataTransfer.effectAllowed = 'copy';
                                e.dataTransfer.setData('Text', this.getAttribute('SeriesInstanceUID'));
                            }, false);
                            td.appendChild(ahref);
                        }
                        {
                            var divTitle = document.createElement('div');
                            var p = document.createElement("P");
                            var date = studyTimelineInfo.Series[idx].Date;
                            var LabelText;
                            var text;
                            if ((!date || date.length == 0) && studyTimelineInfo.Studies)
                                date = studyTimelineInfo.Studies[0].Date;
                            if (date && date.length > 0) {
                                date = Utils.dateFormatter(date, dateFormat);
                            }
                            p.style.fontFamily = "Arial, Helvetica, sans-serif";
                            p.style.fontSize = "xx-small";
                            p.style.verticalAlign = "text-top";
                            p.style.textAlign = "center";
                            p.style.padding = "0px";
                            p.style.margin = "0px";
                            p.style.whiteSpace = "nowrap";
                            LabelText = "[" + studyTimelineInfo.Series[idx].Modality + "]";
                            if (date && date.length > 0) {
                                LabelText += " " + date;
                            }
                            text = document.createTextNode(LabelText);
                            p.appendChild(text);
                            divTitle.appendChild(p);
                            divTitle.title = LabelText;
                            divTitle.style.width = cellHeight + "px";
                            divTitle.style.height = cellTitleHeight + "px";
                            divTitle.style.color = "#FFFFFF";
                            divTitle.style.padding = "0px";
                            divTitle.style.margin = "0px";
                            divTitle.style.overflow = "hidden";
                            divTitle.style.border = "0px";
                            td.appendChild(divTitle);
                        }
                    };
                }
                function touchScroll(div) {
                    if (lt.LTHelper.supportsTouch) {
                        //div.addEventListener('touchstart', function (e) { touchstart(e); }, false);
                        //div.addEventListener('touchmove', function (e) { touchmove(e); }, false);
                    }
                    else {
                        //div.addEventListener('MSPointerDown', function (e) { mouseStart(e); }, true);
                        div.onselectstart = function () { return false; };
                        //div.addEventListener('mousedown', function (e) { mouseStart(e);; }, true);
                        //div.addEventListener('mousemove', function (e) { mousemove(e); }, true);
                        //div.addEventListener('mouseup', function (e) { mouseEnd(e) }, true);
                        //div.addEventListener('MSPointerUp', function (e) { mouseEnd(e) }, true);
                    }
                }
                var mouseDown;
                function hilightSeries(seriesInstanceUID) {
                    $(".timeLineCellClass").each(function (i) {
                        if (seriesInstanceUID == this.getAttribute('SeriesInstanceUID')) {
                            _lastSelectedElement = this;
                            this.style.border = '3px solid #5C880C';
                        }
                        else {
                            this.style.border = '3px solid #000000';
                        }
                    });
                }
                function replaceActiveCell(target) {
                    var seriesInstanceUID = '';
                    if (null != _lastSelectedElement)
                        _lastSelectedElement.style.border = '3px solid #000000';
                    _lastSelectedElement = target.parentNode.parentNode.parentNode;
                    _lastSelectedElement.style.border = '3px solid #5C880C';
                    if (lt.LTHelper.browser == lt.LTBrowser.opera) {
                        //
                        // in opera, this is used to refresh the td, not repainted automatically
                        //
                        $(_lastSelectedElement).fadeOut(0).fadeIn(0);
                    }
                    seriesInstanceUID = target.getAttribute('SeriesInstanceUID');
                    //scope.replaceCell({ seriesInstanceUID: seriesInstanceUID });
                }
                function appendCell(target) {
                    var seriesInstanceUID = '';
                    if (null != _lastSelectedElement)
                        _lastSelectedElement.style.border = '3px solid #000000';
                    _lastSelectedElement = target.parentNode.parentNode.parentNode;
                    _lastSelectedElement.style.border = '3px solid #5C880C';
                    if (lt.LTHelper.browser == lt.LTBrowser.opera) {
                        //
                        // in opera, this is used to refresh the td, not repainted automatically
                        //
                        $(_lastSelectedElement).fadeOut(0).fadeIn(0);
                    }
                    seriesInstanceUID = target.getAttribute('SeriesInstanceUID');
                    scope.appendCell({ seriesInstanceUID: seriesInstanceUID });
                }
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('pwdConfirm', function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, elem, attrs, ctrl) {
            var firstPassword = '#' + attrs.pwdConfirm;
            elem.add(firstPassword).on('keyup', function () {
                scope.$apply(function () {
                    var v = elem.val() === $(firstPassword).val();
                    ctrl.$setValidity('pwmatch', v);
                });
            });
        }
    };
});
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('checkList', function () {
    return {
        scope: {
            list: '=checkList',
            value: '@'
        },
        link: function (scope, elem, attrs) {
            var handler = function (setup) {
                var checked = elem.prop('checked');
                var index = scope.list.indexOf(scope.value);
                if (checked && index == -1) {
                    if (setup)
                        elem.prop('checked', false);
                    else
                        scope.list.push(scope.value);
                }
                else if (!checked && index != -1) {
                    if (setup)
                        elem.prop('checked', true);
                    else
                        scope.list.splice(index, 1);
                }
            };
            var setupHandler = handler.bind(null, true);
            var changeHandler = handler.bind(null, false);
            elem.bind('change', function () {
                scope.$apply(changeHandler);
            });
            scope.$watch('list', setupHandler, true);
        }
    };
});
directives.directive('ngEnter', function () {
    return function (scope, element, attrs) {
        element.bind("keydown keypress", function (event) {
            if (event.which === 13) {
                scope.$apply(function () {
                    scope.$eval(attrs.ngEnter);
                });
                event.preventDefault();
            }
        });
    };
});
function processInput(ctrl, val, regex) {
    var digits = val.replace(regex, '');
    if (digits !== val) {
        ctrl.$setViewValue(digits);
        ctrl.$render();
    }
    return digits;
}
//
// Directive that only allows digits and a decimal
//
directives.directive('onlyDigitsd', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attr, ctrl) {
            function inputValue(val) {
                if (val) {
                    return processInput(ctrl, val, /[^0-9.]/g);
                }
                return undefined;
            }
            ctrl.$parsers.push(inputValue);
        }
    };
});
//
// Directive that only allows digits and a decimal
//
directives.directive('onlyDigits', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attr, ctrl) {
            function inputValue(val) {
                if (val) {
                    return processInput(ctrl, val, /[^0-9]/g);
                }
                return undefined;
            }
            ctrl.$parsers.push(inputValue);
        }
    };
});
//
// Forces a blur when value changes.  Android chrome <select> requires this.
//
directives.directive('forceBlur', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attr, ctrl) {
            if (ctrl && ctrl.$viewChangeListeners) {
                ctrl.$viewChangeListeners.push(function () {
                    $(element).blur();
                });
            }
        }
    };
});
app.directive('ngDebounce', ["$timeout", function ($timeout) {
        return {
            restrict: 'A',
            require: 'ngModel',
            priority: 99,
            link: function (scope, elm, attr, ngModelCtrl) {
                if (attr.type === 'radio' || attr.type === 'checkbox') {
                    return;
                }
                var delay = parseInt(attr.ngDebounce, 10);
                if (isNaN(delay)) {
                    delay = 1000;
                }
                elm.unbind('input');
                var debounce;
                elm.bind('input', function () {
                    $timeout.cancel(debounce);
                    debounce = $timeout(function () {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(elm.val());
                        });
                    }, delay);
                });
                elm.bind('blur', function () {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(elm.val());
                    });
                });
            }
        };
    }]);
app.directive("modalShow", function () {
    return {
        restrict: "A",
        scope: {
            modalVisible: "="
        },
        link: function (scope, element, attrs) {
            //Hide or show the modal
            scope.showModal = function (visible) {
                if (visible) {
                    element.modal("show");
                }
                else {
                    element.modal("hide");
                }
            };
            //Check to see if the modal-visible attribute exists
            if (!attrs.modalVisible) {
                //The attribute isn't defined, show the modal by default
                scope.showModal(true);
            }
            else {
                //Watch for changes to the modal-visible attribute
                scope.$watch("modalVisible", function (newValue, oldValue) {
                    scope.showModal(newValue);
                });
                //Update the visible value when the dialog is closed through UI actions (Ok, cancel, etc.)
                element.bind("hide.bs.modal", function () {
                    scope.modalVisible = false;
                    if (!scope.$$phase && !scope.$root.$$phase)
                        scope.$apply();
                });
            }
        }
    };
});
app.directive('elheightresize', ['$window', '$parse', function ($window, $parse) {
        return {
            link: function (scope, elem, attrs) {
                var doResize = Utils.debounce(function () {
                    scope.onResize();
                    scope.$apply();
                }, 150);
                scope.onResize = function () {
                    var pos = elem.position();
                    $(elem).height($window.innerHeight - (pos.top + 5));
                    if (angular.isDefined(attrs.resize)) {
                        scope.$apply(function () {
                            var method = $parse(attrs.resize);
                            method(scope, {});
                        });
                    }
                };
                doResize();
                angular.element($window).bind('resize', function () {
                    setTimeout(function () {
                        doResize();
                    }, 350);
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('resizeToParent', function () {
    return {
        restrict: 'A',
        link: function (scope, elem, attr) {
            var parent = $(elem).parent();
            function resize() {
                $(elem).width(parent.innerWidth());
                $(elem).height(parent.innerHeight());
            }
            if (parent != null) {
                parent.resize(function (event) {
                    resize();
                });
            }
            $(window).bind('orientationchange', function () {
                if (parent != null) {
                    resize();
                }
            });
        }
    };
});
directives.directive('resizeWidthToParent', function ($timeout) {
    return {
        restrict: 'A',
        link: function (scope, elem, attr) {
            var parent = $(elem).parent();
            function resize() {
                $timeout(function () {
                    $(elem).width(parent.innerWidth());
                }, 250);
            }
            if (parent != null) {
                parent.resize(function (event) {
                    resize();
                });
            }
            $(window).bind('orientationchange', function () {
                if (parent != null) {
                    resize();
                }
            });
        }
    };
});
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('scroller', ["$timeout", function ($timeout) {
        return {
            restrict: "A",
            scope: false,
            link: function (scope, element, attributes) {
                var $element = $(element).addClass("scroll-parent");
                var leftDiv = document.createElement("div");
                leftDiv.id = 'scrollLeft_toolbar_button';
                var $left = $(leftDiv).addClass("scroll-button scroll-button-left");
                var $right = $(document.createElement("div")).addClass("scroll-button scroll-button-right");
                var $body = $(document.createElement("div")).addClass("scroll-body");
                var scrollArea = document.createElement("div");
                scrollArea.id = 'scrollArea';
                var $scrollAreaBody = $(scrollArea).addClass("toolbarbodyArea");
                $body.append($scrollAreaBody);
                var InnerScroll = document.createElement("div");
                InnerScroll.id = 'scrollInner';
                var $bodyInner = $(InnerScroll).addClass("scroll-body-inner");
                var $children = $element.children();
                var disabled = false;
                var disabledClass = "scroll-button-disabled";
                InnerScroll.left = 0;
                InnerScroll.setLeft = function (value) {
                    InnerScroll.style.left = value + "px";
                    InnerScroll.left = value;
                };
                InnerScroll.getLeft = function () {
                    return InnerScroll.left;
                };
                $left.append($(document.createElement("span")).addClass("fa fa-angle-double-left"));
                $right.append($(document.createElement("span")).addClass("fa fa-angle-double-right"));
                $right.css('float', 'right');
                $right.css('z-index', '3000');
                $body.css('position', 'absolute');
                $scrollAreaBody.append($bodyInner);
                $children.detach();
                $bodyInner.append($children);
                $bodyInner.css("left", "0px");
                $bodyInner.css("overflow", "visible");
                $bodyInner.css("display", "inline");
                $bodyInner.css("white-space", "nowrap");
                $bodyInner.css("position", "relative");
                $body.css("overflow", "visible");
                $left.css("z-index", 1000);
                $element.append($left).append($body).append($right);
                $element.resize(function () {
                    $timeout(function () {
                        var innerWidth = $bodyInner.width();
                        var outerWidth = $body.parent().width();
                        if (innerWidth > outerWidth) {
                            disabled = false;
                            $left.removeClass(disabledClass);
                            $right.removeClass(disabledClass);
                        }
                        else {
                            disabled = true;
                            $left.addClass(disabledClass);
                            $right.addClass(disabledClass);
                        }
                        if ($bodyInner.position().left != 0) {
                            $bodyInner.css({
                                left: InnerScroll.left + "px"
                            });
                        }
                    }, 850);
                });
                var watchFunc = function () {
                    var innerWidth = $bodyInner.width();
                    var outerWidth = $body.parent().width();
                    return (innerWidth > outerWidth);
                };
                $left.on('click touchstart', function (event) {
                    var current;
                    var half;
                    var newLeft;
                    if (disabled || $left.hasClass(disabledClass))
                        return;
                    event.stopPropagation();
                    event.preventDefault();
                    current = parseInt($bodyInner.css("left"));
                    half = Math.floor($body.parent().width() / 2);
                    newLeft = Math.min(InnerScroll.left, current + half);
                    $bodyInner.css({
                        left: newLeft + "px"
                    });
                    if (newLeft == 0) {
                        if (!$left.hasClass(disabledClass)) {
                            $left.addClass(disabledClass);
                        }
                        if ($right.hasClass(disabledClass)) {
                            $right.removeClass(disabledClass);
                        }
                    }
                    else {
                        if ($right.hasClass(disabledClass)) {
                            $right.removeClass(disabledClass);
                        }
                    }
                });
                $right.on('click touchstart', function (event) {
                    var current;
                    var half;
                    var newLeft;
                    var max;
                    var width = 0;
                    var lastChild = $bodyInner.children().last();
                    var lastWidth;
                    if (disabled || $right.hasClass(disabledClass))
                        return;
                    if (lastChild[0].hasChildNodes) {
                        lastWidth = 0;
                        lastChild.children().width(function (i, w) {
                            lastWidth += w;
                        });
                    }
                    else {
                        lastWidth = lastChild.outerWidth(true);
                    }
                    if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device == lt.LTDevice.mobile) {
                        lastWidth += 10;
                    }
                    if (!lastChild.hasClass('btn-group')) {
                        lastWidth += lastWidth;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                    width = lastChild.position().left + lastWidth;
                    current = parseInt($bodyInner.css("left"));
                    half = Math.floor($body.parent().outerWidth(true) / 2);
                    max = Math.floor($body.parent().outerWidth(true) - width);
                    newLeft = Math.max(max, (current - (half + lastWidth)));
                    $bodyInner.css({
                        left: newLeft + "px"
                    });
                    if (newLeft == max) {
                        if (!$right.hasClass(disabledClass)) {
                            $right.addClass(disabledClass);
                        }
                        if ($left.hasClass(disabledClass)) {
                            $left.removeClass(disabledClass);
                        }
                    }
                    else {
                        if ($left.hasClass(disabledClass)) {
                            $left.removeClass(disabledClass);
                        }
                    }
                });
                scope.$watch(watchFunc, function (isLarger) {
                    if (isLarger) {
                        disabled = false;
                        $left.removeClass(disabledClass);
                        $right.removeClass(disabledClass);
                    }
                    else {
                        disabled = true;
                        $left.addClass(disabledClass);
                        $right.addClass(disabledClass);
                        if ($bodyInner.position().left != 0) {
                            $bodyInner.css({
                                left: InnerScroll.left + "px"
                            });
                        }
                    }
                });
            }
        };
    }]);
directives.directive('verticalScroller', function ($timeout) {
    return {
        restrict: "A",
        scope: false,
        link: function (scope, element, attributes) {
            var $element = $(element).addClass("scroll-parent-vertical");
            var $top = $(document.createElement("div")).addClass("scroll-button-vertical scroll-button-up");
            var $right = $(document.createElement("div")).addClass("scroll-button-vertical scroll-button-down");
            var $body = $(document.createElement("div")).addClass("scroll-body-vertical");
            var InnerScroll = document.createElement("div");
            var $bodyInner = $(InnerScroll).addClass("scroll-body-inner");
            var $children = $element.children();
            var disabled = false;
            var disabledClass = "scroll-button-disabled";
            $top.append($(document.createElement("span")).addClass("fa fa-angle-double-up"));
            $right.append($(document.createElement("span")).addClass("fa fa-angle-double-down"));
            $right.css('position', 'fixed');
            $right.css('bottom', '0');
            $right.css('z-index', '3000');
            $body.css('position', 'absolute');
            $body.append($bodyInner);
            $children.detach();
            $bodyInner.append($children);
            $bodyInner.css("top", "0px");
            $bodyInner.css("overflow", "visible");
            $bodyInner.css("display", "inline");
            $bodyInner.css("white-space", "nowrap");
            $bodyInner.css("position", "relative");
            InnerScroll.setLeft = function (value) {
                InnerScroll.style.left = value + "px";
                InnerScroll.left = value;
            };
            $body.css("overflow", "visible");
            $top.css("z-index", 1000);
            $element.append($top).append($body).append($right);
            $element.resize(function () {
                $timeout(function () {
                    var innerHeight = $bodyInner.height();
                    var outerHeight = $body.parent().height();
                    if (innerHeight > outerHeight) {
                        disabled = false;
                        $top.removeClass(disabledClass);
                        $right.removeClass(disabledClass);
                    }
                    else {
                        disabled = true;
                        $top.addClass(disabledClass);
                        $right.addClass(disabledClass);
                    }
                    if ($bodyInner.position().top != 0) {
                        $bodyInner.css({
                            top: "0px"
                        });
                    }
                }, 850);
            });
            var watchFunc = function () {
                var innerHeight = $bodyInner.height();
                var outerHeight = $body.parent().height();
                return (innerHeight > outerHeight);
            };
            $top.on('click touchstart', function (event) {
                var current;
                var half;
                var newLeft;
                if (disabled || $top.hasClass(disabledClass))
                    return;
                event.stopPropagation();
                event.preventDefault();
                current = parseInt($bodyInner.css("left"));
                half = Math.floor($body.parent().width() / 2);
                newLeft = Math.min(InnerScroll.left, current + half);
                $bodyInner.css({
                    left: newLeft + "px"
                });
                if (newLeft == 0) {
                    if (!$top.hasClass(disabledClass)) {
                        $top.addClass(disabledClass);
                    }
                    if ($right.hasClass(disabledClass)) {
                        $right.removeClass(disabledClass);
                    }
                }
                else {
                    if ($right.hasClass(disabledClass)) {
                        $right.removeClass(disabledClass);
                    }
                }
            });
            $right.on('click touchstart', function (event) {
                var current;
                var half;
                var newLeft;
                var max;
                var width = 0;
                var lastChild = $bodyInner.children().last();
                var lastWidth;
                if (disabled || $right.hasClass(disabledClass))
                    return;
                if (lastChild[0].hasChildNodes) {
                    lastWidth = 0;
                    lastChild.children().width(function (i, w) {
                        lastWidth += w;
                    });
                }
                else {
                    lastWidth = lastChild.outerWidth(true);
                }
                if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device == lt.LTDevice.mobile) {
                    lastWidth += 10;
                }
                event.stopPropagation();
                event.preventDefault();
                width = lastChild.position().left + lastWidth;
                current = parseInt($bodyInner.css("left"));
                half = Math.floor($body.parent().outerWidth(true) / 2);
                max = Math.floor($body.parent().outerWidth(true) - width);
                newLeft = Math.min(InnerScroll.left, Math.max(max, (current - half)));
                $bodyInner.css({
                    left: newLeft + "px"
                });
                if (newLeft == max) {
                    if (!$right.hasClass(disabledClass)) {
                        $right.addClass(disabledClass);
                    }
                    if ($top.hasClass(disabledClass)) {
                        $top.removeClass(disabledClass);
                    }
                }
                else {
                    if ($top.hasClass(disabledClass)) {
                        $top.removeClass(disabledClass);
                    }
                }
            });
            scope.$watch(watchFunc, function (isLarger) {
                if (isLarger) {
                    disabled = false;
                    $top.removeClass(disabledClass);
                    $right.removeClass(disabledClass);
                }
                else {
                    disabled = true;
                    $top.addClass(disabledClass);
                    $right.addClass(disabledClass);
                    if ($bodyInner.position().left != 0) {
                        $bodyInner.css({
                            left: InnerScroll.left + " px"
                        });
                    }
                }
            });
        }
    };
});
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var PatientAccessRightsService = /** @class */ (function () {
    function PatientAccessRightsService(config, authenticationService, $http) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._patientAccessRightsUrl = config.urls.serviceUrl + config.urls.patientAccessRightsServiceName;
    }
    PatientAccessRightsService.prototype.GetUserAccess = function (user, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            user: user,
            extraOptions: extraOptions
        };
        return this._http.post(this._patientAccessRightsUrl + "/GetUserAccess", JSON.stringify(data));
    };
    PatientAccessRightsService.prototype.GrantUserPatients = function (user, patientIds, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            user: user,
            patientIds: patientIds,
            extraOptions: extraOptions
        };
        return this._http.post(this._patientAccessRightsUrl + "/GrantUserPatients", JSON.stringify(data));
    };
    PatientAccessRightsService.prototype.GetRoleAccess = function (role, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            role: role,
            extraOptions: extraOptions
        };
        return this._http.post(this._patientAccessRightsUrl + "/GetRoleAccess", JSON.stringify(data));
    };
    PatientAccessRightsService.prototype.GrantRolePatients = function (role, patientIds, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            role: role,
            patientIds: patientIds,
            extraOptions: extraOptions
        };
        return this._http.post(this._patientAccessRightsUrl + "/GrantRolePatients", JSON.stringify(data));
    };
    PatientAccessRightsService.prototype.GetRolesAccess = function (roles, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            roles: roles,
            extraOptions: extraOptions
        };
        return this._http.post(this._patientAccessRightsUrl + "/GetRolesAccess", JSON.stringify(data));
    };
    PatientAccessRightsService.$inject = ['app.config', 'authenticationService', '$http'];
    return PatientAccessRightsService;
}());
services.service('patientAccessRightsService', PatientAccessRightsService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../app.ts" />
var EventNames;
(function (EventNames) {
    EventNames.SeriesSelected = "Search\Series\Selected";
    EventNames.SeriesLoading = "Search\Series\SeriesLoading";
    EventNames.SelectedTabChanged = "ViewerTab\SelectedTabChanged";
    EventNames.SearchSeriesFailure = "Search\Series\Failure";
    EventNames.SearchPatientsSuccess = "Search\Patients\Success";
    EventNames.LoginSuccess = "AuthenticationService\AuthenticationSuccess";
    EventNames.LoginFailed = "AuthenticationService\AuthenticationFailed";
    EventNames.Logout = "AuthenticationService\Logout";
    EventNames.NorthPaneResized = "UiLayout/Pane/Resized/North";
    EventNames.SouthPaneResized = "UiLayout/Pane/Resized/South";
    EventNames.EastPaneResized = "UiLayout/Pane/Resized/East";
    EventNames.WestPaneResized = "UiLayout/Pane/Resized/West";
    EventNames.CenterPaneResized = "UiLayout/Pane/Resized/Center";
    EventNames.LoadSeries = "Loader/LoadSeries";
    EventNames.ActiveSeriesChanged = "Viewer/ActiveSeriesChanged";
    EventNames.OnLoadLayout = "DicomLoader/OnLoadLayout";
    EventNames.OnPresentationInfoLoaded = "DicomLoader/PresentationInfoLoaded";
    EventNames.OnFrameLoaded = "DicomLoader/OnFrameLoaded";
    EventNames.OnInstancesFound = "DicomLoader/InstancesFound";
    EventNames.OnDicomXmlRetrieved = "DicomLoader/OnDicomXmlRetrieved";
    EventNames.OnDicomJSONRetrieved = "DicomLoader/OnDicomJSONRetrieved";
    EventNames.InstanceOverflow = "DicomLoader/InstanceOverflow";
    EventNames.InstanceOverflowClear = "DicomLoader/InstanceOverflowClear";
    EventNames.InstanceOverflowSwap = "DicomLoader/InstanceOverflowSwap";
    EventNames.InstanceOverflowAdd = "DicomLoader/InstanceOverflowAdd";
    EventNames.InstanceOverflowClose = "DicomLoader/InstanceOverflowClose";
    EventNames.ImageInformationReady = "DicomLoader/ImageInformationReady";
    EventNames.ImageDataReady = "DicomLoader/ImageDataReady";
    EventNames.LoadingSeriesFrames = "DicomLoader/LoadingSeriesFrames";
    EventNames.PresentationStateLoaded = "DicomLoader/PresentationStateLoaded";
    EventNames.AnnotationsLoaded = "DicomLoader/AnnotationsLoaded";
    EventNames.CurrentDesignerChanged = "SeriesViewer/CurrentDesignerChanged";
    EventNames.DerivedImageCreated = "Store/DerivedImageCreated";
    EventNames.DeleteAnnotation = "Annotation/DeleteAnnotation";
    EventNames.FrameChanged = "Cine/FrameChanged";
    EventNames.PlayerStopped = "Cine/PlayerStopped";
    EventNames.DownloadSeries = "UserQueue/DownloadSeries";
    EventNames.JobUpdated = "UserQueue/JobUpdated";
    EventNames.JobCreated = "UserQueue/JobCreated";
    EventNames.PreviewLoaded = "DicomLoader/PreviewLoaded";
    EventNames.PreviewFailed = "DicomLoader/PreviewFailed";
    EventNames.LoadedDicomXml = "DicomLoader/LoadedDicomXml";
    EventNames.LoadedDicomJSON = "DicomLoader/LoadedDicomJSON";
    EventNames.DeleteTab = "Viewer/DeleteTab";
    EventNames.NewCellsAdded = "Viewer/NewCellsAdded";
    EventNames.StackChanged = "Viewer/StackChanged";
    EventNames.NewSubCellSelected = "Viewer/NewFrameSelected";
    EventNames.ToolbarCreated = "Viewer/ToolbarCreated";
    EventNames.TemplatesImported = "TemplateEditor/TemplatesImported";
    EventNames.DeleteSeries = "Viewer/DeleteSeries";
    EventNames.MrtiInfoReady = "DicomLoader/MrtiInfoReady";
    EventNames.LinkedChanged = "Viewer/LinkedChanged";
    EventNames.OpenStudyTimeLine = "Viewer/OpenStudyTimeLine";
    EventNames.UpdateToolbarPressed = "Viewer/UpdateToolbarPressed";
    EventNames.LoadStructuredDisplay = "Viewer/LoadStructuredDisplay";
    EventNames.StructuredDisplaySelected = "Viewer/StructuredDisplaySelected";
    EventNames.StructuredDisplayUpdated = "Viewer/StructuredDisplayUpdated";
    EventNames.EnableSeriesList = "Viewer/EnableSeriesList";
    EventNames.LoadFromOverflow = "DicomLoader/LoadFromOverflow";
    EventNames.OverflowExcessImage = "Viewer/OverflowExcessImage";
    EventNames.LoadSelectedSeries = "Viewer/LoadSelectedSeries";
    EventNames.RefreshToolbar = "Viewer/RefreshToolbar";
})(EventNames || (EventNames = {}));
var EventService = /** @class */ (function () {
    function EventService($q, $rootScope) {
        this.subscriptions = {};
        this.rootScope = $rootScope;
        this.$q = $q;
    }
    EventService.prototype.subscribe = function (name, callback) {
        return this.rootScope.$on(name, callback);
    };
    EventService.prototype.unsubscribe = function (handle) {
        if (angular.isFunction(handle)) {
            handle();
        }
    };
    EventService.prototype.publish = function (name, args) {
        if (!this.rootScope.$$listeners[name]) {
            return [];
        }
        var deferred = [];
        for (var i = 0; i < this.rootScope.$$listeners[name].length; i++) {
            deferred.push(this.$q.defer());
        }
        var eventArgs = {
            args: args,
            reject: function (a) {
                deferred.pop().reject(a);
            },
            resolve: function (a) {
                deferred.pop().resolve(a);
            }
        };
        //send the event
        this.rootScope.$broadcast(name, eventArgs);
        //return an array of promises
        var promises = $.map(deferred, function (p) {
            return p.promise;
        });
        return promises;
    };
    EventService.$inject = ['$q', '$rootScope'];
    return EventService;
}());
services.service('eventService', EventService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var ExportService = /** @class */ (function () {
    function ExportService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this.exportUrl = config.urls.serviceUrl + config.urls.exportServiceName;
    }
    ExportService.prototype.ExportAllSeries = function (patientID, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            patientID: patientID,
            options: options
        };
        return this._http.post(this.exportUrl + "/ExportAllSeries", JSON.stringify(data));
    };
    ExportService.prototype.ExportSeries = function (seriesInstanceUIDs, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUIDs: seriesInstanceUIDs,
            options: options,
        };
        return this._http.post(this.exportUrl + "/ExportSeries", JSON.stringify(data));
    };
    ExportService.prototype.ExportInstances = function (instanceUIDS, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            instanceUIDs: instanceUIDS,
            options: options,
        };
        return this._http.post(this.exportUrl + "/ExportInstances", JSON.stringify(data));
    };
    ExportService.prototype.ExportLayout = function (seriesInstanceUID, layout, annotationFileName, burnAnnotations, compression, width) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUID: seriesInstanceUID,
            layout: layout,
            compression: compression,
            width: width,
            annotationFileName: annotationFileName
        };
        return this._http.post(this.exportUrl + "/ExportLayout", JSON.stringify(data));
    };
    ExportService.prototype.GetInstanceLocalPathName = function (instanceUID) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            instanceUID: instanceUID
        };
        return this._http.post(this.exportUrl + "/GetInstanceLocalPathName", JSON.stringify(data));
    };
    ExportService.$inject = ['app.config', 'authenticationService', '$http'];
    return ExportService;
}());
services.service('exportService', ExportService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/angular/angular.d.ts" />
/// <reference path="../../lib/angular/angular-route.d.ts" />
var ExportImagesSource;
(function (ExportImagesSource) {
    ExportImagesSource.AllPatientImages = "AllPatientImages";
    ExportImagesSource.LoadedSeries = "LoadedSeries";
    ExportImagesSource.CurrentSeries = "CurrentSeries";
    ExportImagesSource.SelectedImages = "SelectedImages";
    ExportImagesSource.PrintCurrentView = "PrintCurrentView";
    ExportImagesSource.Layout = "Layout";
})(ExportImagesSource || (ExportImagesSource = {}));
var PrintImagesSource;
(function (PrintImagesSource) {
    PrintImagesSource.AllPatientImages = "AllPatientImages";
    PrintImagesSource.LoadedSeries = "LoadedSeries";
    PrintImagesSource.CurrentSeries = "CurrentSeries";
    PrintImagesSource.SelectedImages = "SelectedImages";
    PrintImagesSource.PrintCurrentView = "PrintCurrentView";
    PrintImagesSource.Layout = "Layout";
})(PrintImagesSource || (PrintImagesSource = {}));
var ExportManagerService = /** @class */ (function () {
    function ExportManagerService($q, exportService, printService, seriesManagerService, tabService, objectRetrieveService, objectStoreService) {
        this._exportService = exportService;
        this._printService = printService;
        this._seriesManagerService = seriesManagerService;
        this._objectRetrieveService = objectRetrieveService;
        this._objectStoreService = objectStoreService;
        this.$q = $q;
        this._tabService = tabService;
    }
    ExportManagerService.prototype.Export = function (exportOptions, source, seriesInstanceUID, sopInstanceUIDs) {
        if (source == ExportImagesSource.PrintCurrentView) {
            var viewer = this._tabService.getActiveViewer();
            var element = document.getElementById(viewer.divId);
            html2canvas(element.parentElement, { onrendered: function (canvas) { OpenPrintViewUrl(canvas.toDataURL()); } });
            var deferred = this.$q.defer();
            deferred.resolve();
            return deferred.promise;
        }
        if (exportOptions.FileFormat == 'PDF')
            return this.Print(exportOptions, source, seriesInstanceUID, sopInstanceUIDs);
        switch (source) {
            case ExportImagesSource.AllPatientImages:
                var cellFrame = this._seriesManagerService.get_activeCellFrame();
                var patientId = DicomHelper.getDicomTagValue(cellFrame.metadata, DicomTag.PatientID);
                return this._exportService.ExportAllSeries(patientId, exportOptions);
            case ExportImagesSource.Layout:
                return this.Print(exportOptions, source, seriesInstanceUID);
            case ExportImagesSource.SelectedImages:
                var cellFrame = this._seriesManagerService.get_activeCellFrame();
                return this._exportService.ExportInstances(sopInstanceUIDs ? sopInstanceUIDs : [cellFrame.Instance.SOPInstanceUID], exportOptions);
            default:
                var seriesInstanceUID = this._seriesManagerService.get_activeCell().get_seriesInstanceUID();
                return this._exportService.ExportSeries([seriesInstanceUID], exportOptions);
        }
    };
    ExportManagerService.prototype.Print = function (exportOptions, source, seriesInstanceUID, sopInstanceUIDs) {
        var printOptions = new Models.PrintOptions();
        printOptions.BurnAnnotations = exportOptions.BurnAnnotations;
        printOptions.IncludeOverflowImages = exportOptions.IncludeOverflowImages;
        printOptions.LayoutImageWidth = exportOptions.LayoutImageWidth;
        printOptions.WhiteBackground = exportOptions.WhiteBackground;
        printOptions.PatientInfo = exportOptions.PatientInfo;
        printOptions.ReduceGrayscaleTo8BitsSelected = exportOptions.ReduceGrayscaleTo8BitsSelected;
        printOptions.AnnotationsFileName = exportOptions.AnnotationsFileName;
        printOptions.BackgroundColor = exportOptions.BackgroundColor;
        printOptions.TextBackgroundColor = exportOptions.TextBackgroundColor;
        printOptions.TextColor = exportOptions.TextColor;
        printOptions.BurnDisplayedAnnotations = exportOptions.BurnDisplayedAnnotations;
        try {
            if (source === PrintImagesSource.AllPatientImages) {
                var cellFrame = this._seriesManagerService.get_activeCellFrame();
                var patientId = DicomHelper.getDicomTagValue(cellFrame.metadata, DicomTag.PatientID);
                return this._printService.PrintAllSeries(patientId, printOptions);
            }
            else if (source === PrintImagesSource.Layout) {
                var layout = new Models.Layout();
                var cell = this._seriesManagerService.get_activeCell();
                if (cell == null)
                    return;
                var viewer = cell.viewer;
                var viewerElement = document.getElementById(cell.viewer.divId);
                printOptions.PageWidth = viewerElement.clientWidth;
                printOptions.PageHeight = viewerElement.clientHeight;
                var length = viewer.layout.items.count;
                var box;
                var subItemLength;
                var subItemIndex = 0;
                for (var index = 0; index < length; index++) {
                    var item = viewer.layout.items.get_item(index);
                    if (item == null)
                        continue;
                    if (!item.visibility)
                        continue;
                    if ((item.imageViewer == null) || (item.imageViewer.items.count == 0)) {
                        var bounds = item.bounds;
                        var sop = "";
                        layout.Boxes.push(new Models.ImageBox(sop, bounds.x, bounds.y, bounds.width + bounds.x, bounds.height + bounds.y));
                    }
                    else {
                        subItemIndex = 0;
                        subItemLength = item.imageViewer.items.count;
                        var subItem;
                        var itemBounds = item.bounds;
                        if (itemBounds == null)
                            continue;
                        for (subItemIndex = 0; subItemIndex < subItemLength; subItemIndex++) {
                            subItem = item.imageViewer.items.get_item(subItemIndex);
                            if (subItem == null)
                                continue;
                            if (subItem.bounds == null)
                                continue;
                            var bounds = lt.LeadRectD.create(subItem.bounds.left * item.bounds.width, subItem.bounds.top * item.bounds.height, subItem.bounds.width * item.bounds.width, subItem.bounds.height * item.bounds.height);
                            bounds.offset(item.bounds.left, item.bounds.top);
                            var frame = null;
                            frame = subItem.attachedFrame;
                            var sop = "";
                            if (frame != null) {
                                if (!frame.Instance)
                                    continue;
                                sop = frame.Instance.SOPInstanceUID.toString();
                            }
                            box = new Models.ImageBox(sop, bounds.x, bounds.y, bounds.width + bounds.x, bounds.height + bounds.y);
                            if (frame != null) {
                                box.WindowWidth = frame.windowWidth;
                                box.WindowCenter = frame.windowCenter;
                                var photometricInverted = (frame.photometricInterpretation == "MONOCHROME1") ? 1 : 0;
                                box.Inverted = (frame.inverted ^ photometricInverted) ? true : false;
                            }
                            var viewRect = subItem.imageViewer.getItemViewBounds(subItem, lt.Controls.ImageViewerItemPart.view, false);
                            var paintRect = subItem.imageViewer.getItemViewBounds(subItem, lt.Controls.ImageViewerItemPart.image, false);
                            box.PaintRect = lt.LeadRectD.create(paintRect.left / viewRect.width, paintRect.top / viewRect.height, paintRect.width / viewRect.width, paintRect.height / viewRect.height);
                            layout.Boxes.push(box);
                        }
                    }
                }
                if (!seriesInstanceUID)
                    seriesInstanceUID = this._seriesManagerService.get_activeCell().get_seriesInstanceUID();
                return this._printService.PrintLayout(seriesInstanceUID, layout, printOptions);
            }
            else if (source === PrintImagesSource.SelectedImages) {
                var cellFrame = this._seriesManagerService.get_activeCellFrame();
                return this._printService.PrintInstances(sopInstanceUIDs ? sopInstanceUIDs : [cellFrame.Instance.SOPInstanceUID], printOptions);
            }
            else {
                var seriesInstanceUID = this._seriesManagerService.get_activeCell().get_seriesInstanceUID();
                return this._printService.PrintSeries([seriesInstanceUID], printOptions);
            }
        }
        catch (e) {
            throw e;
        }
    };
    ExportManagerService.prototype.UploadAnnotations = function (burnAnnotations) {
        try {
            var deferred = this.$q.defer();
            if (!burnAnnotations) {
                deferred.resolve();
                return deferred.promise;
            }
            var cell = this._seriesManagerService.get_activeCell();
            if (cell) {
                var seriesInstanceUID = cell.get_seriesInstanceUID();
                var annotationsData = this._seriesManagerService.get_cellAnnotations(cell, false);
                var description = "_printing";
                return this._objectStoreService.StoreAnnotations(seriesInstanceUID, annotationsData, description);
            }
            else {
                deferred.resolve();
                return deferred.promise;
            }
        }
        catch (e) {
            throw e;
        }
    };
    ExportManagerService.prototype.buildIpArray = function (cellFrame) {
        var ipArray = new Array();
        var ipItems = cellFrame.imageProcessingList.toArray();
        var foundItems;
        foundItems = $.grep(ipItems, function (item) { return item.command == "UnsharpMask" || item.command == "Perio" || item.command == "Dentin" || item.command == "Endo"; });
        if (foundItems.length > 0) {
            for (var i = 0; i < foundItems.length; i++) {
                var ip = foundItems[0];
                if (ip.arguments["MultiscaleEnhancement"]) {
                    ipArray.push({
                        Name: "MultiscaleEnhancement", Parameters: ip.arguments["MultiscaleEnhancement"].replace(/=/g, "")
                    });
                }
                if (ip.arguments["GammaCorrect"]) {
                    ipArray.push({
                        Name: "GammaCorrect", Parameters: ip.arguments["GammaCorrect"].replace(/=/g, "")
                    });
                }
                if (ip.arguments["UnsharpMask"]) {
                    ipArray.push({
                        Name: "UnsharpMask", Parameters: ip.arguments["UnsharpMask"]
                    });
                }
            }
        }
        foundItems = $.grep(ipItems, function (item) { return item.command == "ContrastBrightnessIntensity"; });
        if (foundItems.length > 0) {
            for (var i = 0; i < foundItems.length; i++) {
                var ip = foundItems[0];
                ipArray.push({
                    Name: "BrightnessContrast",
                    Parameters: ip.arguments["brightness"] + "," + ip.arguments["contrast"]
                });
            }
        }
        foundItems = $.grep(ipItems, function (item) { return item.command == "ChangeHueSaturationIntensity"; });
        if (foundItems.length > 0) {
            for (var i = 0; i < foundItems.length; i++) {
                var ip = foundItems[0];
                ipArray.push({
                    Name: "HSL",
                    Parameters: ip.arguments["hue"] + "," + ip.arguments["saturation"] + "," + ip.arguments["intensity"]
                });
            }
        }
        foundItems = $.grep(ipItems, function (item) { return item.command == "StretchHistogram"; });
        if (foundItems.length > 0) {
            ipArray.push({ Name: "StretchHistogram", Parameters: "" });
        }
        if (cellFrame.flipped) {
            ipArray.push({ Name: "Flip", Parameters: "" });
        }
        if (cellFrame.reversed) {
            ipArray.push({ Name: "Flip", Parameters: "true" });
        }
        if (cellFrame.rotateAngle != 0) {
            ipArray.push({ Name: "Rotate", Parameters: cellFrame.rotateAngle.toString() });
        }
        if (cellFrame.mrtiInfo.supportWindowLevel) {
            var photoMetric = cellFrame.information.photometricInterpretation;
            var inverted = (cellFrame.information.photometricInterpretation == "MONOCHROME1");
            ipArray.push({
                Name: "WindowLevel", Parameters: cellFrame.wlRenderer.windowLevelWidth.toString() + "," +
                    cellFrame.wlRenderer.windowLevelCenter.toString() + "," +
                    inverted
            });
        }
        else {
            if (cellFrame.inverted) {
                ipArray.push({ Name: "Invert", Parameters: "" });
            }
        }
        return ipArray;
    };
    ExportManagerService.prototype.PopupCapture = function () {
        var cell = this._seriesManagerService.get_activeCell();
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            var cell3D = cell;
            var tab = window.open("", "_blank");
            tab.location.href = cell3D.image.src + ".jpg";
            return;
        }
        if (cell instanceof lt.Controls.Medical.PanoramicCell) {
            var cellPano = cell;
            var frame;
            frame = cellPano.frames.get_item(0);
            OpenPrintViewUrl(frame.lowResImage.canvas.toDataURL());
            return;
        }
        var cellFrame = this._seriesManagerService.get_activeCellFrame();
        var automation;
        var subCell;
        var viewer;
        var annotationsData = "";
        var codecs = new lt.Annotations.Engine.AnnCodecs();
        var annFound = false;
        var container;
        var newTab = null; //iPad workaround
        var __this = this;
        var res;
        var loader;
        var ipArray = this.buildIpArray(cellFrame);
        if (cellFrame == null) {
            return;
        }
        loader = this._seriesManagerService.get_seriesLoaderById(cell);
        automation = cell.get_automation();
        subCell = cell.get_selectedItem();
        viewer = subCell.get_imageViewer();
        res = viewer.get_imageResolution();
        if (lt.LTHelper.OS == lt.LTOS.android && lt.LTHelper.browser == lt.LTBrowser.android) {
            //secondaryCapturer.PopupCapturedData(cellframe, viewer, automation, subCell.get_overlayCanvas(), OnPostRenderImage);
            return;
        }
        container = automation.get_container();
        if (container.get_children().get_count() > 0) {
            annFound = true;
            annotationsData = codecs.save(container, 1, null, length + 1);
        }
        if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device != lt.LTDevice.mobile) {
            newTab = window.open("", "_blank");
            window.focus();
        }
        if (annFound) {
            this._objectRetrieveService.UploadAnnotations(annotationsData)
                .then(function (result) {
                var data = result.data.replace(/"/g, "");
                var xDpi = 254;
                var yDpi = 254;
                if (cellFrame.columnSpacing > 0)
                    xDpi = 25.4 / cellFrame.columnSpacing;
                if (cellFrame.rowSpacing > 0)
                    yDpi = 25.4 / cellFrame.rowSpacing;
                var downloadImageUrl = __this._objectRetrieveService.DownloadImageUrl(cellFrame, data.replace('\"', ''), 0, 0, xDpi, yDpi, JSON.stringify(ipArray));
                if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device != lt.LTDevice.mobile) {
                    newTab.location.href = downloadImageUrl;
                    newTab.focus();
                }
                else {
                    window.location.href = downloadImageUrl;
                }
            }, function (error) {
            });
        }
        else {
            var downloadImageUrl = __this._objectRetrieveService.DownloadImageUrl(cellFrame, null, 0, 0, 150, 150, JSON.stringify(ipArray));
            if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device != lt.LTDevice.mobile) {
                newTab.location.href = downloadImageUrl;
                newTab.focus();
            }
            else {
                window.location.href = downloadImageUrl;
            }
        }
    };
    ExportManagerService.$inject = ['$q', 'exportService', 'printService', 'seriesManagerService', 'tabService', 'objectRetrieveService', 'objectStoreService', 'seriesManagerService'];
    return ExportManagerService;
}());
services.service('exportManagerService', ExportManagerService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var MonitorCalibrationService = /** @class */ (function () {
    function MonitorCalibrationService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._monitorCalibrationUrl = config.urls.serviceUrl + config.urls.monitorCalibrationServiceName;
    }
    MonitorCalibrationService.prototype.GetCalibrations = function () {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + '&cache=' + new Date().toString();
        return this._http.get(this._monitorCalibrationUrl + "/GetCalibrations?" + parameter, { cache: false });
    };
    MonitorCalibrationService.prototype.AddCalibration = function (calibration) {
        var parameters = {
            authenticationCookie: this._authenticationService.authenticationCode,
            calibration: calibration
        };
        return this._http.post(this._monitorCalibrationUrl + "/AddCalibration", JSON.stringify(parameters));
    };
    MonitorCalibrationService.$inject = ['app.config', 'authenticationService', '$http'];
    return MonitorCalibrationService;
}());
services.service('monitorCalibrationService', MonitorCalibrationService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var AuditLogService = /** @class */ (function () {
    function AuditLogService(config, authenticationService, $http, optionsService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._optionsService = optionsService;
        this._auditLogUrl = config.urls.serviceUrl + config.urls.auditLogServiceName;
    }
    AuditLogService.prototype.Log = function (userName, workstation, date, details, userData, authenticationCode) {
        var data = {
            authenticationCookie: authenticationCode || this._authenticationService.authenticationCode,
            user: userName,
            workstation: workstation,
            date: date,
            details: details,
            userData: userData
        };
        return this._http.post(this._auditLogUrl + "/Log", JSON.stringify(data, function (key, value) {
            if (key == "date") {
                var date = new Date(value);
                var jsonString = '/Date(' + date.getTime() + '-0800)/';
                return jsonString;
            }
            else
                return value;
        }));
    };
    AuditLogService.prototype.log_launch = function () {
        if (this._optionsService.get(OptionNames.EnableAuditLog) && this._optionsService.get(OptionNames.LogUserActivity)) {
            return this.Log("?", "?", new Date(), "Medical Web Viewer Launched", "");
        }
        return null;
    };
    AuditLogService.prototype.log_exit = function () {
        if (this._optionsService.get(OptionNames.EnableAuditLog) && this._optionsService.get(OptionNames.LogUserActivity)) {
            return this.Log("?", "?", new Date(), "Medical Web Viewer Exited", "");
        }
    };
    AuditLogService.prototype.log_logOut = function (authenticationCode) {
        if (this._optionsService.get(OptionNames.EnableAuditLog) && this._optionsService.get(OptionNames.LogUserActivity)) {
            return this.Log("?", "?", new Date(), "Medical Web Viewer Exited", "", authenticationCode);
        }
    };
    AuditLogService.prototype.log_openPatient = function (patient) {
        if (this._optionsService.get(OptionNames.EnableAuditLog) && this._optionsService.get(OptionNames.LogUserActivity)) {
            return this.Log("?", "?", new Date(), "Opened Patient: " + patient.ID + ", " + patient.Name, "");
        }
    };
    AuditLogService.prototype.log_showSeries = function (series) {
        if (this._optionsService.get(OptionNames.EnableAuditLog) && this._optionsService.get(OptionNames.LogUserActivity)) {
            var $root = $('<XMLDocument />');
            $root.append($('<extra />').append(($('<uid />').text(series.InstanceUID))));
            return this.Log("?", "?", new Date(), "View Series: " + series.Description, $root.html());
        }
    };
    AuditLogService.$inject = ['app.config', 'authenticationService', '$http', 'optionsService'];
    return AuditLogService;
}());
services.service('auditLogService', AuditLogService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var ExternalApp = /** @class */ (function () {
    function ExternalApp() {
    }
    return ExternalApp;
}());
var ExternalApplicationsService = /** @class */ (function () {
    function ExternalApplicationsService($rootScope, $http) {
        this.httpInject = $http;
        this.rootScopeInject = $rootScope;
    }
    ExternalApplicationsService.prototype.addApp = function (externalApp) {
        if (!externalApp.name || !externalApp.path) {
            throw new Error("'Name' and 'Path' must be provided");
        }
        var xtrnal = this.getAppList();
        xtrnal[externalApp.name] = externalApp;
        this.setAppList(xtrnal);
    };
    ExternalApplicationsService.prototype.setAppList = function (externalApps) {
        var serialized = JSON.stringify(externalApps);
        $.cookie("externalApps", serialized, { expires: 10 * 365 });
    };
    ExternalApplicationsService.prototype.getAppList = function () {
        var cookie = $.cookie("externalApps");
        if (null != cookie) {
            var appList = JSON.parse(cookie);
            return appList;
        }
        else {
            var appList = {};
            return appList;
        }
    };
    ExternalApplicationsService.prototype.runApp = function (app) {
        try {
            var oShell = new ActiveXObject("Shell.Application");
            if (!oShell) {
                throw new Error("This feature is supported in Internet Explorer only");
            }
            if (!app) {
                throw new Error("Invalid parameter passed (app)");
            }
            oShell.ShellExecute(app.path, app.args, "", "open", "1");
        }
        catch (e) {
            var err = e;
            if (e.hasOwnProperty("number")) {
                if (e.number == -2146828218) {
                    err += "\n";
                    err += "\n";
                    err += "In Internet Explorer, do the followings:";
                    err += "\n";
                    err += "1. Enable unsigned ActiveX controls for the current zone";
                    err += "\n";
                    err += "Tools > Internet Options > Security > Custom level...";
                    err += "\n";
                    err += "Enable \"ActiveX Controls and plug-ins\" > \"Initialize and script ActiveX controls not marked as safe for scripting\"";
                    err += "\n";
                    err += "2. Allow Active Content to run files";
                    err += "Tools > Internet Options > Advanced > Security Enable \"Allow Active Content to run in files on My Computer\"";
                }
            }
            alert(err);
        }
    };
    ExternalApplicationsService.prototype.deleteApp = function (appName) {
        try {
            var xtrnal = this.getAppList();
            delete xtrnal[appName];
            this.setAppList(xtrnal);
        }
        catch (e) {
            alert(e);
        }
    };
    ExternalApplicationsService.$inject = ["$rootScope", "$http"];
    return ExternalApplicationsService;
}());
services.service('externalApplicationsService', ExternalApplicationsService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var PrintService = /** @class */ (function () {
    function PrintService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this.printUrl = config.urls.serviceUrl + config.urls.exportServiceName;
    }
    PrintService.prototype.PrintAllSeries = function (patientID, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            patientID: patientID,
            options: options
        };
        return this._http.post(this.printUrl + "/PrintAllSeries", JSON.stringify(data));
    };
    PrintService.prototype.PrintSeries = function (seriesInstanceUIDs, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUIDs: seriesInstanceUIDs,
            options: options,
        };
        return this._http.post(this.printUrl + "/PrintAllSeries", JSON.stringify(data));
    };
    PrintService.prototype.PrintInstances = function (instanceUIDS, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            instanceUIDs: instanceUIDS,
            options: options,
        };
        return this._http.post(this.printUrl + "/PrintInstances", JSON.stringify(data));
    };
    PrintService.prototype.PrintLayout = function (seriesInstanceUID, layout, options) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            seriesInstanceUID: seriesInstanceUID,
            layout: layout,
            options: options
        };
        return this._http.post(this.printUrl + "/PrintLayout", JSON.stringify(data));
    };
    PrintService.$inject = ['app.config', 'authenticationService', '$http'];
    return PrintService;
}());
services.service('printService', PrintService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var QueryPacsService = /** @class */ (function () {
    function QueryPacsService(config, authenticationService, $http, eventService, optionsService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._queryPacsUrl = config.urls.serviceUrl + config.urls.queryPacsServiceName;
        this.ReadRemoteConfigs(optionsService);
    }
    Object.defineProperty(QueryPacsService.prototype, "remoteConnections", {
        get: function () {
            return this._remoteConfig.servers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryPacsService.prototype, "pacsConnections", {
        get: function () {
            var result = new Array();
            for (var index = 0; index < this._remoteConfig.servers.length; index++) {
                if (this._remoteConfig.servers[index].type == 'pacs') {
                    result.push(this._remoteConfig.servers[index]);
                }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryPacsService.prototype, "clientAETitle", {
        get: function () {
            return this._remoteConfig.client;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryPacsService.prototype, "wadoConnections", {
        get: function () {
            var result = new Array();
            for (var index = 0; index < this._remoteConfig.servers.length; index++) {
                if (this._remoteConfig.servers[index].type == 'wado') {
                    result.push(this._remoteConfig.servers[index]);
                }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryPacsService.prototype, "server", {
        get: function () {
            return this._server;
        },
        enumerable: false,
        configurable: true
    });
    QueryPacsService.prototype.ReadRemoteConfigs = function (optionsService) {
        this._remoteConfig = Models.RemoteConfig.Factory(optionsService.get(OptionNames.RemoteConfig));
    };
    QueryPacsService.prototype.FindPatients = function (server, clientAETitle, queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: { AETitle: clientAETitle },
            options: queryParams
        };
        return this._http.post(this._queryPacsUrl + "/FindPatients", JSON.stringify(data));
    };
    QueryPacsService.prototype.FindStudies = function (server, clientAETitle, queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: { AETitle: clientAETitle },
            options: queryParams
        };
        this._server = server;
        return this._http.post(this._queryPacsUrl + "/FindStudies", JSON.stringify(data));
    };
    QueryPacsService.prototype.FindSeries = function (server, clientAETitle, queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: { AETitle: clientAETitle },
            options: queryParams
        };
        this._server = server;
        return this._http.post(this._queryPacsUrl + "/FindSeries", JSON.stringify(data));
    };
    QueryPacsService.prototype.FindPresentationState = function (referencedSeries) {
        var parameter = "auth=" + encodeURIComponent(this._authenticationService.authenticationCode) + "&series=" + referencedSeries;
        return this._http.get(this._queryPacsUrl + "/FindPresentationState?" + parameter);
    };
    QueryPacsService.prototype.FindInstances = function (queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams
        };
        return this._http.post(this._queryPacsUrl + "/FindInstances", JSON.stringify(data));
    };
    QueryPacsService.prototype.FindInstancesForCT = function (queryParams) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams
        };
        return this._http.post(this._queryPacsUrl + "/FindInstancesForCT", JSON.stringify(data));
    };
    QueryPacsService.prototype.ElectStudyTimeLineInstances = function (queryParams, userData) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            options: queryParams,
            userData: userData || null
        };
        return this._http.post(this._queryPacsUrl + "/ElectStudyTimeLineInstances", JSON.stringify(data));
    };
    QueryPacsService.prototype.VerifyConnection = function (server, clientAETitle) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: { AETitle: clientAETitle },
            options: null
        };
        return this._http.post(this._queryPacsUrl + "/VerifyConnection", JSON.stringify(data));
    };
    QueryPacsService.prototype.GetConnectionInfo = function () {
        return this._http.get(this._queryPacsUrl + "/GetConnectionInfo");
    };
    QueryPacsService.$inject = ['app.config', 'authenticationService', '$http', 'eventService', 'optionsService'];
    return QueryPacsService;
}());
services.service('queryPacsService', QueryPacsService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var JobDownloadInfo = /** @class */ (function () {
    function JobDownloadInfo() {
        this.Server = null;
        this.Client = null;
        this.Series = null;
        this.SeriesInformation = null;
    }
    return JobDownloadInfo;
}());
var SeriesDownloadQueueService = /** @class */ (function () {
    function SeriesDownloadQueueService(config, eventService, pacsRetrieveService, $timeout) {
        this._loadingJobs = false;
        var __this = this;
        this._eventService = eventService;
        this._pendingDownloads = new Array();
        this._pacsRetrieveService = pacsRetrieveService;
        this._timeout = $timeout;
        this._userJobs = null;
        this._unfinishedJobs = new Array();
        this._jobsUpdater = new JobStatusUpdater(pacsRetrieveService, eventService);
        eventService.subscribe(EventNames.JobUpdated, function (event, data) {
            if (data.args.job.Status != DownloadStatus.Idle && data.args.job.Status != DownloadStatus.Started) {
                __this._unfinishedJobs.splice(data.args.index, 1);
            }
        });
    }
    SeriesDownloadQueueService.prototype.loadUserQueue = function () {
        var __this = this;
        if (this._loadingJobs) {
            return;
        }
        this._loadingJobs = true;
        return this._pacsRetrieveService.loadQueue().success(function (result) {
            __this._userJobs = result;
            __this._loadingJobs = false;
            __this.fillUncompletedJobs();
            __this.processDownloadQueue();
        }).error(function () {
            __this._loadingJobs = false;
            __this.processDownloadQueue();
        });
    };
    SeriesDownloadQueueService.prototype.downloadSeries = function (server, client, series, seriesInformation) {
        if (this._loadingJobs) {
            var downloadInfo = new JobDownloadInfo();
            downloadInfo.Server = server;
            downloadInfo.Client = client;
            downloadInfo.Series = series;
            downloadInfo.SeriesInformation = seriesInformation;
            this._pendingDownloads.push(downloadInfo);
        }
        else {
            var extraData = null;
            var __this = this;
            if (seriesInformation != null) {
                var userData = JSON.stringify(seriesInformation);
                extraData = {};
                extraData.UserData = userData;
            }
            this._pacsRetrieveService.DownloadImages(server, client, series.PatientID, series.StudyInstanceUID, series.InstanceUID, null, extraData)
                .success(function (jobInfo) {
                if (__this._userJobs == null) {
                    __this.loadJobs([jobInfo]);
                }
                else {
                    __this.updateJobSeriesInfo(jobInfo);
                    __this._userJobs.push(jobInfo);
                    if (jobInfo.Status == DownloadStatus.Idle || jobInfo.Status == DownloadStatus.Started) {
                        __this.markUnfinishedJob(jobInfo);
                    }
                }
                __this._eventService.publish(EventNames.JobCreated, { job: jobInfo });
            })
                .error(function (error) {
            });
        }
    };
    SeriesDownloadQueueService.prototype.deleteJobs = function (jobIds) {
        return this._pacsRetrieveService.DeleteDownloadInfos(jobIds);
    };
    SeriesDownloadQueueService.prototype.autoRefresh = function (refresh) {
        if (refresh) {
            if (this._refreshTimer == null) {
                this.onRefreshQueue();
            }
        }
        else {
            if (this._refreshTimer != null) {
                this._timeout.cancel(this._refreshTimer);
            }
        }
    };
    SeriesDownloadQueueService.prototype.onRefreshQueue = function () {
        if (this._refreshTimer != null) {
            this._timeout.cancel(this._refreshTimer);
            this._refreshTimer = null;
        }
        this.refreshQueueStatus();
        this._refreshTimer = this._timeout($.proxy(this.onRefreshQueue, this), 1000);
    };
    SeriesDownloadQueueService.prototype.refreshQueueStatus = function () {
        if (this._jobsUpdater.isBusy || this._userJobs == null || this._unfinishedJobs.length == 0) {
            return;
        }
        this._jobsUpdater.updateJobs(this._unfinishedJobs.slice(0));
    };
    SeriesDownloadQueueService.prototype.loadJobs = function (userJobs) {
        this._loadingJobs = false;
        this._userJobs = userJobs;
    };
    SeriesDownloadQueueService.prototype.fillUncompletedJobs = function () {
        for (var jobIndex = 0; jobIndex < this._userJobs.length; jobIndex++) {
            var job = this._userJobs[jobIndex];
            this.updateJobSeriesInfo(job);
            if (job.Status === DownloadStatus.Idle ||
                job.Status === DownloadStatus.Started) {
                this.markUnfinishedJob(job);
            }
        }
    };
    SeriesDownloadQueueService.prototype.processDownloadQueue = function () {
        if (this._pendingDownloads.length > 0) {
            var length = this._pendingDownloads.length;
            while (length--) {
                var downloadInfo = this._pendingDownloads.pop();
                this.downloadSeries(downloadInfo.Server, downloadInfo.Client, downloadInfo.Series, downloadInfo.SeriesInformation);
            }
        }
    };
    SeriesDownloadQueueService.prototype.updateJobSeriesInfo = function (jobInfo) {
        if (jobInfo.UserData) {
            try {
                jobInfo.SeriesInfo = JSON.parse(jobInfo.UserData);
            }
            catch (e) { }
        }
    };
    SeriesDownloadQueueService.prototype.markUnfinishedJob = function (job) {
        this._unfinishedJobs.push(job);
    };
    SeriesDownloadQueueService.$inject = ['app.config', 'eventService', 'pacsRetrieveService', '$timeout'];
    return SeriesDownloadQueueService;
}());
services.service('seriesDownloadQueueService', SeriesDownloadQueueService);
var JobStatusUpdater = /** @class */ (function () {
    function JobStatusUpdater(pacsRetrieveService, eventService) {
        this._pacsRetrieveService = pacsRetrieveService;
        this._eventService = eventService;
        this._isBusy = false;
    }
    Object.defineProperty(JobStatusUpdater.prototype, "isBusy", {
        get: function () {
            return this._isBusy;
        },
        enumerable: false,
        configurable: true
    });
    JobStatusUpdater.prototype.updateJobs = function (jobs) {
        this._jobs = jobs;
        this._isBusy = true;
        this.updateNextJob();
    };
    JobStatusUpdater.prototype.updateNextJob = function () {
        var job;
        var __this = this;
        if (this._jobs.length === 0) {
            this._isBusy = false;
            return;
        }
        job = this._jobs.pop();
        this._pacsRetrieveService.UpdateDownloadInfoStatus(job).success(function (jobInfo) {
            __this._eventService.publish(EventNames.JobUpdated, { job: jobInfo, index: __this._jobs.length });
            __this.updateNextJob();
        }).
            error(function (error) {
        });
    };
    return JobStatusUpdater;
}());
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="AuthenticationService.ts" />
var DownloadStatus;
(function (DownloadStatus) {
    DownloadStatus.Idle = 0;
    DownloadStatus.Started = 1;
    DownloadStatus.Completed = 2;
    DownloadStatus.Error = 3;
    DownloadStatus.Aborted = 4;
    DownloadStatus.All = 5;
})(DownloadStatus || (DownloadStatus = {}));
var PacsRetrieveService = /** @class */ (function () {
    function PacsRetrieveService(config, authenticationService, $http, eventService) {
        this._http = $http;
        this._authenticationService = authenticationService;
        this._retrievePacsUrl = config.urls.serviceUrl + config.urls.pacsRetrieveServiceName;
    }
    PacsRetrieveService.prototype.loadQueue = function () {
        return this.GetDownloadInfos(null, null, null, null, null, null, DownloadStatus.All, null);
    };
    PacsRetrieveService.prototype.GetDownloadInfos = function (server, client, patientID, studyInstanceUID, seriesInstanceUID, sopInstanceUID, status, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: client,
            patientID: patientID,
            studyInstanceUID: studyInstanceUID,
            seriesInstanceUID: seriesInstanceUID,
            sopInstanceUID: sopInstanceUID,
            status: status,
            extraOptions: extraOptions
        };
        return this._http.post(this._retrievePacsUrl + "/GetDownloadInfos", JSON.stringify(data));
    };
    PacsRetrieveService.prototype.DownloadImages = function (server, client, patientID, studyInstanceUID, seriesInstanceUID, sopInstanceUID, extraOptions) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            server: server,
            client: client,
            studyInstanceUID: studyInstanceUID,
            seriesInstanceUID: seriesInstanceUID,
            sopInstanceUID: sopInstanceUID,
            extraOptions: extraOptions
        };
        return this._http.post(this._retrievePacsUrl + "/DownloadImages", JSON.stringify(data));
    };
    PacsRetrieveService.prototype.DeleteDownloadInfos = function (jobIds) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            jobIds: jobIds,
            extraOptions: null
        };
        return this._http.post(this._retrievePacsUrl + "/DeleteDownloadInfos", JSON.stringify(data));
    };
    PacsRetrieveService.prototype.UpdateDownloadInfoStatus = function (job) {
        var data = {
            authenticationCookie: this._authenticationService.authenticationCode,
            info: job,
            extraOptions: null
        };
        return this._http.post(this._retrievePacsUrl + "/UpdateDownloadInfoStatus", JSON.stringify(data));
    };
    PacsRetrieveService.$inject = ['app.config', 'authenticationService', '$http'];
    return PacsRetrieveService;
}());
services.service('pacsRetrieveService', PacsRetrieveService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AddToolbarItemController = /** @class */ (function () {
        function AddToolbarItemController($scope, $modalInstance, item) {
            $scope.item = item || new Models.ToolbarItem();
            $scope.isFormValid = function () {
                return $scope.item.id != undefined && $scope.item.id.length != 0 &&
                    $scope.item.action != undefined && $scope.item.action.length != 0;
            };
            $scope.ok = function () {
                $scope.item.type = "button";
                $modalInstance.close($scope.item);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
        }
        AddToolbarItemController.$inject = ['$scope', '$modalInstance', 'item'];
        return AddToolbarItemController;
    }());
    Controllers.AddToolbarItemController = AddToolbarItemController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AdminToolbarSettingsController = /** @class */ (function () {
        function AdminToolbarSettingsController($scope, $modalInstance, toolbarService, $modal, authenticationService, optionsService, dialogs, $translate) {
            this._roleToolbars = {};
            this._previousRole = '';
            var __this = this;
            this._previousRole = '';
            this._roleToolbars = {};
            this._optionsService = optionsService;
            this._toolbarService = toolbarService;
            this._hasSaved = false;
            $scope.toolbars = new Array();
            $scope.config = {
                extensions: ['table'],
                selectMode: 3,
                autoActivate: false,
                autoSetHeight: false,
                keyboard: true,
                autoScroll: true,
                table: { indentation: 20, nodeColumnIdx: 1, checkboxColumnIdx: 0 },
                checkbox: true,
                icons: false,
                renderColumns: function (event, data) {
                    var tbItem = data.node.data;
                    var $tdList = $(data.node.tr).find(">td");
                    var itemSize = (lt.LTHelper.device == lt.LTDevice.desktop) ? 50 : 25;
                    if (tbItem.cssIconClass && !data.node.hasChildren()) {
                        var html = "<div class='" + tbItem.cssIconClass + "' style='width: " + itemSize + "px; height: " + itemSize + "px;vertical-align:middle;margin-left;auto;margin-right:auto'></div>";
                        $tdList.eq(2).html(html);
                    }
                }
            };
            $scope.toolbars = toolbarService.getToolbars();
            $scope.selectedToolbar = $scope.toolbars[0];
            $scope.buttons = $scope.toolbars[0].items;
            $scope.activeNode = null;
            $scope.treeApi = {};
            $scope.disabledItems = toolbarService.getDisabledItems($scope.selectedToolbar.name);
            $scope.roles = new Array();
            $scope.role = {};
            $scope.close = function () {
                $modalInstance.close(__this._hasSaved);
            };
            $scope.itemDeactivated = function (event, data) {
                $scope.activeNode = null;
            };
            $scope.itemActivated = function (event, data) {
                $scope.activeNode = data.node;
            };
            $scope.deleteToolbarItem = function () {
                $scope.activeNode.remove();
            };
            $scope.save = function () {
                var disabledItems = new Array();
                var toolbar = new Array();
                var disabledName = "DisabledToolbarItems_" + $scope.selectedToolbar.name;
                var toolbarName = "Toolbar_" + $scope.selectedToolbar.name;
                var data = {};
                __this.getToolbarInfo($scope, disabledItems, toolbar);
                data[disabledName] = JSON.stringify(disabledItems);
                data[toolbarName] = JSON.stringify({ name: $scope.selectedToolbar.name, items: toolbar });
                if ($scope.role.name == null) {
                    optionsService.saveDefaultOptions(data).success(function () {
                        __this._hasSaved = true;
                        dialogs.notify(__this._notificationTitle, __this._optionsSuccessMsg);
                    }).error(function (e, status) {
                        dialogs.error(__this._optionsFailureMsg + ": " + status);
                    });
                }
                else {
                    optionsService.saveRoleOptions($scope.role.name, data).success(function () {
                        __this._hasSaved = true;
                        dialogs.notify(__this._notificationTitle, __this._optionsSuccessMsg);
                    }).error(function (e, status) {
                        dialogs.error(__this._optionsFailureMsg + ": " + status);
                    });
                }
            };
            $scope.roleChanged = function () {
                var role = __this._previousRole == null || __this._previousRole == "" ? "default" : __this._previousRole;
                var disabledItems = new Array();
                var toolbar = new Array();
                if (!__this._roleToolbars[$scope.selectedToolbar.name]) {
                    __this._roleToolbars[$scope.selectedToolbar.name] = {};
                }
                if (!__this._roleToolbars[$scope.selectedToolbar.name][role]) {
                    __this._roleToolbars[$scope.selectedToolbar.name][role] = {};
                }
                __this.getToolbarInfo($scope, disabledItems, toolbar);
                __this._roleToolbars[$scope.selectedToolbar.name][role].disabledItems = disabledItems;
                __this._roleToolbars[$scope.selectedToolbar.name][role].items = toolbar;
                $scope.treeApi.clear();
                __this.loadRoleToolbar($scope, $scope.role.name);
                __this._previousRole = $scope.role.name;
            };
            $scope.addToolbarItem = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddToolbarItem.html',
                    controller: Controllers.AddToolbarItemController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            return undefined;
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var node = null;
                    node = $scope.treeApi.addNode($scope.activeNode, item);
                    if (node != null) {
                        $scope.treeApi.activateNode(node);
                    }
                });
            };
            $scope.addRootToolbarItem = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddToolbarItem.html',
                    controller: Controllers.AddToolbarItemController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            return undefined;
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var node = null;
                    node = $scope.treeApi.addNode(null, item);
                    if (node != null) {
                        $scope.treeApi.activateNode(node);
                    }
                });
            };
            $scope.editToolbarItem = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddToolbarItem.html',
                    controller: Controllers.AddToolbarItemController,
                    backdrop: 'static',
                    resolve: {
                        item: function () {
                            return $scope.activeNode.data;
                        }
                    }
                });
                modalInstance.result.then(function (item) {
                    var node = $scope.activeNode;
                    node.setTitle(item.id);
                    node.tooltip = item.tooltip;
                });
            };
            authenticationService.getRolesNames().success(function (roles) {
                $scope.roles = roles;
                $scope.role.name = roles[0];
            }).error(function (error) {
            });
            $translate('DIALOGS_TOOLBAR_SAVED').then(function (translation) {
                __this._optionsSuccessMsg = translation;
            });
            $translate('DIALOGS_TOOLBAR_SAVED_FAILURE').then(function (translation) {
                __this._optionsFailureMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
        }
        AdminToolbarSettingsController.prototype.getToolbarInfo = function (scope, disabledItems, toolbar) {
            scope.treeApi.visit(function (node) {
                if (!node.selected && node.hasChildren()) {
                    var disable = true;
                    node.visit(function (node) {
                        if (node.selected) {
                            disable = false;
                            return false;
                        }
                        return true;
                    });
                    if (disable) {
                        disabledItems.push(node.data.id);
                    }
                }
                else if (!node.selected) {
                    disabledItems.push(node.data.id);
                }
                if (node.parent == undefined || node.parent.title == 'root') {
                    toolbar.push(node.data);
                    if (node.data.items) {
                        node.data.items.clear();
                    }
                }
                else {
                    var result = $.grep(toolbar, function (item) { return item.id == node.parent.data.id; });
                    if (result.length == 1) {
                        result[0].items.push(node.data);
                        if (node.data.items) {
                            node.data.items.clear();
                        }
                    }
                }
            });
        };
        AdminToolbarSettingsController.prototype.loadRoleToolbar = function (scope, role) {
            var __this = this;
            role = role == null || role == "" ? "default" : role;
            /*if (this._roleToolbars[scope.selectedToolbar.name] && this._roleToolbars[scope.selectedToolbar.name][role]) {
                var items: Array<Models.ToolbarItem> = this._roleToolbars[scope.selectedToolbar.name][role].items;
                var disabledItems: Array<string> = this._roleToolbars[scope.selectedToolbar.name][role].disabledItems;

                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        scope.treeApi.addData(null, items[i]);
                    };
                }
                scope.treeApi.setDisabledItems(disabledItems);
            }
            else */ {
                if (role == "default") {
                    var items = __this._toolbarService.getToolbars()[0].items;
                    var disabledItems = __this._toolbarService.getDisabledItems(scope.selectedToolbar.name);
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            scope.treeApi.addData(null, items[i]);
                        }
                        ;
                    }
                    scope.treeApi.setDisabledItems(disabledItems);
                }
                else {
                    var toolbarName = scope.selectedToolbar.name;
                    this._optionsService.getRoleOption(role, OptionNames.Toolbar + "_" + toolbarName).success(function (data) {
                        __this._optionsService.getRoleOption(role, OptionNames.DisabledToolbarItems + "_" + toolbarName).success(function (disabledItems) {
                            var items = null;
                            if (data && data.length > 0) {
                                data = data.replace(/(\r\n|\n|\r|\t|\\)/gm, "");
                                items = JSON.parse(data).items;
                            }
                            else {
                                items = __this._toolbarService.getToolbars()[0].items;
                            }
                            if (items) {
                                for (var i = 0; i < items.length; i++) {
                                    scope.treeApi.addData(null, items[i]);
                                }
                                ;
                            }
                            scope.treeApi.setDisabledItems(disabledItems);
                        }).error(function (error) {
                        });
                    }).error(function (error) {
                    });
                }
            }
        };
        AdminToolbarSettingsController.$inject = ['$scope', '$modalInstance', 'toolbarService', '$modal', 'authenticationService', 'optionsService', 'dialogs', '$translate'];
        return AdminToolbarSettingsController;
    }());
    Controllers.AdminToolbarSettingsController = AdminToolbarSettingsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var AddTagController = /** @class */ (function () {
        function AddTagController($scope, $modalInstance, tag) {
            $scope.types = [
                { name: 'Window Level', id: 0 },
                { name: 'Instance Number', id: 1 },
                { name: 'User Data', id: 2 },
                { name: 'Image Quality', id: 3 },
                { name: 'Frame Number', id: 4 },
                { name: 'Left Orientation', id: 5 },
                { name: 'Right Orientation', id: 6 },
                { name: 'Top Orientation', id: 7 },
                { name: 'Bottom Orientation', id: 8 }
            ];
            $scope.overlay = {};
            if (tag == null) {
                $scope.tag = new Controllers.OverlayTag();
                $scope.overlay.item = $scope.types[0];
            }
            else {
                var types;
                if (tag.overlayType == undefined)
                    tag.overlayType = 2;
                types = $.grep($scope.types, function (type, index) { return type.id == tag.overlayType; });
                $scope.tag = tag;
                $scope.overlay.item = types[0];
            }
            $scope.ok = function () {
                if (tag != null) {
                    $scope.tag.overlayType = $scope.overlay.item.id;
                    $scope.tag.id = UUID.generate();
                }
                else
                    $scope.tag.overlayType = $scope.overlay.item.id;
                $modalInstance.close($scope.tag);
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.isUserData = function (type) {
                return type == lt.Controls.Medical.OverlayTextType.userData;
            };
        }
        AddTagController.$inject = ['$scope', '$modalInstance', 'tag'];
        return AddTagController;
    }());
    Controllers.AddTagController = AddTagController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var GetWorkstationController = /** @class */ (function () {
        function GetWorkstationController($scope, $modalInstance, optionsService) {
            $scope.info = { workstation: '', comments: '' };
            $scope.isWorkstationEmpty = function () {
                return $scope.info.workstation.length == 0;
            };
            $scope.cancel = function () {
                $modalInstance.dismiss('cancel');
            };
            $scope.ok = function () {
                $modalInstance.close({ workstation: $scope.info.workstation, comments: $scope.info.comments });
            };
        }
        GetWorkstationController.$inject = ['$scope', '$modalInstance', 'optionsService'];
        return GetWorkstationController;
    }());
    Controllers.GetWorkstationController = GetWorkstationController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var GlobalOptionsController = /** @class */ (function () {
        function GlobalOptionsController($q, $scope, $modalInstance, dialogs, $translate, optionsService) {
            this._changes = {};
            this._saved = false;
            var __this = this;
            $scope.items = new Array();
            addProperty("Behavior", "num", "", "", "", optionsService.get(OptionNames.DefaultSeriesRowCount), "DefaultSeriesRowCount");
            addProperty("Behavior", "num", "", "", "", optionsService.get(OptionNames.DefaultSeriesColumnCount), "DefaultSeriesColumnCount");
            addProperty("Behavior", "cdrop", "", "Series View|Study View", "", optionsService.get(OptionNames.ViewerMode), "ViewerMode");
            addProperty("Behavior", "cdrop", "", "true|false", "", optionsService.get(OptionNames.SinglePatientMode), "SinglePatientMode");
            addProperty("Behavior", "cdrop", "", "true|false", "", optionsService.get(OptionNames.SingleSeriesMode), "SingleSeriesMode");
            addProperty("Behavior", "cdrop", "", "true|false", "", optionsService.get(OptionNames.ShowFrameBorder), "ShowFrameBorder");
            addProperty("Behavior", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnablePatientRestriction), "EnablePatientRestriction");
            addProperty("Thumbnails", "cdrop", "", "true|false", "", optionsService.get(OptionNames.ShowSearchThumbnails), "ShowSearchThumbnails");
            addProperty("Thumbnails", "num", "", "", "", optionsService.get(OptionNames.SeriesThumbnailWidth), "SeriesThumbnailWidth");
            addProperty("Thumbnails", "num", "", "", "", optionsService.get(OptionNames.SeriesThumbnailHeight), "SeriesThumbnailHeight");
            addProperty("Color", "color", "", "", "", optionsService.get(OptionNames.EmptyCellBackgroundColor), "EmptyCellBackgroundColor");
            addProperty("Color", "color", "", "", "", optionsService.get(OptionNames.SelectedBorderColor), "SelectedBorderColor");
            addProperty("Color", "color", "", "", "", optionsService.get(OptionNames.BackgroundColor), "BackgroundColor");
            addProperty("Autocomplete", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnablePatientIdAutoComplete), "EnablePatientIdAutoComplete");
            addProperty("Autocomplete", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnablePatientNameAutoComplete), "EnablePatientNameAutoComplete");
            addProperty("Derived Series", "input", "", "", "", optionsService.get(OptionNames.Derived3DSeriesDescriptionText), "Derived 3dSeriesDescriptionText");
            addProperty("Derived Series", "input", "", "", "", optionsService.get(OptionNames.DerivedSeriesDescriptionText), "DerivedSeriesDescriptionText");
            addProperty("Derived Series", "input", "", "", "", optionsService.get(OptionNames.DerivedPanoramicSeriesDescriptionText), "DerivedPanoramicSeriesDescriptionText");
            addProperty("Derived Series", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableSeriesNumberEdit), "EnableSeriesNumberEdit");
            addProperty("Derived Series", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableProtocolNameEdit), "EnableProtocolNameEdit");
            addProperty("Audit Log", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableAuditLog), "EnableAuditLog");
            addProperty("Audit Log", "cdrop", "", "true|false", "", optionsService.get(OptionNames.LogUserActivity), "LogUserActivity");
            addProperty("Audit Log", "cdrop", "", "true|false", "", optionsService.get(OptionNames.LogUserSecurity), "LogUserSecurity");
            addProperty("Audit Log", "cdrop", "", "true|false", "", optionsService.get(OptionNames.LogSettingChanges), "LogSettingChanges");
            addProperty("Audit Log", "cdrop", "", "true|false", "", optionsService.get(OptionNames.LogSecuritySettingChanges), "LogSecuritySettingChanges");
            addProperty("Annotations", "color", "", "", "", optionsService.get(OptionNames.AnnotationStrokeColor), "AnnotationStrokeColor");
            addProperty("Annotations", "color", "", "", "", optionsService.get(OptionNames.AnnotationTextColor), "AnnotationTextColor");
            addProperty("Annotations", "color", "", "", "", optionsService.get(OptionNames.AnnotationHiliteColor), "AnnotationHiliteColor");
            addProperty("Annotations", "cdrop", "", "true|false", "", optionsService.get(OptionNames.CalibrateUsingDpi), "CalibrateUsingDpi");
            addProperty("Timeout", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableIdleTimeout), "EnableIdleTimeout");
            addProperty("Timeout", "num", "", "", "", optionsService.get(OptionNames.IdleTimeout), "IdleTimeout");
            addProperty("Timeout", "num", "", "", "", optionsService.get(OptionNames.IdleWarningDuration), "IdleWarningDuration");
            addProperty("Query Results", "num", "", "", "", optionsService.get(OptionNames.MaxStudyResults), "MaxStudyResults");
            addProperty("Query Results", "num", "", "", "", optionsService.get(OptionNames.MaxSeriesResults), "MaxSeriesResults");
            addProperty("Query Results", "cdrop", "", "true|false", "", optionsService.get(OptionNames.SearchOtherPatientIds), "SearchOtherPatientIds");
            addProperty("Query Results", "cdrop", "", "true|false", "", optionsService.get(OptionNames.SearchStructuredDisplay), "SearchStructuredDisplay");
            addProperty("Template Editor", "color", "", "", "", optionsService.get(OptionNames.TemplateBackgroundColor), "TemplateBackgroundColor");
            addProperty("Template Editor", "color", "", "", "", optionsService.get(OptionNames.TemplateForeColor), "TemplateForeColor");
            addProperty("Template Editor", "color", "", "", "", optionsService.get(OptionNames.TemplateBorderColor), "TemplateBorderColor");
            addProperty("Template Editor", "num", "", "", "", optionsService.get(OptionNames.TemplateBorderSize), "TemplateBorderSize");
            addProperty("Template Editor", "cdrop", "", "true|false", "", optionsService.get(OptionNames.TemplateBoundsNotification), "TemplateBoundsNotification");
            addProperty("Template Editor", "input", "", "", "", optionsService.get(OptionNames.DefaultScript), "DefaultScript");
            // Remove this option for now because it conflicts with loading a structured display
            // if (!optionsService.isSeriesView()) {
            //     addProperty("Hanging Protocol", "cdrop", "", "true|false", "", optionsService.get(OptionNames.AutoLoadHangingProtocol), "AutoLoadHangingProtocol");
            // }
            //Remove this option for now
            addProperty("Lazy Loading", "num", "", "", "", optionsService.get(OptionNames.LazyLoadingThreshold), "LazyLoadingThreshold");
            addProperty("Lazy Loading", "num", "", "", "", optionsService.get(OptionNames.LazyLoadingMobileThreshold), "LazyLoadingMobileThreshold");
            addProperty("Lazy Loading", "num", "", "", "", optionsService.get(OptionNames.LazyLoadingBuffer), "LazyLoadingBuffer");
            if (VersionNumber.viewerType != "Medicore")
                addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.ShowPacsQuery), "ShowPacsQuery");
            addProperty("Miscellaneous", "input", "", "", "", optionsService.get(OptionNames.DateFormat), "DateFormat");
            addProperty("Miscellaneous", "input", "", "", "", optionsService.get(OptionNames.TimeFormat), "TimeFormat");
            addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.HideOverlays), "HideOverlays");
            addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.HideCustomLayouts), "HideCustomLayouts");
            addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.ShowStudyTimeLine), "ShowStudyTimeLine");
            addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.LinkImages), "LinkImages");
            //addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.SplitSeries), "SplitSeries");
            addProperty("Miscellaneous", "cdrop", "", "true|false", "", optionsService.get(OptionNames.StackSingleFrames), "StackSingleFrames");
            addProperty("Miscellaneous", "num", "", "", "", optionsService.get(OptionNames.BackgroundSize), "BackgroundSize");
            addProperty("Miscellaneous", "num", "", "", "", optionsService.get(OptionNames.SDBackgroundSize), "SDBackgroundSize");
            addProperty("Miscellaneous", "textarea", "", "", "", optionsService.get(OptionNames.TwoFactorsAuthenticationMessage), "TwoFactorsAuthenticationMessage");
            addProperty("Miscellaneous", "input", "", "", "", optionsService.get(OptionNames.SearchPageSize), "SearchPageSize");
            addProperty("Print To PDF", "num", "", "", "", optionsService.get(OptionNames.PrintSize), "PrintSize");
            addProperty("Print To PDF", "cdrop", "", "true|false", "", optionsService.get(OptionNames.PrintLayout), "PrintLayout");
            addProperty("Print To PDF", "input_suggestions", "", "", "", optionsService.get(OptionNames.PrintName), "PrintName");
            addProperty("Print To PDF", "color", "", "", "", optionsService.get(OptionNames.TextBackgroundColor), "TextBackground");
            addProperty("Print To PDF", "color", "", "", "", optionsService.get(OptionNames.TextColor), "TextColor");
            addProperty("Print To PDF", "color", "", "", "", optionsService.get(OptionNames.PdfBackgroundColor), "PdfBackgroundColor");
            addProperty("3D", "cdrop", "", "Server Side|Client Side", "", optionsService.get(OptionNames.MPRRenderSide), "MprRenderSide");
            addProperty("3D", "cdrop", "", "Hardware Software|Software Only", "", optionsService.get(OptionNames.RenderingMethod), "RenderingMethod");
            addProperty("Sign-in", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableOkta), OptionNames.EnableOkta);
            //#Shibboleth: always disable shibboleth, uncomment this line to enable functionality
            //addProperty("Sign-in", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableShibboleth), OptionNames.EnableShibboleth);
            addProperty("Caching", "cdrop", "", "true|false", "", optionsService.get(OptionNames.EnableCaching), OptionNames.EnableCaching);
            $scope.onPropertyChanged = function (name, value) {
                __this._changes[name] = value;
            };
            $scope.keyDown = function ($event) {
                $event.originalEvent.stopPropagation();
            };
            $scope.hasChanges = function () {
                for (var p in __this._changes) {
                    return true;
                }
                return false;
            };
            $scope.close = function () {
                if ($scope.hasChanges()) {
                    if (window.confirm('Save before exit?')) {
                        $scope.save().then(function () {
                            $modalInstance.close(__this._saved);
                        });
                        return;
                    }
                }
                $modalInstance.close(__this._saved);
            };
            $scope.save = function () {
                var defer = $q.defer();
                optionsService.saveDefaultOptions(__this._changes).success(function () {
                    for (var p in __this._changes) {
                        optionsService.set(p, __this._changes[p]);
                    }
                    __this._changes = {};
                    showSavedNotification();
                    //dialogs.notify(__this._notificationTitle, __this._optionsSuccessMsg);
                    __this._saved = true;
                    defer.resolve();
                }).
                    error(function (error, status) {
                });
                return defer.promise;
            };
            $translate('DIALOGS_OPTIONS_SAVED').then(function (translation) {
                __this._optionsSuccessMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
            function showSavedNotification() {
                var button = document.getElementById("optionsSaveButton");
                if (button.children.length != 0)
                    button.removeChild(button.children[0]);
                button.innerHTML = "<label class='optionsSaved' style='outline: none; padding-left:50px'>Saved</label>";
            }
            function addProperty(groupName, rowType, cssName, drpFields, isSubGroup, value, propertyName) {
                var item = new PropertyGridItem();
                item.groupName = groupName;
                item.rowType = rowType;
                item.cssName = cssName;
                item.dropFields = drpFields;
                item.isSubGroup = isSubGroup;
                item.value = value;
                item.propertyName = propertyName;
                $scope.items.push(item);
            }
        }
        GlobalOptionsController.$inject = ['$q', '$scope', '$modalInstance', 'dialogs', '$translate', 'optionsService'];
        return GlobalOptionsController;
    }());
    Controllers.GlobalOptionsController = GlobalOptionsController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Controllers;
(function (Controllers) {
    var LoginController = /** @class */ (function () {
        function LoginController($scope, config, authenticationService, $location, eventService, optionsService, linkToken, linkProtocol, sharedProperties, deferredQ) {
            var __this = this;
            this._scope = $scope;
            $scope.Copyright = config.copyright;
            $scope.authenticationMessage = "";
            $scope.Invalid = false;
            $scope.RememberMe = false;
            $scope.Username = config.defaultUserName;
            $scope.Password = config.defaultPassword;
            $scope.codeInvalid = "";
            $scope.urlInvalid = "";
            this.auth = authenticationService;
            $scope.GetKey = function () {
                var index = 0;
                var length = 6;
                var key = "";
                if (__this._scope.supportsTouch)
                    return document.getElementById('sixSymbolText').value;
                for (index = 1; index <= length; index++) {
                    key += document.getElementById('key' + index).innerText;
                }
                return key;
            };
            $scope.sixDigitSubmit = function () {
                /*authenticationService.verifyURLCode(url, $scope.GetKey()).then(function (data)*/ {
                    /*if (data.data.verified)*/ {
                        __this.loginLoad(true, "tempAuthenticaionLoading", "tempAuthenticaionSubmitButton", "SUBMIT");
                        var myAuthenticationInfoResult;
                        authenticationService.tempAuthenticate(linkToken, linkProtocol, $scope.GetKey()).success(function (authenticationInfoResult) {
                            myAuthenticationInfoResult = authenticationInfoResult;
                            sharedProperties.SetToken(authenticationInfoResult.Cookie);
                            sharedProperties.SetPolling(true);
                            document.getElementById('verionNumberFooter').innerHTML = "";
                            authenticationService.autologin(myAuthenticationInfoResult.UserName, authenticationInfoResult.Cookie);
                        }).error(function (error) {
                            __this._scope.urlInvalid = error.Message;
                            __this._scope.codeInvalid = "Invalid code... Please try again.";
                            __this.loginLoad(false, "tempAuthenticaionLoading", "tempAuthenticaionSubmitButton", "SUBMIT");
                            var message = "";
                            if (error) {
                                if (error.Message)
                                    message = error.Message;
                                else
                                    message = error;
                            }
                            LogUtils.DebugLog("tempAuthenticate error: " + error.Message);
                        });
                    }
                }
                //});
            };
            $scope.externalSubmit = function () {
                __this.loginLoad(true, "tempAuthenticaionLoading", "tempAuthenticaionSubmitButton", "SUBMIT");
                var myAuthenticationInfoResult;
                authenticationService.externalAuthenticate(linkToken, linkProtocol).success(function (authenticationInfoResult) {
                    myAuthenticationInfoResult = authenticationInfoResult;
                    sharedProperties.SetToken(authenticationInfoResult.Cookie);
                    sharedProperties.SetPolling(true);
                    document.getElementById('verionNumberFooter').innerHTML = "";
                    authenticationService.autologin(myAuthenticationInfoResult.UserName, authenticationInfoResult.Cookie);
                }).error(function (error) {
                    __this._scope.urlInvalid = error.Message;
                    __this._scope.codeInvalid = "Invalid code... Please try again.";
                    __this.loginLoad(false, "tempAuthenticaionLoading", "tempAuthenticaionSubmitButton", "SUBMIT");
                    var message = "";
                    if (error) {
                        if (error.Message)
                            message = error.Message;
                        else
                            message = error;
                    }
                    LogUtils.DebugLog("tempAuthenticate error: " + error.Message);
                });
            };
            $scope.enableTwoFactorsAuthentication = false; //optionsService.get(OptionNames.EnableTwoFactorsAuthentication);
            $scope.verifyURLScreen = authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication;
            if (authenticationService.isExternalAuthentication === true) {
                $scope.externalSubmit();
                return;
            }
            if ($scope.verifyURLScreen) {
                $scope.supportsTouch = lt.LTHelper.supportsTouch || (lt.LTHelper.browser == lt.LTBrowser.internetExplorer);
                // send the e-mail
                authenticationService.sendPatientURLVerification(linkProtocol, linkToken).then(function (data) {
                    if (!data.data.NeedsVerification) {
                        $scope.sixDigitSubmit();
                        return;
                    }
                    $scope.enableTwoFactorsAuthentication = true;
                    $scope.phoneNumber = data.data.Email;
                });
                setTimeout(function () {
                    document.getElementById('key1').focus();
                }, 100);
            }
            else {
                document.getElementById("username").autofocus;
            }
            $scope.submit = function () {
                __this.loginLoad(true, "loginloading", "submitButton", "Login");
                __this.auth.login($scope.Username, $scope.Password, $scope.RememberMe);
            };
            $scope.loginOkta = function () {
                window.location.replace(config.urls.idpServiceUrl + "Account/LoginOkta");
            };
            $scope.loginShibboleth = function () {
                window.location.replace(config.urls.idpServiceUrl + "Account/LoginShibboleth");
            };
            $scope.loginOktaHelp = function () {
                window.location.href = config.urls.oktaHelpUrl;
            };
            if (typeof config.urls.oktaHelpUrl != 'undefined' && config.urls.oktaHelpUrl) {
                $scope.oktaHelpIsEnabled = true;
            }
            $scope.loginShibbolethHelp = function () {
                window.location.href = config.urls.loginShibbolethHelpUrl;
            };
            $scope.pasteHandler = function (event) {
                __this._scope.SetKey(__this.getClipboardData(event));
                event.preventDefault();
                event.stopPropagation();
            };
            $scope.SetKey = function (value) {
                var index = 1;
                var symbollength = 6;
                var stringLength = value.length;
                var key = "";
                var counter = 0;
                for (; (index <= symbollength && counter < stringLength); counter++) {
                    // we are moving up in (Index) if the value in the paste is good.
                    if (__this.setSymbol(document.getElementById('key' + index), value[counter]))
                        index++;
                }
            };
            $scope.currentYear = new Date().getFullYear();
            $scope.oktaIsEnabled = optionsService.get(OptionNames.EnableOkta);
            $scope.shibbolethIsEnabled = optionsService.get(OptionNames.EnableShibboleth);
            $scope.sendAgain = function () {
                // send the e-mail
                authenticationService.sendPatientURLVerification(linkProtocol, linkToken).then(function (data) {
                    if (!data.data.NeedsVerification) {
                        __this._scope.sixDigitSubmit();
                        return;
                    }
                    __this._scope.enableTwoFactorsAuthentication = true;
                    __this._scope.phoneNumber = data.data.Email;
                });
            };
            // the key action when in the 6-digit code.
            $scope.keyDown = function (args) {
                var index = parseInt(args.target.id[3]);
                var key = args.key;
                if (key.match(/BackSpace/i)) {
                    // if you are at the last digit, just take it out.
                    if (!(index == 6 && document.getElementById('key6').innerText)) {
                        index--;
                    }
                    args.preventDefault();
                    args.stopPropagation();
                }
                if (key.match(/Del|Delete|BackSpace/i)) {
                    var control = document.getElementById('key' + index);
                    if (control) {
                        control.innerText = "";
                        control.focus();
                        for (; index < 6; index++) {
                            document.getElementById('key' + index).innerText = document.getElementById('key' + (index + 1)).innerText;
                        }
                        document.getElementById('key' + (index)).innerText = "";
                    }
                    args.preventDefault();
                    args.stopPropagation();
                    return;
                }
                // check if the user wants to move the right
                if (key.match(/ArrowRight|ArrowDown|PageDown/i)) {
                    if (index < 6)
                        index++;
                    document.getElementById('key' + index).focus();
                    args.preventDefault();
                    args.stopPropagation();
                    return;
                }
                // check if the user wants to move the left
                if (key.match(/ArrowLeft|ArrowUp|PageUp/i)) {
                    if (index > 1)
                        index--;
                    document.getElementById('key' + index).focus();
                    args.preventDefault();
                    args.stopPropagation();
                    return;
                }
                if (key.match(/Enter/i)) {
                    __this._scope.sixDigitSubmit();
                }
            };
            $scope.sepclick = function (args) {
                var index = parseInt(args.target.id[3]);
                if (args.offsetX > args.target.clientWidth / 2) {
                    index++;
                }
                document.getElementById('key' + index).focus();
            };
            $scope.keyPressed = function (args) {
                args.preventDefault();
                args.stopPropagation();
                // it has to be a letter to be processed
                if (args.key.length == 1) {
                    // check if the user pressed a valid character, which is anything from A to Z or from 0 to 9 and enter it in the focused key area.
                    var array = args.key.match(/[a-z|0-9]/i);
                    if (array && array.length != 0) {
                        __this.setSymbol(args.target, args.key);
                        var curIndex = args.target.tabIndex;
                        var index = parseInt(args.target.id[3]);
                        if (index < 6)
                            index++;
                        document.getElementById('key' + index).focus();
                    }
                }
            };
            eventService.subscribe("AuthenticationService/AuthenticationFailed", function (event, message) {
                __this.loginLoad(false, "loginloading", "submitButton", "Login");
                $scope.authenticationMessage = message.args;
                $scope.Invalid = true;
            });
        }
        LoginController.prototype.loginLoad = function (start, loadingId, buttonId, text) {
            if (start) {
                this._scope.authenticationMessage = "";
                this._scope.Invalid = false;
                document.getElementById(loadingId).style.visibility = "visible";
                document.getElementById(buttonId).value = "";
            }
            else {
                document.getElementById(loadingId).style.visibility = "hidden";
                document.getElementById(buttonId).value = text;
            }
        };
        LoginController.prototype.setSymbol = function (target, key) {
            var array = key.match(/[a-z|0-9]/i);
            if (array && array.length != 0) {
                target.innerHTML = "<div class='fadeLetter'>" + key.toUpperCase() + "</div>";
                return true;
            }
            return false;
        };
        LoginController.prototype.getClipboardData = function (event) {
            if (event.originalEvent.clipboardData)
                return event.originalEvent.clipboardData.getData("text");
            else {
                if (window.clipboardData) {
                    return window.clipboardData.getData("text");
                }
            }
            return "";
        };
        LoginController.prototype.init = function (_optionsService) {
            this._scope.oktaIsEnabled = _optionsService.get(OptionNames.EnableOkta);
            this._scope.shibbolethIsEnabled = _optionsService.get(OptionNames.EnableShibboleth);
        };
        LoginController.$inject = ['$scope', 'app.config', 'authenticationService', '$location', 'eventService', 'optionsService', 'linkToken', 'linkProtocol', 'sharedProperties', 'deferredQ'];
        return LoginController;
    }());
    Controllers.LoginController = LoginController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
/// <reference path="../../Scripts/models/Tab.ts" /> 
/// <reference path="../../Scripts/Services/OptionsService.ts" />
/// <reference path="../../Scripts/Services/TabService.ts" />
/// <reference path="../../Scripts/externalCommand/ExternalCommandHandlerService.ts" />
/// <reference path="../../Scripts/externalCommand/AutoService.ts" />
var VersionNumber = /** @class */ (function () {
    function VersionNumber() {
    }
    VersionNumber.GetFileVersion = function () { return "Version " + VersionNumber.MajorNumber + VersionNumber.MinorVersion; };
    VersionNumber.MinorVersion = ".1.0.197";
    VersionNumber.MajorNumber = lt.LTVersion.fileMajor.toString();
    VersionNumber.viewerType = "Leadtools";
    return VersionNumber;
}());
var Controllers;
(function (Controllers) {
    var MedicalWebViewerController = /** @class */ (function () {
        function MedicalWebViewerController($scope, eventService, authenticationService, optionsService, externalCommandHandlerService, tabService, dataService, $modal, $idle, monitorCalibrationService, seriesManagerService, toolbarService, auditLogService, $commangular, queryPacsService, $window, hotkeys, sharedPropertiesService, cinePlayerService, $timeout, $templateCache, $q, $location, dataCache, objectRetrieveService, dialogs, autoService, templateService) {
            var tab;
            var __this = this;
            var initViewTab = false;
            var dentalMode = optionsService.isSeriesView();
            this._eventService = eventService;
            this._templateService = templateService;
            $templateCache.put("template/tabs/tabset.html", "\n" +
                "<div>\n" +
                "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
                "  <div class=\"vbox boxItem tab-content\">\n" +
                "    <div class=\"vbox boxItem tab-pane\" \n" +
                "         ng-repeat=\"tab in tabs\" \n" +
                "         ng-class=\"{active: tab.active}\"\n" +
                "         tab-content-transclude=\"tab\">\n" +
                "    </div>\n" +
                "  </div>\n" +
                "</div>\n" +
                "");
            if (tabService.get_allTabs().length == 0) {
                if (!sharedPropertiesService.GetExternalControlMode()) {
                    if (!dentalMode) {
                        tab = tabService.add_tab(UUID.generate(), "Search", "views/SearchView.html", Controllers.SearchViewController);
                        tab.type = TabTypes.Search;
                        // don't show search bar for temporary users.
                        tab.visible = !(authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication);
                    }
                    else {
                        tab = tabService.add_tab(UUID.generate(), "Search", "views/DentalSearchView.html", Controllers.DentalSearchViewController);
                        tab.type = TabTypes.Search;
                        // don't show search bar for temporary users.
                        tab.visible = !(authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication);
                    }
                }
                if ($commangular != null) {
                    window.addEventListener('keydown', function (e) {
                        if (e.keyCode == 13) {
                            $commangular.dispatch("ToggleFullScreen");
                        }
                        //if (e.keyCode == 32) {
                        //    $commangular.dispatch("OnToggleCine");
                        //} 
                    }, false);
                }
                if (VersionNumber.viewerType != "Medicore") {
                    if (!sharedPropertiesService.GetExternalControlMode() && authenticationService.hasPermission(PermissionNames.CanDownloadImages) && optionsService.get(OptionNames.ShowPacsQuery)) {
                        var tab = tabService.add_tab(UUID.generate(), "User Queue", "views/UserQueueView.html", Controllers.UserQueueController);
                        tab.type = TabTypes.UserQueue;
                        tab.visible = !(authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication);
                    }
                }
            }
            externalCommandHandlerService.Initialize();
            autoService.Initialize();
            $scope.tabs = tabService.get_allTabs();
            $scope.user = authenticationService.user;
            $scope.countdown = optionsService.get(OptionNames.IdleWarningDuration);
            $scope.idleWait = optionsService.get(OptionNames.IdleWarningDuration);
            eventService.publish("ViewerTab\AddTabs", { tabs: $scope.tabs });
            $scope.$watch('activeTab', function (newValue, oldValue) {
                if (newValue != oldValue) {
                    if ((newValue != null) && (oldValue != null)) {
                        if (newValue.id == oldValue.id) {
                            return;
                        }
                    }
                    if (newValue.type == TabTypes.Viewer) {
                        var controller = tabService.get_tabData(newValue.id, TabDataKeys.ViewController);
                        if (controller) {
                            var viewer = controller.getViewer();
                            var cell = viewer.layout.get_selectedItem();
                            if (angular.isDefined(cell)) {
                                seriesManagerService.set_activeCell(cell.divID);
                            }
                            $timeout(function () {
                                viewer.onSizeChanged();
                            }, 500);
                        }
                    }
                    tabService.activeTab = tabService.get_allTabs().indexOf(newValue);
                    eventService.publish(EventNames.SelectedTabChanged, { previousTab: oldValue, currentTab: newValue });
                }
            }, true);
            $scope.tabSelected = function (index) {
                $scope.activeTab = index;
            };
            $scope.logout = function () {
                authenticationService.logout();
                externalCommandHandlerService.LogoutNotify("User Logout");
                autoService.LogoutNotify("User Logout");
            };
            $scope.findTab = function (id) {
                var foundTab;
                $.each($scope.tabs, function (index, tab) {
                    if (tab.id == id) {
                        foundTab = tab;
                        return false;
                    }
                });
                return foundTab;
            };
            eventService.subscribe(EventNames.DeleteTab, function (event, data) {
                $scope.deleteTab(data.args.id);
            });
            $scope.deleteTab = function (id, event) {
                var tab = tabService.find_tab(id);
                var anycell = seriesManagerService.get_anyCell();
                if (tab && tab.type == TabTypes.Viewer) {
                    var seriesList = seriesManagerService.get_allSeries();
                    for (var i = 0; i < seriesList.length; i++) {
                        var seriesTab = seriesManagerService.get_seriesTab(seriesList[i]);
                        if (seriesTab == tab) {
                            seriesManagerService.set_seriesTab(seriesList[i], null);
                            seriesManagerService.dispose_seriesCell(seriesList[i]);
                            eventService.publish(EventNames.DeleteSeries, { seriesInstanceUID: seriesList[i] });
                        }
                    }
                }
                var patientId = tabService.get_tabData(tab.id, TabDataKeys.PatientId);
                tabService.set_tabData(tab.id, TabDataKeys.PatientId, "");
                var activiatedTab;
                activiatedTab = tabService.findTabByKey(TabDataKeys.PatientId, patientId);
                if (activiatedTab == null)
                    activiatedTab = tabService.find_tabsByType(TabTypes.Search);
                $timeout(function () {
                    if (activiatedTab != null) {
                        if (angular.isDefined(activiatedTab) && activiatedTab.length > 0) {
                            activiatedTab[0].active = true;
                        }
                    }
                    tabService.delete_tab(id);
                }, 200, true);
            };
            function closeModals() {
                if ($scope.warning) {
                    $scope.warning.close();
                    $scope.warning = null;
                }
                if ($scope.timedout) {
                    $scope.timedout.close();
                    $scope.timedout = null;
                }
            }
            $scope.$on('$idleStart', function () {
                closeModals();
                $scope.warning = $modal.open({
                    templateUrl: 'warning-dialog.html',
                    windowClass: 'modal-danger'
                });
            });
            $scope.$on('$idleEnd', function () {
                closeModals();
            });
            $scope.$on('$idleTimeout', function () {
                closeModals();
                $idle.unwatch();
                authenticationService.logout();
                // externalCommandHandlerService.LogoutNotify("Idle Timeout");
            });
            $scope.$on('$keepaliveResponse', function (event, data, status) {
            });
            $scope.openAdminOverlay = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/OverlaySettings.html',
                    controller: Controllers.OverlaySettingsController,
                    backdrop: 'static'
                });
            };
            $scope.openAdminGlobal = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/GlobalOptions.html',
                    controller: Controllers.GlobalOptionsController,
                    backdrop: 'static'
                });
                modalInstance.result.then(function (saved) {
                    if (saved) {
                        sessionStorage.setItem('AuthCode', authenticationService.authenticationCode);
                        $window.location.reload();
                    }
                });
            };
            $scope.openAdminToolbar = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/ToolbarSettings.html',
                    controller: Controllers.AdminToolbarSettingsController,
                    backdrop: 'static'
                });
                modalInstance.result.then(function (saved) {
                    if (saved) {
                        sessionStorage.setItem('AuthCode', authenticationService.authenticationCode);
                        $window.location.reload();
                    }
                });
            };
            function imageExists(url, callback) {
                var img = new Image();
                img.onload = function () { callback(true); };
                img.onerror = function () { callback(false); };
                img.src = url;
            }
            $scope.aboutDialog = function () {
                // if (optionsService.get(OptionNames.UseMedicoreLogo)) {
                var year = new Date().getFullYear();
                var imageUrl = "";
                if (VersionNumber.viewerType == "Medicore") {
                    var imageUrl = 'images/mipacsAboutDark.jpg';
                    var currentTheme = window.localStorage.getItem("leadmedicalwebviewertheme");
                    switch (currentTheme) {
                        case "dark":
                            imageUrl = 'images/mipacsAboutDark.jpg';
                            break;
                        case "light":
                            imageUrl = 'images/mipacsAboutLight.jpg';
                            break;
                    }
                    var opts = { size: 'lg' };
                    dialogs.notify("About", "<center><img src=" + imageUrl + " width=600 height=400  align=\"middle\"></img></center> <center><br><b>MiPACS HTML5 Web Viewer</b></br>  - " + VersionNumber.GetFileVersion() + " <br/><br/>Copyright (c) 1991-" + year.toString() + " LEAD Technologies, Inc.<\center>", opts);
                }
                else {
                    dialogs.notify("About", "<b>Medical Web Viewer</b>  -  " + VersionNumber.GetFileVersion() + "<br/><br/>Copyright (c) 1991-" + year.toString() + " LEAD Technologies, Inc.");
                }
            };
            $scope.themeDialog = function () {
                //launch dialog
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/UISettings.html',
                    controller: Controllers.UISettingsController,
                    backdrop: 'static'
                });
            };
            $scope.clearCachedObjects = function () {
                window.localStorage.clear();
                var promise = objectRetrieveService.ClearCache();
                promise.then(function (result) {
                    if (angular.isDefined(result.data) && angular.isDefined(result.data.Message)) {
                        dialogs.error("Cache", result.data.Message);
                    }
                    else {
                        dialogs.notify("Cache", "Cached objects were cleared.");
                    }
                }, function (error) {
                    dialogs.error("Cache", error);
                });
            };
            $scope.openAdminCalibration = function () {
                monitorCalibrationService.GetCalibrations().success(function (calibrations) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/MonitorCalibration.html',
                        controller: Controllers.MonitorCalibrationController,
                        backdrop: 'static',
                        resolve: {
                            calibrations: function () {
                                return calibrations;
                            }
                        }
                    });
                }).error(function (error, status) {
                });
            };
            $scope.openRemotePacs = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/RemotePacs.html',
                    controller: Controllers.RemotePacsController,
                    backdrop: 'static'
                });
                if (optionsService.get(OptionNames.ShowPacsQuery)) {
                    modalInstance.result.then(function (saved) {
                        if (saved) {
                            sessionStorage.setItem('AuthCode', authenticationService.authenticationCode);
                            $window.location.reload();
                        }
                    });
                }
            };
            $scope.openRemoteWado = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/RemoteWado.html',
                    controller: Controllers.RemoteWadoController,
                    backdrop: 'static'
                });
                if (optionsService.get(OptionNames.ShowPacsQuery)) {
                    modalInstance.result.then(function (saved) {
                        if (saved) {
                            sessionStorage.setItem('AuthCode', authenticationService.authenticationCode);
                            $window.location.reload();
                        }
                    });
                }
            };
            $scope.openTemplateEditor = function () {
                $location.path('/templateeditor');
            };
            $scope.openChangePassword = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/PasswordChange.html',
                    controller: Controllers.PermissionsManagementController,
                    backdrop: 'static'
                });
                modalInstance.result.then(function (result) {
                    var tabId = __this.get_activeTabId();
                    __this._authenticationService.refreshPermissions().then(function (result) {
                        var canSaveHangingProtocol = __this._authenticationService.hasPermission(PermissionNames.CanSaveHangingProtocol);
                        toolbarService.enable('HangingProtocol' + tabId, function () {
                            return canSaveHangingProtocol;
                        });
                    });
                });
            };
            $scope.openPermissionsManagement = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/PermissionsManagement.html',
                    controller: Controllers.PermissionsManagementController,
                    backdrop: 'static'
                });
                modalInstance.result.then(function (result) {
                    var tabId = __this.get_activeTabId();
                    __this._authenticationService.refreshPermissions().then(function (result) {
                        var canSaveHangingProtocol = __this._authenticationService.hasPermission(PermissionNames.CanSaveHangingProtocol);
                        toolbarService.enable('HangingProtocol' + tabId, function () {
                            return canSaveHangingProtocol;
                        });
                    });
                });
            };
            function removeArray(arr, item) {
                var what, a = arguments, L = a.length, ax;
                while (L > 1 && arr.length) {
                    what = a[--L];
                    while ((ax = arr.indexOf(what)) !== -1) {
                        arr.splice(ax, 1);
                    }
                }
                return arr;
            }
            $scope.openRolePatientsAccessManagement = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/RolePatientsAccess.html',
                    controller: Controllers.RolePatientsAccessController,
                    backdrop: 'static',
                    resolve: {
                        roles: function () {
                            var deferred = $q.defer();
                            authenticationService.getRolesNames().success(function (roles) {
                                if (angular.isArray(roles)) {
                                    //
                                    // Administrative users always have access to patients
                                    //
                                    removeArray(roles, "Administrators");
                                }
                                deferred.resolve(roles);
                            }).error(function () {
                                deferred.resolve(new Array());
                            });
                            return deferred.promise;
                        }
                    }
                });
            };
            $scope.openUserPatientsAccessManagement = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/UserPatientsAccess.html',
                    controller: Controllers.UserPatientsAccessController,
                    backdrop: 'static',
                    resolve: {
                        users: function () {
                            var deferred = $q.defer();
                            authenticationService.getAllUsers().success(function (users) {
                                var rusers = [];
                                if (users && users.length > 0) {
                                    for (var _i = 0, users_1 = users; _i < users_1.length; _i++) {
                                        var u = users_1[_i];
                                        if (u.UserName) {
                                            rusers.push(u.UserName);
                                        }
                                        else {
                                            rusers.push(u);
                                        }
                                    }
                                }
                                deferred.resolve(rusers);
                            }).error(function () {
                                deferred.resolve(new Array());
                            });
                            return deferred.promise;
                        }
                    }
                });
            };
            $scope.doUpload = function (files) {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/UploadFiles.html',
                    controller: Controllers.UploadFileController,
                    backdrop: 'static'
                });
            };
            $scope.canSend = function () {
                // either get the information from the Json file or from the patient search tab.
                var tab = tabService.get_allTabs()[0];
                if (!tab)
                    return false;
                var controller = tabService.get_tabData(tab.id, TabDataKeys.searchViewerController);
                if (!controller)
                    return false;
                return controller.get_patientSelected();
            };
            $scope.doSend = function (files) {
                // either get the information from the Json file or from the patient search tab.
                var tab = tabService.get_allTabs()[0];
                var controller = tabService.get_tabData(tab.id, TabDataKeys.searchViewerController);
                var info = null;
                var cell = __this._seriesManagerService.get_activeCell();
                if (cell) {
                    var frame = __this._seriesManagerService.get_activeCellFrame();
                    if (frame) {
                        if (frame.JSON)
                            info = frame.JSON;
                    }
                }
                if (!info) {
                    // copy the patient info in a new class but add the word "Patient" at the beginig so it looks like the same property name from the JSON file.
                    // this is done because we want to parse information from either Patient info or JSON file to be place on the e-mail body.
                    var patientInfo = controller.get_selectedPatient();
                    // copy the info.
                    info = {};
                    for (var key in patientInfo) {
                        info["Patient" + key] = patientInfo[key];
                    }
                }
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/EmailURL.html',
                    controller: Controllers.EmailURLController,
                    backdrop: 'static',
                    resolve: {
                        patientInfo: function () {
                            return info;
                        }
                    }
                });
            };
            $scope.canShare = function () {
                return authenticationService.hasPermission(PermissionNames.CanStore);
            };
            $scope.isNotTempOrExter = function () {
                return !(authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication);
            };
            $scope.isNotExt = function () {
                return !authenticationService.isExternalAuthentication;
            };
            $scope.canStore = function () {
                return authenticationService.hasPermission(PermissionNames.CanStore);
            };
            eventService.subscribe(EventNames.Logout, function (event, data) {
                auditLogService.log_logOut(data.args.authenticationCode);
                externalCommandHandlerService.LogoutNotify("User Logout");
                autoService.LogoutNotify("User Logout");
            });
            eventService.subscribe(EventNames.ImageDataReady, $.proxy(this.onImageDataReady, this));
            eventService.subscribe(EventNames.CurrentDesignerChanged, $.proxy(this.onCurrentDesignerChanged, this));
            eventService.subscribe(EventNames.AnnotationsLoaded, $.proxy(this.onAnnotationsLoaded, this));
            eventService.subscribe(EventNames.LoadingSeriesFrames, $.proxy(this.onLoadingSeriesFrames, this));
            eventService.subscribe(EventNames.StackChanged, $.proxy(this.onStackChanged, this));
            eventService.subscribe(EventNames.NewSubCellSelected, $.proxy(this.onNewSubCellSelected, this));
            hotkeys.bindTo($scope)
                .add({
                combo: 'del',
                description: "Delete Cell",
                callback: $.proxy(this.onDelete, this)
            });
            function resetSeriesArrangement(viewer, boxes) {
                var cellLength = Math.min(boxes.length, viewer.layout.items.count);
                var length = viewer.get_emptyDivs().items.count;
                for (var index = 0; index < length; index++) {
                    viewer.get_emptyDivs().get_items().get_item(index).set_position(index + cellLength);
                }
            }
            function rearrangeSeries(viewer, structuredDisplay, boxes) {
                var length = viewer.emptyDivs.items.count;
                viewer.layout.beginUpdate();
                for (var index = 0; index < length; index++) {
                    var boxNumber = index + 1;
                    var series = $.grep(structuredDisplay.Series, function (series) {
                        return series.ImageBoxNumber == boxNumber;
                    });
                    if (series.length == 0) {
                        var item = viewer.emptyDivs.items.item(index);
                        var box = boxes[index];
                        var rect = Utils.createLeadRect(box.Position.leftTop.x, box.Position.leftTop.y, box.Position.rightBottom.x, box.Position.rightBottom.y);
                        item.bounds = rect;
                    }
                }
                viewer.layout.endUpdate();
            }
            eventService.subscribe(EventNames.StructuredDisplayUpdated, function (event, data) {
                var tab = tabService.get_allTabs()[tabService.activeTab];
                var currentController = tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                if (currentController != null) {
                    var viewer = currentController.getViewer();
                    viewer.SDInstances = data.args.InstanceUIDs;
                    if (viewer.exploded)
                        viewer.explode(viewer.explodedCell, false);
                    viewer.layout.beginUpdate();
                    var length = viewer.layout.items.count;
                    var cell;
                    for (var index = 0; index < length; index++) {
                        cell = viewer.layout.items.get_item(index);
                        cell.visibility = data.args.InstanceUIDs[cell.seriesInstanceUID];
                    }
                    viewer.layout.endUpdate();
                    viewer.emptyDivs.beginUpdate();
                    length = viewer.emptyDivs.items.count;
                    var emptyCell;
                    for (index = 0; index < length; index++) {
                        emptyCell = viewer.emptyDivs.get_items().get_item(index);
                        emptyCell.visibility = false;
                    }
                    viewer.emptyDivs.endUpdate();
                }
            });
            eventService.subscribe(EventNames.OverflowExcessImage, function (event, data) {
                var seriesList = data.args.seriesList;
                var series = {};
                series.Patient = {};
                series.Patient.ID = data.args.patientID;
                var viewController = dentalMode ? Controllers.DentalViewerController : Controllers.ViewerController;
                var viewUrl = dentalMode ? "views/DentalViewer.html" : "views/Viewer.html";
                var tabInfo = __this.get_patientTab(series, series, viewUrl, viewController, false, false);
                for (var seriesInstanceUID in __this._seriesManagerService.SeriesInstancesList) {
                    var index = 0;
                    var length = seriesList.length;
                    var seriesData = null;
                    for (index = 0; index < length; index++) {
                        if (seriesList[index].InstanceUID == seriesInstanceUID) {
                            seriesData = JSON.parse(JSON.stringify(seriesList[index]));
                            break;
                        }
                    }
                    if (!seriesData)
                        continue;
                    seriesData.InstanceUID = __this._seriesManagerService.SeriesInstancesList[seriesInstanceUID][0].SeriesInstanceUID;
                    seriesData.SopInstanceUIDs = [__this._seriesManagerService.SeriesInstancesList[seriesInstanceUID][0].SOPInstanceUID];
                    __this._seriesManagerService.set_seriesTab(seriesData.InstanceUID, tabInfo.tab);
                    __this._seriesManagerService.set_seriesInfo(seriesData.InstanceUID, seriesData);
                    __this._eventService.publish(EventNames.InstanceOverflow, { instance: __this._seriesManagerService.SeriesInstancesList[seriesInstanceUID][0], metadata: 0, frame: 0, parentCell: 0 });
                }
            });
            eventService.subscribe(EventNames.StructuredDisplaySelected, function (event, data) {
                var viewController = dentalMode ? Controllers.DentalViewerController : Controllers.ViewerController;
                var viewUrl = dentalMode ? "views/DentalViewer.html" : "views/Viewer.html";
                var structuredDisplay = data.args.structureDisplay;
                var series = {};
                series.Patient = {};
                series.Patient.ID = structuredDisplay.PatientID;
                var tabInfo = __this.get_patientTab(series, series, viewUrl, viewController, false, true);
                if (tabInfo.tab) {
                    var currentController = tabService.get_tabData(tabInfo.tab.id, TabDataKeys.ViewController);
                    // this is filled for when you move from the search tab to the viewer tab.
                    // now that we are here at the viewer tab, we don't need no more.
                    if (currentController != null) {
                        var viewer = currentController.getViewer();
                        currentController._viewerApi.studyLayout = null;
                        //viewer.layout.beginUpdate();
                        //viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.grid;
                        //viewer.gridLayout.rows = 2;
                        //viewer.gridLayout.columns = 2;
                        //viewer.layout.endUpdate();
                        var structuredDisplay = data.args.structureDisplay;
                        if (structuredDisplay.Boxes) {
                            structuredDisplay.Boxes.sort(function (a, b) {
                                return a.ImageBoxNumber - b.ImageBoxNumber;
                            });
                        }
                        // delete all previous cells and start over.
                        __this.ResetViewer(seriesManagerService, eventService, tabInfo.tab);
                        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.random;
                        viewer.totalCells = structuredDisplay.Boxes.length;
                        resetSeriesArrangement(viewer, structuredDisplay.Boxes);
                        rearrangeSeries(viewer, structuredDisplay, structuredDisplay.Boxes);
                        var occupiedCellIndex = -1;
                        var index = 0;
                        var length = structuredDisplay.Boxes.length;
                        for (index = 0; index < length; index++) {
                            //if (item.referencedSOPInstanceUID.length == 0) {
                            var item = structuredDisplay.Boxes[index];
                            var cell = viewer.emptyDivs.items.get_item(index); //new lt.Controls.Medical.EmptyCell(viewer.emptyDivs, viewer, UUID.generate(), 1, 1);
                            if (cell == null) {
                                if (occupiedCellIndex == -1)
                                    occupiedCellIndex = index;
                                cell = viewer.layout.items.get_item(index - occupiedCellIndex);
                            }
                            var rect = Utils.createLeadRect(item.Position.leftTop.x, item.Position.leftTop.y, item.Position.rightBottom.x, item.Position.rightBottom.y);
                            cell.position = item.ImageBoxNumber;
                            cell.bounds = rect;
                            //}
                        }
                        viewer.onSizeChanged();
                    }
                }
            });
            eventService.subscribe(EventNames.SeriesSelected, function (event, data) {
                if (!data.args.remote) {
                    var structuredDisplay = data.args.structureDisplay;
                    var templateItem = data.args.templateItem;
                    $timeout(function () {
                        var viewUrl = dentalMode ? "views/DentalViewer.html" : "views/Viewer.html";
                        var viewController = dentalMode ? Controllers.DentalViewerController : Controllers.ViewerController;
                        var tabController;
                        var tabPatientId;
                        var tabInfo;
                        var currentController;
                        var forCompare = data.args.forCompare;
                        var series = data.args.series;
                        var style = data.args.style;
                        if (forCompare) {
                            viewUrl = "views/CompareView.html";
                            viewController = Controllers.CompareViewController;
                            series = data.args.series[0];
                        }
                        __this._hideOverlay = false;
                        tabInfo = __this.get_patientTab(series, data.args.series, viewUrl, viewController, forCompare);
                        if (style && style === 'medicor') {
                            optionsService.set(OptionNames.UseMedicoreLogo, true);
                        }
                        else {
                            optionsService.set(OptionNames.UseMedicoreLogo, false);
                        }
                        currentController = tabService.get_tabData(tabInfo.tab.id, TabDataKeys.ViewController);
                        if (currentController != null) {
                            // if the the current list has a different id, then free the series list row and populate it with the new patient serie
                            if (currentController._listController != null) {
                                if (currentController._listController._list != null) {
                                    if (currentController._listController._list.parentNode.id != series.Patient.ID) {
                                        currentController._listController._list.parentNode.id = series.Patient.ID;
                                        currentController._listController.refreshContent(objectRetrieveService, seriesManagerService, series.Patient.ID);
                                    }
                                }
                            }
                        }
                        if (!data.args.studyLoad) {
                            if (forCompare) {
                                __this.log_OpenPatient(tabInfo.tab, tabService, auditLogService, series.Patient);
                                tabService.select_tab(tabInfo.tab.id);
                                tabInfo.tab.canDelete = true;
                                if (lt.LTHelper.device == lt.LTDevice.mobile) {
                                    tabInfo.tab.title = 'Compare';
                                }
                                else {
                                    tabInfo.tab.title = 'Compare [' + $.tmplParse("<%=Patient.Name.replace(/\^/g, ' ')%> - <%=Patient.ID%>", series) + ']';
                                }
                                tabController = tabService.get_tabData(tabInfo.tab.id, TabDataKeys.ViewController);
                                return;
                            }
                            if (currentController != null) {
                                var viewer = currentController.getViewer();
                                if (data.args.resetLayout) {
                                    currentController._viewerApi.studyLayout = null; //this._templateService.currentStudyLayout;
                                    viewer.layout.beginUpdate();
                                    viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.grid;
                                    viewer.gridLayout.rows = 1;
                                    viewer.gridLayout.columns = 1;
                                    // rest all the visibitly status.
                                    for (var instance in viewer.SDInstances) {
                                        viewer.SDInstances[instance] = true;
                                    }
                                    viewer.layout.endUpdate();
                                }
                                if (viewer != null) {
                                    if (viewer.exploded) {
                                        viewer.explode(viewer.explodedCell, false);
                                        window.setTimeout(function () {
                                            viewer.onSizeChanged();
                                        }, 250);
                                    }
                                }
                            }
                        }
                        else {
                            tabInfo.tab.showStudyTimeLine = true;
                        }
                        __this.log_OpenPatient(tabInfo.tab, tabService, auditLogService, series.Patient);
                        tabService.select_tab(tabInfo.tab.id);
                        if (tabInfo.setOverlay) {
                            if (__this._hideOverlay) {
                                tabService.set_tabData(tabInfo.tab.id, TabDataKeys.TagToggle, false);
                            }
                        }
                        if (tabInfo.setLinked && dentalMode) {
                            tabService.set_tabData(tabInfo.tab.id, TabDataKeys.Linked, false);
                        }
                        if (dataCache["StudyInstanceUID"]) {
                            tabService.set_tabData(tabInfo.tab.id, TabDataKeys.LaunchingStudy, dataCache["StudyInstanceUID"]);
                            delete dataCache["StudyInstanceUID"];
                        }
                        seriesManagerService.set_seriesTab(series.InstanceUID, tabInfo.tab);
                        seriesManagerService.set_seriesInfo(series.InstanceUID, series);
                        if (data.args.id != null)
                            seriesManagerService.set_activeCell(data.args.id);
                        tabInfo.tab.canDelete = !(authenticationService.isTempAuthentication || authenticationService.isExternalAuthentication);
                        if (lt.LTHelper.device == lt.LTDevice.mobile) {
                            tabInfo.tab.title = 'Viewer';
                        }
                        else {
                            tabInfo.tab.title = 'Viewer [' + $.tmplParse("<%=Patient.Name.replace(/\^/g, ' ')%> - <%=Patient.ID%>", series) + ']';
                        }
                        tabController = tabService.get_tabData(tabInfo.tab.id, TabDataKeys.ViewController);
                        auditLogService.log_showSeries(series);
                        if (tabController != null) {
                            if (angular.isFunction(tabController.getListController)) {
                                var listControl = tabController.getListController();
                                if (listControl != null) {
                                    listControl.loadSeriesList(series.Patient.ID, series.InstanceUID, data.args.fromList);
                                }
                            }
                        }
                        //$timeout(function () {
                        $scope.$apply();
                        //});
                        // If from structured display,
                        var displaySetNumberTemp = data.args.displaySetNumber;
                        if (displaySetNumberTemp == null) {
                            displaySetNumberTemp = series.ImageBoxNumber;
                        }
                        if (!structuredDisplay)
                            __this._seriesManagerService.SeriesInstancesList = null;
                        eventService.publish((structuredDisplay ? EventNames.LoadStructuredDisplay : EventNames.LoadSeries) + tabInfo.tab.id, {
                            sdID: data.args.study.sdID,
                            study: data.args.study,
                            tabid: tabInfo.tab.id,
                            series: series,
                            template: data.args.template,
                            templateItem: templateItem,
                            view: data.args.view,
                            displaySetNumber: displaySetNumberTemp,
                            isSTL: data.args.isSTL
                        });
                    });
                }
                else {
                    var queueTabs = tabService.find_tabsByType(TabTypes.UserQueue);
                    var queueTab = null;
                    if (queueTabs.length == 0) {
                        queueTab = tabService.add_tab(UUID.generate(), "User Queue", 'views/UserQueueView.html', Controllers.UserQueueController, TabTypes.UserQueue);
                    }
                    else
                        queueTab = queueTabs[0];
                    tabService.select_tab(queueTab.id);
                    setTimeout(function () { $scope.$apply(); });
                    data.args.series =
                        eventService.publish(EventNames.DownloadSeries, {
                            studyInfo: data.args.study,
                            pacsClientInfo: queryPacsService.server,
                            clientAe: queryPacsService.clientAETitle,
                            seriesInfo: data.args.series,
                        });
                }
            });
            eventService.subscribe(EventNames.RefreshToolbar, function (event, data) {
                var cell = data.args.cell;
                var tab = data.args.tab;
                var viewer = data.args.viewer;
                __this.refreshToolbarItems(viewer, cell, authenticationService);
            });
            eventService.subscribe(EventNames.ActiveSeriesChanged, function (event, data) {
                var cell = seriesManagerService.get_activeCell();
                __this.refreshToolbarItems(null, cell, authenticationService);
                __this.updateMultiFrame(cell);
                if (!(cell instanceof lt.Controls.Medical.Cell3D))
                    __this.onAnnotationsLoaded(event, data);
                var tabId = __this.get_activeTabId();
                var tab = __this.get_activeTab();
                eventService.publish(EventNames.OpenStudyTimeLine, { show: tab.showStudyTimeLine /*seriesManagerService.get_ShowStudyTimeLine()*/ });
            });
            function get_annotationVisiblity(tabid) {
                var visibility = tabService.get_tabData(tabid, TabDataKeys.AnnotationVisiblity);
                if (visibility == undefined)
                    visibility = true;
                return visibility;
            }
            eventService.subscribe(EventNames.NewCellsAdded, function (event, data) {
                var cells = data.args.cells;
                var length = cells.length;
                var tabIndex = tabService.activeTab;
                var tab = tabIndex != -1 ? tabService.get_allTabs()[tabIndex] : null;
                for (var index = 0; index < length; index++) {
                    var cell = cells[index];
                    if (cell == null)
                        continue;
                    if (!cell.get_automation)
                        continue;
                    var automation = cell.get_automation();
                    if (automation == null)
                        continue;
                    var viewer = cell.get_imageViewer();
                    automation.add_activeContainerChanged(function (sender, e) {
                        if (automation.activeContainer != null) {
                            var tab = seriesManagerService.get_seriesTab(cell.get_seriesInstanceUID());
                            if (tab != null) {
                                var visibility = get_annotationVisiblity(tab.id);
                                automation.activeContainer.set_isVisible(visibility);
                                automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                            }
                        }
                    });
                    viewer.add_itemChanged(function (sender, e) {
                        if (e.get_reason() == lt.Controls.ImageViewerItemChangedReason.url) {
                            __this.refreshToolbarItems(null, cell, authenticationService);
                        }
                    });
                }
            });
            $scope.canCalibrateMonitor = function () {
                return optionsService.isSeriesView() && authenticationService.hasPermission(PermissionNames.CanCalibrateMonitor);
            };
            $scope.canManageRemotePacs = function () {
                if (VersionNumber.viewerType == "Medicore")
                    return false;
                return authenticationService.hasPermission(PermissionNames.CanManageRemotePACS);
            };
            $scope.canDeleteCache = function () {
                return authenticationService.hasPermission(PermissionNames.CanDeleteCache);
            };
            $scope.canManagePermissions = function () {
                return authenticationService.hasPermission(PermissionNames.CanManageRoles) || authenticationService.hasPermission(PermissionNames.CanManageUsers);
            };
            $scope.canManageAccessRights = function () {
                return authenticationService.hasPermission(PermissionNames.CanManageAccessRight);
            };
            $scope.isAdmin = function () {
                return authenticationService.permissions.isAdmin;
            };
            $scope.canSharePatients = function () {
                return authenticationService.hasPermission(PermissionNames.CanSharePatients);
            };
            $scope.canShowTemplates = function () {
                //return authenticationService.hasPermission(PermissionNames.CanEditTemplates) || authenticationService.hasPermission(PermissionNames.CanViewTemplates);
                return authenticationService.hasPermission(PermissionNames.CanEditTemplates);
            };
            this._seriesManagerService = seriesManagerService;
            this._toolbarService = toolbarService;
            this._authenticationService = authenticationService;
            this._optionsService = optionsService;
            this._tabService = tabService;
            this._commangular = $commangular;
            this._dataService = dataService;
            this._cinePlayerService = cinePlayerService;
            this._objectRetrieveService = objectRetrieveService;
            this._dialogs = dialogs;
        }
        MedicalWebViewerController.prototype.ResetViewer = function (seriesManagerService, eventService, tab) {
            var seriesList = seriesManagerService.get_allSeries();
            for (var i = 0; i < seriesList.length; i++) {
                var seriesTab = seriesManagerService.get_seriesTab(seriesList[i]);
                if (seriesTab == tab) {
                    seriesManagerService.remove_seriesCell(seriesList[i]);
                    //eventService.publish(EventNames.DeleteSeries, { seriesInstanceUID: seriesList[i] });
                }
            }
        };
        MedicalWebViewerController.prototype.get_patientTab = function (series, seriesArray, viewUrl, viewController, forCompare, noNew) {
            var singlePatientMode = this._optionsService.get(OptionNames.SinglePatientMode);
            var tab;
            var setOverlay = false;
            var setLinked = false;
            if (forCompare) {
                //tab = this.getPatientTab(series.Patient.ID, this._tabService);
                tab = this._tabService.add_tab(UUID.generate(), "Compare", viewUrl, viewController, TabTypes.Compare);
                this._tabService.set_tabData(tab.id, TabDataKeys.CompareInstances, seriesArray);
                this._tabService.set_tabData(tab.id, TabDataKeys.TagToggle, false);
                setOverlay = true;
                setLinked = true;
            }
            else if (!singlePatientMode) {
                tab = this.getPatientTab(series.Patient.ID, this._tabService);
                if ((!tab) && !noNew) {
                    tab = this._tabService.add_tab(UUID.generate(), "View", viewUrl, viewController, TabTypes.Viewer);
                    this._tabService.set_tabData(tab.id, TabDataKeys.PatientId, series.Patient.ID);
                    this._hideOverlay = this._optionsService.get(OptionNames.HideOverlays);
                    setOverlay = true;
                    setLinked = true;
                }
            }
            else {
                var viewerTabs = this._tabService.find_tabsByType(TabTypes.Viewer);
                if ((viewerTabs.length == 0) && !noNew) {
                    tab = this._tabService.add_tab(UUID.generate(), "View", viewUrl, viewController, TabTypes.Viewer);
                    this._hideOverlay = this._optionsService.get(OptionNames.HideOverlays);
                    setOverlay = true;
                    setLinked = true;
                }
                else {
                    tab = viewerTabs[0];
                }
            }
            return { tab: tab, setOverlay: setOverlay, setLinked: setLinked };
        };
        MedicalWebViewerController.prototype.log_OpenPatient = function (tab, tabService, auditLogService, patient) {
            var patientId = tabService.get_tabData(tab.id, TabDataKeys.PatientId);
            var log = true;
            if (patientId) {
                if (patientId != patient.ID) {
                    log = true;
                }
                else
                    log = false;
            }
            if (log) {
                auditLogService.log_openPatient(patient);
            }
            tabService.set_tabData(tab.id, TabDataKeys.PatientId, patient.ID);
        };
        MedicalWebViewerController.prototype.getPatientTab = function (patientid, tabService) {
            var seriesList = this._seriesManagerService.get_allSeries();
            for (var i = 0; i < seriesList.length; i++) {
                var series = this._seriesManagerService.get_seriesInfo(seriesList[i]);
                if (series && (patientid == series.Patient.ID)) {
                    var tab = this._seriesManagerService.get_seriesTab(seriesList[i]);
                    return tab;
                }
            }
            return null;
        };
        MedicalWebViewerController.prototype.onImageDataReady = function (event, data) {
            var cell = this._seriesManagerService.get_seriesCellById(data.args.id);
            var tabId = this.get_activeTabId();
            var __this = this;
            var interactiveMode = CommandManager.LastCommand.Action;
            this.refreshToolbarItems(cell ? cell.viewer : null, cell, this._authenticationService);
            if (interactiveMode == MedicalViewerAction.WindowLevel && this._toolbarService.isEnabled("WindowLevel" + tabId)) {
                //this._commangular.dispatch('WindowLevelInteractiveMode', { buttonId: 'WindowLevel' + tabId });
            }
            {
                if (interactiveMode != -1) {
                    var commandId = '';
                    if (currentIcon[tabId])
                        commandId = currentIcon[tabId].id;
                    else if (interactiveMode == MedicalViewerAction.WindowLevel) {
                        commandId = 'WindowLevel' + tabId;
                    }
                    else if (interactiveMode == MedicalViewerAction.Offset) {
                        commandId = 'Pan' + tabId;
                    }
                    else if (interactiveMode == MedicalViewerAction.Scale) {
                        commandId = 'Zoom' + tabId;
                    }
                    else if (interactiveMode == MedicalViewerAction.Offset) {
                        commandId = 'Magnify' + tabId;
                    }
                    else if (interactiveMode == MedicalViewerAction.Stack) {
                        commandId = 'Stack' + tabId;
                    }
                    else if (interactiveMode == MedicalViewerAction.ProbeTool) {
                        commandId = 'ProbeTool' + tabId;
                    }
                    if (commandId != '') {
                        SetCurrentInteractiveMode(this._toolbarService, this._tabService, interactiveMode, commandId);
                    }
                }
            }
        };
        MedicalWebViewerController.prototype.EnableButtons = function (buttons, enable, tabId) {
            var index = 0;
            var length = buttons.length;
            for (index = 0; index < length; index++) {
                if (enable)
                    this._toolbarService.enable(buttons[index] + tabId);
                else
                    this._toolbarService.disable(buttons[index] + tabId);
            }
        };
        MedicalWebViewerController.prototype.EnableButtonsFor3D = function (is3D, tabId) {
            this.EnableButtons(['LayoutCompose', 'MergeCells', 'HangingProtocol', 'DeleteStudyStructuredDisplay', 'Magnify', 'Stack', 'ProbeTool', 'Spyglass', 'OneToOne', 'ClearAllAnnotations', 'ClearAll', 'SaveAnn', 'TrueSizeDisplay', 'Orientation', 'HorizontalAlignment', 'VerticalAlignment', 'ScrollingType', 'SortSeries', 'Endo', 'Perio', 'Dentin', 'Annotations', 'Measurements', 'AnnotationShowHide', 'DeleteAnnotations', 'ClearAnnotations', 'SaveAnn', 'LoadAnn', 'LinkImages', 'Cursor3D', 'ReferenceLine', 'ShowFirstLast', 'SeriesLayouts', 'SynchronizeSeries', 'ToggleCine', 'WaveformBasicAudio', 'LinkCells', 'ShutterObject', 'LineProfile', 'SpyglassGroup', 'FitImage', 'EdgeEnhancment'], !is3D, tabId);
        };
        MedicalWebViewerController.prototype.Enable3DButtons = function (enable, tabId) {
            this.EnableButtons(['Rotate3D', 'DisplayOrientation', 'Settings3D'], enable, tabId);
        };
        MedicalWebViewerController.prototype.CheckPrintToPDF = function (viewer, cell, tabId) {
            if (!viewer && !cell) {
                this._toolbarService.disable("PopupCapture" + tabId);
                return;
            }
            if (!(this._templateService && this._templateService.currentStudyLayout)) {
                //var viewer: lt.Controls.Medical.MedicalViewer = cell.viewer;
                var index = 0;
                var length = viewer.layout.items.count;
                var currentCell;
                var subCell;
                var frameIndex = 0;
                var frameLength;
                var cell3d;
                var enablePopCapture = true;
                var frame = null;
                // make sure everthing is ready before loading the image.
                /*for (index = 0; index < length; index++)*/ {
                    currentCell = cell; //viewer.layout.items.get_item(index);
                    {
                        if (currentCell instanceof lt.Controls.Medical.Cell) {
                            frameIndex = 0;
                            frameLength = currentCell.imageViewer.items.count;
                            for (frameIndex = 0; frameIndex < frameLength; frameIndex++) {
                                subCell = (currentCell.imageViewer.items.get_item(frameIndex));
                                frame = subCell.attachedFrame;
                                if (!(frame && frame.information && frame.Instance && frame.Instance.SOPInstanceUID)) {
                                    this._toolbarService.disable("PopupCapture" + tabId);
                                    return;
                                }
                            }
                        }
                        else if (currentCell instanceof lt.Controls.Medical.Cell3D) {
                            //cell3d = <lt.Controls.Medical.Cell3D>currentCell;
                            //if (!(cell3d.object3D && cell3d.object3D.volumeReady)) {
                            this._toolbarService.disable("PopupCapture" + tabId);
                            return;
                            //}
                        }
                        else {
                            this._toolbarService.disable("PopupCapture" + tabId);
                            return;
                        }
                    }
                }
                if (this._authenticationService.hasPermission(PermissionNames.CanExport))
                    this._toolbarService.enable("PopupCapture" + tabId);
            }
        };
        MedicalWebViewerController.prototype.refreshToolbarItems = function (viewer, cell, authenticationService) {
            var index;
            var seriesInstanceUID;
            var tabId = this.get_activeTabId();
            if (cell) {
                viewer = cell.viewer;
            }
            this._toolbarService.checkDentalEffects(viewer, cell, tabId);
            this.CheckPrintToPDF(viewer, cell, tabId);
            if (cell == null || !cell.get_selected())
                return;
            var isCell3D = cell instanceof lt.Controls.Medical.Cell3D;
            var isCellMPR = cell instanceof lt.Controls.Medical.MPRCell;
            if (CommandManager.Last3DCommand.ButtonID == "") {
                CommandManager.Last3DCommand.ButtonID = "Rotate3D" + tabId;
            }
            if (CommandManager.LastCommand.ButtonID == "") {
                CommandManager.LastCommand.ButtonID = "WindowLevel" + tabId;
            }
            var status = lt.Controls.Medical.Object3DEngine.canDo3D(cell);
            this.EnableButtons(['VolumeType', 'DentalPanoramic', 'RotationTool', 'Cephalometric', 'CutLine'], (cell instanceof lt.Controls.Medical.Cell3D) || (status == lt.Controls.Medical.CanDo3DStatus.ok), tabId);
            seriesInstanceUID = cell.get_seriesInstanceUID();
            index = cell.currentOffset;
            this.EnableButtonsFor3D(isCell3D, tabId);
            this.Enable3DButtons((isCell3D), tabId);
            this.EnableButtons(['EdgeEnhancment'], !isCell3D && !isCellMPR, tabId);
            if (DicomHelper.supportWindowLevel(cell, index)) {
                if (this._seriesManagerService.isDataReady(cell, index)) {
                    this._toolbarService.enable("WindowLevel" + tabId);
                    this._toolbarService.enable("WindowLevelCustom" + tabId);
                    this._toolbarService.enable("Invert" + tabId);
                    this._toolbarService.disable("BrightnessContrast" + tabId);
                    this._toolbarService.disable("StretchHistogram" + tabId);
                    this._toolbarService.disable("HSL" + tabId);
                }
                else {
                    this._toolbarService.enable("WindowLevel" + tabId);
                    this._toolbarService.enable("WindowLevelCustom" + tabId);
                    this._toolbarService.disable("Invert" + tabId);
                    this._toolbarService.disable("BrightnessContrast" + tabId);
                    this._toolbarService.disable("StretchHistogram" + tabId);
                    this._toolbarService.disable("HSL" + tabId);
                }
            }
            else {
                var enable = true;
                this._toolbarService.enable("WindowLevel" + tabId);
                this._toolbarService.enable("WindowLevelCustom" + tabId);
                this._toolbarService.enable(["Invert" + tabId, "BrightnessContrast" + tabId, "StretchHistogram" + tabId, "HSL" + tabId], function () {
                    return enable;
                });
            }
            var tab = this.get_activeTab();
            if (isCell3D) {
                PressButton(this._toolbarService, tab, CommandManager.Last3DCommand.ButtonID);
            }
            else {
                PressButton(this._toolbarService, tab, CommandManager.LastCommand.ButtonID);
            }
            if (isCell3D) {
                var cell3D = cell;
                this.EnableButtons(['WindowLevel', 'WindowLevelCustom'], cell3D.volumeType != lt.Controls.Medical.VolumeType.SSD, tabId);
            }
            if ((authenticationService) && (authenticationService.hasPermission)) {
                var canSaveStructuredDisplay = authenticationService.hasPermission(PermissionNames.CanSaveStructuredDisplay);
                var canStore = authenticationService.hasPermission(PermissionNames.CanStore);
                if (!canSaveStructuredDisplay) {
                    this.EnableButtons(['LayoutCompose'], false, tabId);
                }
            }
        };
        MedicalWebViewerController.prototype.onCurrentDesignerChanged = function (event, data) {
            var __this = this;
            var tabId = this.get_activeTabId();
            //this._toolbarService.enable("DeleteAnn" + tabId, function () {
            //    return data.args.automation.canDeleteObjects && data.args.automation.currentEditObject;
            //});
            this._toolbarService.enable("CalibrateRuler" + tabId, function () {
                return data.args.selectedObject instanceof lt.Annotations.Engine.AnnPolyRulerObject;
            });
            //this._toolbarService.enable("ShutterObject" + tabId, function () {
            //    return __this.enableShutterObject();
            //});
        };
        MedicalWebViewerController.prototype.enableShutterObject = function () {
            var cell = this._seriesManagerService.get_activeCell();
            if (cell) {
                var frame = this._seriesManagerService.get_activeCellFrame();
                var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
                var controller = this._tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                var medicalViewer = controller.getViewer();
                var automation;
                var editObject;
                if (medicalViewer == null)
                    return false;
                automation = cell.get_automation();
                editObject = automation.get_currentEditObject();
                if (!editObject)
                    return false;
                return lt.Controls.Medical.ShutterObject.isValid(editObject) && automation.selectObjects.length == 1;
            }
        };
        MedicalWebViewerController.prototype.enableCrossHair = function (subcell, frame) {
            var cell = subcell.parentCell;
            var mprcell = cell instanceof lt.Controls.Medical.MPRCell;
            var tabId = this.get_activeTabId();
            this._toolbarService.enable("CrossHair" + tabId, function () {
                return mprcell || cell.derivatives.count > 0;
            });
        };
        MedicalWebViewerController.prototype.onAnnotationsLoaded = function (event, data) {
            var annotations = this._seriesManagerService.get_annotationIDs(data.args.seriesInstanceUID, data.args.id);
            var tabId = this.get_activeTabId();
            var dentalMode = this._optionsService.isSeriesView();
            var __this = this;
            if (annotations && annotations.length > 0 && this._authenticationService.hasPermission(PermissionNames.CanViewAnnotations)) {
                this._toolbarService.enable("LoadAnn" + tabId);
                if (dentalMode) {
                    this._toolbarService.hilightBorder("LoadAnn" + tabId, "1px", "#ff0000");
                }
            }
            else {
                this._toolbarService.disable("LoadAnn" + tabId);
                if (dentalMode) {
                    this._toolbarService.unhilightBorder("LoadAnn" + tabId);
                }
            }
            this._toolbarService.enable("SaveAnn" + tabId, function () {
                return __this._authenticationService.hasPermission(PermissionNames.CanStoreAnnotations);
            });
            this._toolbarService.disable("DeleteAnn" + tabId);
            this._toolbarService.disable("CalibrateRuler" + tabId);
            this._toolbarService.enable("SecondaryCapture" + tabId, function () {
                return __this._authenticationService.hasPermission(PermissionNames.CanStore);
            });
            this._toolbarService.enable("LayoutCompose" + tabId, function () {
                return __this._authenticationService.hasPermission(PermissionNames.CanStore);
            });
        };
        MedicalWebViewerController.prototype.get_activeTabId = function () {
            if (this._tabService.activeTab != -1) {
                var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
                if (angular.isDefined(tab))
                    return tab.id;
            }
            return '';
        };
        MedicalWebViewerController.prototype.get_activeTab = function () {
            if (this._tabService.activeTab != -1) {
                var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
                return tab;
            }
            return null;
        };
        MedicalWebViewerController.prototype.onLoadingSeriesFrames = function (event, data) {
            var cell = this._seriesManagerService.get_seriesCellById(data.args.id);
            var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
            var tagToggle = this._tabService.get_tabData(tab.id, TabDataKeys.TagToggle);
            var controller = this._tabService.get_tabData(tab.id, TabDataKeys.ViewController);
            var viewer = controller.getViewer();
            this.updateMultiFrame(cell);
            this.refreshToolbarItems(viewer, cell, this._authenticationService);
            if (!tagToggle) {
                cell.set_overlayTextVisible(tagToggle);
            }
            if (viewer.showReferenceLine || viewer.showFirstAndLastReferenceLine) {
                var showRef = false;
                var showFirstLast = false;
                if (viewer.showReferenceLine) {
                    viewer.showReferenceLine = false;
                    showRef = true;
                }
                else {
                    viewer.showFirstAndLastReferenceLine = false;
                    showFirstLast = true;
                }
                if (showRef || showFirstLast) {
                    viewer.invalidate();
                    setTimeout(function () {
                        if (showRef)
                            viewer.showReferenceLine = true;
                        if (showFirstLast)
                            viewer.showFirstAndLastReferenceLine = true;
                        if (showRef || showFirstLast) {
                            viewer.refreshReferenceLine();
                        }
                    }, 350);
                }
            }
        };
        MedicalWebViewerController.prototype.updateMultiFrame = function (cell) {
            var maxStack = this._seriesManagerService.get_maxAllowedStackIndex(cell);
            var enableMultiFrame = (maxStack > 1);
            var tabId = this.get_activeTabId();
            this._toolbarService.enable(['CinePlayer' + tabId, 'Stack' + tabId], function () {
                return enableMultiFrame;
            });
        };
        MedicalWebViewerController.prototype.onStackChanged = function (event, data) {
            if (!this._cinePlayerService.isPlaying) {
                var cell = this._seriesManagerService.get_activeCell();
                if (cell) {
                    this.refreshToolbarItems(null, cell, this._authenticationService);
                }
            }
        };
        MedicalWebViewerController.prototype.onNewSubCellSelected = function (event, data) {
            var frame = data.args.frame;
            var subCell = data.args.subCell;
            var cell = subCell.get_parentCell();
            var index = cell.frames.indexOf(frame);
            var tabId = this.get_activeTabId();
            if (DicomHelper.supportWindowLevel(cell, index) && frame.isDataReady) {
                this._toolbarService.enable("WindowLevel" + tabId);
                this._toolbarService.enable("WindowLevelCustom" + tabId);
                this._toolbarService.enable("Invert" + tabId);
                this._toolbarService.disable("BrightnessContrast" + tabId);
                this._toolbarService.disable("StretchHistogram" + tabId);
                this._toolbarService.disable("HSL" + tabId);
            }
            else {
                var enable = frame == null ? false : frame.mrtiInfo != null;
                this._toolbarService.enable("WindowLevel" + tabId);
                this._toolbarService.enable("WindowLevelCustom" + tabId);
                this._toolbarService.enable(["Invert" + tabId, "BrightnessContrast" + tabId, "StretchHistogram" + tabId, "HSL" + tabId], function () {
                    return enable;
                });
                this._toolbarService.enable("Invert" + tabId);
            }
            this.enableCrossHair(data.args.subCell, data.args.frame);
        };
        MedicalWebViewerController.prototype.onDelete = function (event, key) {
            var cell = this._seriesManagerService.get_activeCell();
            if (cell == null)
                return;
            var automation = cell.get_automation();
            var tabId = this.get_activeTabId();
            if (automation == null) {
                this._commangular.dispatch('DeleteCell');
                return;
            }
            var designer = automation.currentDesigner;
            if (designer != null && designer.operationStatus)
                automation.cancel();
            else {
                if (automation.canDeleteObjects && automation.currentEditObject) {
                    this._commangular.dispatch('OnDeleteAnnotation');
                }
                else {
                    this._commangular.dispatch('DeleteCell');
                }
            }
        };
        MedicalWebViewerController.$inject = ['$scope', 'eventService', 'authenticationService', 'optionsService',
            'externalCommandHandlerService', 'tabService', 'dataService', '$modal', '$idle',
            'monitorCalibrationService', 'seriesManagerService', 'toolbarService', 'auditLogService',
            '$commangular', 'queryPacsService', '$window', 'hotkeys', 'sharedPropertiesService', 'cinePlayerService', '$timeout', '$templateCache', '$q', '$location', 'dataCache', 'objectRetrieveService', 'dialogs', 'autoService'];
        return MedicalWebViewerController;
    }());
    Controllers.MedicalWebViewerController = MedicalWebViewerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="Scopes.ts" />
var SearchController = /** @class */ (function () {
    function SearchController($rootScope, $scope, queryArchiveService, optionsService, authenticationService, queryPacsService, tabService, eventService, templateService, templateEditorService, $translate) {
        this._openWith = "Open With";
        this._templatesHasAutoMatch = false;
        var scrollTop;
        this._scope = $scope;
        this._queryArchiveService = queryArchiveService;
        this._authenticationService = authenticationService;
        this._templateService = templateService;
        this._modalities = templateEditorService.getModalities();
        this._options = optionsService;
        $scope.showPacsQuery = VersionNumber.viewerType != "Medicore" ? optionsService.get(OptionNames.ShowPacsQuery) && authenticationService.hasPermission(PermissionNames.CanQueryPACS) : false;
        $scope.querySource = {};
        $scope.querySource.name = 'database';
        $scope.querySource.pacs = null;
        $scope.isTabletOrMobile = Utils.isTabletOrMobile();
        $scope.getUrl = function (row) {
            return Utils.get_thumbnailUrl(row.entity);
        };
        queryPacsService.GetConnectionInfo().then(function (result) {
            $scope.pacsClientInfo = result.data[0];
            $scope.storageServerInfo = result.data[1];
            var pacsConfig = null;
            if (optionsService != null) {
                pacsConfig = Models.RemoteConfig.Factory(optionsService.get(OptionNames.RemoteConfig));
                if (pacsConfig) {
                    if (pacsConfig.client) {
                        $scope.pacsClientInfo.AETitle = pacsConfig.client;
                    }
                }
            }
        }.bind(this));
        if (authenticationService.hasPermission(PermissionNames.CanViewTemplates)) {
            templateService.GetAllTemplates().then(function (result) {
                if (result && result.data) {
                    this._templates = result.data;
                    Utils.Templates = this._templates;
                    this.updateTemplatesHaveAutoMatch();
                }
            }.bind(this));
        }
        eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
            var tab = tabService.find_tab(data.args.currentTab.id);
            if (tab.type == TabTypes.Search) {
                if ($scope.onSearchTabSelected) {
                    $scope.onSearchTabSelected();
                }
            }
        });
        $translate('OPEN_WITH').then(function (translation) {
            this._openWith = translation;
        }.bind(this));
        $translate('SD_OPEN_WITH').then(function (translation) {
            this._sdOpenWith = translation;
        }.bind(this));
        $scope.$watch('windowDimensions', function (newValue, oldValue) {
            if ($scope.onLayoutChanged) {
                $scope.onLayoutChanged(newValue, oldValue);
            }
        });
    }
    SearchController.prototype.get_structuredDisplay = function () {
        return this._structuredDisplay;
    };
    SearchController.prototype.set_structuredDisplay = function (value) {
        this._structuredDisplay = value;
    };
    SearchController.prototype.patientids = function (patientId) {
        if (this._options.get(OptionNames.EnablePatientIdAutoComplete)) {
            return this._queryArchiveService.AutoComplete("patientid", patientId).then(function (results) {
                var ids = new Array();
                angular.forEach(results.data, function (item) {
                    ids.push(item.Word);
                });
                return ids;
            });
        }
    };
    SearchController.prototype.patientNames = function (patientName) {
        if (this._options.get(OptionNames.EnablePatientNameAutoComplete)) {
            var term = patientName.replace(" ", "^");
            return this._queryArchiveService.AutoComplete("patientname", term).then(function (results) {
                var ids = new Array();
                angular.forEach(results.data, function (item) {
                    ids.push(item.Word);
                });
                return ids;
            });
        }
    };
    SearchController.prototype.updateTemplatesHaveAutoMatch = function () {
        if (this._templates) {
            for (var i = 0; i < this._templates.length; i++) {
                var template = this._templates[i];
                if (template.AutoMatching) {
                    this._templatesHasAutoMatch = true;
                    return;
                }
            }
        }
        this._templatesHasAutoMatch = false;
    };
    SearchController.prototype.createStructuredDisplayFromTemplate = function (template, studyInstanceUID, seriesInstanceUID) {
        var output = {};
        var input = template.Frames ? template.Frames : template.Boxes;
        var index = 0;
        var length = input.length;
        var box;
        var frame;
        output.Boxes = [];
        output.Rows = -1;
        output.Columns = -1;
        output.Name = template.Name;
        output.OtherStudies = [];
        output.Series = [];
        for (index = 0; index < length; index++) {
            frame = input[index];
            box = {};
            box.ColumnPosition = frame.ColumnPosition ? frame.ColumnPosition : -1;
            box.FirstFrame = frame.FirstFrame ? frame.FirstFrame : {};
            box.HorizontalJustification = frame.HorizontalJustification;
            box.VerticalJustification = frame.VerticalJustification;
            box.ImageBoxLargeScrollAmount = frame.ImageBoxLargeScrollAmount;
            box.ImageBoxLargeScrollType = frame.ImageBoxLargeScrollType ? frame.ImageBoxLargeScrollType : 0;
            box.ImageBoxLayoutType = frame.ImageBoxLayoutType ? frame.ImageBoxLayoutType : 4;
            box.ImageBoxNumber = frame.FrameNumber ? frame.FrameNumber : index + 1;
            box.ImageBoxScrollDirection = frame.ImageBoxScrollDirection;
            box.ImageBoxSmallScrollAmount = frame.ImageBoxSmallScrollAmount;
            box.ImageBoxSmallScrollType = frame.ImageBoxSmallScrollType;
            box.ImageBoxTileHorizontalDimension = frame.ImageBoxTileHorizontalDimension ? frame.ImageBoxTileHorizontalDimension : 1;
            box.ImageBoxTileVerticalDimension = frame.ImageBoxTileVerticalDimension ? frame.ImageBoxTileVerticalDimension : 1;
            box.NumberOfColumns = frame.NumberOfColumns ? frame.NumberOfColumns : 0;
            box.NumberOfRows = frame.NumberOfRows ? frame.NumberOfRows : 0;
            box.Position = {
                leftTop: { x: frame.Position.leftTop.x, y: frame.Position.leftTop.y }, rightBottom: { x: frame.Position.rightBottom.x, y: frame.Position.rightBottom.y }
            };
            // to handle the case where the y is calculate from top left or bottom left;
            if (box.Position.rightBottom.y < box.Position.leftTop.y) {
                var temp = box.Position.rightBottom.y;
                box.Position.rightBottom.y = box.Position.leftTop.y;
                box.Position.leftTop.y = temp;
            }
            box.PreferredPlaybackSequencing = frame.PreferredPlaybackSequencing;
            box.RecommendedDisplayFrameRate = frame.RecommendedDisplayFrameRate;
            box.ReferencedPresentationStateSOP = frame.ReferencedPresentationStateSOP ? frame.ReferencedPresentationStateSOP : "";
            box.RowPosition = frame.RowPosition ? frame.RowPosition : -1;
            box.WindowCenter = frame.WindowWidth ? frame.WindowWidth : -1;
            box.WindowWidth = frame.WindowCenter ? frame.WindowCenter : -1;
            box.referencedSOPInstanceUID = frame.referencedSOPInstanceUID;
            box.FrameNumber = frame.FrameNumber;
            box.SequenceNumber = frame.SequenceNumber;
            box.Rotation = frame.Rotation;
            box.PresentationSizeMode = frame.PresentationSizeMode;
            box.Magnification = frame.Magnification;
            box.ImageComments = frame.ImageComments;
            box.AnatomicDescription = frame.AnatomicDescription;
            box.Script = frame.Script;
            box.Flip = frame.Flip;
            box.Reverse = frame.Reverse;
            box.Invert = frame.Invert;
            output.Boxes[index] = box;
        }
        output.Series[0] = { StudyInstanceUID: studyInstanceUID, SeriesInstanceUID: seriesInstanceUID };
        return output;
    };
    SearchController.prototype.getTemplateMenu = function (modality) {
        var menuItems = {};
        if (this._templates) {
            var noMatchTemplates = new Array();
            for (var i = 0; i < this._templates.length; i++) {
                var template = this._templates[i];
                if (this.isTemplateMatch(modality, template)) {
                    var item = {};
                    menuItems[template.Id] = {
                        name: template.Name
                    };
                }
                else {
                    noMatchTemplates.push(template);
                }
            }
            if (!$.isEmptyObject(menuItems) && noMatchTemplates.length > 0) {
                menuItems["seperator"] = "-----";
            }
            if (noMatchTemplates.length > 0) {
                menuItems["nonmatching"] = {
                    name: "Other Templates",
                    items: {}
                };
                for (var i = 0; i < noMatchTemplates.length; i++) {
                    var template = noMatchTemplates[i];
                    menuItems["nonmatching"]["items"][template.Id] = {
                        name: template.Name
                    };
                }
            }
        }
        return menuItems;
    };
    SearchController.prototype.isTemplateMatch = function (modality, template) {
        var data = template.Modality.split('|');
        var modalities;
        if (data.length == 0)
            return false;
        if (data.length == 1) {
            modalities = $.grep(this._modalities, function (modality, index) {
                return modality.classType == data[0];
            });
        }
        else {
            modalities = $.grep(this._modalities, function (modality, index) {
                return modality.classType == data[0] && modality.description == data[1];
            });
        }
        if (modalities.length > 0) {
            return modalities[0].name == modality;
        }
        return false;
    };
    SearchController.prototype.getTemplate = function (id) {
        return Utils.findFirst(this._templates, function (template) {
            return id == template.Id;
        });
    };
    SearchController.prototype.getAutoMatchTemplates = function () {
        if (!this._templates) {
            var el = new Array();
            return el;
        }
        return Utils.findAll(this._templates, function (template) {
            return template.AutoMatching;
        });
    };
    SearchController.prototype.isAnyTemplateAutoMatch = function () {
        return this._templatesHasAutoMatch;
    };
    SearchController.$inject = ["$rootScope", "$scope", "queryArchiveService", "optionsService", "authenticationService", "queryPacsService", "tabService", "eventService", "templateService", "templateEditorService", "$translate"];
    return SearchController;
}());
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/custom.d.ts" />
/// <reference path="Scopes.ts" />
/// <reference path="SearchController.ts" />
var Controllers;
(function (Controllers) {
    var DentalSearchViewController = /** @class */ (function (_super) {
        __extends(DentalSearchViewController, _super);
        function DentalSearchViewController($rootScope, $scope, $modal, uiGridConstants, eventService, queryArchiveService, optionsService, dataService, authenticationService, queryPacsService, seriesManagerService, tabService, templateService, templateEditorService, objectRetrieveService, $translate, toolbarService) {
            var _this_1 = this;
            var __this;
            var selection;
            var patientGroup = "Patients";
            var seriesGroup = "Series";
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var timeFormat = optionsService.get(OptionNames.TimeFormat);
            _this_1 = _super.call(this, $rootScope, $scope, queryArchiveService, optionsService, authenticationService, queryPacsService, tabService, eventService, templateService, templateEditorService, $translate) || this;
            __this = _this_1;
            _this_1._$scope = $scope;
            _this_1._seriesManagerService = seriesManagerService;
            _this_1._eventService = eventService;
            _this_1._queryArchiveService = queryArchiveService;
            _this_1._queryPacsService = queryPacsService;
            _this_1._optionsService = optionsService;
            _this_1._tabService = tabService;
            _this_1._dataService = dataService;
            _this_1._objectRetrieveService = objectRetrieveService;
            _this_1._viewStudy = false;
            _this_1._rowIndexPrevious = -1;
            _this_1._toolbarService = toolbarService;
            _this_1._patientDataRange_from = 0;
            _this_1._patientDataRange_pageSize = parseInt(optionsService.get(OptionNames.SearchPageSize));
            $scope.hpContextMenu = _this_1.hpContextMenu.bind(_this_1);
            $scope.handleCellClicked = _this_1.handleCellClicked.bind(_this_1);
            $scope.patientids = $.proxy(_this_1.patientids, _this_1);
            $scope.patientNames = $.proxy(_this_1.patientNames, _this_1);
            _this_1._tabService.set_tabData(_this_1._tabService.tabs[0].id, TabDataKeys.searchViewerController, _this_1);
            _this_1._patientSelected = false;
            $scope.gridOptions = {
                rowSelection: 'single',
                rowClass: 'patientContext',
                groupHeaders: true,
                suppressNoRowsOverlay: true,
                columnDefs: [
                    {
                        headerName: patientGroup,
                        children: [
                            {
                                headerName: "",
                                cellRenderer: Utils.countRenderer,
                                width: 29,
                                onCellContextMenu: _this_1.hpContextMenu.bind(_this_1),
                                suppressSizeToFit: true
                            },
                            {
                                headerName: "Patient ID",
                                field: "ID",
                                onCellContextMenu: _this_1.hpContextMenu.bind(_this_1),
                            },
                            {
                                headerName: "Name",
                                onCellContextMenu: _this_1.hpContextMenu.bind(_this_1),
                                valueGetter: function (params) {
                                    return Utils.nameFormatter(params.data.Name);
                                }
                            },
                            {
                                headerName: "Sex",
                                onCellContextMenu: _this_1.hpContextMenu.bind(_this_1),
                                field: "Sex"
                            },
                            {
                                headerName: "Birth Date",
                                onCellContextMenu: _this_1.hpContextMenu.bind(_this_1),
                                field: "BirthDate",
                                cellRenderer: Utils.dateRenderer
                            }
                        ]
                    }
                ],
                onRowSelected: _this_1.patientSelected.bind(_this_1),
                rowData: null,
                onGridReady: function () {
                    $scope.gridOptions.api.hideOverlay();
                    setTimeout(function () {
                        $scope.gridOptions.api.sizeColumnsToFit();
                    }, 500);
                    $.contextMenu({
                        selector: '.patientContext',
                        trigger: 'none',
                        className: 'data-title',
                        build: function ($trigger, e) {
                            return {
                                callback: function (key, options) {
                                    __this._seriesManagerService.currentPatientSeries = __this._$scope.gridOptionsSeries.rowData;
                                    var index = 0;
                                    var length = __this._localStructuredDisplay.length;
                                    for (index = 0; index < length; index++) {
                                        if (__this._localStructuredDisplay[index].SeriesInstanceUID == key) {
                                            __this._seriesManagerService.currentLoadingSeries = __this.getSelectedSeries(__this._localStructuredDisplay[index]);
                                            __this._seriesManagerService.structuredDisplayList = __this._localStructuredDisplay;
                                            __this._seriesManagerService._currentStructuredDisplay = __this._localStructuredDisplay[index];
                                            __this.loadselectedStructureDisplay(__this._localStructuredDisplay[index]);
                                            return;
                                        }
                                    }
                                },
                                items: __this.get_PatientStructuredDisplayItems()
                            };
                        }
                    });
                }
            };
            $scope.gridOptionsSeries = {
                rowSelection: 'single',
                suppressNoRowsOverlay: true,
                suppressLoadingOverlay: false,
                groupHeaders: true,
                rowClass: 'seriesContext',
                rowHeight: parseInt(optionsService.get(OptionNames.SeriesThumbnailHeight)),
                overlayNoRowsTemplate: '<span style="padding: 10px; border: 2px solid #444; background: lightgoldenrodyellow;">No Series Found</span>',
                overlayLoadingTemplate: '<span class="ag-overlay-loading-center">Loading Series...</span>',
                columnDefs: [
                    {
                        headerName: seriesGroup,
                        children: [
                            {
                                headerName: "",
                                cellRenderer: Utils.has_mrtiRenderer,
                                width: 29,
                                suppressSizeToFit: true,
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            },
                            {
                                headerName: "",
                                cellRenderer: Utils.thumbnailRenderer,
                                hide: !optionsService.get(OptionNames.ShowSearchThumbnails),
                                width: parseInt(optionsService.get(OptionNames.SeriesThumbnailWidth)),
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1),
                            },
                            {
                                headerName: 'Number', field: 'Number',
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            },
                            {
                                headerName: 'Series Date', field: 'Date',
                                cellRenderer: Utils.dateRenderer,
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            },
                            {
                                headerName: 'Description',
                                field: 'Description',
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            },
                            {
                                headerName: 'Modality',
                                field: 'Modality',
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            },
                            {
                                headerName: 'Instances',
                                field: 'NumberOfRelatedInstances',
                                onCellContextMenu: _this_1.contextMenu.bind(_this_1)
                            }
                        ]
                    }
                ],
                onRowSelected: _this_1.seriesSelected.bind(_this_1),
                rowData: null,
                onGridReady: function () {
                    $scope.gridOptionsSeries.api.hideOverlay();
                    $.contextMenu({
                        selector: '.seriesContext',
                        trigger: 'none',
                        className: 'data-title',
                        build: function ($trigger, e) {
                            return {
                                callback: function (key, options) {
                                    var rawData = __this._$scope.gridOptionsSeries.rowData[0];
                                    __this.loadStructuredDisplayFromTemplate(__this.getTemplate(key), rawData.InstanceUID, rawData.StudyInstanceUID);
                                    return;
                                },
                                items: __this.getTemplateMenu(__this._selectedSeries.Modality)
                            };
                        }
                    });
                    setTimeout(function () {
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    }, 500);
                }
            };
            $scope.queryOptions = new Models.QueryOptions();
            $scope.queryOptions.PatientsOptions.PatientID = '';
            $scope.pacsConnections = queryPacsService.remoteConnections;
            $scope.dateFormat = dateFormat;
            $scope.patient_data_from = 0;
            $scope.toolbar_height = "100%";
            $scope.patient_data_to = 0;
            $scope.patient_data_total = 0;
            $scope.patient_data_page_from = 0;
            $scope.patient_data_page_total = 0;
            $scope.dateOptions = {
                'show-weeks': false
            };
            $scope.datePicker = {};
            $scope.datePicker.dateStartOpened = false;
            $scope.datePicker.dateEndOpened = false;
            selection = $scope.pacsConnections.filter(function (connection, index, array) {
                return connection.isDefault;
            });
            $scope.textFocused = function (event) {
                event.currentTarget.placeholder = dateFormat;
            };
            $scope.seriesToChanged = function (event) {
                if (event.currentTarget)
                    $scope.queryOptions.SeriesOptions.SeriesDateEnd = event.currentTarget.value;
            };
            $scope.seriesFromChanged = function (event) {
                if (event.currentTarget)
                    $scope.queryOptions.SeriesOptions.SeriesDateStart = event.currentTarget.value;
            };
            window.addEventListener('keydown', function (e) {
                if (e.keyCode == 34) {
                    $scope.nextPage();
                }
                else if (e.keyCode == 33) {
                    $scope.previousPage();
                }
                else if (e.keyCode == 35) {
                    $scope.lastPage();
                }
                else if (e.keyCode == 36) {
                    $scope.firstPage();
                }
            }, false);
            if (selection.length > 0) {
                $scope.querySource.pacs = selection[0];
            }
            $scope.updatePatientDataList = function () {
                var rangedPatientData = $scope.getPatientDataRange();
                $scope.gridOptions.api.setRowData(rangedPatientData);
            };
            $scope.nextPage = function () {
                if ((__this._patientDataRange_from + __this._patientDataRange_pageSize) > __this._patientData.length)
                    return;
                __this._patientDataRange_from += __this._patientDataRange_pageSize;
                $scope.updatePatientDataList();
            };
            $scope.lastPage = function () {
                __this._patientDataRange_from = Math.floor(__this._patientData.length / __this._patientDataRange_pageSize) * __this._patientDataRange_pageSize;
                $scope.updatePatientDataList();
            };
            $scope.firstPage = function () {
                if (__this._patientDataRange_from <= 0)
                    return;
                __this._patientDataRange_from = 0;
                $scope.updatePatientDataList();
            };
            $scope.previousPage = function () {
                if (__this._patientDataRange_from <= 0)
                    return;
                __this._patientDataRange_from -= __this._patientDataRange_pageSize;
                $scope.updatePatientDataList();
            };
            $scope.cantPageForward = function () {
                if (!__this._patientData)
                    return true;
                return (__this._patientDataRange_from + __this._patientDataRange_pageSize) >= __this._patientData.length;
            };
            $scope.cantPageBackward = function () {
                if (!__this._patientData)
                    return true;
                return __this._patientDataRange_from <= 0;
            };
            $scope.updatePagingToolbar = function () {
                Utils.countRenderer_StartIndex = __this._patientDataRange_from;
                $scope.patient_data_from = __this._patientDataRange_from + 1;
                $scope.patient_data_to = Math.min(__this._patientData.length, __this._patientDataRange_from + __this._patientDataRange_pageSize);
                $scope.patient_data_total = __this._patientData.length;
                $scope.patient_data_page_from = Math.floor(__this._patientDataRange_from / __this._patientDataRange_pageSize) + 1;
                $scope.patient_data_page_total = Math.ceil(__this._patientData.length / __this._patientDataRange_pageSize);
            };
            $scope.showPagingTool = function () {
                if (__this._patientData) {
                    var show = __this._patientDataRange_pageSize < __this._patientData.length;
                    $scope.toolbar_height = show ? "calc(100% - 40px)" : "100%";
                    return show;
                }
                $scope.toolbar_height = "100%";
                return false;
            };
            $scope.getPatientDataRange = function () {
                var index = __this._patientDataRange_from;
                var length = index + __this._patientDataRange_pageSize;
                length = Math.min(__this._patientData.length, length);
                var counter = 0;
                var output = [];
                for (; index < length; index++) {
                    output[counter++] = __this._patientData[index];
                }
                $scope.updatePagingToolbar();
                return output;
            };
            $scope.doSearch = function () {
                __this.set_patientSelected(false);
                var queryOptions = angular.copy($scope.queryOptions);
                if (angular.isDefined(queryOptions.PatientsOptions.PatientName)) {
                    var m = queryOptions.PatientsOptions.PatientName.match(/"(.*?)"/);
                    if (m == null) {
                        queryOptions.PatientsOptions.PatientName = queryOptions.PatientsOptions.PatientName.replace(' ', '^');
                    }
                    else {
                        queryOptions.PatientsOptions.PatientName = m[1].replace(/"/g, '');
                    }
                }
                __this._selectedSeries = null;
                this.gridOptions.api.setRowData([]);
                this.gridOptionsSeries.api.setRowData([]);
                this.gridOptionsSeries.api.hideOverlay();
                switch ($scope.querySource.name) {
                    case 'database':
                        queryArchiveService.FindPatients(queryOptions, "10000").then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    __this._$scope.gridOptionsSeries.api.hideOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                eventService.publish(EventNames.SearchPatientsSuccess, result.data);
                                __this._patientDataRange_from = 0;
                                __this._patientData = result.data;
                                var rangedPatientData = $scope.getPatientDataRange();
                                $scope.gridOptions.api.setRowData(rangedPatientData);
                            }
                        }, function (error) {
                        });
                        break;
                    case 'pacs':
                        queryPacsService.FindPatients($scope.querySource.pacs, queryPacsService.clientAETitle, queryOptions).then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    __this._$scope.gridOptionsSeries.api.hideOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                eventService.publish(EventNames.SearchPatientsSuccess, result.data);
                                __this._patientData = result.data;
                                var rangedPatientData = $scope.getPatientDataRange();
                                $scope.gridOptions.api.setRowData(rangedPatientData);
                            }
                        }, function (error) {
                            eventService.publish("Search/Study/Failure", { error: error });
                        });
                        break;
                }
            };
            $scope.clear = function () {
                $scope.queryOptions = new Models.QueryOptions();
                $scope.queryOptions.SeriesOptions.SeriesDateStart = null;
                $scope.queryOptions.SeriesOptions.SeriesDateEnd = null;
                this.gridOptions.api.setRowData([]);
                this.gridOptionsSeries.api.setRowData([]);
                this._selectedSeries = null;
                __this._patientData = null;
            };
            $scope.OnSeriesSearchError = function (data, status) {
                eventService.publish(EventNames.SearchSeriesFailure, { data: data, status: status });
            };
            $scope.openDateStart = function ($event) {
                $event.preventDefault();
                $event.stopPropagation();
                $scope.datePicker.dateStartOpened = !$scope.datePicker.dateStartOpened;
            };
            $scope.openDateEnd = function ($event) {
                $event.preventDefault();
                $event.stopPropagation();
                $scope.datePicker.dateEndOpened = !$scope.datePicker.dateEndOpened;
            };
            $scope.queryModeChanged = function () {
                $scope.clear();
            };
            $scope.onLayoutChanged = function (newValue, oldValue) {
                setTimeout(function () {
                    try {
                        $scope.gridOptions.api.sizeColumnsToFit();
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    }
                    catch (e) {
                    }
                }, 250);
            };
            $scope.onSearchTabSelected = function () {
                setTimeout(function () {
                    var studyNodes = $scope.gridOptions.api.getSelectedNodes();
                    var seriesNodes = $scope.gridOptions.api.getSelectedNodes();
                    $scope.gridOptions.api.sizeColumnsToFit();
                    $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    $scope.gridOptions.api.refreshView();
                    $scope.gridOptionsSeries.api.refreshView();
                    if (studyNodes.length > 0) {
                        $scope.gridOptions.api.ensureNodeVisible(studyNodes[0]);
                    }
                    if (seriesNodes.length > 0) {
                        $scope.gridOptionsSeries.api.ensureNodeVisible(seriesNodes[0]);
                    }
                }, 225);
            };
            $scope.$watch('windowDimensions', function (newValue, oldValue) {
                if ($scope.gridOptions.api) {
                    setTimeout(function () {
                        $scope.gridOptions.api.sizeColumnsToFit();
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    }, 500);
                }
            });
            // when the first frame is loaded, then you can removing the loading background from the series list in the search tab.
            eventService.subscribe(EventNames.SeriesLoading, function (event, data) {
                if (__this._$scope != null) {
                    if (__this._$scope.gridOptionsSeries != null) {
                        if (__this._$scope.gridOptionsSeries.api != null) {
                            __this._$scope.gridOptionsSeries.api.hideOverlay();
                        }
                    }
                }
            });
            eventService.subscribe(EventNames.LoadSelectedSeries, function (event, data) {
                var input = {};
                input.node = {};
                input.node.data = data.args.data;
                var study = [];
                study[0] = {};
                study[0].data = input.node.data.Patient;
                __this._seriesManagerService.currentLoadingSeries = data.args.data;
                __this._seriesManagerService.currentPatientSeries = data.args.study;
                __this._selectedSeries = data.args.data;
                __this._selectedStudy = input.node.data.Patient;
                if (__this._selectedSeries.Boxes != undefined) {
                    __this._seriesManagerService.currentPatientSeries = data.args.study;
                    __this._seriesManagerService.currentLoadingSeries = data.args.data;
                    __this._seriesManagerService.currentStructuredDisplay = __this._selectedSeries;
                    __this._templateService.currentStudyLayout = __this._selectedSeries;
                    __this.loadselectedStructureDisplay(__this._selectedSeries);
                    __this._eventService.publish(EventNames.StructuredDisplaySelected, {
                        structureDisplay: __this._selectedSeries,
                    });
                }
                else {
                    __this.matchTemplateForSeries(input, study);
                }
            });
            eventService.subscribe(EventNames.LoadFromOverflow, function (event, data) {
                var cell = data.args.cell;
                // delete the cell that we are dragging, then load the newly dragged cell.
                if (cell) {
                    cell.viewer.layout.get_items().remove(cell);
                    if (cell.get_automation) {
                        Utils.disposeAutomation(cell.get_automation());
                    }
                    __this._seriesManagerService.remove_cell(cell);
                    __this._seriesManagerService.set_activeCell(cell.divID);
                    cell.dispose();
                }
                __this.queryForSeries(__this, data.args.SeriesInstanceUID, data.args.ImageBoxNumber, data.args.SopInstanceUID, true /*data.args.structuredDisplay*/, __this._templateService.currentStudyLayoutID);
            }.bind(_this_1));
            eventService.subscribe(EventNames.MrtiInfoReady, function (event, data) {
                if (this._$scope && this._$scope.gridOptionsSeries) {
                    Utils.clearMrti(this._$scope.gridOptionsSeries.api, this._$scope.gridOptionsSeries.rowData, data.args.seriesInstanceUID);
                }
            }.bind(_this_1));
            eventService.subscribe(EventNames.OnFrameLoaded, function (event, data) {
                var cell = data.args.cell;
                var patient = __this._queryArchiveService.get_PatientData(cell.seriesInstanceUID);
                if (__this._templateService.currentStudyLayout) {
                    patient.LoadedBoxes--;
                    var tab = __this.getPatientTab(patient[0].Patient.ID, __this._tabService);
                    if (patient.LoadedBoxes < 1) {
                        if (authenticationService.hasPermission(PermissionNames.CanExport))
                            __this._toolbarService.enable("PopupCapture" + tab.id);
                    }
                }
                else {
                    eventService.publish(EventNames.RefreshToolbar, {
                        cell: null,
                        tab: tab,
                        viewer: null
                    });
                }
            });
            eventService.subscribe(EventNames.ToolbarCreated, function (event, data) {
                //var cell: lt.Controls.Medical.Cell = data.args.cell;
                //var patient = __this._queryArchiveService.get_PatientData(cell.seriesInstanceUID);
                //if (__this._templateService.currentStudyLayout) {
                //    patient.LoadedBoxes = 0;
                //    var tab: Models.Tab = __this.getPatientTab(patient[0].Patient.ID, __this._tabService);
                //    __this._toolbarService.disable("PopupCapture" + tab.id);
                //}
                //else {
                //    eventService.publish(EventNames.RefreshToolbar, {
                //        cell: null,
                //        tab: tab,
                //        viewer: null
                //    });
                //}
            });
            return _this_1;
        }
        DentalSearchViewController.prototype.get_patientSelected = function () {
            return this._patientSelected;
        };
        DentalSearchViewController.prototype.set_patientSelected = function (value) {
            this._patientSelected = value;
        };
        DentalSearchViewController.prototype.get_selectedSeries = function () {
            return this._selectedSeries;
        };
        DentalSearchViewController.prototype.set_selectedSeries = function (series) {
            this._selectedSeries = series;
        };
        DentalSearchViewController.prototype.get_selectedPatient = function () {
            return this._selectedPatient;
        };
        DentalSearchViewController.prototype.getSelectedSeries = function (structureDisplay, usedList) {
            var seriesInstanceUID = structureDisplay.Series[0].SeriesInstanceUID;
            var studyInstanceUID = structureDisplay.Series[0].StudyInstanceUID;
            var index = 0;
            var seriesArray = usedList ? this._queryArchiveService._currentPatientSeries : this._$scope.gridOptionsSeries.rowData;
            if (!seriesArray) {
                seriesArray = this._seriesManagerService.currentPatientSeries;
            }
            var length = seriesArray.length;
            for (index = 0; index < length; index++) {
                if (seriesArray[index].InstanceUID) {
                    if (seriesArray[index].InstanceUID == seriesInstanceUID)
                        return seriesArray[index];
                }
                else {
                    if (seriesArray[index].StudyInstanceUID == studyInstanceUID)
                        return seriesArray[index];
                }
            }
        };
        DentalSearchViewController.prototype.get_PatientStructuredDisplayItems = function () {
            var menuItems = {};
            for (var i = 0; i < this._localStructuredDisplay.length; i++) {
                var protocolResult = this._localStructuredDisplay[i];
                menuItems[protocolResult.Name] = {
                    name: protocolResult.Name
                };
            }
            return menuItems;
        };
        DentalSearchViewController.prototype.handleCellClicked = function (params) {
            if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device != lt.LTDevice.desktop) {
                if (this._rowIndexPrevious == params.rowIndex) {
                    if (this._viewStudy == false) {
                        this._$scope.hpContextMenu(params);
                    }
                }
                this._rowIndexPrevious = params.rowIndex;
            }
        };
        // get the data, find if the series {seriesInstanceUID} is in there, and load it.
        DentalSearchViewController.prototype.loadSeriesFromData = function (data, seriesInstanceUID, imageBoxNumber, sopInstanceList, loadstructureDisplay, sdID, templateItem) {
            if (data["FaultType"]) {
                if (data["Message"]) {
                    alert(data["Message"]);
                }
            }
            else {
                var index = 0;
                var length = data.length;
                var seriesData = null;
                var item = data.get_PatientData(seriesInstanceUID);
                length = item.length;
                for (index = 0; index < length; index++) {
                    if (item[index].InstanceUID == seriesInstanceUID) {
                        seriesData = JSON.parse(JSON.stringify(item[index]));
                        break;
                    }
                }
                if (seriesData) {
                    // if this is not an over flow image, then add it to the list of loaded boxes of the structured display.
                    if (imageBoxNumber != -1)
                        item.LoadedBoxes++;
                    seriesData.ImageBoxNumber = imageBoxNumber; // studyLayout.ImageBoxNumber;
                    seriesData.SopInstanceUIDs = sopInstanceList;
                    this.loadSeries({ InstanceUID: seriesData.StudyInstanceUID, sdID: sdID, templateItem: templateItem }, seriesData, loadstructureDisplay);
                }
            }
        };
        DentalSearchViewController.prototype.queryForSeries = function (self, seriesInstanceUID, imageBoxNumber, sopInstanceUidList, loadstructureDisplay, sdID, templateItem) {
            var query = new Models.QueryOptions;
            var _seriesInstanceUID = seriesInstanceUID;
            var _imageBoxNumber = imageBoxNumber;
            var _sopInstanceList = sopInstanceUidList;
            query.SeriesOptions.SeriesInstanceUID = _seriesInstanceUID;
            // optimizing the speed, we just got the series information when we clicked on the patient for the first time, so we saved the results for this.
            if (self._queryArchiveService._currentPatientSeries != null) {
                setTimeout(function () {
                    var data = self._queryArchiveService._currentPatientSeries;
                    self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID, templateItem);
                }, 1);
            }
            else {
                switch (self._$scope.querySource.name) {
                    case 'database':
                        self._queryArchiveService.FindSeries(query, 1).then(function (result) {
                            var imageData = result.data;
                            if (imageData.length)
                                imageData = result.data[0];
                            self._queryArchiveService._currentPatientSeriesArray[imageData.Patient.ID] = result.data;
                            self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID);
                        });
                        break;
                    case 'pacs':
                        self._queryPacsService.FindSeries(self._$scope.querySource.pacs, self._queryPacsService.clientAETitle, query).then(function (result) {
                            var imageData = result.data;
                            if (imageData.length)
                                imageData = result.data[0];
                            self._queryArchiveService._currentPatientSeriesArray[imageData.Patient.ID] = result.data;
                            self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID);
                        });
                        break;
                }
            }
        };
        DentalSearchViewController.prototype.loadSeries = function (study, series, loadstructureDisplay) {
            this._eventService.publish(EventNames.SeriesSelected, {
                study: study,
                series: series,
                remote: this._$scope.querySource.name == 'pacs',
                structureDisplay: loadstructureDisplay,
                templateItem: study.templateItem,
                studyLoad: true,
                dentalSearchController: this
            });
        };
        DentalSearchViewController.prototype.getStructredDisplayInstancesInfo = function (data) {
            var seriesList = [];
            var self = this;
            var index = 0;
            var length = data.Series.length;
            for (index = 0; index < length; index++) {
                if (seriesList.indexOf(data.Series[index].SeriesInstanceUID) == -1)
                    seriesList.add(data.Series[index].SeriesInstanceUID);
            }
            //console.clear();
            //Utils.debug_timer = (new Date()).getTime();
            return this._queryArchiveService.FindSeriesArrayInstances(seriesList).then(function (result) {
                var output = {};
                var data = result.data;
                var seriesInstanceUID;
                if (data == null)
                    return;
                index = 0;
                length = data.length;
                for (index = 0; index < length; index++) {
                    seriesInstanceUID = data[index].SeriesInstanceUID;
                    if (!output[seriesInstanceUID]) {
                        output[seriesInstanceUID] = [];
                    }
                    output[seriesInstanceUID].add(data[index]);
                }
                self._seriesManagerService.SeriesInstancesList = output;
                //alert(((new Date()).getTime() - Utils.debug_timer).toString());
                return;
            });
        };
        DentalSearchViewController.prototype.matchItemToTemplate = function (series, studyInstanceUID, seriesInstanceUID, structuredDisplay) {
            var __this = this;
            var sopInstanceUID = series.SOPInstanceUID;
            // load the json for every frame and see where it fits in the viewer.
            this._objectRetrieveService.GetDicomJSON(studyInstanceUID, seriesInstanceUID, sopInstanceUID).then(function (result) {
                var json = JSON.parse(result.data);
                var loaded = false;
                var length = structuredDisplay.Boxes.length;
                for (var index = 0; index < length; index++) {
                    var box = structuredDisplay.Boxes[index];
                    if (Utils.isInstanceOfSOP(box, json, sopInstanceUID, DicomHelper.getDicomTagValue(json, DicomTag.InstanceNumber, 0))) {
                        var frameOFRefrences = [];
                        if (box && !box.IsMapped) {
                            box.IsMapped = true;
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                // array of 1 item.
                                frameOFRefrences = [sopInstanceUID];
                                // load the frame on a seprate cell.
                                __this.queryForSeries(__this, seriesInstanceUID, box.ImageBoxNumber, frameOFRefrences, true, structuredDisplay.ID, box);
                                loaded = true;
                                structuredDisplay.LoadedItems++;
                            }
                        }
                    }
                }
                if (!loaded) {
                    __this.queryForSeries(__this, seriesInstanceUID, -1, series, true, structuredDisplay.ID);
                    structuredDisplay.LoadedItems++;
                    structuredDisplay.OverflowItems++;
                }
                // if we load all the images but found out that none of them was overflow image, then we need to close the overflow window.
                if (structuredDisplay.TotalNumber == structuredDisplay.LoadedItems) {
                    if (structuredDisplay.OverflowItems == 0) {
                        var tab = __this.getPatientTab(structuredDisplay.PatientID, __this._tabService);
                        __this._eventService.publish(EventNames.InstanceOverflowClose, { seriesInstanceUID: seriesInstanceUID, tab: tab });
                    }
                }
            });
        };
        DentalSearchViewController.prototype.createStructuredDisplayFromTemplate = function (template, studyInstanceUID, seriesInstanceUID) {
            var output = {};
            var input = template.Frames ? template.Frames : template.Boxes;
            var index = 0;
            var length = input.length;
            var box;
            var frame;
            output.Boxes = [];
            output.Rows = -1;
            output.Columns = -1;
            output.Name = template.Name;
            output.OtherStudies = [];
            output.Series = [];
            for (index = 0; index < length; index++) {
                frame = input[index];
                box = {};
                box.ColumnPosition = frame.ColumnPosition ? frame.ColumnPosition : -1;
                box.FirstFrame = frame.FirstFrame ? frame.FirstFrame : {};
                box.HorizontalJustification = frame.HorizontalJustification;
                box.VerticalJustification = frame.VerticalJustification;
                box.ImageBoxLargeScrollAmount = frame.ImageBoxLargeScrollAmount;
                box.ImageBoxLargeScrollType = frame.ImageBoxLargeScrollType ? frame.ImageBoxLargeScrollType : 0;
                box.ImageBoxLayoutType = frame.ImageBoxLayoutType ? frame.ImageBoxLayoutType : 4;
                box.ImageBoxNumber = frame.FrameNumber ? frame.FrameNumber : index + 1;
                box.ImageBoxScrollDirection = frame.ImageBoxScrollDirection;
                box.ImageBoxSmallScrollAmount = frame.ImageBoxSmallScrollAmount;
                box.ImageBoxSmallScrollType = frame.ImageBoxSmallScrollType;
                box.ImageBoxTileHorizontalDimension = frame.ImageBoxTileHorizontalDimension ? frame.ImageBoxTileHorizontalDimension : 1;
                box.ImageBoxTileVerticalDimension = frame.ImageBoxTileVerticalDimension ? frame.ImageBoxTileVerticalDimension : 1;
                box.NumberOfColumns = frame.NumberOfColumns ? frame.NumberOfColumns : 0;
                box.NumberOfRows = frame.NumberOfRows ? frame.NumberOfRows : 0;
                box.Position = {
                    leftTop: { x: frame.Position.leftTop.x, y: frame.Position.leftTop.y }, rightBottom: { x: frame.Position.rightBottom.x, y: frame.Position.rightBottom.y }
                };
                // to handle the case where the y is calculate from top left or bottom left;
                if (box.Position.rightBottom.y < box.Position.leftTop.y) {
                    var temp = box.Position.rightBottom.y;
                    box.Position.rightBottom.y = box.Position.leftTop.y;
                    box.Position.leftTop.y = temp;
                }
                box.PreferredPlaybackSequencing = frame.PreferredPlaybackSequencing;
                box.RecommendedDisplayFrameRate = frame.RecommendedDisplayFrameRate;
                box.ReferencedPresentationStateSOP = frame.ReferencedPresentationStateSOP ? frame.ReferencedPresentationStateSOP : "";
                box.RowPosition = frame.RowPosition ? frame.RowPosition : -1;
                box.WindowCenter = frame.WindowWidth ? frame.WindowWidth : -1;
                box.WindowWidth = frame.WindowCenter ? frame.WindowCenter : -1;
                box.referencedSOPInstanceUID = frame.referencedSOPInstanceUID;
                box.FrameNumber = frame.FrameNumber;
                box.SequenceNumber = frame.SequenceNumber;
                box.Rotation = frame.Rotation;
                box.PresentationSizeMode = frame.PresentationSizeMode;
                box.Magnification = frame.Magnification;
                box.ImageComments = frame.ImageComments;
                box.AnatomicDescription = frame.AnatomicDescription;
                box.Script = frame.Script;
                box.Flip = frame.Flip;
                box.Reverse = frame.Reverse;
                box.Invert = frame.Invert;
                output.Boxes[index] = box;
            }
            output.Series[0] = { StudyInstanceUID: studyInstanceUID, SeriesInstanceUID: seriesInstanceUID };
            return output;
        };
        // when you get a template, convert the template value into a structred display format.
        DentalSearchViewController.prototype.loadStructuredDisplayFromTemplate = function (template, seriesInstanceUID, studyInstanceUID) {
            var structuredDisplay = this.createStructuredDisplayFromTemplate(template, studyInstanceUID, seriesInstanceUID);
            // converted structured display (structuredDisplay)
            var self = this;
            this._seriesManagerService.currentLoadingSeries = this.getSelectedSeries(structuredDisplay, false);
            this._seriesManagerService.structuredDisplayList = this._localStructuredDisplay;
            this._seriesManagerService.currentStructuredDisplay = structuredDisplay;
            this._templateService.currentStudyLayout = structuredDisplay;
            structuredDisplay.PatientID = this._seriesManagerService.currentLoadingSeries.Patient.ID;
            structuredDisplay.LoadedItems = 0;
            structuredDisplay.OverflowItems = 0;
            this._templateService.currentStudyLayoutID = UUID.genV4().toString();
            structuredDisplay.ID = this._templateService.currentStudyLayoutID;
            var self = this;
            // clear the overflow everytime you load a new structured display.
            if (structuredDisplay.Series.length != 0) {
                var tab = self.getPatientTab(structuredDisplay.PatientID, self._tabService);
                self._eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: seriesInstanceUID, tab: tab });
            }
            // load the jason of every frame and display them according to the json data matching the template value.
            this.getStructredDisplayInstancesInfo(structuredDisplay).then(function (result) {
                var index = 0;
                var seriesList = self._seriesManagerService.SeriesInstancesList[seriesInstanceUID];
                var length = seriesList.length;
                structuredDisplay.TotalNumber = length;
                for (index = 0; index < length; index++) {
                    self.matchItemToTemplate(seriesList[index], studyInstanceUID, seriesInstanceUID, structuredDisplay);
                }
            });
            // reset the viewer, so we can load the next template.
            this._eventService.publish(EventNames.StructuredDisplaySelected, {
                structureDisplay: structuredDisplay,
            });
            return structuredDisplay;
        };
        DentalSearchViewController.prototype.loadselectedStructureDisplay = function (data) {
            // 
            this._templateService.currentStudyLayoutID = UUID.genV4().toString();
            data.ID = this._templateService.currentStudyLayoutID;
            var self = this;
            this.getStructredDisplayInstancesInfo(data).then(function () {
                //Utils.debug_counter = 0;
                //Utils.debug_timer = (new Date()).getTime();
                //eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                //}.bind(this));
                var loadstructureDisplay = true;
                //this._dataCache['StudyInstanceUID'] = this._selectedStudy.InstanceUID;
                var studyLayout = null;
                //this._objectRetrieveService.GetStudyLayout(<any>(this._selectedStudy.InstanceUID)).then(function (result) {
                studyLayout = data;
                self._templateService.currentHangingProtocol = null;
                if (data == "") {
                    var counter = 0;
                    var index = 0;
                    var length = self._$scope.gridOptionsSeries.rowData.length;
                    for (index = 0; index < length; index++) {
                        if (self._$scope.gridOptionsSeries.rowData[index].CompleteMRTI) {
                            counter++;
                        }
                    }
                }
                if (self._templateService.currentStudyLayoutID != data.ID)
                    return;
                self._templateService.currentStudyLayout = studyLayout;
                // when you load the structured display, remove any previous series loaded on that tab, this value will become false after clearing the series.
                self._seriesManagerService.cleanupSeries = true;
                if (!angular.isDefined(studyLayout["Series"])) {
                    self.loadSeries(self._selectedStudy, self._$scope.gridOptionsSeries.rowData[0], loadstructureDisplay);
                }
                else {
                    var tab = self.getPatientTab(data.Patient.ID, self._tabService);
                    var usedSOP = [];
                    var frameOFRefrences = null;
                    self._templateService.currentStudyLayout.LoadedBoxes = 0;
                    // clear the overflow everytime you load a new structured display.
                    if (studyLayout.Series.length != 0) {
                        self._eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: studyLayout.Series[0].SeriesInstanceUID, tab: tab });
                    }
                    studyLayout['studyInstanceUID'] = self._selectedStudy.InstanceUID;
                    $.each(studyLayout.Series, function (index, item) {
                        var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                        var box = studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)];
                        if (box) {
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                frameOFRefrences = box.referencedSOPInstanceUID;
                                self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, frameOFRefrences, loadstructureDisplay, data.ID);
                                usedSOP.add(frameOFRefrences[0]);
                            }
                        }
                    });
                    $.each(studyLayout.OtherStudies, function (index, study) {
                        $.each(study.Series, function (index, item) {
                            var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                            var box = studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)];
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                frameOFRefrences = box.referencedSOPInstanceUID;
                                self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, frameOFRefrences, loadstructureDisplay, data.ID);
                                usedSOP.add(frameOFRefrences[0]);
                            }
                        });
                    });
                    // go through all the images in the selected study, and see if it's used in the strcutured, display, if not, then it belongs to the overflow.
                    for (var seriesInstanceUID in self._seriesManagerService.SeriesInstancesList) {
                        var index = 0;
                        var length = self._seriesManagerService.SeriesInstancesList[seriesInstanceUID].length;
                        var sop;
                        var foundOne = false;
                        for (index = 0; index < length; index++) {
                            // if the frame is not used, then use it here.
                            if (usedSOP.indexOf(self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][index].SOPInstanceUID) == -1) {
                                self.queryForSeries(self, seriesInstanceUID, -1, self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][index], loadstructureDisplay, data.ID);
                                foundOne = true;
                            }
                        }
                    }
                    /// mock overflow display for testing, comment this out.
                    //for (var seriesInstanceUID in self._seriesManagerService.SeriesInstancesList) {
                    //    self.queryForSeries(self, seriesInstanceUID, -1, self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][0]/*studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)].referencedSOPInstanceUID*/, loadstructureDisplay, data.ID);
                    //        }
                    // close the overflow if you can't find a single overflow image.
                    if (!foundOne) {
                        self._eventService.publish(EventNames.InstanceOverflowClose, { seriesInstanceUID: studyLayout.Series[0].SeriesInstanceUID, tab: tab });
                    }
                }
                //});
                self._viewStudy = false;
            });
        };
        DentalSearchViewController.prototype.getImageBox = function (imageBoxNumber, boxes) {
            var index = 0;
            var length = boxes.length;
            for (index = 0; index < length; index++) {
                if (boxes[index].ImageBoxNumber == imageBoxNumber)
                    return index;
            }
            return -1;
        };
        DentalSearchViewController.prototype.waitForStructuredDisplayData = function (data, loadBest) {
            var self = this;
            // if we are still loading the patient series, then keep trying until we are done loading (the flag will be false by then).
            if (self._loadingPatientSeries == true) {
                setTimeout(function () {
                    self.waitForStructuredDisplayData(data);
                }, 100);
            }
            else {
                var query = new Models.HangingProtocolQuery();
                this._loadingStructuredDisplay = true;
                this._localStructuredDisplay = new Array();
                // show the structured display once we done loading them.
                this.showStructuredDisplayMenu(data, loadBest);
                this._objectRetrieveService.GetPatientStructuredDisplay(data.data.ID).then(function (result) {
                    self._localStructuredDisplay = result.data;
                    self.set_structuredDisplay(result.data);
                    self._loadingStructuredDisplay = false;
                });
            }
        };
        DentalSearchViewController.prototype.showStructuredDisplayMenu = function (data, loadBest) {
            var self = this;
            if (this._loadingStructuredDisplay == true) {
                setTimeout(function () {
                    self.showStructuredDisplayMenu(data, loadBest);
                }, 100);
            }
            else {
                try {
                    if (this._localStructuredDisplay != null) {
                        if (this._localStructuredDisplay.length != 0) {
                            $('.patientContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
                        }
                    }
                }
                catch (_a) { }
                if (this._sdOpenWith.length > 0) {
                    $('.data-title').attr('data-menutitle', this._sdOpenWith);
                }
            }
        };
        DentalSearchViewController.prototype.getModality = function (data) {
            var index = 0;
            var length = data.length;
            var series;
            for (index = 0; index < length; index++) {
                series = data[index];
                series.Modaa;
            }
        };
        // series is temp until we get the correct data.
        DentalSearchViewController.prototype.patientSelected = function (evt) {
            this.set_patientSelected(true);
            var selectedNodes = this._$scope.gridOptions.api.getSelectedNodes();
            var self = this;
            if (selectedNodes.length == 1 && selectedNodes[0].data != this._selectedPatient) {
                var queryOptions = new Models.QueryOptions();
                var maxSeriesResults = this._optionsService.get(OptionNames.MaxSeriesResults);
                queryOptions.PatientsOptions.PatientID = evt.node.data.ID;
                this._selectedPatient = evt.node.data;
                if (angular.isDefined(this._$scope.queryOptions.SeriesOptions.SeriesDateStart)) {
                    queryOptions.SeriesOptions.SeriesDateStart = this._$scope.queryOptions.SeriesOptions.SeriesDateStart;
                }
                if (angular.isDefined(this._$scope.queryOptions.SeriesOptions.SeriesDateEnd)) {
                    queryOptions.SeriesOptions.SeriesDateEnd = this._$scope.queryOptions.SeriesOptions.SeriesDateEnd;
                }
                if (angular.isDefined(this._$scope.queryOptions.SeriesOptions.SeriesDescription)) {
                    queryOptions.SeriesOptions.SeriesDescription = this._$scope.queryOptions.SeriesOptions.SeriesDescription;
                }
                // status is.... we are loading the patient series now.
                self._loadingPatientSeries = true;
                var patientID = evt.node.data.ID;
                this._$scope.gridOptionsSeries.api.setRowData([]);
                this._$scope.gridOptionsSeries.api.hideOverlay();
                switch (this._$scope.querySource.name) {
                    case 'database':
                        this._queryArchiveService.FindSeries(queryOptions, maxSeriesResults).then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    self._$scope.gridOptionsSeries.api.hideOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                var nodes = self._$scope.gridOptions.api.getSelectedNodes();
                                if (nodes && nodes.length > 0) {
                                    patientID = nodes[0].data.ID;
                                }
                                if (result.data.length > 0) {
                                    if (patientID != result.data[0].Patient.ID) {
                                        return;
                                    }
                                }
                                if (self._optionsService.get(OptionNames.SearchStructuredDisplay)) {
                                    self._objectRetrieveService.GetPatientStructuredDisplay(queryOptions.PatientsOptions.PatientID).then(function (sdResult) {
                                        var nodes = self._$scope.gridOptions.api.getSelectedNodes();
                                        if (nodes && nodes.length > 0) {
                                            patientID = nodes[0].data.ID;
                                        }
                                        if (result.data.length > 0) {
                                            if (patientID != result.data[0].Patient.ID) {
                                                return;
                                            }
                                        }
                                        Utils.prepareDataForSeriesDisplay(sdResult.data, result.data[0], result.data[0].Patient);
                                        self._localStructuredDisplay = sdResult.data;
                                        // filtering out the strcutrued display that doesn't meet the search criteria.
                                        Utils.filterOutStructuredDisplay(self._localStructuredDisplay, result.data);
                                        Utils.findSeriesNotUsedByStructuredDisplay(self._localStructuredDisplay, self._localStructuredDisplay, result.data, false);
                                        self._dataService.set_Series(self._localStructuredDisplay);
                                        // sort data based on the date.
                                        Utils.SortData(sdResult.data);
                                        self._$scope.gridOptionsSeries.api.setRowData(sdResult.data);
                                        if (sdResult.data.length == 0) {
                                            self._$scope.gridOptionsSeries.suppressNoRowsOverlay = false;
                                            self._$scope.gridOptionsSeries.api.showNoRowsOverlay();
                                        }
                                        self._loadingPatientSeries = false;
                                        self._queryArchiveService._currentPatientSeries = result.data;
                                        self._queryArchiveService.set_CurrentPatientSeries(patientID, result.data);
                                    });
                                }
                                else {
                                    // sort data based on the date.
                                    Utils.SortData(result.data);
                                    self._dataService.set_Series(result.data);
                                    self._$scope.gridOptionsSeries.api.setRowData(result.data);
                                    if (result.data.length == 0) {
                                        self._$scope.gridOptionsSeries.suppressNoRowsOverlay = false;
                                        self._$scope.gridOptionsSeries.api.showNoRowsOverlay();
                                    }
                                    self._loadingPatientSeries = false;
                                    self._queryArchiveService._currentPatientSeries = result.data;
                                    self._queryArchiveService.set_CurrentPatientSeries(patientID, result.data);
                                }
                            }
                        });
                        break;
                    case 'pacs':
                        self._queryPacsService.FindSeries(this._$scope.querySource.pacs, self._queryPacsService.clientAETitle, queryOptions).then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    self._$scope.gridOptionsSeries.api.hideLoadingOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                self._dataService.set_Series(result.data);
                                self._$scope.gridOptionsSeries.api.setRowData(result.data);
                                if (result.data.length == 0) {
                                    self._$scope.gridOptionsSeries.suppressNoRowsOverlay = false;
                                    self._$scope.gridOptionsSeries.api.showNoRowsOverlay();
                                }
                            }
                            self._loadingPatientSeries = false;
                            self._queryArchiveService._currentPatientSeries = result.data;
                            self._queryArchiveService.set_CurrentPatientSeries(patientID, result.data);
                        });
                        break;
                }
            }
            this._selectedSeries = null;
            this._selectedStudy = evt.node.data;
        };
        DentalSearchViewController.prototype.matchTemplateForSeries = function (data, selectedStudies) {
            var StudyInstanceUID = data.node.data.StudyInstanceUID;
            var SeriesInstanceUID = data.node.data.InstanceUID;
            var _this = this;
            if (StudyInstanceUID && SeriesInstanceUID) {
                //read first instance's json
                var promise = this._objectRetrieveService.GetDicomJSON(StudyInstanceUID, SeriesInstanceUID, '');
                //on success
                promise.success(function (json) {
                    var _template = null;
                    this.getAutoMatchTemplates().some(function (template) {
                        //parse the json and see if we have a match
                        try {
                            if (!_template) {
                                if (Utils.executeScript(template.AutoMatching, json)) {
                                    console.log('template auto-match found');
                                    _template = template;
                                    return true; //break;
                                }
                            }
                        }
                        catch (e) {
                            console.log(e);
                        }
                        return false; //continue
                    });
                    // is there a template that matchs the series so we could load it
                    if (_template) {
                        var searchController = this._tabService.get_tabData(this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                        searchController.loadStructuredDisplayFromTemplate(_template, SeriesInstanceUID, StudyInstanceUID);
                    }
                    else {
                        json = JSON.parse(json);
                        var isStl = Utils.containsSTLData(json);
                        // last try, try to see if the SD creator has a layout that can be used to display the series.
                        return this._objectRetrieveService.GetSeriesLayout(SeriesInstanceUID, StudyInstanceUID).then(function (layout) {
                            if (layout) {
                                _template = layout.data;
                            }
                            if (_template) {
                                var searchController = _this._tabService.get_tabData(_this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                                searchController.loadStructuredDisplayFromTemplate(_template, SeriesInstanceUID, StudyInstanceUID);
                            }
                            else {
                                // oh for god sake, just load the series normally.
                                _this._eventService.publish(EventNames.SeriesSelected, {
                                    study: selectedStudies[0].data,
                                    series: data.node.data,
                                    remote: _this._$scope.querySource.name == 'pacs',
                                    template: _template,
                                    isSTL: isStl,
                                    dentalSearchController: _this,
                                    resetLayout: true
                                });
                            }
                        });
                    }
                }.bind(this));
                //on error - default to no template - continue loading
                promise.error(function (e) {
                    console.log(e);
                    this._eventService.publish(EventNames.SeriesSelected, {
                        study: selectedStudies[0].data,
                        series: data.node.data,
                        remote: this._$scope.querySource.name == 'pacs'
                    });
                });
            }
            else {
                console.log('failed to read study/series id');
                //default to no template - continue loading
                this._eventService.publish(EventNames.SeriesSelected, {
                    study: selectedStudies[0].data,
                    series: data.node.data,
                    remote: this._$scope.querySource.name == 'pacs'
                });
            }
        };
        DentalSearchViewController.prototype.getPatientTab = function (patientid, tabService) {
            var tab = tabService.findTabByKey(TabDataKeys.PatientId, patientid);
            if (tab)
                return tab;
            var seriesList = this._seriesManagerService.get_allSeries();
            for (var i = 0; i < seriesList.length; i++) {
                var series = this._seriesManagerService.get_seriesInfo(seriesList[i]);
                if (series && (patientid == series.Patient.ID)) {
                    var tab = this._seriesManagerService.get_seriesTab(seriesList[i]);
                    return tab;
                }
            }
            return null;
        };
        DentalSearchViewController.prototype.seriesSelected = function (data) {
            this._$scope.gridOptionsSeries.api.showLoadingOverlay();
            var selectedStudies = this._$scope.gridOptions.api.getSelectedNodes();
            if (selectedStudies.length == 1) {
                var selectedSeries = this._$scope.gridOptionsSeries.api.getSelectedNodes();
                if (selectedSeries.length == 1) {
                    if ((selectedSeries[0].data != this._selectedSeries) || true) {
                        this._selectedSeries = data.node.data;
                        var tab = this.getPatientTab(this._selectedSeries.Patient.ID, this._tabService);
                        if (tab != null) {
                            var controller = this._tabService.get_tabData(tab.id, TabDataKeys.ViewController);
                            controller = controller;
                        }
                        this._seriesManagerService.structuredDisplayList = this._localStructuredDisplay;
                        // is this a structured display that we are loading?
                        if (this._selectedSeries.Boxes != undefined) {
                            this._seriesManagerService.currentPatientSeries = this._queryArchiveService._currentPatientSeries;
                            this._seriesManagerService.currentLoadingSeries = this.getSelectedSeries(this._selectedSeries, true);
                            this._seriesManagerService.currentStructuredDisplay = this._selectedSeries;
                            this._templateService.currentStudyLayout = this._selectedSeries;
                            this.loadselectedStructureDisplay(this._selectedSeries);
                            this._eventService.publish(EventNames.StructuredDisplaySelected, {
                                structureDisplay: this._selectedSeries,
                            });
                        }
                        else {
                            this._seriesManagerService.currentLoadingSeries = data.node.data;
                            this._seriesManagerService.currentPatientSeries = this._queryArchiveService._currentPatientSeries;
                            this._seriesManagerService.currentStructuredDisplay = null;
                            this._templateService.currentStudyLayout = null;
                            this.matchTemplateForSeries(data, selectedStudies);
                        }
                    }
                }
            }
        };
        DentalSearchViewController.prototype.hpContextMenu = function (data) {
            this._$scope.gridOptions.api.selectNode(data.node, false, true);
            //$('.patientContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
            //if (this._sdOpenWith.length > 0) {
            //    $('.data-title').attr('data-menutitle', this._sdOpenWith);
            //}
            this.patientSelected(data);
            //this.waitForStructuredDisplayData(data);
        };
        DentalSearchViewController.prototype.contextMenu = function (data) {
            this._selectedSeries = data.data;
            this._$scope.gridOptionsSeries.api.selectNode(data.node, false, true);
            $('.seriesContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
            if (this._openWith.length > 0) {
                $('.data-title').attr('data-menutitle', this._openWith);
            }
        };
        DentalSearchViewController.$inject = ['$rootScope', '$scope', '$modal', 'uiGridConstants', 'eventService', 'queryArchiveService', 'optionsService', 'dataService', 'authenticationService', 'queryPacsService', 'seriesManagerService', 'tabService', 'templateService', 'templateEditorService', 'objectRetrieveService', '$translate', 'toolbarService'];
        return DentalSearchViewController;
    }(SearchController));
    Controllers.DentalSearchViewController = DentalSearchViewController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/datejs.d.ts" />
var Controllers;
(function (Controllers) {
    var MonitorCalibrationController = /** @class */ (function () {
        function MonitorCalibrationController($scope, $modalInstance, optionsService, calibrations, $modal, authenticationService, monitorCalibrationService, dialogs, $translate, uiGridConstants) {
            var __this = this;
            this._modal = $modal;
            this._scope = $scope;
            $scope.calibrations = calibrations;
            $scope.selectedCalibration = null;
            $scope.canCalibrate = true;
            $scope.showDialog = true;
            $scope.gridOptions = {
                enableSorting: true,
                enableRowSelection: true,
                enableRowHeaderSelection: lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet,
                noUnselect: true,
                multiSelect: false,
                onRegisterApi: function (gridApi) {
                    gridApi.selection.on.rowSelectionChanged($scope, function (selectedRow) {
                        $scope.selectedCalibration = selectedRow.entity;
                    });
                },
                columnDefs: [
                    { name: "Calibration Time", field: "CalibrationTime", enableHiding: false, sort: { direction: uiGridConstants.DESC, priority: 0 } },
                    { name: "Workstation", field: "Workstation", enableHiding: false },
                    { name: "Username", field: "Username", enableHiding: false },
                    { name: "Comments", field: "Comments", enableHiding: false },
                ],
                data: calibrations
            };
            $scope.calibrate = function () {
                __this.showCalibrationImage("images/calibration.png", function (data) {
                    var DateJS = new Date();
                    var calibration = {
                        CalibrationTime: DateJS.toString("M/d/yyyy hh:mm:ss tt"),
                        Workstation: data.workstation,
                        Username: authenticationService.user,
                        Comments: data.comments
                    };
                    monitorCalibrationService.AddCalibration(calibration).success(function () {
                        $scope.canCalibrate = false;
                        $scope.calibrations.push(calibration);
                        dialogs.notify(__this._notificationTitle, __this._calibrationSuccessMsg);
                    }).error(function (error, status) {
                        dialogs.error(__this._calibrationFailureMsg + ": " + status);
                    });
                });
            };
            $scope.close = function () {
                $('.modal-backdrop').remove();
                $modalInstance.close();
            };
            $translate('DIALOGS_CALIBRATION_SUCCESS').then(function (translation) {
                __this._calibrationSuccessMsg = translation;
            });
            $translate('DIALOGS_CALIBRATION_FAILURE').then(function (translation) {
                __this._calibrationFailureMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
        }
        MonitorCalibrationController.prototype.showCalibrationImage = function (imageUrl, callback) {
            var __this = this;
            if ($('#lightbox').length > 0) { // #lightbox exists
                //place href as img src value
                $('#content').html('<img src="' + imageUrl + '" />');
                //show lightbox window - you could use .show('fast') for a transition
                //$("#calibrationDialog").dialog("close");
                __this._modal("hide");
                $('#lightbox').show();
            }
            else {
                __this._scope.showDialog = false;
                //create HTML markup for lightbox window
                var lightbox = '<div id="lightbox" style="z-index:3000; position:fixed; top:0; right:0; left:0">' +
                    '<div id="content">' + //insert clicked link's href into img src
                    '<img src="' + imageUrl + '" />' +
                    '</div>' +
                    '</div>';
                $('body').append(lightbox);
                $('#lightbox').on('click', function () {
                    $('#lightbox').hide();
                    $('#lightBox').remove();
                    __this._scope.showDialog = true;
                    __this.getWorkstation(callback);
                });
            }
        };
        MonitorCalibrationController.prototype.getWorkstation = function (callback) {
            var modalInstance = this._modal.open({
                templateUrl: 'views/dialogs/GetWorkstation.html',
                controller: Controllers.GetWorkstationController,
                backdrop: 'static'
            });
            modalInstance.result.then(function (calibrationInfo) {
                if (callback) {
                    callback(calibrationInfo);
                }
            }, function (error) {
            });
        };
        MonitorCalibrationController.$inject = ['$scope', '$modalInstance', 'optionsService', 'calibrations', '$modal', 'authenticationService', 'monitorCalibrationService', 'dialogs', '$translate', 'uiGridConstants'];
        return MonitorCalibrationController;
    }());
    Controllers.MonitorCalibrationController = MonitorCalibrationController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var OverlayTag = /** @class */ (function () {
        function OverlayTag() {
            this.id = "";
            this.tag = "";
            this.overlayType = 0;
            this.color = "#FFFFFF";
            this.title = "";
        }
        return OverlayTag;
    }());
    Controllers.OverlayTag = OverlayTag;
    var OverlayTags = /** @class */ (function () {
        function OverlayTags() {
            this.topRight = new Array();
            this.topLeft = new Array();
            this.bottomLeft = new Array();
            this.bottomRight = new Array();
            this.centerLeft = new Array();
            this.centerTop = new Array();
            this.centerRight = new Array();
            this.centerBottom = new Array();
        }
        return OverlayTags;
    }());
    Controllers.OverlayTags = OverlayTags;
    var OverlaySettingsController = /** @class */ (function () {
        function OverlaySettingsController($scope, $modalInstance, eventService, authenticationService, optionsService, overlayManagerService, $modal, dialogs, $translate, $timeout) {
            var __this = this;
            var saved = false;
            this._overlayManagerService = overlayManagerService;
            this._scope = $scope;
            $scope.position = { value: 'topLeft' };
            $scope.gridOptions = {
                appScopeProvider: $scope,
                enableSorting: true,
                enableRowSelection: true,
                enableRowHeaderSelection: lt.LTHelper.device == lt.LTDevice.mobile || lt.LTHelper.device == lt.LTDevice.tablet,
                noUnselect: true,
                multiSelect: false,
                onRegisterApi: function (gridApi) {
                    gridApi.selection.on.rowSelectionChanged($scope, function (selectedRow) {
                        $scope.selectedOverlay = selectedRow.entity;
                    });
                },
                columnDefs: [
                    {
                        name: "Type",
                        field: "overlayType",
                        enableHiding: false,
                        cellFilter: 'mapType'
                    },
                    { name: "Title", field: "title", enableHiding: false },
                    { name: "Tag", field: "tag", enableHiding: false },
                    {
                        name: "Color",
                        field: "color",
                        enableHiding: false,
                        enableSorting: false,
                        cellTemplate: '<div class="ui-grid-cell-contents" title="TOOLTIP"><div style="background-color:{{COL_FIELD}}; width:inherit; height:inherit"></div></div>'
                    },
                ],
                data: 'overlays[position.value]'
            };
            $scope.overlays = Utils.clone(overlayManagerService.getOverlayTags());
            $scope.close = function () {
                $modalInstance.close();
            };
            $scope.addTag = function () {
                var modalInstance = $modal.open({
                    templateUrl: 'views/dialogs/AddOverlayTag.html',
                    controller: Controllers.AddTagController,
                    backdrop: 'static',
                    resolve: {
                        tag: function () {
                            return null;
                        }
                    }
                });
                modalInstance.result.then(function (tag) {
                    if (!angular.isDefined($scope.overlays[$scope.position.value])) {
                        $scope.overlays[$scope.position.value] = [];
                    }
                    $scope.overlays[$scope.position.value].push(tag);
                    $scope.hasChanged = true;
                }, function () { });
            };
            $scope.editTag = function () {
                var overlayTag = $scope.selectedOverlay;
                if (overlayTag != null) {
                    var modalInstance = $modal.open({
                        templateUrl: 'views/dialogs/AddOverlayTag.html',
                        controller: Controllers.AddTagController,
                        backdrop: 'static',
                        resolve: {
                            tag: function () {
                                return overlayTag;
                            }
                        }
                    });
                    modalInstance.result.then(function (tag) {
                        var index = $scope.overlays[$scope.position.value].indexOf(overlayTag);
                        $scope.overlays[$scope.position.value][index] = tag;
                        $scope.hasChanged = true;
                    }, function () { });
                }
            };
            $scope.deleteTag = function () {
                var data = $scope.selectedOverlay;
                if (data != null) {
                    var results = $.grep($scope.overlays[$scope.position.value], function (overlay, index) { return overlay.id == data.id; });
                    if (results.length > 0) {
                        var index = $scope.overlays[$scope.position.value].indexOf(results[0]);
                        if (index != -1) {
                            $scope.overlays[$scope.position.value].splice(index, 1);
                            $scope.hasChanged = true;
                        }
                    }
                }
            };
            $scope.restore = function () {
                $scope.overlays = Utils.clone(overlayManagerService.getOverlayTags());
                $scope.hasChanged = false;
            };
            $scope.save = function () {
                overlayManagerService.saveOverlayTags($scope.overlays).success(function () {
                    optionsService.set(OptionNames.OverlaySettings, JSON.stringify($scope.overlays));
                    dialogs.notify(__this._notificationTitle, __this._overlaySuccessMsg);
                    $scope.hasChanged = false;
                    saved = true;
                }).error(function (data, status) {
                });
            };
            $scope.getColor = function (row) {
            };
            $scope.hasSelection = function () {
                return !angular.isUndefined($scope.selectedOverlay) && $scope.selectedOverlay != null;
            };
            $translate('DIALOGS_OVERLAY_SAVED').then(function (translation) {
                __this._overlaySuccessMsg = translation;
            });
            $translate('DIALOGS_NOTIFICATION').then(function (translation) {
                __this._notificationTitle = translation;
            });
        }
        OverlaySettingsController.$inject = ['$scope', '$modalInstance', 'eventService', 'authenticationService', 'optionsService', 'overlayManagerService', '$modal', 'dialogs', '$translate', '$timeout'];
        return OverlaySettingsController;
    }());
    Controllers.OverlaySettingsController = OverlaySettingsController;
})(Controllers || (Controllers = {}));
app.filter('mapType', function () {
    return function (code) {
        var olm = angular.element('*[ng-app]').injector().get("overlayManagerService");
        if (!angular.isDefined(code)) {
            return 'UserData';
        }
        else {
            return olm.getOverlayTypeName(code);
        }
    };
});
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="Scopes.ts" />
/// <reference path="../Services/QueryArchiveService.ts" />
var Controllers;
(function (Controllers) {
    var SearchViewController = /** @class */ (function (_super) {
        __extends(SearchViewController, _super);
        function SearchViewController($rootScope, $scope, $modal, eventService, queryArchiveService, optionsService, dataService, queryPacsService, authenticationService, tabService, seriesManagerService, objectStoreService, templateService, templateEditorService, $translate, objectRetrieveService, dataCache) {
            var _this = this;
            var __this;
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var timeFormat = optionsService.get(OptionNames.TimeFormat);
            var maxStudyResults = optionsService.get(OptionNames.MaxStudyResults);
            var previous = UUID.generate();
            var next = UUID.generate();
            var selection;
            var studiesGroup = "Studies";
            var seriesGroup = "Series";
            _this = _super.call(this, $rootScope, $scope, queryArchiveService, optionsService, authenticationService, queryPacsService, tabService, eventService, templateService, templateEditorService, $translate) || this;
            __this = _this;
            _this._$scope = $scope;
            _this._queryArchiveService = queryArchiveService;
            _this._queryPacsService = queryPacsService;
            _this._dataService = dataService;
            _this._optionsService = optionsService;
            _this._eventService = eventService;
            _this._tabService = tabService;
            _this._seriesManagerService = seriesManagerService;
            _this._objectStoreService = objectStoreService;
            _this._objectRetrieveService = objectRetrieveService;
            _this._viewStudy = false;
            _this._dataCache = dataCache;
            _this._hpOpenWith = "Hanging Protocol";
            _this._sdOpenWith = "Structured Display";
            _this._rowIndexPrevious = -1;
            _this._tabService.set_tabData(_this._tabService.tabs[0].id, TabDataKeys.searchViewerController, _this);
            _this._patientSelected = false;
            $scope.hpContextMenu = _this.hpContextMenu.bind(_this);
            $scope.handleCellClicked = _this.handleCellClicked.bind(_this);
            $scope.gridOptions = {
                rowSelection: 'single',
                suppressNoRowsOverlay: true,
                groupHeaders: true,
                enableSorting: true,
                rowClass: 'studyContext',
                angularCompileRows: true,
                columnDefs: [
                    {
                        headerName: studiesGroup,
                        children: [
                            {
                                headerName: "",
                                cellRenderer: Utils.countRenderer,
                                width: 35,
                                suppressSizeToFit: true,
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Patient ID",
                                valueGetter: function (params) {
                                    return Utils.nameFormatter(params.data.Patient.ID);
                                },
                                cellRenderer: Utils.hyperlinkPatientIdRenderer,
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Name", valueGetter: function (params) {
                                    return Utils.nameFormatter(params.data.Patient.Name);
                                },
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Accession #",
                                field: "AccessionNumber",
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Study Date",
                                field: "Date",
                                cellRenderer: Utils.dateRenderer,
                                comparator: Utils.dateComparator,
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Refer Dr Name", valueGetter: function (params) {
                                    return Utils.nameFormatter(params.data.ReferringPhysiciansName);
                                },
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            },
                            {
                                headerName: "Description",
                                field: "Description",
                                onCellContextMenu: _this.hpContextMenu.bind(_this),
                                onCellClicked: _this.handleCellClicked.bind(_this)
                            }
                        ]
                    }
                ],
                onRowSelected: _this.studySelected.bind(_this),
                rowData: null,
                onGridReady: function () {
                    $scope.gridOptions.api.hideOverlay();
                    setTimeout(function () {
                        $scope.gridOptions.api.sizeColumnsToFit();
                    }, 500);
                    $.contextMenu({
                        selector: '.studyContext',
                        trigger: 'none',
                        className: 'data-title',
                        build: function ($trigger, e) {
                            var options = {
                                callback: function (key, options) {
                                    var selectedNodes = __this._$scope.gridOptions.api.getSelectedNodes();
                                    if (key == "NoHangingProtocolFound_407B6C09-83C2-4A7F-9643-AA4301F6A67A") {
                                        return;
                                    }
                                    __this.viewHangingProtocol(selectedNodes[0], key);
                                },
                                // items: __this.get_hangingProtocols_test()
                                items: __this.get_hangingProtocols()
                            };
                            return options;
                        }
                    });
                }
            };
            $scope.gridOptionsSeries = {
                rowSelection: 'single',
                suppressNoRowsOverlay: true,
                enableSorting: true,
                rowClass: 'seriesContext',
                groupHeaders: true,
                rowHeight: parseInt(optionsService.get(OptionNames.SeriesThumbnailHeight)),
                columnDefs: [
                    {
                        headerName: seriesGroup,
                        children: [
                            {
                                headerName: "",
                                cellRenderer: Utils.has_mrtiRenderer,
                                width: 29,
                                suppressSizeToFit: true,
                                onCellContextMenu: _this.contextMenu.bind(_this),
                                suppressSorting: true
                            },
                            {
                                headerName: "",
                                cellRenderer: Utils.thumbnailRenderer,
                                hide: !optionsService.get(OptionNames.ShowSearchThumbnails),
                                width: parseInt(optionsService.get(OptionNames.SeriesThumbnailWidth)),
                                onCellContextMenu: _this.contextMenu.bind(_this),
                                suppressSorting: true
                            },
                            {
                                headerName: 'Number', field: 'Number',
                                onCellContextMenu: _this.contextMenu.bind(_this)
                            },
                            {
                                headerName: 'Series Date', field: 'Date',
                                cellRenderer: Utils.dateRenderer,
                                onCellContextMenu: _this.contextMenu.bind(_this),
                                comparator: Utils.dateComparator
                            },
                            {
                                headerName: 'Description', field: 'Description',
                                onCellContextMenu: _this.contextMenu.bind(_this)
                            },
                            {
                                headerName: 'Modality', field: 'Modality',
                                onCellContextMenu: _this.contextMenu.bind(_this)
                            },
                            {
                                headerName: 'Instances', field: 'NumberOfRelatedInstances',
                                onCellContextMenu: _this.contextMenu.bind(_this)
                            }
                        ]
                    }
                ],
                onRowSelected: _this.seriesSelected.bind(_this),
                rowData: null,
                onGridReady: function () {
                    $scope.gridOptionsSeries.api.hideOverlay();
                    $.contextMenu({
                        selector: '.seriesContext',
                        trigger: 'none',
                        className: 'data-title',
                        build: function ($trigger, e) {
                            return {
                                callback: function (key, options) {
                                    var rawData = __this._$scope.gridOptionsSeries.rowData[0];
                                    __this.loadStructuredDisplayFromTemplate(__this.getTemplate(key), rawData.InstanceUID, rawData.StudyInstanceUID);
                                    return;
                                },
                                items: __this.getTemplateMenu(__this._selectedSeries.Modality)
                            };
                        }
                    });
                    setTimeout(function () {
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    }, 500);
                },
            };
            $scope.queryOptions = new Models.QueryOptions();
            $scope.studies = new Array();
            $scope.pacsConnections = queryPacsService.remoteConnections;
            selection = $scope.pacsConnections.filter(function (connection, index, array) {
                return connection.isDefault;
            });
            if (selection.length > 0) {
                $scope.querySource.pacs = selection[0];
            }
            $scope.doSearch = function () {
                __this.set_patientSelected(false);
                this._rowIndexPrevious = -1;
                var queryOptions = angular.copy($scope.queryOptions);
                if (angular.isDefined(queryOptions.PatientsOptions.PatientName)) {
                    var m = queryOptions.PatientsOptions.PatientName.match(/"(.*?)"/);
                    if (m == null) {
                        queryOptions.PatientsOptions.PatientName = queryOptions.PatientsOptions.PatientName.replace(' ', '^');
                    }
                    else {
                        queryOptions.PatientsOptions.PatientName = m[1].replace(/"/g, '');
                    }
                }
                if (angular.isDefined(queryOptions.StudiesOptions.ReferDoctorName)) {
                    var m = queryOptions.StudiesOptions.ReferDoctorName.match(/"(.*?)"/);
                    if (m == null) {
                        queryOptions.StudiesOptions.ReferDoctorName = queryOptions.StudiesOptions.ReferDoctorName.replace(' ', '^');
                    }
                    else {
                        queryOptions.StudiesOptions.ReferDoctorName = m[1].replace(/"/g, '');
                    }
                }
                if (angular.isDefined(queryOptions.StudiesOptions.ModalitiesInStudy)) {
                    if (queryOptions.StudiesOptions.ModalitiesInStudy.length > 0) {
                        var modality = queryOptions.StudiesOptions.ModalitiesInStudy;
                        queryOptions.StudiesOptions.ModalitiesInStudy = [];
                        queryOptions.StudiesOptions.ModalitiesInStudy.push(modality);
                    }
                }
                __this._selectedStudy = null;
                __this._selectedSeries = null;
                $scope.gridOptions.api.setRowData([]);
                $scope.gridOptionsSeries.api.setRowData([]);
                $scope.gridOptionsSeries.api.hideOverlay();
                switch ($scope.querySource.name) {
                    case 'database':
                        queryArchiveService.FindStudies(queryOptions, maxStudyResults).then(function (result) {
                            eventService.publish("Search/Study/Success", result.data);
                            $scope.gridOptions.api.setRowData(result.data);
                        }, function (error) {
                            eventService.publish("Search/Study/Failure", { error: error });
                        });
                        break;
                    case 'pacs':
                        queryPacsService.FindStudies($scope.querySource.pacs, queryPacsService.clientAETitle, queryOptions).then(function (result) {
                            eventService.publish("Search/Study/Success", result.data);
                            $scope.gridOptions.api.setRowData(result.data);
                        }, function (error) {
                            eventService.publish("Search/Study/Failure", { error: error });
                        });
                        break;
                }
            };
            $scope.clear = function () {
                $scope.queryOptions = new Models.QueryOptions();
                $scope.queryOptions.SeriesOptions.SeriesDateStart = null;
                $scope.queryOptions.SeriesOptions.SeriesDateEnd = null;
                $scope.gridOptions.api.setRowData([]);
                $scope.gridOptionsSeries.api.setRowData([]);
                __this._selectedStudy = null;
                __this._selectedSeries = null;
            };
            $scope.queryModeChanged = function () {
                $scope.studies.length = 0;
            };
            $scope.patientids = $.proxy(_this.patientids, _this);
            $scope.patientNames = $.proxy(_this.patientNames, _this);
            $scope.onLayoutChanged = function (newValue, oldValue) {
                setTimeout(function () {
                    if ($scope.gridOptions.api)
                        $scope.gridOptions.api.sizeColumnsToFit();
                    if ($scope.gridOptionsSeries.api)
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                }, 250);
            };
            $scope.onSearchTabSelected = function () {
                setTimeout(function () {
                    var studyNodes = $scope.gridOptions.api.getSelectedNodes();
                    var seriesNodes = $scope.gridOptions.api.getSelectedNodes();
                    $scope.gridOptions.api.refreshView();
                    $scope.gridOptionsSeries.api.refreshView();
                    $scope.gridOptions.api.sizeColumnsToFit();
                    $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    if (studyNodes.length > 0) {
                        $scope.gridOptions.api.ensureNodeVisible(studyNodes[0]);
                    }
                    if (seriesNodes.length > 0) {
                        $scope.gridOptionsSeries.api.ensureNodeVisible(seriesNodes[0]);
                    }
                }, 225);
            };
            $scope.$watch('windowDimensions', function (newValue, oldValue) {
                if ($scope.gridOptions.api) {
                    setTimeout(function () {
                        $scope.gridOptions.api.sizeColumnsToFit();
                        $scope.gridOptionsSeries.api.sizeColumnsToFit();
                    }, 500);
                }
            });
            eventService.subscribe(EventNames.LoadFromOverflow, function (event, data) {
                var cell = data.args.cell;
                // delete the cell that we are dragging, then load the newly dragged cell.
                if (cell) {
                    cell.viewer.layout.get_items().remove(cell);
                    if (cell.get_automation) {
                        Utils.disposeAutomation(cell.get_automation());
                    }
                    __this._seriesManagerService.remove_cell(cell);
                    __this._seriesManagerService.set_activeCell(cell.divID);
                    cell.dispose();
                }
                __this.queryForSeries(__this, data.args.SeriesInstanceUID, data.args.ImageBoxNumber, data.args.SopInstanceUID, true /*data.args.structuredDisplay*/, __this._templateService.currentStudyLayoutID);
            }.bind(_this));
            eventService.subscribe(EventNames.MrtiInfoReady, function (event, data) {
                if (this._$scope && this._$scope.gridOptionsSeries) {
                    Utils.clearMrti(this._$scope.gridOptionsSeries.api, this._$scope.gridOptionsSeries.rowData, data.args.seriesInstanceUID);
                }
            }.bind(_this));
            eventService.subscribe(EventNames.LoadSelectedSeries, function (event, data) {
                var input = {};
                input.node = {};
                input.node.data = data.args.data;
                __this._seriesManagerService.currentLoadingSeries = data.args.data;
                __this._seriesManagerService.currentPatientSeries = data.args.study;
                __this._selectedSeries = data.args.data;
                if (__this._selectedSeries.Boxes != undefined) {
                }
                if (__this.isAnyTemplateAutoMatch()) {
                    __this.matchTemplateForSeries(input, input.node.data.Patient);
                }
                else {
                    __this._eventService.publish(EventNames.SeriesSelected, {
                        study: input.node.data.Patient,
                        series: input.node.data,
                        remote: __this._$scope.querySource.name == 'pacs',
                    });
                }
            });
            $scope.onViewStudy = _this.onViewStudy.bind(_this);
            return _this;
        }
        SearchViewController.prototype.get_patientSelected = function () {
            return this._patientSelected;
        };
        SearchViewController.prototype.set_patientSelected = function (value) {
            this._patientSelected = value;
        };
        SearchViewController.prototype.get_selectedSeries = function () {
            return this._selectedSeries;
        };
        SearchViewController.prototype.set_selectedSeries = function (series) {
            this._selectedSeries = series;
        };
        SearchViewController.prototype.get_selectedPatient = function () {
            return this._selectedPatient;
        };
        SearchViewController.prototype.onViewStudy = function (data) {
            this._viewStudy = true;
        };
        SearchViewController.prototype.viewHangingProtocol = function (data, sopInstanceUID) {
            var self = this;
            this._objectRetrieveService.GetHangingProtocol(sopInstanceUID).then(function (result) {
                var hp = result.data;
                self._templateService.currentStudyLayout = null;
                self._templateService.currentHangingProtocol = hp;
                self._objectRetrieveService.GetHangingProtocolInstances(sopInstanceUID, self._selectedStudy.Patient.ID, self._selectedStudy.InstanceUID, self._selectedStudy.Date).then(function (result) {
                    self.loadHangingProtocol(result.data, hp);
                }, function (error) {
                });
            });
        };
        SearchViewController.prototype.getSelectedSeries = function (structureDisplay, usedList) {
            var seriesInstanceUID = structureDisplay.Series[0].SeriesInstanceUID;
            var studyInstanceUID = structureDisplay.Series[0].StudyInstanceUID;
            var index = 0;
            var seriesArray = usedList ? this._queryArchiveService._currentPatientSeries : this._$scope.gridOptionsSeries.rowData;
            if (!seriesArray) {
                seriesArray = this._seriesManagerService.currentPatientSeries;
            }
            var length = seriesArray.length;
            for (index = 0; index < length; index++) {
                if (seriesArray[index].InstanceUID) {
                    if (seriesArray[index].InstanceUID == seriesInstanceUID)
                        return seriesArray[index];
                }
                else {
                    if (seriesArray[index].StudyInstanceUID == studyInstanceUID)
                        return seriesArray[index];
                }
            }
        };
        SearchViewController.prototype.loadSeriesFromData = function (data, seriesInstanceUID, imageBoxNumber, sopInstanceList, loadstructureDisplay, sdID, templateItem) {
            if (data["FaultType"]) {
                if (data["Message"]) {
                    alert(data["Message"]);
                }
            }
            else {
                var index = 0;
                var length = data.length;
                var seriesData = null;
                var item = data.get_PatientData(seriesInstanceUID);
                length = item.length;
                for (index = 0; index < length; index++) {
                    if (item[index].InstanceUID == seriesInstanceUID) {
                        seriesData = JSON.parse(JSON.stringify(item[index]));
                        break;
                    }
                }
                if (seriesData) {
                    // if this is not an over flow image, then add it to the list of loaded boxes of the structured display.
                    if (imageBoxNumber != -1)
                        item.LoadedBoxes++;
                    seriesData.ImageBoxNumber = imageBoxNumber; // studyLayout.ImageBoxNumber;
                    seriesData.SopInstanceUIDs = sopInstanceList;
                    this.loadSeries({ InstanceUID: seriesData.StudyInstanceUID, sdID: sdID, templateItem: templateItem }, seriesData, loadstructureDisplay);
                }
            }
        };
        SearchViewController.prototype.matchItemToTemplate = function (series, studyInstanceUID, seriesInstanceUID, structuredDisplay) {
            var __this = this;
            var sopInstanceUID = series.SOPInstanceUID;
            // load the json for every frame and see where it fits in the viewer.
            this._objectRetrieveService.GetDicomJSON(studyInstanceUID, seriesInstanceUID, sopInstanceUID).then(function (result) {
                var json = JSON.parse(result.data);
                var loaded = false;
                var length = structuredDisplay.Boxes.length;
                for (var index = 0; index < length; index++) {
                    var box = structuredDisplay.Boxes[index];
                    if (Utils.isInstanceOfSOP(box, json, sopInstanceUID, DicomHelper.getDicomTagValue(json, DicomTag.InstanceNumber, 0))) {
                        var frameOFRefrences = [];
                        if (box && !box.IsMapped) {
                            box.IsMapped = true;
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                // array of 1 item.
                                frameOFRefrences = [sopInstanceUID];
                                // load the frame on a seprate cell.
                                __this.queryForSeries(__this, seriesInstanceUID, box.ImageBoxNumber, frameOFRefrences, true, structuredDisplay.ID, box);
                                loaded = true;
                                structuredDisplay.LoadedItems++;
                            }
                        }
                    }
                }
                if (!loaded) {
                    __this.queryForSeries(__this, seriesInstanceUID, -1, series, true, structuredDisplay.ID);
                    structuredDisplay.LoadedItems++;
                    structuredDisplay.OverflowItems++;
                }
                // if we load all the images but found out that none of them was overflow image, then we need to close the overflow window.
                if (structuredDisplay.TotalNumber == structuredDisplay.LoadedItems) {
                    if (structuredDisplay.OverflowItems == 0) {
                        var tab = __this.getPatientTab(structuredDisplay.PatientID, __this._tabService);
                        __this._eventService.publish(EventNames.InstanceOverflowClose, { seriesInstanceUID: seriesInstanceUID, tab: tab });
                    }
                }
            });
        };
        SearchViewController.prototype.loadStructuredDisplayFromTemplate = function (template, seriesInstanceUID, studyInstanceUID) {
            var structuredDisplay = this.createStructuredDisplayFromTemplate(template, studyInstanceUID, seriesInstanceUID);
            // converted structured display (structuredDisplay)
            var self = this;
            this._seriesManagerService.currentLoadingSeries = this.getSelectedSeries(structuredDisplay, false);
            this._seriesManagerService.structuredDisplayList = this._localStructuredDisplay;
            this._seriesManagerService.currentStructuredDisplay = structuredDisplay;
            this._templateService.currentStudyLayout = structuredDisplay;
            structuredDisplay.PatientID = this._seriesManagerService.currentLoadingSeries.Patient.ID;
            structuredDisplay.LoadedItems = 0;
            structuredDisplay.OverflowItems = 0;
            this._templateService.currentStudyLayoutID = UUID.genV4().toString();
            structuredDisplay.ID = this._templateService.currentStudyLayoutID;
            var self = this;
            // clear the overflow everytime you load a new structured display.
            if (structuredDisplay.Series.length != 0) {
                var tab = self.getPatientTab(structuredDisplay.PatientID, self._tabService);
                self._eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: seriesInstanceUID, tab: tab });
            }
            // load the jason of every frame and display them according to the json data matching the template value.
            this.getStructredDisplayInstancesInfo(structuredDisplay).then(function (result) {
                var index = 0;
                var seriesList = self._seriesManagerService.SeriesInstancesList[seriesInstanceUID];
                var length = seriesList.length;
                structuredDisplay.TotalNumber = length;
                for (index = 0; index < length; index++) {
                    self.matchItemToTemplate(seriesList[index], studyInstanceUID, seriesInstanceUID, structuredDisplay);
                }
            });
            // reset the viewer, so we can load the next template.
            this._eventService.publish(EventNames.StructuredDisplaySelected, {
                structureDisplay: structuredDisplay,
            });
            return structuredDisplay;
        };
        SearchViewController.prototype.studySelected = function (data, hpSopInstanceUID) {
            this.set_patientSelected(true);
            var selectedNodes = this._$scope.gridOptions.api.getSelectedNodes();
            var viewStudy = this._viewStudy;
            this._viewStudy = false;
            this._loadingStudySeries = true;
            if (selectedNodes.length == 1 && selectedNodes[0].data != this._selectedStudy) {
                var query = new Models.QueryOptions;
                var maxSeriesResults = this._optionsService.get(OptionNames.MaxSeriesResults);
                var __this = this;
                var modalitiesInStudy = this._$scope.queryOptions.StudiesOptions.ModalitiesInStudy;
                this._selectedPatient = data.node.data.Patient;
                this._selectedStudy = data.node.data;
                this._$scope.gridOptionsSeries.api.setRowData(undefined);
                query.StudiesOptions = new Models.StudyQueryOptions();
                query.StudiesOptions.StudyInstanceUID = data.node.data.InstanceUID;
                if (angular.isDefined(modalitiesInStudy)) {
                    if (modalitiesInStudy.length > 0) {
                        var modality = modalitiesInStudy;
                        query.StudiesOptions.ModalitiesInStudy = [];
                        query.StudiesOptions.ModalitiesInStudy.push(modality);
                    }
                }
                switch (this._$scope.querySource.name) {
                    case 'database':
                        this._queryArchiveService.FindSeries(query, maxSeriesResults).then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    __this._$scope.gridOptionsSeries.api.hideOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                __this._dataService.set_Series(result.data);
                                __this._queryArchiveService._currentPatientSeries = result.data;
                                __this._queryArchiveService.set_CurrentPatientSeries(result.data[0].Patient.ID, result.data);
                                if (__this._selectedStudy.InstanceUID == result.data[0].StudyInstanceUID) {
                                    __this._$scope.gridOptionsSeries.api.setRowData(result.data);
                                    if (viewStudy) {
                                        __this.loadStudy();
                                    }
                                }
                            }
                            __this._loadingStudySeries = false;
                        });
                        break;
                    case 'pacs':
                        this._queryPacsService.FindSeries(this._$scope.querySource.pacs, this._queryPacsService.clientAETitle, query).then(function (result) {
                            if (result.data["FaultType"]) {
                                if (result.data["Message"]) {
                                    __this._$scope.gridOptionsSeries.api.hideLoadingOverlay();
                                    alert(result.data["Message"]);
                                }
                            }
                            else {
                                __this._dataService.set_Series(result.data);
                                __this._queryArchiveService._currentPatientSeries = result.data;
                                __this._queryArchiveService.set_CurrentPatientSeries(result.data[0].Patient.ID, result.data);
                                if (__this._selectedStudy.InstanceUID == result.data[0].StudyInstanceUID) {
                                    __this._$scope.gridOptionsSeries.api.setRowData(result.data);
                                    if (viewStudy) {
                                        __this.loadStudy();
                                    }
                                }
                            }
                            __this._loadingStudySeries = false;
                        });
                        break;
                }
            }
            else {
                this._loadingStudySeries = false;
                if (viewStudy) {
                    this.loadStudy();
                }
            }
        };
        SearchViewController.prototype.loadHangingProtocol = function (views, hp) {
            var self = this;
            angular.forEach(views, function (value, key) {
                var study = {
                    InstanceUID: value.Series.StudyInstanceUID,
                    Patient: value.Series.Patient
                };
                self.loadHangingProtocolSeries(study, value.Series, value);
            });
        };
        SearchViewController.prototype.getStructredDisplayInstancesInfo = function (data) {
            var seriesList = [];
            var self = this;
            var index = 0;
            var length = data.Series.length;
            for (index = 0; index < length; index++) {
                if (seriesList.indexOf(data.Series[index].SeriesInstanceUID) == -1)
                    seriesList.add(data.Series[index].SeriesInstanceUID);
            }
            //console.clear();
            //Utils.debug_timer = (new Date()).getTime();
            return this._queryArchiveService.FindSeriesArrayInstances(seriesList).then(function (result) {
                var output = {};
                var data = result.data;
                var seriesInstanceUID;
                if (data == null)
                    return;
                index = 0;
                length = data.length;
                for (index = 0; index < length; index++) {
                    seriesInstanceUID = data[index].SeriesInstanceUID;
                    if (!output[seriesInstanceUID]) {
                        output[seriesInstanceUID] = [];
                    }
                    output[seriesInstanceUID].add(data[index]);
                }
                self._seriesManagerService.SeriesInstancesList = output;
                //alert(((new Date()).getTime() - Utils.debug_timer).toString());
                return;
            });
        };
        SearchViewController.prototype.getPatientTab = function (patientid, tabService) {
            var seriesList = this._seriesManagerService.get_allSeries();
            for (var i = 0; i < seriesList.length; i++) {
                var series = this._seriesManagerService.get_seriesInfo(seriesList[i]);
                if (series && (patientid == series.Patient.ID)) {
                    var tab = this._seriesManagerService.get_seriesTab(seriesList[i]);
                    return tab;
                }
            }
            return null;
        };
        SearchViewController.prototype.loadselectedStructureDisplay = function (data) {
            // 
            this._templateService.currentStudyLayoutID = UUID.genV4().toString();
            data.ID = this._templateService.currentStudyLayoutID;
            var self = this;
            this.getStructredDisplayInstancesInfo(data).then(function () {
                //Utils.debug_counter = 0;
                //Utils.debug_timer = (new Date()).getTime();
                //eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                //}.bind(this));
                var loadstructureDisplay = true;
                //this._dataCache['StudyInstanceUID'] = this._selectedStudy.InstanceUID;
                var studyLayout = null;
                //this._objectRetrieveService.GetStudyLayout(<any>(this._selectedStudy.InstanceUID)).then(function (result) {
                studyLayout = data;
                self._templateService.currentHangingProtocol = null;
                if (data == "") {
                    var counter = 0;
                    var index = 0;
                    var length = self._$scope.gridOptionsSeries.rowData.length;
                    for (index = 0; index < length; index++) {
                        if (self._$scope.gridOptionsSeries.rowData[index].CompleteMRTI) {
                            counter++;
                        }
                    }
                }
                if (self._templateService.currentStudyLayoutID != data.ID)
                    return;
                self._templateService.currentStudyLayout = studyLayout;
                // when you load the structured display, remove any previous series loaded on that tab, this value will become false after clearing the series.
                self._seriesManagerService.cleanupSeries = true;
                if (!angular.isDefined(studyLayout["Series"])) {
                    self.loadSeries(self._selectedStudy, self._$scope.gridOptionsSeries.rowData[0], loadstructureDisplay);
                }
                else {
                    var tab = self.getPatientTab(data.Patient.ID, self._tabService);
                    var usedSOP = [];
                    var frameOFRefrences = null;
                    self._templateService.currentStudyLayout.LoadedBoxes = 0;
                    // clear the overflow everytime you load a new structured display.
                    if (studyLayout.Series.length != 0) {
                        self._eventService.publish(EventNames.InstanceOverflowClear, { seriesInstanceUID: studyLayout.Series[0].SeriesInstanceUID, tab: tab });
                    }
                    studyLayout['studyInstanceUID'] = self._selectedStudy.InstanceUID;
                    $.each(studyLayout.Series, function (index, item) {
                        var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                        var box = studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)];
                        if (box) {
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                frameOFRefrences = box.referencedSOPInstanceUID;
                                self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, frameOFRefrences, loadstructureDisplay, data.ID);
                                usedSOP.add(frameOFRefrences[0]);
                            }
                        }
                    });
                    $.each(studyLayout.OtherStudies, function (index, study) {
                        $.each(study.Series, function (index, item) {
                            var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                            var box = studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)];
                            // workaround for the overflow, if any of boxes them doesn't have a valid width or height, then consider it overflow.
                            var width = box.Position.rightBottom.x - box.Position.leftTop.x;
                            var height = box.Position.rightBottom.y - box.Position.leftTop.y;
                            if (width != 0 && height != 0) {
                                frameOFRefrences = box.referencedSOPInstanceUID;
                                self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, frameOFRefrences, loadstructureDisplay, data.ID);
                                usedSOP.add(frameOFRefrences[0]);
                            }
                        });
                    });
                    // go through all the images in the selected study, and see if it's used in the strcutured, display, if not, then it belongs to the overflow.
                    for (var seriesInstanceUID in self._seriesManagerService.SeriesInstancesList) {
                        var index = 0;
                        var length = self._seriesManagerService.SeriesInstancesList[seriesInstanceUID].length;
                        var sop;
                        var foundOne = false;
                        for (index = 0; index < length; index++) {
                            // if the frame is not used, then use it here.
                            if (usedSOP.indexOf(self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][index].SOPInstanceUID) == -1) {
                                self.queryForSeries(self, seriesInstanceUID, -1, self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][index], loadstructureDisplay, data.ID);
                                foundOne = true;
                            }
                        }
                    }
                    /// mock overflow display for testing, comment this out.
                    //for (var seriesInstanceUID in self._seriesManagerService.SeriesInstancesList) {
                    //    self.queryForSeries(self, seriesInstanceUID, -1, self._seriesManagerService.SeriesInstancesList[seriesInstanceUID][0]/*studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)].referencedSOPInstanceUID*/, loadstructureDisplay, data.ID);
                    //        }
                    // close the overflow if you can't find a single overflow image.
                    if (!foundOne) {
                        self._eventService.publish(EventNames.InstanceOverflowClose, { seriesInstanceUID: studyLayout.Series[0].SeriesInstanceUID, tab: tab });
                    }
                }
                //});
                self._viewStudy = false;
            });
        };
        SearchViewController.prototype.queryForSeries = function (self, seriesInstanceUID, imageBoxNumber, sopInstanceUidList, loadstructureDisplay, sdID, templateItem) {
            var query = new Models.QueryOptions;
            var _seriesInstanceUID = seriesInstanceUID;
            var _imageBoxNumber = imageBoxNumber;
            var _sopInstanceList = sopInstanceUidList;
            query.SeriesOptions.SeriesInstanceUID = _seriesInstanceUID;
            // optimizing the speed, we just got the series information when we clicked on the patient for the first time, so we saved the results for this.
            if (self._queryArchiveService._currentPatientSeries != null) {
                setTimeout(function () {
                    var data = self._queryArchiveService._currentPatientSeries;
                    self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID, templateItem);
                }, 1);
            }
            else {
                switch (self._$scope.querySource.name) {
                    case 'database':
                        self._queryArchiveService.FindSeries(query, 1).then(function (result) {
                            var imageData = result.data;
                            if (imageData.length)
                                imageData = result.data[0];
                            self._queryArchiveService._currentPatientSeriesArray[imageData.Patient.ID] = result.data;
                            self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID);
                        });
                        break;
                    case 'pacs':
                        self._queryPacsService.FindSeries(self._$scope.querySource.pacs, self._queryPacsService.clientAETitle, query).then(function (result) {
                            var imageData = result.data;
                            if (imageData.length)
                                imageData = result.data[0];
                            self._queryArchiveService._currentPatientSeriesArray[imageData.Patient.ID] = result.data;
                            self.loadSeriesFromData(self._queryArchiveService, _seriesInstanceUID, _imageBoxNumber, _sopInstanceList, loadstructureDisplay, sdID);
                        });
                        break;
                }
            }
        };
        //private queryForSeries(self, seriesInstanceUID: string, imageBoxNumber: number, sopInstanceUidList: string[]) {
        //    var query: Models.QueryOptions = new Models.QueryOptions;
        //    var _seriesInstanceUID = seriesInstanceUID;
        //    var _imageBoxNumber = imageBoxNumber;
        //    var _sopInstanceList = sopInstanceUidList;
        //    query.SeriesOptions.SeriesInstanceUID = _seriesInstanceUID;
        //    switch (self._$scope.querySource.name) {
        //        case 'database':
        //            self._queryArchiveService.FindSeries(query, 1).then(function (result) {
        //                if (result.data["FaultType"]) {
        //                    if (result.data["Message"]) {
        //                        alert(result.data["Message"]);
        //                    }
        //                }
        //                else {
        //                    if (result.data && result.data.length > 0) {
        //                        result.data[0].ImageBoxNumber = _imageBoxNumber; // studyLayout.ImageBoxNumber;
        //                        result.data[0].SopInstanceUIDs = _sopInstanceList;
        //                        self.loadSeries({ InstanceUID: result.data[0].StudyInstanceUI}, result.data[0]
        //                        );
        //                    }
        //                }
        //            });
        //            break;
        //        case 'pacs':
        //            self._queryPacsService.FindSeries(self._$scope.querySource.pacs, self._queryPacsService.clientAETitle, query).then(function (result) {
        //                if (result.data["FaultType"]) {
        //                    if (result.data["Message"]) {
        //                        alert(result.data["Message"]);
        //                    }
        //                }
        //                else {
        //                    if (result.data && result.data.length > 0) {
        //                        result.data[0].SopInstanceUIDs = _sopInstanceList;
        //                        self.loadSeries({ InstanceUID: result.data[0].StudyInstanceUID}, result.data[0]);
        //                    }
        //                }
        //            });
        //            break;
        //    }
        //}
        SearchViewController.prototype.getImageBox = function (imageBoxNumber, boxes) {
            var index = 0;
            var length = boxes.length;
            for (index = 0; index < length; index++) {
                if (boxes[index].ImageBoxNumber == imageBoxNumber)
                    return index;
            }
            return -1;
        };
        SearchViewController.prototype.loadStudy = function (checkHangingProtocol) {
            var self = this;
            //eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
            //}.bind(this));
            this._dataCache['StudyInstanceUID'] = this._selectedStudy.InstanceUID;
            var studyLayout = null;
            this._objectRetrieveService.GetStudyLayout((this._selectedStudy.InstanceUID)).then(function (result) {
                studyLayout = result.data;
                self._templateService.currentHangingProtocol = null;
                if (result.data == "") {
                    var counter = 0;
                    var index = 0;
                    var length = self._$scope.gridOptionsSeries.rowData.length;
                    for (index = 0; index < length; index++) {
                        if (self._$scope.gridOptionsSeries.rowData[index].CompleteMRTI) {
                            counter++;
                        }
                    }
                }
                self._templateService.currentStudyLayout = studyLayout;
                if (!angular.isDefined(studyLayout["Series"])) {
                    self.loadSeries(self._selectedStudy, self._$scope.gridOptionsSeries.rowData[0], false);
                }
                else {
                    studyLayout['studyInstanceUID'] = self._selectedStudy.InstanceUID;
                    $.each(studyLayout.Series, function (index, item) {
                        var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                        if (!series) {
                            self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)].referencedSOPInstanceUID, false, "");
                        }
                    });
                    $.each(studyLayout.OtherStudies, function (index, study) {
                        $.each(study.Series, function (index, item) {
                            var series = self._seriesManagerService.get_seriesInfo(item.SeriesInstanceUID);
                            if (!series) {
                                self.queryForSeries(self, item.SeriesInstanceUID, item.ImageBoxNumber, studyLayout.Boxes[self.getImageBox(item.ImageBoxNumber, studyLayout.Boxes)].referencedSOPInstanceUID, false, "");
                            }
                        });
                    });
                }
            });
            this._viewStudy = false;
        };
        SearchViewController.prototype.autoLoadWithHangingProtocol = function () {
            var nodes = this._$scope.gridOptions.api.getSelectedNodes();
            this.studySelected(nodes[0]);
            this.waitForSeries(nodes[0], true);
        };
        SearchViewController.prototype.loadSeries = function (study, series, loadstructureDisplay) {
            this._eventService.publish(EventNames.SeriesSelected, {
                study: study,
                series: series,
                remote: this._$scope.querySource.name == 'pacs',
                structureDisplay: loadstructureDisplay,
                templateItem: study.templateItem,
                studyLoad: true,
                dentalSearchController: this
            });
        };
        SearchViewController.prototype.loadHangingProtocolSeries = function (study, series, view) {
            this._eventService.publish(EventNames.SeriesSelected, {
                study: study,
                series: series,
                view: view,
                remote: this._$scope.querySource.name == 'pacs',
                displaySetNumber: view.DisplaySetNumber
            });
        };
        SearchViewController.prototype.matchTemplateForSeries = function (data) {
            var StudyInstanceUID = data.node.data.StudyInstanceUID;
            var SeriesInstanceUID = data.node.data.InstanceUID;
            if (StudyInstanceUID && SeriesInstanceUID) {
                //read first instance's json
                var promise = this._objectRetrieveService.GetDicomJSON(StudyInstanceUID, SeriesInstanceUID, '');
                //on success
                promise.success(function (json) {
                    var _template = null;
                    this.getAutoMatchTemplates().some(function (template) {
                        //parse the json and see if we have a match
                        try {
                            if (!_template) {
                                if (Utils.executeScript(template.AutoMatching, json)) {
                                    console.log('template auto-match found');
                                    _template = template;
                                    return true; //break;
                                }
                            }
                        }
                        catch (e) {
                            console.log(e);
                        }
                        return false; //continue
                    });
                    //use template (if any) to view
                    this._eventService.publish(EventNames.SeriesSelected, {
                        study: this._selectedStudy,
                        series: data.node.data,
                        remote: this._$scope.querySource.name == 'pacs',
                        template: _template
                    });
                }.bind(this));
                //on error - default to no template - continue loading
                promise.error(function (e) {
                    console.log(e);
                    this._eventService.publish(EventNames.SeriesSelected, {
                        study: this._selectedStudy,
                        series: data.node.data,
                        remote: this._$scope.querySource.name == 'pacs'
                    });
                });
            }
            else {
                console.log('failed to read study/series id');
                //default to no template - continue loading
                this._eventService.publish(EventNames.SeriesSelected, {
                    study: this._selectedStudy,
                    series: data.node.data,
                    remote: this._$scope.querySource.name == 'pacs'
                });
            }
        };
        SearchViewController.prototype.seriesSelected = function (data) {
            var selectedNodes = this._$scope.gridOptionsSeries.api.getSelectedNodes();
            this._templateService.currentStudyLayout = null;
            if (selectedNodes.length == 1) {
                if (selectedNodes[0].data != this._selectedSeries) {
                    this._selectedSeries = data.node.data;
                    if (this.isAnyTemplateAutoMatch()) {
                        this.matchTemplateForSeries(data);
                    }
                    else {
                        this._eventService.publish(EventNames.SeriesSelected, {
                            study: this._selectedStudy,
                            series: data.node.data,
                            remote: this._$scope.querySource.name == 'pacs'
                        });
                    }
                }
                else if (selectedNodes[0].data == this._selectedSeries) {
                    var tab = this._seriesManagerService.get_seriesTab(data.node.data.InstanceUID);
                    if (tab != null) {
                        this._tabService.select_tab(tab.id);
                    }
                    else {
                        if (this.isAnyTemplateAutoMatch()) {
                            this.matchTemplateForSeries(data);
                        }
                        else {
                            this._eventService.publish(EventNames.SeriesSelected, {
                                study: this._selectedStudy,
                                series: data.node.data,
                                remote: this._$scope.querySource.name == 'pacs'
                            });
                        }
                    }
                }
            }
        };
        SearchViewController.prototype.contextMenu = function (data) {
            this._selectedSeries = data.data;
            this._$scope.gridOptionsSeries.api.selectNode(data.node, false, true);
            $('.seriesContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
            if (this._openWith.length > 0) {
                $('.data-title').attr('data-menutitle', this._openWith);
            }
        };
        SearchViewController.prototype.hpContextMenu = function (data) {
            this._$scope.gridOptions.api.selectNode(data.node, false, true);
            this.studySelected(data);
            this.waitForSeries(data);
        };
        SearchViewController.prototype.handleCellClicked = function (params) {
            if (lt.LTHelper.OS == lt.LTOS.iOS && lt.LTHelper.device != lt.LTDevice.desktop) {
                if (this._rowIndexPrevious == params.rowIndex) {
                    if (this._viewStudy == false) {
                        this._$scope.hpContextMenu(params);
                    }
                }
                this._rowIndexPrevious = params.rowIndex;
            }
        };
        SearchViewController.prototype.waitForSeries = function (data, loadBest) {
            var self = this;
            if (this._loadingStudySeries == true) {
                setTimeout(function () {
                    self.waitForSeries(data);
                }, 100);
            }
            else {
                var query = new Models.HangingProtocolQuery();
                var modalites = this.get_ModalitesInActiveStudy();
                this._loadingHangingProtocols = true;
                this._hangingProtocols = new Array();
                var isDental = this._optionsService.isSeriesView();
                this.waitForHangingProtocols(data, loadBest);
                this._queryArchiveService.FindHangingProtocols(data.data.InstanceUID).then(function (result) {
                    self._hangingProtocols = result.data;
                    self._loadingHangingProtocols = false;
                });
            }
        };
        SearchViewController.prototype.showStructuredDisplayMenu = function (data, loadBest) {
            var self = this;
            if (this._loadingHangingProtocols == true) {
                setTimeout(function () {
                    self.showStructuredDisplayMenu(data, loadBest);
                }, 100);
            }
            else {
                $('.studyContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
                if (this._sdOpenWith.length > 0) {
                    $('.data-title').attr('data-menutitle', this._sdOpenWith);
                }
            }
        };
        //
        // Waits for all the hanging protocols to be loaded.  If load best is true then the
        // best matched hanging protocol will be loaded. 
        //
        SearchViewController.prototype.waitForHangingProtocols = function (data, loadBest) {
            var self = this;
            if (this._loadingHangingProtocols == true) {
                setTimeout(function () {
                    self.waitForHangingProtocols(data, loadBest);
                }, 100);
            }
            else {
                if (this._hangingProtocols && this._hangingProtocols.length >= 0) {
                    if (!loadBest) {
                        $('.studyContext').contextMenu({ x: data.event.pageX, y: data.event.pageY });
                        if (this._hpOpenWith.length > 0) {
                            $('.data-title').attr('data-menutitle', this._hpOpenWith);
                        }
                    }
                    else {
                        if (this._hangingProtocols.length == 0) {
                            this._objectRetrieveService.GetHangingProtocol(self._hangingProtocols[0].SOPInstanceUID).then(function (result) {
                                var hp = result.data;
                                self._templateService.currentStudyLayout = null;
                                self._templateService.currentHangingProtocol = hp;
                                self._objectRetrieveService.GetHangingProtocolInstances(self._hangingProtocols[0].SOPInstanceUID, self._selectedStudy.Patient.ID, self._selectedStudy.InstanceUID, null).then(function (result) {
                                    self.loadHangingProtocol(result.data, hp);
                                }, function (error) {
                                });
                            });
                        }
                    }
                }
                //else {
                //    self.loadStudy(false);
                //}
            }
        };
        SearchViewController.prototype.get_ModalitesInActiveStudy = function () {
            var modalities = new Array();
            var count = this._$scope.gridOptionsSeries.rowData.length;
            for (var i = 0; i < count; i++) {
                var series = this._$scope.gridOptionsSeries.rowData[i];
                if (modalities.indexOf(series.Modality) == -1)
                    modalities.push(series.Modality);
            }
            return modalities;
        };
        SearchViewController.prototype.get_hangingProtocolsType = function (level) {
            var menuItems = {};
            var isEmpty = true;
            var iconName = "";
            switch (level) {
                case Models.HangingProtocolLevel.Manufacturer:
                    iconName = "fa-gear";
                    break;
                case Models.HangingProtocolLevel.Site:
                    iconName = "fa-institution";
                    break;
                case Models.HangingProtocolLevel.UserGroup:
                    iconName = "fa-group";
                    break;
                case Models.HangingProtocolLevel.SingleUser:
                    iconName = "fa-user";
                    break;
            }
            for (var i = 0; i < this._hangingProtocols.length; i++) {
                var protocolResult = this._hangingProtocols[i];
                if (protocolResult.Level == level) {
                    isEmpty = false;
                    menuItems[protocolResult.SOPInstanceUID] = {
                        name: protocolResult.Name,
                        icon: iconName
                    };
                }
            }
            if (isEmpty) {
                menuItems = null;
            }
            return menuItems;
        };
        SearchViewController.prototype.addSeparator = function (menuItems, needsSeparator, separatorName) {
            if (needsSeparator)
                menuItems[separatorName] = "---------";
        };
        SearchViewController.prototype.get_hangingProtocols = function () {
            var menuItems = {};
            var manufacturerItems = this.get_hangingProtocolsType(Models.HangingProtocolLevel.Manufacturer);
            var siteItems = this.get_hangingProtocolsType(Models.HangingProtocolLevel.Site);
            var userGroupItems = this.get_hangingProtocolsType(Models.HangingProtocolLevel.UserGroup);
            var singleUserItems = this.get_hangingProtocolsType(Models.HangingProtocolLevel.SingleUser);
            var needsSeparator = false;
            // Manufacturer Items
            if (manufacturerItems != null) {
                menuItems = jQuery.extend(menuItems, manufacturerItems);
                needsSeparator = true;
            }
            // Site
            if (siteItems != null) {
                this.addSeparator(menuItems, needsSeparator, "sepSite");
                menuItems = jQuery.extend(menuItems, siteItems);
                needsSeparator = true;
            }
            // User Group
            if (userGroupItems != null) {
                this.addSeparator(menuItems, needsSeparator, "sepUserGroup");
                menuItems = jQuery.extend(menuItems, userGroupItems);
                needsSeparator = true;
            }
            // Single User
            if (singleUserItems != null) {
                this.addSeparator(menuItems, needsSeparator, "sepSingleUser");
                menuItems = jQuery.extend(menuItems, singleUserItems);
                needsSeparator = true;
            }
            // No Hanging Protocols found, so create a menu that indicates this
            if (needsSeparator == false) {
                menuItems = {
                    "NoHangingProtocolFound_407B6C09-83C2-4A7F-9643-AA4301F6A67A": {
                        name: "No Hanging Protocols",
                        // disabled: true,
                        icon: "fa-exclamation-triangle",
                        className: "context-menu-red-message"
                    },
                };
            }
            return menuItems;
        };
        SearchViewController.prototype.get_hangingProtocols_test = function () {
            var items = {
                "Manufacturer": { name: "Manufacturer", disabled: true },
                "edit": { name: "Edit", icon: "edit" },
                "cut": { name: "Cut", icon: "fa-gear" },
                "sepSite": "---------",
                "Site": { name: "Site", disabled: true },
                "copy": { name: "Copy", icon: "copy" },
                "paste": { name: "Paste", icon: "paste" },
                "stayOpen": { name: "StayOpen", icon: "paste", callback: function () { return false; } },
                "sepUserGroup": "---------",
                "UserGroup": { name: "User Group", disabled: true },
            };
            return items;
        };
        SearchViewController.$inject = ['$rootScope', '$scope', '$modal', 'eventService', 'queryArchiveService', 'optionsService', 'dataService', 'queryPacsService', 'authenticationService', 'tabService', 'seriesManagerService', 'objectStoreService', 'templateService', 'templateEditorService', '$translate', 'objectRetrieveService', 'dataCache'];
        return SearchViewController;
    }(SearchController));
    Controllers.SearchViewController = SearchViewController;
    //export class SearchViewController extends SearchController {
    //}
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../controls/OverflowManager.ts" />
var Controllers;
(function (Controllers) {
    var DentalViewerController = /** @class */ (function () {
        function DentalViewerController($rootScope, $scope, eventService, toolbarService, optionsService, seriesManagerService, objectRetrieveService, dataService, tabService, dicomLoaderService, hotkeys, templateService, authenticationService, queryArchiveService) {
            this._listController = null;
            this._objectRetrieveService = null;
            // this is a timer to keep trying to see if the layout is ready for the overflow manager to be created.
            this._overflowTimerId = -1;
            // this is the list for the items to be added to the overflow manager when the overflow manager is not ready yet.
            this._overflowManagerReadyList = [];
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var singleSeries = optionsService.get(OptionNames.SingleSeriesMode);
            var __this = this;
            var spacingSize = Utils.get_spacingSize();
            var overflowSize = optionsService.get(OptionNames.SeriesThumbnailWidth) * 2;
            __this._templateService = templateService;
            if (overflowSize > 150)
                overflowSize = 150;
            this._toolbarService = toolbarService;
            this._tabService = tabService;
            $scope.layoutConfig = {
                autoBindCustomButtons: true,
                scrollToBookmarkOnLoad: false,
                applyDemoStyles: true,
                spacing_closed: spacingSize * 2,
                spacing_open: spacingSize * 2,
                livePaneResizing: false,
                west__size: $(window).width() * (Utils.isTabletOrMobile() ? .25 : .25),
                west__resizable: true,
                west__togglerLength_closed: 21,
                south__resizable: false,
                south__initHidden: true,
                south__togglerContent_open: "<span style='vertical-align:top; color:white; vertical-align:middle'>Overflow</span>",
                south__togglerLength_open: 64,
                south__togglerContent_closed: "<span style='vertical-align:top; color:white'>Overflow</span>",
                south__togglerLength_closed: 64,
                south__size: overflowSize,
                east__initHidden: true,
                east__resizable: true,
                east__size: $(window).width() * (Utils.isTabletOrMobile() ? .25 : .25),
                north__size: "auto",
                north__resizable: false,
                north__showOverflowOnHover: true
            };
            $scope.toolbars = toolbarService.getToolbars();
            $scope.query = new Models.QueryOptions();
            $scope.tabId = '';
            $scope.viewerId = UUID.generate();
            $scope.overflowId = UUID.generate();
            $scope.viewerConfig = new MedicalViewerConfig();
            $scope.viewerConfig.rows = 1;
            $scope.viewerConfig.columns = 1;
            $scope.viewerConfig.splitterSize = Utils.get_splitterSize();
            $scope.viewerConfig.studyLayout = templateService.currentStudyLayout;
            $scope.viewerapi = {};
            $scope.viewerConfig.OnApiReady = function (viewerApi) {
                __this._viewerApi = viewerApi;
                __this._toolbarService.enable("DeleteStudyStructuredDisplay" + __this._tabService.selectedTab.id, function () {
                    return viewerApi.hasLayout;
                });
            };
            $scope.layoutApi = {};
            $scope.seriesList = new Array();
            $scope.autoHideEW = false;
            this._objectRetrieveService = objectRetrieveService;
            this._scope = $scope;
            this._overflowManager = null;
            var deregister = $scope.$watch('tabId', function (newValue, oldValue) {
                var unsubscribe;
                tabService.set_tabData($scope.tabId, TabDataKeys.ViewController, __this);
                tabService.set_tabData($scope.tabId, TabDataKeys.Linked, true);
                deregister();
                unsubscribe = eventService.subscribe(EventNames.ToolbarCreated, function (event, data) {
                    if (data.args == $scope.tabId) {
                        var cell = seriesManagerService.get_activeCell();
                        var linked = optionsService.get(OptionNames.LinkImages);
                        var cell = data.args.cell;
                        toolbarService.disable("PopupCapture" + $scope.tabId);
                        toolbarService.updateClass('LinkImages' + $scope.tabId, 'Linked', 'UnLinked', function () { return linked; });
                        eventService.publish(EventNames.RefreshToolbar, { cell: cell, tab: null, viewer: cell ? cell.viewer : null });
                        unsubscribe();
                        if (angular.isDefined($scope.layoutApi.refresh)) {
                            setTimeout(function () {
                                $scope.layoutApi.openPane('north');
                                $scope.layoutApi.refresh();
                            }, 900);
                        }
                    }
                });
                eventService.subscribe(EventNames.LoadSeries + $scope.tabId, function (event, data) {
                    var series = new MedicalViewerSeries(data.args.series.InstanceUID, data.args.series.Patient.ID);
                    var patientSeries = seriesManagerService.currentLoadingSeries.Patient.ID;
                    series.template = data.args.template;
                    series.dislaySetNumber = data.args.displaySetNumber;
                    series.type = data.args.isSTL ? "stl" : "dicom";
                    series.modality = data.args.series.Modality;
                    series.mrtiCell = data.args.series.mrtiCell;
                    if (singleSeries) {
                        $scope.seriesList.length = 0;
                    }
                    else {
                        var cellCount = 1;
                        var s = data.args.series;
                        var result = $.grep($scope.seriesList, function (e, index) {
                            return s.Patient.ID != e.patientID;
                        });
                        if (angular.isDefined($scope.viewerapi.get_cellCount)) {
                            cellCount = $scope.viewerapi.get_cellCount();
                        }
                        else {
                            cellCount = $scope.viewerConfig.columns * $scope.viewerConfig.rows;
                        }
                        if (result.length != 0 || cellCount <= 1) {
                            $scope.seriesList.length = 0;
                        }
                    }
                    if (__this._overflowManager != null) {
                        __this._overflowManager.clear();
                    }
                    series.link = optionsService.get(OptionNames.LinkImages);
                    $scope.seriesList.push(series);
                    $scope.autoHideEW = (patientSeries.length < 2) || (lt.LTHelper.device == lt.LTDevice.mobile);
                    $scope.$apply();
                    if (angular.isDefined($scope.layoutApi.closePane)) {
                        $scope.layoutApi.closePane('south');
                    }
                });
                eventService.subscribe(EventNames.LoadStructuredDisplay + $scope.tabId, function (event, data) {
                    var tab = seriesManagerService.get_seriesTab(data.args.series.InstanceUID);
                    if (tab != null && tab.id == $scope.tabId) {
                        var series = new MedicalViewerSeries(data.args.series.InstanceUID, data.args.series.Patient.ID, data.args.sdID);
                        series.templateItem = data.args.templateItem;
                        // don't load series layout when you load the structured display
                        series.loadSeriesLayout = false;
                        // series.sopInstanceUIDS: null or empty if all instances in the series should be loaded
                        //                       : contains a list of SOPInstanceUids
                        series.sopInstanceUIDS = data.args.series.SopInstanceUIDs; //new Array<string>(2);
                        series.template = data.args.template;
                        series.dislaySetNumber = data.args.displaySetNumber;
                        series.mrtiCell = data.args.series.mrtiCell;
                        if (seriesManagerService.cleanupSeries) {
                            $scope.seriesList.length = 0;
                            seriesManagerService.cleanupSeries = false;
                        }
                        {
                            var s = data.args.series;
                            var result = $.grep($scope.seriesList, function (e, index) {
                                return s.Patient.ID != e.patientID;
                            });
                            if (result.length != 0) {
                                $scope.seriesList.length = 0;
                            }
                        }
                        if (!angular.isDefined(series.dislaySetNumber)) {
                            objectRetrieveService.GetSeriesStacks(data.args.series.InstanceUID).then(function (result) {
                                var stacks = result.data;
                                series.link = optionsService.get(OptionNames.LinkImages);
                                if (stacks.length > 1)
                                    series.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                                tab.itemCount += (stacks.length != 0) ? stacks.length : 1;
                                var cellCount = tab.itemCount;
                                if (!cellCount)
                                    cellCount = 0;
                                if ($scope.viewerapi != null) {
                                    var viewer = $scope.viewerapi.getMedicalViewer();
                                    //updateGridLayoutSize(viewer, cellCount);
                                }
                                if (data.args.series.ImageBoxNumber == -1) {
                                    eventService.publish(EventNames.InstanceOverflow, {
                                        instance: data.args.series.SopInstanceUIDs,
                                        metadata: 0,
                                        frame: 0,
                                        parentCell: null,
                                        parentViewer: viewer
                                    });
                                }
                                else {
                                    $scope.seriesList.push(series);
                                    if (stacks.length > 1) {
                                        for (var i = 1; i < stacks.length; i++) {
                                            var stackSeries;
                                            stackSeries = angular.copy(series);
                                            //Add the parent display number
                                            if (data.args != null)
                                                stackSeries.view = data.args.view;
                                            stackSeries.id = UUID.genV4().toString();
                                            stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                                            $scope.seriesList.push(stackSeries);
                                        }
                                    }
                                }
                            }.bind(this));
                        }
                        else {
                            if (data.args.series.ImageBoxNumber == -1) {
                                eventService.publish(EventNames.InstanceOverflow, {
                                    instance: data.args.series.SopInstanceUIDs,
                                    metadata: 0,
                                    frame: 0,
                                    parentCell: null,
                                    parentViewer: viewer
                                });
                            }
                            else {
                                if ($scope.viewerapi != null) {
                                    if ($scope.viewerapi.getMedicalViewer != null) {
                                        var viewer = $scope.viewerapi.getMedicalViewer();
                                        tab.itemCount++;
                                        //updateGridLayoutSize(viewer, tab.itemCount);
                                    }
                                }
                                $scope.seriesList.push(series);
                            }
                        }
                    }
                    if ($scope.layoutApi && $scope.layoutApi.closePane) {
                        $scope.layoutApi.closePane('east');
                    }
                });
            });
            $scope.setListController = function (listController) {
                __this._listController = listController;
            };
            $scope.getListController = function () {
                return __this._listController;
            };
            $scope.InitializeOverflowManager = function (tab) {
                if (tab != null) {
                    $scope.layoutApi.openPane('south');
                    if (__this._overflowManager == null) {
                        __this._overflowManager = new OverflowManager("#" + $scope.overflowId, dicomLoaderService.get_newLoader(), { api: __this._scope.layoutApi, direction: 'south' }, tabService, tab, eventService);
                        if (!$("#" + $scope.overflowId)[0]) {
                            __this._overflowManager = null;
                        }
                    }
                }
                if (__this._overflowManager) {
                    $scope.layoutApi.openPane('south');
                    for (var index = 0; index < __this._overflowManagerReadyList.length; index++) {
                        __this._overflowManager.add(__this._overflowManagerReadyList[index].instance);
                        // set the seriesInstance for the overflow manager.
                        if (index == 0)
                            __this._overflowManager.set_seriesInstanceUID(__this._overflowManagerReadyList[index].instance.SeriesInstanceUID);
                    }
                    __this._overflowManager.filterOutInvalidOverflow(seriesManagerService);
                    __this._overflowManagerReadyList = [];
                    return true;
                }
                return false;
            };
            eventService.subscribe(EventNames.InstanceOverflow, function (event, data) {
                if (!$scope.isOverflowItemValid(seriesManagerService, data.args.instance.SeriesInstanceUID))
                    return;
                // add the data to the rady list so when the layout is ready, creat the overflow and add them.
                __this._overflowManagerReadyList.add(data.args);
                var tab = seriesManagerService.get_seriesTab(data.args.instance.SeriesInstanceUID);
                if (!tab)
                    return;
                // the layout is not ready yet, for some fucking reason, we need to keep looping and try until it is.
                if (!$scope.layoutApi.openPane) {
                    // keep trying every 500 millisecond until the data is ready.
                    if (__this._overflowTimerId == -1) {
                        __this._overflowTimerId = window.setInterval(function (e) {
                            // the layout is ready, initialize now.
                            if ($scope.layoutApi.openPane)
                                if ($scope.InitializeOverflowManager(tab)) {
                                    // initializtion is a success, clear the timer now and rest the variables.
                                    window.clearInterval(__this._overflowTimerId);
                                    __this._overflowTimerId = -1;
                                }
                        }, 500);
                    }
                }
                else
                    $scope.InitializeOverflowManager(tab);
            });
            eventService.subscribe(EventNames.InstanceOverflowClear, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (!tab)
                    tab = data.args.tab;
                if (tab != null && tab.id == $scope.tabId) {
                    if (__this._templateService.currentStudyLayout.LoadedBoxes == 0) {
                        __this._toolbarService.disable("PopupCapture" + tab.id);
                    }
                    if (__this._overflowManager != null) {
                        __this._overflowManager.clear();
                    }
                }
            });
            eventService.subscribe(EventNames.InstanceOverflowClose, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (!tab)
                    tab = data.args.tab;
                if (tab != null && tab.id == $scope.tabId) {
                    $scope.layoutApi.closePane('south');
                }
            });
            $scope.previousImage = function () {
                var cell = seriesManagerService.get_activeCell();
                var current = cell.currentOffset;
                if (current != 0 && current >= 1) {
                    cell.currentOffset = current - 1;
                    //$scope.currentPosition = current - 1;
                }
            };
            $scope.isOverflowItemValid = function (seriesManagerService, seriesInstanceUID) {
                // we assume it's valid... if there is no information at all
                var valid = true;
                // if there is a currentloadingSeries, then we check if the series matches the seriesInstanceUID in question.
                if (seriesManagerService.currentLoadingSeries) {
                    valid = false;
                    if (seriesManagerService.currentLoadingSeries.InstanceUID == seriesInstanceUID)
                        return true;
                }
                // if there is a structured display, then we check if there is any reference in the SeriesInstanceUID in the structured display.
                if (seriesManagerService.currentStructuredDisplay) {
                    valid = false;
                    if (seriesManagerService.currentStructuredDisplay.Series) {
                        var index = 0;
                        var length = seriesManagerService.currentStructuredDisplay.Series.length;
                        for (index = 0; index < length; index++) {
                            if (seriesManagerService.currentStructuredDisplay.Series[index].SeriesInstanceUID == seriesInstanceUID)
                                return true;
                        }
                    }
                }
                return false;
            };
            $scope.nextImage = function () {
                var cell = seriesManagerService.get_activeCell();
                var seriesInstanceUID = cell.seriesInstanceUID;
                var max = seriesManagerService.get_maxAllowedStackIndex(cell);
                var current = cell.currentOffset;
                if (current != -1 && current < max) {
                    cell.currentOffset = current + 1;
                    //$scope.currentPosition = current + 2;
                }
            };
            hotkeys.bindTo($scope)
                .add({
                combo: ['+', 'down'],
                description: 'Next Image',
                callback: $scope.nextImage
            })
                .add({
                combo: ['-', 'up'],
                description: 'Previous Image',
                callback: $scope.previousImage
            });
        }
        DentalViewerController.prototype.getListController = function () {
            return this._listController;
        };
        DentalViewerController.prototype.getViewer = function () {
            return this._scope.viewerapi.getMedicalViewer();
        };
        DentalViewerController.prototype.getOverflowManager = function () {
            return this._overflowManager;
        };
        DentalViewerController.prototype.showTimeLine = function () {
        };
        DentalViewerController.prototype.isTimeLineShowing = function () {
            return false;
        };
        DentalViewerController.prototype.hideTimeLine = function () {
        };
        DentalViewerController.prototype.hasLayout = function () {
            return this._viewerApi.hasLayout;
        };
        DentalViewerController.prototype.getStudyLayout = function () {
            return this._viewerApi.studyLayout;
        };
        DentalViewerController.prototype.clearLayout = function () {
            this._viewerApi.clearLayout();
        };
        DentalViewerController.prototype.setStudyLayout = function (layout) {
            this._viewerApi.studyLayout = layout;
        };
        DentalViewerController.$inject = [
            '$rootScope', '$scope', 'eventService', 'toolbarService', 'optionsService', 'seriesManagerService',
            'objectRetrieveService', 'dataService', 'tabService', 'dicomLoaderService', 'hotkeys', 'templateService', 'authenticationService', 'queryArchiveService'
        ];
        return DentalViewerController;
    }());
    Controllers.DentalViewerController = DentalViewerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var SeriesListController = /** @class */ (function () {
        function SeriesListController($rootScope, $scope, uiGridConstants, eventService, optionsService, dataService, seriesManagerService, $commangular, templateService, objectRetrieveService, tabService, authenticationService) {
            this._templatesHasAutoMatch = false;
            this._autoExpand = false;
            this._unsubscribeList = [];
            var dateFormat = optionsService.get(OptionNames.DateFormat);
            var timeFormat = optionsService.get(OptionNames.TimeFormat);
            var patientId = seriesManagerService.currentLoadingSeries.Patient.ID;
            var __this = this;
            var seriesGroup = "Series List";
            var compareButton;
            this._options = optionsService;
            this._objectRetrieveService = objectRetrieveService;
            this._tabService = tabService;
            $scope.setListController(this);
            $scope.activeSeriesInstanceUID = seriesManagerService.currentLoadingSeries.InstanceUID;
            this._templates = Utils.Templates;
            this.updateTemplatesHaveAutoMatch();
            //if (authenticationService.hasPermission(PermissionNames.CanViewTemplates)) {
            //    templateService.GetAllTemplates().then(function (result) {
            //        if (result && result.data) {
            //            this._templates = result.data;
            //            this.updateTemplatesHaveAutoMatch();
            //        }
            //    }.bind(this));
            //}
            this._scope = $scope;
            this._seriesManagerService = seriesManagerService;
            this._eventService = eventService;
            this._$commangular = $commangular;
            this._seriesTemplate = {};
            this._authenticationService = authenticationService;
            this._objectRetrieveService = objectRetrieveService;
            var searchResultID = $("div.seriesList");
            var div = searchResultID[searchResultID.length - 1];
            div.id = patientId;
            this._enabled = true;
            this.refreshContent(objectRetrieveService, seriesManagerService, patientId);
            this._dataService = dataService;
            this._unsubscribeList.add(eventService.subscribe(EventNames.EnableSeriesList, function (event, data) {
                __this.EnableList(data.args.enable);
            }));
            this._unsubscribeList.add(eventService.subscribe(EventNames.ActiveSeriesChanged, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (tab != null) {
                    if (tab.id == $scope.tabId) {
                        $scope.activeSeriesInstanceUID = data.args.series;
                        // don't change selection if the selected is structured display, 
                        // because the user might click on one of the structured display images,
                        // and make the list swtich to that image on the series.
                        if (!__this._seriesManagerService.currentStructuredDisplay)
                            __this.selectSeries($scope.activeSeriesInstanceUID);
                    }
                }
            }));
            this._unsubscribeList.add(eventService.subscribe(EventNames.DerivedImageCreated, function (event, data) {
                if ($.grep(__this._seriesManagerService.currentPatientSeries, function (item) { return item.InstanceUID == data.args.series.InstanceUID; }).length == 0) {
                    seriesManagerService.currentPatientSeries[seriesManagerService.currentPatientSeries.length] = data.args.series;
                    seriesManagerService.currentLoadingSeries = data.args.series;
                    __this.refreshContent(objectRetrieveService, seriesManagerService, patientId);
                }
            }));
            this._unsubscribeList.add(eventService.subscribe(EventNames.SelectedTabChanged, function (event, data) {
                //setTimeout(function () {
                //    $scope.gridOptions.api.refreshView();
                //}, 250);
            }));
            $scope.$on("$destroy", function handler() {
                var index = 0;
                var length = __this._unsubscribeList.length;
                for (index = 0; index < length; index++) {
                    eventService.unsubscribe(__this._unsubscribeList[index]);
                }
            });
            eventService.subscribe(EventNames.MrtiInfoReady, function (event, data) {
                if ($scope && $scope.gridOptionsSeries) {
                    Utils.clearMrti($scope.gridOptions.api, $scope.gridOptions.rowData, data.args.seriesInstanceUID);
                }
            }.bind(this));
            $scope.all = { checked: false };
            $scope.doCheckAll = function (checkAll) {
                var list = this.getListController();
                list.Deselect();
                if (checkAll) {
                    var index = 1;
                    var length = list._list.rows.length;
                    for (index = 1; index < length; index += 2) {
                        if (list._list.rows[index].data) {
                            list._list.rows[index].setAttribute("Selected", "1");
                        }
                        if (__this.isSubTreeExpanded(list._list.rows[index])) {
                            __this.RecheckAllSubTree(list._list.rows[index]);
                        }
                    }
                }
                var nodes = list.getSelectedSeries();
                list._compareButton.disabled = (nodes.length < 2);
                list.RefreshList();
            };
        }
        SeriesListController.prototype.EnableList = function (enable) {
            var loadingScreen = document.getElementById("seriesLoadingScreen");
            this._enabled = enable;
            if (this._enabled) {
                this._list.style.pointerEvents = "all";
                if (loadingScreen)
                    loadingScreen.style.visibility = "hidden";
            }
            else {
                this._list.style.pointerEvents = "none";
                if (loadingScreen)
                    loadingScreen.style.visibility = "visible";
            }
        };
        SeriesListController.prototype.ClearList = function (patientId) {
            var list = this._list;
            if (!list)
                return;
            list.parentElement.id = patientId;
            var index = 0;
            var length = list.rows.length;
            for (index = 1; index < length; index++) {
                list.deleteRow(1);
            }
        };
        SeriesListController.prototype.setNewSeriesListData = function (listData, patientId, seriesManagerService, objectRetrieveService) {
            var __this = this;
            __this.ClearList(seriesManagerService.currentLoadingSeries.Patient.ID);
            // remove structured display that doesn't contain in value in Boxes, which is where you supposed to load the image.
            var data = __this.filterBadStructuredDisplay(listData);
            seriesManagerService.structuredDisplayList = data;
            __this._sturctureDisplayList = data;
            var searchResultID = $("div.seriesList");
            var myTable = __this.getTableDiv(searchResultID, seriesManagerService.currentLoadingSeries.Patient.ID);
            __this._span = myTable.children[0];
            __this._list = myTable.children[1];
            __this._list.parentElement.id = patientId;
            __this.fillTable(seriesManagerService.currentPatientSeries, seriesManagerService.structuredDisplayList);
            __this.prepareButtons();
            __this.registerEvents();
            __this.selectSeries(seriesManagerService.currentLoadingSeries.InstanceUID);
        };
        SeriesListController.prototype.refreshContent = function (objectRetrieveService, seriesManagerService, patientId) {
            var __this = this;
            var list = seriesManagerService.structuredDisplayList;
            // if the list is there, just use it, if not,  then request it
            if ((list) && (list[0]) && (list[0].Patient)) {
                __this.setNewSeriesListData(list, patientId, seriesManagerService, objectRetrieveService);
            }
            else {
                objectRetrieveService.GetPatientStructuredDisplay(patientId).then(function (result) {
                    __this.setNewSeriesListData(result.data, patientId, seriesManagerService, objectRetrieveService);
                });
            }
        };
        SeriesListController.prototype.getTableDiv = function (searchResultID, id) {
            var index = 0;
            var length = searchResultID.length;
            for (index = 0; index < length; index++) {
                if (searchResultID[index].id == id)
                    return searchResultID[index];
            }
        };
        SeriesListController.prototype.filterBadStructuredDisplay = function (data) {
            var index = 0;
            var length = data.length;
            var output = [];
            var counter = 0;
            for (index = 0; index < length; index++) {
                if (data[index]) {
                    if (data[index].Boxes) {
                        if (data[index].Boxes.length > 0) {
                            output[counter] = data[index];
                            counter++;
                        }
                    }
                }
            }
            return output;
        };
        SeriesListController.prototype.prepareButtons = function () {
            var headers1 = $("div.seriesList");
            var headers = $("span.ag-header-group-text");
            // this._span has 3 children, the first, is the label, the second is the export button, and the 3rd is the compare button.
            this._exportButton = this._span.children[1];
            this._compareButton = this._span.children[2];
            $(this._exportButton).unbind();
            $(this._compareButton).unbind();
            $(this._exportButton).click(this.onExport.bind(this));
            $(this._compareButton).click(this.onCompare.bind(this));
            this.canDoExport();
        };
        SeriesListController.prototype.fillTable = function (currentPatientSeries, structuredDisplayList) {
            var index;
            var length;
            var counter = 1;
            var output = [];
            if (this._options.get(OptionNames.SearchStructuredDisplay)) {
                Utils.findSeriesNotUsedByStructuredDisplay(output, structuredDisplayList, currentPatientSeries, true);
                if (output.length != 0) {
                    if (currentPatientSeries.length != 0) {
                        Utils.prepareDataForSeriesDisplay(output, currentPatientSeries[0], currentPatientSeries[0].Patient);
                        var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
                        var searchController = this._tabService.get_tabData(this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                        if (searchController._selectedStudy == null) {
                            searchController._selectedStudy = currentPatientSeries[0].Patient;
                        }
                    }
                }
            }
            else {
                output = currentPatientSeries;
            }
            Utils.SortData(output);
            var sdIndex = 0;
            index = 0;
            length = output.length;
            var isSD = false;
            for (index = 0; index < length; index++) {
                if (output[index].Boxes != undefined)
                    this.AddRow(this._list, output[index], 'images/SD.jpg', output[index].Name, output[index].SeriesDescription ? output[index].SeriesDescription : "Unknown Structured Display", counter, true, parseInt(this._options.get(OptionNames.SeriesThumbnailHeight)), true);
                else
                    this.AddRow(this._list, output[index], Utils.get_thumbnailUrl(output[index]), output[index].Date, output[index].Description, counter, true, parseInt(this._options.get(OptionNames.SeriesThumbnailHeight)), false);
            }
        };
        SeriesListController.prototype.UpdateSelection = function (row, column) {
            if (this.selectRow(row, column)) {
                if (!this.IsRowSelected(row)) {
                    // this is when you click on the row to deselect it.
                    return;
                }
                var tab = this._tabService.get_allTabs()[this._tabService.activeTab];
                var searchController = this._tabService.get_tabData(this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                // check if the it's a structured display root, load the structured display with all the series.
                var rowData = row.data;
                if (rowData.Boxes) {
                    //this._enabled = false;
                    searchController.loadselectedStructureDisplay(rowData);
                    this._eventService.publish(EventNames.StructuredDisplaySelected, {
                        structureDisplay: row.data,
                    });
                }
                else {
                    // just a normal series.
                    var data = {};
                    data.node = {};
                    data.node.data = rowData;
                    searchController._templateService.currentStudyLayout = null;
                    this.seriesSelected(data);
                }
            }
        };
        // if the user click on the row that has sub-tree, then recheck everything.
        SeriesListController.prototype.RecheckAllSubTree = function (row) {
            // this is the next item on the list, which is the sub-tree.
            var tree = row.nextElementSibling;
            if (tree.children.length == 0)
                return;
            if (tree.children[0].children.length == 0)
                return;
            var table = tree.children[0].children[0];
            var index = 0;
            var length = table.rows.length;
            for (index = 0; index < length; index++) {
                table.rows[index].setAttribute("Selected", "1");
            }
            this.refreshSubtreeSelection(table);
            this.RefreshList();
        };
        SeriesListController.prototype.registerEvents = function () {
            var index;
            var _this = this;
            var rows = this._list.rows.length;
            var j;
            var columns = this._list.rows[0].children.length;
            var rowCounter = -1;
            for (index = 1; index < rows; index++) {
                if (!_this._list.rows[index].data)
                    continue;
                rowCounter++;
                for (j = 0; j < columns; j++) {
                    this._list.rows[index].children[j].setAttribute("rowPosition", index.toString());
                    this._list.rows[index].children[j].setAttribute("colPosition", j);
                    this._list.rows[index].children[j].addEventListener("click", function (e) {
                        if (!_this._enabled)
                            return;
                        _this.EnableList(false);
                        var td = e.currentTarget;
                        var column = parseInt(td.getAttribute("colPosition"));
                        var row = td.parentElement;
                        if (_this.IsRowSelected(row) && !_this.IsMultipleSelection()) {
                            if (_this.IsStructuredDisplay(row)) {
                                if (column == 0) {
                                    if (_this.isSubTreeExpanded(row)) {
                                        // recheck everything if collapse the tree.
                                        _this.RecheckAllSubTree(row);
                                        _this.collapseSubTree(row);
                                    }
                                    else {
                                        _this.expandSubTree(row);
                                    }
                                }
                                // if the user clicks on the tree parent again, then you will reselect everything on the sub-tree in case some are unselected, and you will remove the indetermine if it's not.
                                _this.RecheckAllSubTree(row);
                            }
                            _this.EnableList(true);
                            return;
                        }
                        _this.UpdateSelection(td.parentElement, column);
                        var nodes = _this.getSelectedSeries();
                        _this._compareButton.disabled = (nodes.length < 2);
                        _this.canDoExport();
                    });
                }
            }
        };
        SeriesListController.prototype.canDoExport = function () {
            this._exportButton.disabled = !(this._authenticationService.hasPermission(PermissionNames.CanStore));
        };
        SeriesListController.prototype.unregisterEvents = function () {
            var index;
            var rows = this._list.rows.length;
            var j;
            var columns = this._list.rows[0].children.length;
            ;
            for (index = 1; index < rows; index++) {
                for (j = 0; j < columns; j++) {
                    this._list.rows[index].children[j].removeAttribute("rowPosition");
                    this._list.rows[index].children[j].removeAttribute("colPosition");
                }
            }
        };
        SeriesListController.prototype.GetSubtreeTable = function (parent) {
            return parent.cells[0].children[0];
        };
        SeriesListController.prototype.Deselect = function (includingSubTree) {
            var index;
            var length = this._list.rows.length;
            var input;
            var row;
            // set all rows to false.
            for (index = 1; index < length; index++) {
                if (this._list.rows[index].data) {
                    this._list.rows[index].setAttribute("Selected", "0");
                }
                else if (this._list.rows[index]) {
                    // that is the sub-tree row.
                    if (includingSubTree) {
                        // get the sub tree
                        var table = this.GetSubtreeTable(this._list.rows[index]);
                        var subIndex = 0;
                        var sublength = table.rows.length;
                        // loop through all the subtree items and set them to false.
                        for (subIndex = 0; subIndex < sublength; subIndex++) {
                            row = table.rows[subIndex];
                            row.setAttribute("Selected", "0");
                        }
                    }
                }
            }
        };
        SeriesListController.prototype.IsMultipleSelection = function () {
            var index;
            var length = this._list.rows.length;
            var input;
            var row;
            var selectionCounter = 0;
            // set all rows to false.
            for (index = 1; index < length; index++) {
                if (this._list.rows[index].data) {
                    selectionCounter += parseInt(this._list.rows[index].getAttribute("Selected"));
                }
            }
            return (selectionCounter > 1);
        };
        SeriesListController.prototype.getDataFromSeries = function (parent, seriesID) {
            var series = ($.grep(this._seriesManagerService.currentPatientSeries, function (item) { return item.InstanceUID == seriesID; }))[0];
            var url = Utils.get_thumbnailUrl(series);
            if (url) {
                var row = this.AddRow(parent, series, url, series.Date, series.Description, 0, false, parseInt(this._options.get(OptionNames.SeriesThumbnailHeight)) * 7 >> 3, false);
                row.setAttribute("Selected", "1");
            }
        };
        SeriesListController.prototype.refreshSubtreeSelection = function (table) {
            var instanceUIDs = {};
            // this is the sub tree row that belong to a structured display.
            // go in and send the instances that are visible and the one that arent.
            var index = 0;
            var length = table.rows.length;
            // nothing to update, get out of here.
            if (length == 0)
                return;
            // create an array of instances that contains whether the series is visible or not.
            for (index = 0; index < length; index++) {
                instanceUIDs[table.rows[index].data.InstanceUID] = (table.rows[index].getAttribute("Selected") == "1");
            }
            // send it.
            this._eventService.publish(EventNames.StructuredDisplayUpdated, {
                InstanceUIDs: instanceUIDs
            });
        };
        SeriesListController.prototype.findSeriesUsedInStructureDisplay = function (parent, data) {
            var index = 0;
            var length = data.Series.length;
            var list = {};
            for (index = 0; index < length; index++) {
                list[data.Series[index].SeriesInstanceUID] = data.Series[index].SeriesInstanceUID;
            }
            for (var item in list) {
                if (list.hasOwnProperty(item)) {
                    this.getDataFromSeries(parent, item);
                }
            }
            var _this = this;
            var index = 0;
            //var rows = this._seriesManagerService.currentPatientSeries.length;
            var columns = 4;
            var j = 0;
            var _table = parent;
            for (var item in list) {
                if (list.hasOwnProperty(item)) {
                    for (j = 0; j < columns; j++) {
                        parent.rows[index].children[j].setAttribute("colPosition", j);
                        parent.rows[index].children[j].addEventListener("click", function (e) {
                            if (!_this._enabled)
                                return;
                            var td = e.currentTarget;
                            var row = td.parentElement;
                            var parentRow = _table.parent;
                            var column = parseInt(td.getAttribute("colPosition"));
                            // make sure that the parent structured display is selected
                            _this.UpdateSelection(parentRow, 1);
                            _this.selectSubRow(row, column);
                            _this.refreshSubtreeSelection(row.parentElement);
                        });
                    }
                    index++;
                }
            }
            //for (this.AddRow()
        };
        //public selectSubRow(table: HTMLTableElement, index, column) {
        //    var input: HTMLInputElement = <HTMLInputElement>table.rows[index].children[0].children[0];
        //    // manually check the check box if the user clicked on the row
        //    if (column != 0)
        //        input.checked = true;
        //    table.rows[index].style.background = input.checked ? "rgba(128, 128, 128, 0.5)" : "rgba(128, 128, 128, 0)";
        //    table.rows[index].setAttribute("Selected", "1");
        //}
        // check whether the row is selected or not.
        SeriesListController.prototype.IsRowSelected = function (row) {
            return row.getAttribute("Selected") == "1";
        };
        SeriesListController.prototype.DeselectSubRows = function (table) {
            if (!table)
                return;
            if (!table.rows)
                return;
            var index = 0;
            var length = table.rows.length;
            for (index = 0; index < length; index++) {
                table.rows[index].setAttribute("Selected", "0");
            }
        };
        // check if all the sub-tree are selected or not, and if they are all not selected, then just mark the check box as indetermined.
        SeriesListController.prototype.UpdateParentCheckBox = function (table) {
            var parentRow = table.parentRow;
            if (parentRow) {
                var input = parentRow.cells[0].children[0];
                if (!input)
                    return;
                if (!this.isAllSelected(table)) {
                    input.indeterminate = true;
                }
                else {
                    input.indeterminate = false;
                    input.checked = true;
                }
            }
        };
        // check if all the rows in the tree is selected.
        SeriesListController.prototype.isAllSelected = function (table) {
            if (!table)
                return false;
            if (!table.rows)
                return false;
            var index = 0;
            var length = table.rows.length;
            for (index = 0; index < length; index++) {
                if (table.rows[index].getAttribute("Selected") == "0")
                    return false;
            }
            return true;
        };
        SeriesListController.prototype.selectSubRow = function (row, column) {
            try {
                if (column == 0)
                    row.setAttribute("Selected", this.IsRowSelected(row) ? "0" : "1");
                else {
                    this.DeselectSubRows(row.parentElement);
                    row.setAttribute("Selected", "1");
                }
                this.RefreshList();
                // make the check box indetermined in case not all sub-tree is selected.
                this.UpdateParentCheckBox(row.parentElement);
            }
            catch (e) {
                console.log(e);
            }
        };
        // does the row contain a structured dispaly or not.
        SeriesListController.prototype.IsStructuredDisplay = function (row) {
            return (row.data.Boxes);
        };
        // check whether the sub-tree is expanded or not.
        SeriesListController.prototype.isSubTreeExpanded = function (row) {
            var tree = row.nextElementSibling;
            return (tree.style.height != "0px");
        };
        SeriesListController.prototype.expandSubTree = function (row) {
            // this is the next item on the list, which is the sub-tree.
            var tree = row.nextElementSibling;
            tree.style.height = "100px";
            //if there are not children, then find them and create teh sub tree
            if (tree.children[0].children[0].innerHTML == "") {
                // set the parent of the sub-tree.
                tree.cells[0].children[0].parentRow = row;
                // find the series that contained in the structured display.
                this.findSeriesUsedInStructureDisplay(tree.cells[0].children[0], row.data);
            }
        };
        SeriesListController.prototype.collapseSubTree = function (row) {
            var tree = row.nextElementSibling;
            // this is the sub-tree row, go through all the children.
            var table = tree.cells[0].children[0];
            tree.style.height = "0px";
            table.innerHTML = "";
        };
        SeriesListController.prototype.selectRow = function (row, column) {
            var input = row.children[0].children[0];
            // unselect all the other rows only if the user doesn't click on the check box. or click on a structured display
            if (column != 0 || row.data.Boxes) {
                this.Deselect();
            }
            var newSelection = this._selectedRow != row;
            // invert status if the user clicked on the check box.
            if (column == 0)
                row.setAttribute("Selected", this.IsRowSelected(row) ? "0" : "1");
            else {
                row.setAttribute("Selected", "1");
            }
            if (this.IsRowSelected(row))
                if (newSelection) {
                    var selected = row.getAttribute("Selected") == "1";
                    this._selectedRow = row;
                    if (selected) {
                        // if it's a structured display then expand... otherwise, stay. unless it's set as an option not to
                        if (row.data.Boxes) {
                            // set this as the current structured display.
                            this._seriesManagerService.currentStructuredDisplay = row.data;
                            if (this._autoExpand || column == 0) {
                                this.expandSubTree(row);
                            }
                        }
                        else
                            this._seriesManagerService.currentStructuredDisplay = null;
                    }
                }
            // update the list by highlighting / de-highlighting / removing sub-tree.
            if (!this.RefreshList())
                this.selectRow(this._selectedRow ? this._selectedRow : this._list.rows[1], column);
            return newSelection;
        };
        // refresh the look of the row based on the "Selected" value, and return the selection status.
        SeriesListController.prototype.RefreshRow = function (row) {
            var input;
            var selected = row.getAttribute("Selected") == "1";
            if (selected) {
                // set the row color to transparent.
                row.style.background = "rgba(128, 128, 128, 0.5)";
                // get the input box that represents the check box.
                input = row.children[0].children[0];
                input.checked = true;
            }
            else {
                // set the row color to transparent.
                row.style.background = "rgba(0, 0, 0, 0)";
                // get the input box that represents the check box.
                input = row.children[0].children[0];
                input.checked = false;
            }
            // in case the indetermine is checked, then uncheck it.
            input.indeterminate = false;
            return selected;
        };
        // loop throw all children and find if there is a selected sub row there.
        SeriesListController.prototype.isSubTreeSelected = function (parentRow) {
            var tree = parentRow.nextElementSibling;
            var table = tree.cells[0].children[0];
            var index = 0;
            var length = table.rows.length;
            var row;
            var found = false;
            // find if one of the rows is selected
            for (index = 0; index < length; index++) {
                // we wont break here, because we want to refresh all sub tree item first.
                if (this.RefreshRow(table.rows[index]))
                    found = true;
            }
            return found;
        };
        // update the look of the list, if any is selected, then highlight it and check the check box, if not, then clear the highlight, and if there is subtree then remove it.
        // it returns that at least one item is selected from the list.
        SeriesListController.prototype.RefreshList = function () {
            var index;
            var length = this._list.rows.length;
            var input;
            var previousRowSelected = false;
            var somethingSelected = false;
            var row;
            // get through each row.
            for (index = 1; index < length; index++) {
                row = this._list.rows[index];
                // if the row is a simple series, then just refresh the row.
                if (row.data) {
                    previousRowSelected = this.RefreshRow(row);
                    // loop through the sub-tree item, refresh the look and return whether at least one is selected so you don't hide the tree.
                    var oneSelected = this.isSubTreeSelected(row);
                    // if the parent (which is the previous row is not selected), then go in and check all the treee items are not selected to remove it from the view.
                    if (!previousRowSelected) {
                        this.collapseSubTree(row);
                    }
                }
                // this is to ensure that the list has one item selected.
                if (previousRowSelected) {
                    somethingSelected = true;
                }
            }
            return somethingSelected;
        };
        SeriesListController.prototype.AddRow = function (parent, data, imageUrl, date, description, rowIndex, root, height, structuredDisplay) {
            if (parent != null) {
                var tr = document.createElement("TR");
                tr.setAttribute("Selected", "0");
                tr.style.height = height + "px";
                tr.id = "row" + rowIndex;
                if (!root)
                    tr.style.fontSize = "10px";
                parent.appendChild(tr);
                tr.data = data;
                // Add the radio button
                var cell = document.createElement("TD");
                //if (rowIndex == 2) {
                //    cell.colSpan = 2;
                //    tr.style.height = "100px";
                //}
                //else {
                if (structuredDisplay) {
                    var input = document.createElement("i");
                    input.className = "fa fa-caret-right";
                    input.style.fontSize = "24px";
                    input.style.textAlign = "center";
                    input.style.color = "#dedede";
                    input.style.textShadow = "1px 1px 1px rgba(0, 0, 0, 0.3)";
                    input.style.marginLeft = "auto";
                    input.style.width = "100%";
                    input.style.textAlign = "center";
                    cell.appendChild(input);
                    cell.style.width = "5%";
                    tr.appendChild(cell);
                    //<i class= style = "font-size:48px;color:red" > </i>
                }
                else {
                    var input = document.createElement("input");
                    input.type = "checkbox";
                    input.style.width = "100%";
                    input.style.margin = "auto";
                    cell.appendChild(input);
                    cell.style.width = "5%";
                    tr.appendChild(cell);
                }
                cell = document.createElement("TD");
                var image = document.createElement("img");
                image.style.height = height + "px";
                image.style.marginLeft = "auto";
                image.style.marginRight = "auto";
                image.style.display = "block";
                image.style.padding = "2px";
                cell.appendChild(image);
                image.src = imageUrl;
                tr.appendChild(cell);
                cell = document.createElement("TD");
                var dateText = "N/A";
                var dateTime = "";
                if (date) {
                    var spaceSep = date.indexOf(' ');
                    dateText = (spaceSep != -1) ? date.substring(0, spaceSep) : date;
                    dateTime = (spaceSep != -1) ? date.substring(spaceSep + 1) : "";
                }
                var labelEleemnt = document.createElement("label");
                labelEleemnt.textContent = dateText;
                labelEleemnt.style.display = "block";
                labelEleemnt.style.margin = "auto";
                cell.style.width = "20%";
                cell.style.textAlign = "center";
                cell.style.cursor = "default";
                cell.appendChild(labelEleemnt);
                if (date) {
                    labelEleemnt = document.createElement("label");
                    labelEleemnt.textContent = dateTime;
                    labelEleemnt.style.fontSize = "10px";
                    labelEleemnt.style.display = "block";
                    labelEleemnt.style.margin = "auto";
                    cell.appendChild(labelEleemnt);
                }
                tr.appendChild(cell);
                cell = document.createElement("TD");
                var descriptionNode = document.createTextNode(description ? description : "N/A");
                cell.style.width = "100%";
                cell.style.textAlign = "center";
                cell.style.cursor = "default";
                cell.appendChild(descriptionNode);
                tr.appendChild(cell);
                //}
                if (root) {
                    var trChildSpace = document.createElement("TR");
                    trChildSpace.style.height = "0px";
                    trChildSpace.style.columnSpan = "3";
                    cell = document.createElement("TD");
                    cell.colSpan = 4;
                    cell.style.overflow = "hidden";
                    trChildSpace.appendChild(cell);
                    var treeTable = document.createElement("TABLE");
                    treeTable.style.left = "5%";
                    treeTable.style.width = "70%";
                    treeTable.border = "1px";
                    treeTable.style.position = "relative";
                    treeTable.cellPadding = "4px";
                    treeTable.id = "subTree" + rowIndex;
                    treeTable.parent = tr;
                    parent.appendChild(trChildSpace);
                    cell.appendChild(treeTable);
                }
                return tr;
            }
            return null;
        };
        SeriesListController.prototype.updateTemplatesHaveAutoMatch = function () {
            if (this._templates) {
                for (var i = 0; i < this._templates.length; i++) {
                    var template = this._templates[i];
                    if (template.AutoMatching) {
                        this._templatesHasAutoMatch = true;
                        return;
                    }
                }
            }
            this._templatesHasAutoMatch = false;
        };
        SeriesListController.prototype.isAnyTemplateAutoMatch = function () {
            return this._templatesHasAutoMatch;
        };
        SeriesListController.prototype.getAutoMatchTemplates = function () {
            return Utils.findAll(this._templates, function (template) {
                return template.AutoMatching;
            });
        };
        SeriesListController.prototype.checkBoxRenderer = function () {
            return '<input type="checkbox" ng-model="all.checked" ng-change="doCheckAll(all.checked)" >';
        };
        SeriesListController.prototype.loadSeriesList = function (patientId, seriesInstanceUID, fromList) {
            this.selectSeries(seriesInstanceUID, fromList);
        };
        SeriesListController.prototype.selectSeries = function (seriesInstanceUID, fromList) {
            this._currentSelectedSeries = seriesInstanceUID;
            if (!this._currentSelectedSeries || this._currentSelectedSeries == "")
                this._currentSelectedSeries = this._seriesManagerService.get_allSeries()[0];
            if (!this._list)
                return;
            var index = 0;
            var length = this._list.rows.length;
            var row;
            for (index = 0; index < length; index++) {
                row = this._list.rows[index];
                if (!row.data)
                    continue;
                // this is  a structured display
                if (row.data.Boxes) {
                    if (this._seriesManagerService.currentStructuredDisplay) {
                        if (this._seriesManagerService.currentStructuredDisplay.SeriesInstanceUID == this._list.rows[index].data.SeriesInstanceUID) {
                            // if the row is already selected, then just get out, nothing to do here.
                            if (this.IsRowSelected(row))
                                return;
                            this.selectRow(row, 1);
                            return;
                        }
                    }
                }
                else {
                    if (row.data) {
                        var data = row.data;
                        if (data.InstanceUID == this._currentSelectedSeries) {
                            // if the row is already selected, then just get out, nothing to do here.
                            if (this.IsRowSelected(row))
                                return;
                            this.selectRow(row, 1);
                            return;
                        }
                    }
                }
            }
            //var instanceUID: string = seriesInstanceUID || this._scope.activeSeriesInstanceUID;
            //if (instanceUID == undefined)
            //    return;
            //fromList = fromList || false;
            //if (angular.isArray(this._seriesManagerService.currentPatientSeries)) {
            //    var data: Array<any> = this._seriesManagerService.currentPatientSeries;
            //    var index = data.map(function (item, index: number) { 
            //        return item.InstanceUID;
            //    }).indexOf(instanceUID);
            //    if (index != -1) {
            //        index += (this._sturctureDisplayList ? this._sturctureDisplayList.length : 0);
            //        this.selectRow(index * 2 + 1, 1);
            //    }
            //    else {
            //        if (angular.isArray(this._seriesManagerService.structuredDisplayList)) {
            //            var data: Array<any> = this._seriesManagerService.structuredDisplayList;
            //            var index = data.map(function (item, index: number) {
            //                return item.InstanceUID;
            //            }).indexOf(instanceUID);
            //            if (index != -1) {
            //                this.selectRow(index * 2 + 1, 1);
            //            }
            //        }
            //    }
            //if (index != -1) {
            //    this._scope.gridOptions.api.selectIndex(index, fromList ? true : false, true);                   
            //}
            //}
        };
        SeriesListController.prototype.matchTemplateForSeries = function (data, study, series) {
            var StudyInstanceUID = data.node.data.StudyInstanceUID;
            var SeriesInstanceUID = data.node.data.InstanceUID;
            if (StudyInstanceUID && SeriesInstanceUID) {
                //read first instance's json
                var promise = this._objectRetrieveService.GetDicomJSON(StudyInstanceUID, SeriesInstanceUID, '');
                var isSTL = false;
                //on success
                promise.success(function (json) {
                    var _template = null;
                    this.getAutoMatchTemplates().some(function (template) {
                        //parse the json and see if we have a match
                        try {
                            isSTL = Utils.containsSTLData(JSON.parse(json));
                            if (!_template) {
                                if (Utils.executeScript(template.AutoMatching, json)) {
                                    console.log('template auto-match found');
                                    _template = template;
                                    return true; //break;
                                }
                            }
                        }
                        catch (e) {
                            console.log(e);
                        }
                        return false; //continue
                    });
                    if (_template) {
                        var searchController = this._tabService.get_tabData(this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                        var structuredDisplay = searchController.loadStructuredDisplayFromTemplate(_template, SeriesInstanceUID, StudyInstanceUID);
                    }
                    else {
                        var _this = this;
                        // last try, try to see if the SD creator has a layout that can be used to display the series.
                        return this._objectRetrieveService.GetSeriesLayout(SeriesInstanceUID, '').then(function (layout) {
                            if (layout) {
                                _template = layout.data;
                            }
                            if (_template) {
                                var searchController = _this._tabService.get_tabData(_this._tabService.tabs[0].id, TabDataKeys.searchViewerController);
                                searchController.loadStructuredDisplayFromTemplate(_template, SeriesInstanceUID, StudyInstanceUID);
                            }
                            else {
                                // oh for god sake, just load the series normally.
                                _this._eventService.publish(EventNames.SeriesSelected, {
                                    study: study,
                                    series: series,
                                    fromList: true,
                                    template: _template,
                                    isSTL: isSTL,
                                    resetLayout: true
                                });
                            }
                        });
                    }
                }.bind(this));
                //on error - default to no template - continue loading
                promise.error(function (e) {
                    console.log(e);
                    this._eventService.publish(EventNames.SeriesSelected, {
                        study: study,
                        series: series,
                        fromList: true,
                        template: undefined,
                        isSTL: isSTL
                    });
                });
            }
            else {
                console.log('failed to read study/series id');
                //default to no template - continue loading
                this._eventService.publish(EventNames.SeriesSelected, {
                    study: study,
                    series: series,
                    fromList: true,
                    template: undefined,
                    isSTL: isSTL
                });
            }
        };
        SeriesListController.prototype.seriesSelected = function (data) {
            var cell = this._seriesManagerService.get_activeCell();
            var seriesInstanceUID = cell == null ? "" : cell.get_seriesInstanceUID();
            if (cell && cell.templateId) {
                if (seriesInstanceUID.length > 0) {
                    var template = Utils.findFirst(this._templates, function (template) {
                        return template.Id == cell.templateId;
                    });
                    if (template) {
                        this._seriesTemplate[seriesInstanceUID] = template;
                    }
                    else {
                        delete this._seriesTemplate[seriesInstanceUID];
                    }
                }
            }
            /*if (seriesInstanceUID != data.node.data.InstanceUID) */ {
                var newSeries = data.node.data;
                if (newSeries) {
                    var study = { InstanceUID: newSeries.StudyInstanceUID, Patient: newSeries.Patient };
                    var __this = this;
                    var template = undefined;
                    this._scope.activeSeriesInstanceUID = data.node.data.InstanceUID;
                    //if(this._scope.all.checked)
                    //    this._scope.all.checked = false;  
                    if (this._seriesTemplate[newSeries.InstanceUID]) {
                        template = this._seriesTemplate[newSeries.InstanceUID];
                    }
                    this.matchTemplateForSeries(data, study, newSeries);
                }
            }
        };
        SeriesListController.prototype.onExport = function () {
            this._$commangular.dispatch('OnSecondaryCapture');
        };
        // get a list of the data of the selected rows
        SeriesListController.prototype.getSelectedSeries = function () {
            var index;
            var length = this._list.rows.length;
            var row;
            var selected = [];
            for (index = 1; index < length; index++) {
                // add this row if it's selected.
                if (this._list.rows[index].getAttribute("Selected") == "1")
                    // make sure we have the series data avaiable
                    if (this._list.rows[index].data) {
                        // not compare for structured display
                        if (!this._list.rows[index].data.Boxes)
                            selected.push(this._list.rows[index].data);
                    }
            }
            return selected;
        };
        SeriesListController.prototype.onCompare = function () {
            var nodes = this.getSelectedSeries();
            if (nodes.length < 2) {
                alert("structure display comparison is not avaiable yet");
            }
            else
                this._$commangular.dispatch('Compare', { series: nodes });
        };
        SeriesListController.$inject = ['$rootScope', '$scope', 'uiGridConstants', 'eventService', 'optionsService', 'dataService', 'seriesManagerService', '$commangular', 'templateService', 'objectRetrieveService', 'tabService', 'authenticationService'];
        return SeriesListController;
    }());
    Controllers.SeriesListController = SeriesListController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Controllers;
(function (Controllers) {
    var ViewerController = /** @class */ (function () {
        function ViewerController($scope, eventService, toolbarService, $modal, tabService, optionsService, dataService, seriesManagerService, safeApply, config, hotkeys, $timeout, $commangular, auditLogService, objectRetrieveService, dicomLoaderService, templateService) {
            // this is a timer to keep trying to see if the layout is ready for the overflow manager to be created.
            this._overflowTimerId = -1;
            // this is the list for the items to be added to the overflow manager when the overflow manager is not ready yet.
            this._overflowManagerReadyList = [];
            var spacingSize = Utils.get_spacingSize();
            var singleSeries = optionsService.get(OptionNames.SingleSeriesMode);
            var rows = optionsService.get(OptionNames.DefaultSeriesRowCount);
            var columns = optionsService.get(OptionNames.DefaultSeriesColumnCount);
            var overflowSize = optionsService.get(OptionNames.SeriesThumbnailWidth) * 3;
            var self = this;
            this._scope = $scope;
            this._seriesManagerService = seriesManagerService;
            this._dataService = dataService;
            this._tabService = tabService;
            this._timeoutService = $timeout;
            this._eventService = eventService;
            this._auditLogService = auditLogService;
            this._objectRetrieveService = objectRetrieveService;
            this._toolbarService = toolbarService;
            this._templateService = templateService;
            $scope.query = new Models.QueryOptions();
            $scope.retrieveUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
            $scope.timelineApi = {};
            if (overflowSize > 150)
                overflowSize = 150;
            $scope.layoutConfig = {
                applyDemoStyles: true,
                scrollToBookmarkOnLoad: false,
                spacing_closed: spacingSize,
                spacing_open: spacingSize,
                livePaneResizing: false,
                north__size: lt.LTHelper.device == lt.LTDevice.mobile ? "25" : "auto",
                north__resizable: false,
                north__initHidden: false,
                north__showOverflowOnHover: true,
                south__resizable: false,
                south__initHidden: false,
                south__size: 160,
                south__resizerToggle: false,
                south__spacing_closed: 0,
                south__spacing_open: 0,
                east__initHidden: true,
                east__size: overflowSize,
                east__maxSize: overflowSize,
                east__minSize: overflowSize,
                east__resizable: false,
                onopen: this.onOpenPane.bind(this)
            };
            $scope.toolbars = toolbarService.getToolbars();
            $scope.tabId = '';
            $scope.viewerId = UUID.generate();
            $scope.postion = 15;
            $scope.numberOfFrames = 0;
            $scope.currentPosition = 0;
            $scope.hideTimeline = true;
            $scope.overflowId = UUID.generate();
            $scope.viewerConfig = new MedicalViewerConfig();
            $scope.viewerConfig.rows = singleSeries ? 1 : rows;
            $scope.viewerConfig.columns = singleSeries ? 1 : columns;
            $scope.viewerConfig.splitterSize = Utils.get_splitterSize();
            $scope.viewerConfig.OnApiReady = function (viewerApi) {
                self._viewerApi = viewerApi;
                self._toolbarService.enable("DeleteStudyStructuredDisplay" + self._tabService.selectedTab.id, function () {
                    return viewerApi.hasLayout;
                });
            };
            $scope.viewerConfig.OnSelectionChanged = this.selectionChanged.bind(this);
            $scope.viewerConfig.studyLayout = templateService.currentStudyLayout;
            $scope.viewerConfig.hangingProtocol = templateService.currentHangingProtocol;
            templateService.currentHangingProtocol = null;
            $scope.viewerConfig.customLayout = optionsService.get(OptionNames.CustomStudyLayout);
            $scope.viewerapi = {};
            $scope.layoutApi = {};
            $scope.seriesList = new Array();
            var deregister = $scope.$watch('tabId', function (newValue, oldValue) {
                var unsubscribe;
                tabService.set_tabData($scope.tabId, TabDataKeys.ViewController, self);
                tabService.set_tabData($scope.tabId, TabDataKeys.Linked, true);
                deregister();
                unsubscribe = eventService.subscribe(EventNames.ToolbarCreated, function (event, data) {
                    if (self._templateService.currentStudyLayout) {
                        self._templateService.currentStudyLayout.LoadedBoxes = 0;
                        var tab = self.getPatientTab(self._templateService.currentStudyLayout.PatientID, self._tabService);
                        self._toolbarService.disable("PopupCapture" + tab.id);
                    }
                    else {
                        eventService.publish(EventNames.RefreshToolbar, {
                            cell: null,
                            tab: tab,
                            viewer: null
                        });
                    }
                    var linked = optionsService.get(OptionNames.LinkImages);
                    toolbarService.updateClass('LinkImages' + $scope.tabId, 'Linked', 'UnLinked', function () { return linked; });
                    unsubscribe();
                    if (angular.isDefined($scope.layoutApi.refresh)) {
                        setTimeout(function () {
                            $scope.layoutApi.openPane('north');
                            $scope.layoutApi.refresh();
                        }, 900);
                    }
                });
                function updateGridLayoutSize(viewer, cellCount) {
                    if (viewer == null)
                        return;
                    if (viewer.gridLayout.rows * viewer.gridLayout.columns < cellCount) {
                        var sq = Math.sqrt(cellCount);
                        if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
                            viewer.layout.beginUpdate();
                            viewer.gridLayout.rows = Math.floor(sq + 0.1);
                            viewer.gridLayout.columns = Math.ceil(cellCount / viewer.gridLayout.rows);
                            viewer.layout.endUpdate();
                        }
                    }
                }
                eventService.subscribe(EventNames.LoadSeries + $scope.tabId, function (event, data) {
                    var tab = seriesManagerService.get_seriesTab(data.args.series.InstanceUID);
                    if (tab != null && tab.id == $scope.tabId) {
                        var series = new MedicalViewerSeries(data.args.series.InstanceUID, data.args.series.Patient.ID);
                        // series.sopInstanceUIDS: null or empty if all instances in the series should be loaded
                        //                       : contains a list of SOPInstanceUids
                        series.sopInstanceUIDS = data.args.series.SopInstanceUIDs; //new Array<string>(2);
                        series.modality = data.args.series.Modality;
                        series.template = data.args.template;
                        series.dislaySetNumber = data.args.displaySetNumber;
                        if (data.args != null)
                            series.view = data.args.view;
                        series.mrtiCell = data.args.series.mrtiCell;
                        if (self._overflowManager != null) {
                            self._overflowManager.clear();
                        }
                        if (singleSeries) {
                            $scope.seriesList.length = 0;
                        }
                        else {
                            var s = data.args.series;
                            var result = $.grep($scope.seriesList, function (e, index) {
                                return s.Patient.ID != e.patientID;
                            });
                            if (result.length != 0) {
                                $scope.seriesList.length = 0;
                            }
                        }
                        series.link = optionsService.get(OptionNames.LinkImages);
                        if (data.args.series.Modality == "CT") {
                            if ($scope.viewerapi != null) {
                                if ($scope.viewerapi.getMedicalViewer != null) {
                                    var viewer = $scope.viewerapi.getMedicalViewer();
                                    tab.itemCount++;
                                    updateGridLayoutSize(viewer, tab.itemCount);
                                }
                            }
                            $scope.seriesList.push(series);
                        }
                        else {
                            if (!angular.isDefined(series.dislaySetNumber)) {
                                objectRetrieveService.GetSeriesStacks(data.args.series.InstanceUID).then(function (result) {
                                    var stacks = result.data;
                                    if (stacks.length > 1)
                                        series.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                                    tab.itemCount += (stacks.length != 0) ? stacks.length : 1;
                                    var cellCount = tab.itemCount;
                                    if (!cellCount)
                                        cellCount = 0;
                                    if ($scope.viewerapi != null) {
                                        var viewer = $scope.viewerapi.getMedicalViewer();
                                        updateGridLayoutSize(viewer, cellCount);
                                    }
                                    $scope.seriesList.push(series);
                                    if (stacks.length > 1 && !singleSeries) {
                                        for (var i = 1; i < stacks.length; i++) {
                                            var stackSeries;
                                            stackSeries = angular.copy(series);
                                            //Add the parent display number
                                            if (data.args != null)
                                                stackSeries.view = data.args.view;
                                            stackSeries.id = UUID.genV4().toString();
                                            stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                                            $scope.seriesList.push(stackSeries);
                                        }
                                    }
                                }.bind(this));
                            }
                            else {
                                if ($scope.viewerapi != null) {
                                    if ($scope.viewerapi.getMedicalViewer != null) {
                                        var viewer = $scope.viewerapi.getMedicalViewer();
                                        tab.itemCount++;
                                        updateGridLayoutSize(viewer, tab.itemCount);
                                    }
                                }
                                $scope.seriesList.push(series);
                            }
                        }
                    }
                    if ($scope.layoutApi && $scope.layoutApi.closePane) {
                        $scope.layoutApi.closePane('east');
                    }
                });
                eventService.subscribe(EventNames.LoadStructuredDisplay + $scope.tabId, function (event, data) {
                    var tab = seriesManagerService.get_seriesTab(data.args.series.InstanceUID);
                    if (tab != null && tab.id == $scope.tabId) {
                        var series = new MedicalViewerSeries(data.args.series.InstanceUID, data.args.series.Patient.ID, data.args.sdID);
                        series.templateItem = data.args.templateItem;
                        // don't load series layout when you load the structured display
                        series.loadSeriesLayout = false;
                        // series.sopInstanceUIDS: null or empty if all instances in the series should be loaded
                        //                       : contains a list of SOPInstanceUids
                        series.sopInstanceUIDS = data.args.series.SopInstanceUIDs; //new Array<string>(2);
                        series.template = data.args.template;
                        series.dislaySetNumber = data.args.displaySetNumber;
                        series.mrtiCell = data.args.series.mrtiCell;
                        if (seriesManagerService.cleanupSeries) {
                            $scope.seriesList.length = 0;
                            seriesManagerService.cleanupSeries = false;
                        }
                        {
                            var s = data.args.series;
                            var result = $.grep($scope.seriesList, function (e, index) {
                                return s.Patient.ID != e.patientID;
                            });
                            if (result.length != 0) {
                                $scope.seriesList.length = 0;
                            }
                        }
                        if (!angular.isDefined(series.dislaySetNumber)) {
                            objectRetrieveService.GetSeriesStacks(data.args.series.InstanceUID).then(function (result) {
                                var stacks = result.data;
                                series.link = optionsService.get(OptionNames.LinkImages);
                                if (stacks.length > 1)
                                    series.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                                tab.itemCount += (stacks.length != 0) ? stacks.length : 1;
                                var cellCount = tab.itemCount;
                                if (!cellCount)
                                    cellCount = 0;
                                if ($scope.viewerapi != null) {
                                    var viewer = $scope.viewerapi.getMedicalViewer();
                                    //updateGridLayoutSize(viewer, cellCount);
                                }
                                if (data.args.series.ImageBoxNumber == -1) {
                                    eventService.publish(EventNames.InstanceOverflow, {
                                        instance: data.args.series.SopInstanceUIDs,
                                        metadata: 0,
                                        frame: 0,
                                        parentCell: null,
                                        parentViewer: viewer
                                    });
                                }
                                else {
                                    $scope.seriesList.push(series);
                                    if (stacks.length > 1) {
                                        for (var i = 1; i < stacks.length; i++) {
                                            var stackSeries;
                                            stackSeries = angular.copy(series);
                                            //Add the parent display number
                                            if (data.args != null)
                                                stackSeries.view = data.args.view;
                                            stackSeries.id = UUID.genV4().toString();
                                            stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                                            $scope.seriesList.push(stackSeries);
                                        }
                                    }
                                }
                            }.bind(this));
                        }
                        else {
                            if (data.args.series.ImageBoxNumber == -1) {
                                eventService.publish(EventNames.InstanceOverflow, {
                                    instance: data.args.series.SopInstanceUIDs,
                                    metadata: 0,
                                    frame: 0,
                                    parentCell: null,
                                    parentViewer: viewer
                                });
                            }
                            else {
                                if ($scope.viewerapi != null) {
                                    if ($scope.viewerapi.getMedicalViewer != null) {
                                        var viewer = $scope.viewerapi.getMedicalViewer();
                                        tab.itemCount++;
                                        //updateGridLayoutSize(viewer, tab.itemCount);
                                    }
                                }
                                $scope.seriesList.push(series);
                            }
                        }
                    }
                });
            });
            $scope.replaceCell = $.proxy(this.replaceCell, this);
            $scope.appendCell = $.proxy(this.appendCell, this);
            $scope.seriesDropped = $.proxy(this.seriesDropped, this);
            eventService.subscribe(EventNames.LoadingSeriesFrames, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (tab != null && tab.id == $scope.tabId) {
                    self.initializeSlider($scope, seriesManagerService, data.args.seriesInstanceUID, data.args.id);
                    self.refreshTimeline(data.args.seriesInstanceUID);
                }
            });
            eventService.subscribe(EventNames.ActiveSeriesChanged, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                var overflowInstances = seriesManagerService.get_seriesOverflow(data.args.seriesInstanceUID);
                var cell = seriesManagerService.get_seriesCellById(data.args.id);
                if (tab != null && tab.id == $scope.tabId) {
                    self.initializeSlider($scope, seriesManagerService, data.args.seriesInstanceUID, data.args.id);
                    self.refreshTimeline(data.args.seriesInstanceUID);
                }
                if (self._overflowManager) {
                    if (self._overflowManager.get_seriesInstanceUID() != data.args.seriesInstanceUID) {
                        self._overflowManager.clear();
                        if (overflowInstances.length > 0 && self._overflowManager != null) {
                            self._overflowManager.addInstances(overflowInstances);
                        }
                    }
                }
            });
            eventService.subscribe(EventNames.OpenStudyTimeLine, function (event, data) {
                var showStudyTimeLine = optionsService.get(OptionNames.ShowStudyTimeLine);
                if (data.args.show || showStudyTimeLine) {
                    self.showTimeLine();
                    setTimeout(function () {
                        $scope.layoutApi.openPane('north');
                        $scope.layoutApi.refresh();
                    }, 900);
                }
                else {
                    setTimeout(function () {
                        $scope.layoutApi.closePane('south');
                        $scope.layoutApi.refresh();
                    }, 900);
                }
            });
            $scope.InitializeOverflowManager = function (tab) {
                if (tab != null) {
                    $scope.layoutApi.openPane('east');
                    if (self._overflowManager == null) {
                        self._overflowManager = new OverflowManager("#" + $scope.overflowId, dicomLoaderService.get_newLoader(), { api: self._scope.layoutApi, direction: 'south' }, tabService, tab, eventService, false);
                        if (!$("#" + $scope.overflowId)[0]) {
                            self._overflowManager = null;
                        }
                    }
                }
                if (self._overflowManager) {
                    $scope.layoutApi.openPane('east');
                    for (var index = 0; index < self._overflowManagerReadyList.length; index++) {
                        self._overflowManager.add(self._overflowManagerReadyList[index].instance);
                        // set the seriesInstance for the overflow manager.
                        if (index == 0)
                            self._overflowManager.set_seriesInstanceUID(self._overflowManagerReadyList[index].instance.SeriesInstanceUID);
                    }
                    self._overflowManagerReadyList = [];
                    return true;
                }
                return false;
            };
            eventService.subscribe(EventNames.InstanceOverflow, function (event, data) {
                // add the data to the rady list so when the layout is ready, creat the overflow and add them.
                self._overflowManagerReadyList.add(data.args);
                var tab = seriesManagerService.get_seriesTab(data.args.instance.SeriesInstanceUID);
                if (!tab)
                    return;
                // the layout is not ready yet, for some fucking reason, we need to keep looping and try until it is.
                if (!$scope.layoutApi.openPane) {
                    // keep trying every 500 millisecond until the data is ready.
                    if (self._overflowTimerId == -1) {
                        self._overflowTimerId = window.setInterval(function (e) {
                            // the layout is ready, initialize now.
                            if ($scope.layoutApi.openPane)
                                if ($scope.InitializeOverflowManager(tab)) {
                                    // initializtion is a success, clear the timer now and rest the variables.
                                    window.clearInterval(self._overflowTimerId);
                                    self._overflowTimerId = -1;
                                }
                        }, 500);
                    }
                }
                else
                    $scope.InitializeOverflowManager(tab);
            });
            eventService.subscribe(EventNames.InstanceOverflowClear, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (!tab)
                    tab = data.args.tab;
                if (tab != null && tab.id == $scope.tabId) {
                    if (self._templateService.currentStudyLayout.LoadedBoxes == 0) {
                        self._toolbarService.disable("PopupCapture" + tab.id);
                    }
                    if (self._overflowManager != null) {
                        self._overflowManager.clear();
                    }
                }
            });
            eventService.subscribe(EventNames.InstanceOverflowClose, function (event, data) {
                var tab = seriesManagerService.get_seriesTab(data.args.seriesInstanceUID);
                if (tab != null && tab.id == $scope.tabId) {
                    $scope.layoutApi.closePane('east');
                }
            });
            $scope.positionChanged = function (position) {
                var cell = seriesManagerService.get_activeCell();
                cell.currentOffset = position;
            };
            $scope.previousImage = function () {
                var cell = seriesManagerService.get_activeCell();
                var current = cell.currentOffset;
                if (current != 0 && current >= 1) {
                    cell.currentOffset = current - 1;
                    $scope.currentPosition = current - 1;
                }
            };
            $scope.nextImage = function () {
                var cell = seriesManagerService.get_activeCell();
                var max = seriesManagerService.get_maxAllowedStackIndex(cell);
                var current = cell.currentOffset;
                if (current != -1 && ((current + 1) < max)) {
                    cell.currentOffset = current + 1;
                    $scope.currentPosition = current + 2;
                }
            };
            $scope.ondelete = function () {
                $commangular.dispatch('DeleteCell');
            };
            $scope.stackChanged = function (sender, e) {
                var cell = seriesManagerService.get_activeCell();
                if (cell) {
                    var current = cell.currentOffset;
                    safeApply($scope, function () {
                        $scope.currentPosition = current + 1;
                    });
                }
            };
            hotkeys.bindTo($scope)
                .add({
                combo: ['+', 'down'],
                description: 'Next Image',
                callback: $scope.nextImage
            })
                .add({
                combo: ['-', 'up'],
                description: 'Previous Image',
                callback: $scope.previousImage
            })
                .add({
                combo: 'left',
                description: 'Align Left',
                callback: function () {
                    var cell = seriesManagerService.get_activeCell();
                }
            })
                .add({
                combo: 'right',
                description: 'Align Right',
                callback: function () {
                    var cell = seriesManagerService.get_activeCell();
                }
            })
                .add({
                combo: 'top',
                description: 'Align Top',
                callback: function () {
                    var cell = seriesManagerService.get_activeCell();
                }
            })
                .add({
                combo: 'bottom',
                description: 'Align Bottom',
                callback: function () {
                    var cell = seriesManagerService.get_activeCell();
                }
            });
            ;
        }
        Object.defineProperty(ViewerController.prototype, "isComposing", {
            get: function () {
                return this._isComposing;
            },
            set: function (value) {
                this._isComposing = value;
            },
            enumerable: false,
            configurable: true
        });
        ViewerController.prototype.getPatientTab = function (patientid, tabService) {
            var seriesList = this._seriesManagerService.get_allSeries();
            for (var i = 0; i < seriesList.length; i++) {
                var series = this._seriesManagerService.get_seriesInfo(seriesList[i]);
                if (series && (patientid == series.Patient.ID)) {
                    var tab = this._seriesManagerService.get_seriesTab(seriesList[i]);
                    return tab;
                }
            }
            return null;
        };
        ViewerController.prototype.selectionChanged = function (count) {
            if (this.isComposing) {
                var self = this;
                this._toolbarService.enable('MergeCells' + this._scope.tabId, function () {
                    return self._viewerApi.canMerge && (count > 1);
                });
            }
        };
        ViewerController.prototype.refreshTimeline = function (seriesInstanceUID) {
            if (this._scope.timelineApi.refresh) {
                var series = this._seriesManagerService.get_seriesInfo(seriesInstanceUID);
                var state = this._scope.layoutApi.get_state('south');
                if (series == null) {
                    series = this._dataService.get_Series(seriesInstanceUID);
                }
                if (state.isVisible) {
                    this._scope.timelineApi.refresh(series.Patient.ID, series.StudyInstanceUID, seriesInstanceUID);
                }
            }
        };
        ViewerController.prototype.getViewer = function () {
            if (!this._scope.viewerapi.getMedicalViewer)
                return null;
            return this._scope.viewerapi.getMedicalViewer();
        };
        ViewerController.prototype.getOverflowManager = function () {
            return this._overflowManager;
        };
        ViewerController.prototype.refreshLayout = function () {
            this._scope.layoutApi.refresh();
        };
        ViewerController.prototype.initializeSlider = function (scope, seriesManagerService, seriesInstanceUID, id) {
            var tab = seriesManagerService.get_seriesTab(seriesInstanceUID);
            if (tab && tab.id == scope.tabId) {
                var cell = seriesManagerService.get_seriesCellById(id);
                if (cell) {
                    scope.numberOfFrames = seriesManagerService.get_maxAllowedStackIndex(cell);
                }
            }
        };
        ViewerController.prototype.toggleView = function (panel, toggle, show) {
            switch (panel) {
                case 'south':
                    var seriesInstanceUID = this._seriesManagerService.activeSeriesInstanceUID;
                    if (seriesInstanceUID && seriesInstanceUID.length > 0) {
                        var series = this._seriesManagerService.get_seriesInfo(seriesInstanceUID);
                        if (series != null) {
                            var __this = this;
                            this._timeoutService(function () {
                                __this._scope.hideTimeline = toggle ? !__this._scope.hideTimeline : !show;
                                __this._scope.$apply();
                                __this._scope.timelineApi.toggle(series.StudyInstanceUID, series.Patient.ID, __this._scope.hideTimeline);
                            });
                        }
                    }
                    break;
            }
        };
        ViewerController.prototype.showTimeLine = function () {
            if (this._scope.hideTimeline) {
                this.toggleView('south', false, true);
            }
        };
        ViewerController.prototype.isTimeLineShowing = function () {
            return !this._scope.hideTimeline;
        };
        ViewerController.prototype.hideTimeLine = function () {
            if (!this._scope.hideTimeline) {
                var seriesInstanceUID = this._seriesManagerService.activeSeriesInstanceUID;
                var series = this._seriesManagerService.get_seriesInfo(seriesInstanceUID);
                var __this = this;
                this._timeoutService(function () {
                    __this._scope.hideTimeline = !__this._scope.hideTimeline;
                    __this._scope.$apply();
                    __this._scope.timelineApi.toggle(series.StudyInstanceUID, series.Patient.ID, __this._scope.hideTimeline);
                });
            }
        };
        ViewerController.prototype.mergeSelectedCells = function () {
            if (this.isComposing) {
                this._viewerApi.mergeSelectedCells();
            }
        };
        ViewerController.prototype.hasLayout = function () {
            return this._viewerApi.hasLayout;
        };
        ViewerController.prototype.getStudyLayout = function () {
            return this._viewerApi.studyLayout;
        };
        ViewerController.prototype.clearLayout = function () {
            this._viewerApi.clearLayout();
        };
        ViewerController.prototype.setStudyLayout = function (layout) {
            this._viewerApi.studyLayout = layout;
        };
        ViewerController.prototype.replaceCell = function (seriesInstanceUID) {
            var viewer = this.getViewer();
            var cell = viewer.layout.get_selectedItem();
            var item, emptyItems;
            var position, rowPosition;
            var colPosition, bounds = null;
            var length;
            var series = this._dataService.get_Series(seriesInstanceUID);
            var newSeries = new MedicalViewerSeries(seriesInstanceUID, series.Patient.ID);
            var tab = this._tabService.find_tab(this._scope.tabId);
            if (viewer.exploded) {
                viewer.explode(viewer.explodedCell, false);
            }
            if (cell != null) {
                if (seriesInstanceUID == cell.get_seriesInstanceUID()) {
                    return;
                }
                position = cell.get_position();
                rowPosition = cell.get_rowPosition();
                colPosition = cell.get_columnsPosition();
                bounds = cell.get_bounds();
            }
            item = viewer.get_emptyDivs().get_selectedItem();
            if (item != null) {
                position = item.get_position();
                rowPosition = item.get_rowPosition();
                colPosition = item.get_columnsPosition();
                bounds = item.get_bounds();
            }
            emptyItems = viewer.get_emptyDivs().get_items();
            length = emptyItems.get_count();
            for (var index = 0; index < length; index++) {
                var cellDiv;
                item = emptyItems.get_item(index);
                cellDiv = document.getElementById(item.get_divID());
                if (cellDiv == this) {
                    position = item.get_position();
                    rowPosition = item.get_rowPosition();
                    colPosition = item.get_columnsPosition();
                    bounds = item.get_bounds();
                    item.dispose();
                    break;
                }
            }
            if (bounds == null)
                return;
            this._seriesManagerService.set_seriesTab(seriesInstanceUID, tab);
            this._objectRetrieveService.GetSeriesStacks(newSeries.seriesInstanceUID).then(function (result) {
                var stacks = result.data;
                var frame = this._seriesManagerService.get_activeCellFrame();
                if (stacks.length > 1)
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                this._scope.viewerapi.replaceSeries(cell.get_seriesInstanceUID(), frame.Instance.SOPInstanceUID, newSeries, position, rowPosition, colPosition, bounds);
                if (stacks.length > 1) {
                    for (var i = 1; i < stacks.length; i++) {
                        var stackSeries;
                        stackSeries = angular.copy(newSeries);
                        stackSeries.id = UUID.genV4().toString();
                        stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                        this._scope.seriesList.push(stackSeries);
                    }
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                }
            }.bind(this));
        };
        ViewerController.prototype.appendCell = function (seriesInstanceUID) {
            var __this = this;
            var series = this._dataService.get_Series(seriesInstanceUID);
            var newSeries = new MedicalViewerSeries(seriesInstanceUID, series.Patient.ID);
            var tab = this._tabService.find_tab(this._scope.tabId);
            var addCell = this._eventService.subscribe(EventNames.NewCellsAdded, function (event, data) {
                if (data.args.cells && data.args.cells.length == 1) {
                    var cell = data.args.cells[0];
                    if (cell.get_seriesInstanceUID() == seriesInstanceUID) {
                        __this._seriesManagerService.set_seriesInfo(seriesInstanceUID, series);
                    }
                }
                addCell();
            });
            this._seriesManagerService.set_seriesTab(seriesInstanceUID, tab);
            this._objectRetrieveService.GetSeriesStacks(newSeries.seriesInstanceUID).then(function (result) {
                var stacks = result.data;
                if (stacks.length > 1)
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                this._scope.seriesList.push(newSeries);
                if (stacks.length > 1) {
                    for (var i = 1; i < stacks.length; i++) {
                        var stackSeries;
                        stackSeries = angular.copy(newSeries);
                        stackSeries.id = UUID.genV4().toString();
                        stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                        this._scope.seriesList.push(stackSeries);
                    }
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                }
            }.bind(this));
        };
        ViewerController.prototype.seriesDropped = function (viewer, oldSeriesInstanceUID, seriesInstanceUID, position, rowPosition, colPosition, bounds) {
            var series = this._dataService.get_Series(seriesInstanceUID);
            var newSeries = new MedicalViewerSeries(seriesInstanceUID, series.Patient.ID);
            var tab = this._tabService.find_tab(this._scope.tabId);
            this._auditLogService.log_showSeries(series);
            this._seriesManagerService.set_seriesTab(seriesInstanceUID, tab);
            this._seriesManagerService.set_seriesInfo(seriesInstanceUID, series);
            this._objectRetrieveService.GetSeriesStacks(newSeries.seriesInstanceUID).then(function (result) {
                var stacks = result.data;
                if (stacks.length > 1)
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                this._scope.viewerapi.replaceSeries(oldSeriesInstanceUID, '', newSeries, position, rowPosition, colPosition, bounds);
                if (stacks.length > 1) {
                    for (var i = 1; i < stacks.length; i++) {
                        var stackSeries;
                        stackSeries = angular.copy(newSeries);
                        stackSeries.id = UUID.genV4().toString();
                        stackSeries.sopInstanceUIDS = stacks[i].SopInstanceUIDs;
                        this._scope.seriesList.push(stackSeries);
                    }
                    newSeries.sopInstanceUIDS = stacks[0].SopInstanceUIDs;
                }
            }.bind(this));
        };
        ViewerController.prototype.onOpenPane = function (pane, item, state) {
            //if (pane == 'east' && this._overflowManager != null) {
            //var seriesInstanceUID = this._seriesManagerService.activeSeriesInstanceUID;
            //var overflowInstances: Array<any> = this._seriesManagerService.get_seriesOverflow(seriesInstanceUID);
            //if (overflowInstances.length > 0) {
            //    this._overflowManager.clear();
            //    this._overflowManager.addInstances(overflowInstances);
            //}                
            //}
        };
        ViewerController.$inject = ['$scope', 'eventService', 'toolbarService', '$modal', 'tabService', 'optionsService', 'dataService',
            'seriesManagerService', 'safeApply', 'app.config', 'hotkeys', '$timeout', '$commangular', 'auditLogService',
            'objectRetrieveService', 'dicomLoaderService', 'templateService'];
        return ViewerController;
    }());
    Controllers.ViewerController = ViewerController;
})(Controllers || (Controllers = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/LEADTOOLS/jquery/jquery.d.ts" />
/// <reference path="../../lib/LEADTOOLS/jquery/jqueryui.d.ts" />
var PropertyGridItem = /** @class */ (function () {
    function PropertyGridItem() {
        this.groupName = "";
        this.rowType = "";
        this.cssName = "";
        this.dropFields = "";
        this.isSubGroup = "";
        this.value = null;
        this.propertyName = "";
        this.enabled = true;
    }
    return PropertyGridItem;
}());
var Group = /** @class */ (function () {
    function Group(groupName, id, subgroup) {
        this._Items = new Array();
        this._SubGroups = new Array();
        this._groupName = groupName;
        if (subgroup) {
            this._outputDiv = 'pg1_subgroup_' + id;
        }
        else {
            this._outputDiv = 'pg1_group_' + id;
        }
    }
    Object.defineProperty(Group.prototype, "GroupName", {
        get: function () {
            return this._groupName;
        },
        set: function (value) {
            this._groupName = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Group.prototype, "OutputDiv", {
        get: function () {
            return this._outputDiv;
        },
        set: function (value) {
            this._outputDiv = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Group.prototype, "SubGroup", {
        get: function () {
            return this._subGroup;
        },
        set: function (value) {
            this._subGroup = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Group.prototype, "Items", {
        get: function () {
            return this._Items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Group.prototype, "SubGroups", {
        get: function () {
            return this._SubGroups;
        },
        enumerable: false,
        configurable: true
    });
    return Group;
}());
;
var ClassItem = /** @class */ (function () {
    function ClassItem(cssName, rowType, drpFields, id, value, propertyName, propertiesLookup, enabled) {
        this._cssId = cssName;
        this._outputDiv = 'pg1_item_' + id;
        this._Type = rowType;
        this._DropFields = drpFields;
        this._value = value;
        this.PropertyName = propertyName;
        this.Enabled = enabled;
        propertiesLookup[propertiesLookup.length] = [cssName, this._outputDiv, rowType];
    }
    Object.defineProperty(ClassItem.prototype, "CssId", {
        get: function () {
            return this._cssId;
        },
        set: function (value) {
            this._cssId = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "OutputDiv", {
        get: function () {
            return this._outputDiv;
        },
        set: function (value) {
            this._outputDiv = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "Type", {
        get: function () {
            return this._Type;
        },
        set: function (value) {
            this._Type = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "Value", {
        get: function () {
            return this._value;
        },
        set: function (value) {
            this._value = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "DropFields", {
        get: function () {
            return this._DropFields;
        },
        set: function (value) {
            this._DropFields = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "PropertyName", {
        get: function () {
            return this._propertyName;
        },
        set: function (value) {
            this._propertyName = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClassItem.prototype, "Enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            this._enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    return ClassItem;
}());
;
var PropertyGrid = /** @class */ (function () {
    function PropertyGrid(outputDiv, sizeType) {
        this._Properties = new Array();
        this._PropertiesLookup = new Array();
        this.groupCount = 0;
        this.subGroupCount = 0;
        this.cssItem = 0;
        this._OutputDivId = outputDiv;
        this._DefaultSizeType = sizeType;
    }
    Object.defineProperty(PropertyGrid.prototype, "GroupCount", {
        get: function () {
            return this._Properties.length;
        },
        enumerable: false,
        configurable: true
    });
    PropertyGrid.prototype.removeOptions = function (selectElement) {
        if (!selectElement)
            return;
        var i, L = selectElement.options.length - 1;
        for (i = L; i >= 0; i--) {
            selectElement.remove(i);
        }
    };
    PropertyGrid.prototype.FillTokens = function (list, filter) {
        var tokens = ["PatientID", "StudyID", "StudyInstanceUID", "StudyDate:mmddyyyy", "CurrentDate:mmddyyyy", "CurrentTime:hhmmsstt", "StudyTime:hhmmsstt", "StudyDescription", "SeriesNumber", "SeriesInstanceUID", "SeriesDate:mmddyyyy", "SeriesTime:hhmmsstt", "SeriesDescription", "InstitutionName", "SOPInstanceUID", "TemplateCategory"];
        var index = 0;
        var length = tokens.length;
        var option;
        if (!list)
            return;
        this.removeOptions(list);
        for (index = 0; index < length; index++) {
            if (!tokens[index])
                continue;
            if (!filter || tokens[index].toLowerCase().indexOf(filter.toLowerCase()) != -1) {
                option = document.createElement("option");
                option.className = 'selectOptionStyle';
                option.text = tokens[index];
                list.options.add(option);
            }
        }
    };
    PropertyGrid.prototype.fillEmailList = function (list, info) {
        var sep = info.indexOf('\n');
        list[0].value = info.substring(0, sep);
        list[1].value = info.substring(sep + 1);
    };
    PropertyGrid.prototype.addProperty = function (groupName, rowType, cssName, drpFields, isSubGroup, value, propertyName, enabled, clickHandler) {
        //create css property
        //first check if groupName exists
        var foundGroup = false;
        for (var i = 0; i < this._Properties.length; i++) {
            if (this._Properties[i].GroupName == groupName) {
                //found group - check if its going to be a sub group or a item within group?
                if (isSubGroup) {
                    //sub group - search the inner subgroups loop
                    var foundSubGroup = false;
                    for (var x = 0; x < this._Properties[i].SubGroups.length; x++) {
                        if (this._Properties[i].SubGroups[x].GroupName == isSubGroup) {
                            //sub group found add item
                            foundSubGroup = true;
                            this._Properties[i].SubGroups[x].Items[this._Properties[i].SubGroups[x].Items.length] = new ClassItem(cssName, rowType, drpFields, this.cssItem, value, propertyName, this._PropertiesLookup, enabled);
                            this.cssItem++;
                        }
                    }
                    if (!foundSubGroup) {
                        //create sub group
                        this._Properties[i].SubGroups[this._Properties[i].SubGroups.length] = new Group(isSubGroup, this.subGroupCount, true);
                        this._Properties[i].SubGroups[this._Properties[i].SubGroups.length - 1].Items[this._Properties[i].SubGroups[this._Properties[i].SubGroups.length - 1].Items.length] = new ClassItem(cssName, rowType, drpFields, this.cssItem, value, propertyName, this._PropertiesLookup, enabled);
                        this.cssItem++;
                        this.subGroupCount++;
                    }
                }
                else {
                    //item within group
                    this._Properties[i].Items[this._Properties[i].Items.length] = new ClassItem(cssName, rowType, drpFields, this.cssItem, value, propertyName, this._PropertiesLookup, enabled);
                    this.cssItem++;
                }
                foundGroup = true;
            }
        }
        if (!foundGroup) {
            //create new group with item
            this._Properties[this._Properties.length] = new Group(groupName, this.groupCount, false);
            this._Properties[this._Properties.length - 1].Items[this._Properties[this._Properties.length - 1].Items.length] = new ClassItem(cssName, rowType, drpFields, this.cssItem, value, propertyName, this._PropertiesLookup, enabled);
            this.groupCount++;
            this.cssItem++;
        }
    };
    PropertyGrid.prototype.updateStyle = function (cssName, newStyle) {
        //clean object up if dirty
        cssName = cssName.replace(/^\s*|\s*$/g, '');
        cssName = cssName.toLowerCase();
        var propLookup = "";
        for (var i = 0; i < this._PropertiesLookup.length; i++) {
            if (this._PropertiesLookup[i][0] == cssName) {
                propLookup = this._PropertiesLookup[i][1];
                document.getElementById(propLookup).value = newStyle;
                //check for col or drop type
                if (this._PropertiesLookup[i][2] == "color") {
                    var colorPalette = document.getElementById("color" + this._PropertiesLookup[i][1]);
                    if (colorPalette != null) {
                        try {
                            document.getElementById("color" + this._PropertiesLookup[i][1]).style.backgroundColor = newStyle;
                        }
                        catch (e) { }
                    }
                }
                //make section visible
                var e = document.getElementById(propLookup).parentNode.parentNode.parentNode;
                if (e.id.indexOf("subgroup") != -1) {
                    //item is in a subgroup sp show this and its parent 
                    e.style.display = "block";
                    var groupId = document.getElementById(propLookup).parentNode.parentNode.parentNode.id;
                    groupId = groupId.replace('child', '');
                    e.style.display = "block";
                    var subGroupId = e.id;
                    subGroupId = subGroupId.replace('child', '');
                    $("#image" + groupId).removeClass('bkExpand').addClass('bkMinimise');
                    $("#image" + subGroupId).removeClass('bkExpand');
                    $("#image" + subGroupId).removeClass('bkExpandSub').addClass('bkMinimiseSub');
                }
                else {
                    var groupId = e.id;
                    groupId = groupId.replace('child', '');
                    e.style.display = "block";
                    $("#image" + groupId).removeClass('bkExpand').addClass('bkMinimise');
                }
            }
        }
    };
    PropertyGrid.prototype.selectStyle = function (cssName) {
        for (var i = 0; i < this._PropertiesLookup.length; i++) {
            if (this._PropertiesLookup[i][0] == cssName) {
                var propLookup = this._PropertiesLookup[i][1];
                return document.getElementById(propLookup).value;
            }
        }
        return null;
    };
    PropertyGrid.prototype.clearGrid = function () {
        $('#propertyGridContainer').remove();
        this._Properties.length = 0;
    };
    PropertyGrid.prototype.renderGrid = function () {
        //creates the html output from Properties Object
        var htmlOut = "<div id=\"propertyGridContainer\">";
        var __this = this;
        try {
            for (var i = 0; i < this._Properties.length; i++) {
                var item = this._Properties[i];
                htmlOut += "<div id=\"" + item.OutputDiv + "\" class=\"pgGroup\"><div id=\"image" + item.OutputDiv + "\" class=\"pgGroupShrink \">&nbsp;</div><div class=\"pgGroupText\">" + item.GroupName + "</div></div>";
                //render group items
                htmlOut += "<div id=\"child" + item.OutputDiv + "\">";
                for (var x = 0; x < item.Items.length; x++) {
                    htmlOut += __this.RenderGridInput(item.Items[x].Type, item.Items[x].OutputDiv, item.Items[x].CssId, item.Items[x].DropFields, item.Items[x].Value, item.Items[x].PropertyName, item.Items[x].Enabled, item.Items[x].Enabled);
                }
                //check for subgroups
                if (item.SubGroups.length > 0) {
                    for (var ii = 0; ii < item.SubGroups.length; ii++) {
                        htmlOut += "<div id=\"" + item.SubGroups[ii].OutputDiv + "\" class=\"pgSubGroup\"><div id=\"image" + item.SubGroups[ii].OutputDiv + "\" class=\"pgSubGroupShrink \">&nbsp;</div><div class=\"pgSubGroupText\">" + item.SubGroups[ii].GroupName + "</div></div>";
                        //render sub group items
                        htmlOut += "<div id=\"child" + item.SubGroups[ii].OutputDiv + "\">";
                        for (var xx = 0; xx < item.SubGroups[ii].Items.length; xx++) {
                            htmlOut += __this.RenderGridInput(item.SubGroups[xx].Items[xx].Type, item.SubGroups[ii].Items[xx].OutputDiv, item.SubGroups[ii].Items[xx].CssId, item.SubGroups[ii].Items[xx].DropFields, item.Value, item.PropertyName);
                        }
                        htmlOut += "</div>";
                    }
                }
                htmlOut += "</div>";
            }
        }
        catch (e) {
            alert(e);
        }
        document.getElementById(this._OutputDivId).innerHTML = htmlOut + "</div>";
        var __this = this;
        $("input[id^=pg1_]").change(function (e) {
            var propertyName = $(e.currentTarget).data("propname");
            if (__this.PropertyChanged) {
                __this.PropertyChanged(propertyName, $(e.currentTarget).val());
            }
        });
        $("button[id^=pg1_]").click(function (e) {
            var propertyName = $(e.currentTarget).data("propname");
            if (__this.PropertyClicked) {
                __this.PropertyClicked(propertyName, $(e.currentTarget).val());
            }
        });
        $('.pgInputColor').colorpicker({
            format: 'hex',
            horizontal: true,
        });
        $('.pgInputColor').colorpicker().on('changeColor', function (ev) {
            var id = $(ev.currentTarget).attr('id');
            var colorSpan = $('#' + 'color' + id);
            var propertyName = colorSpan.data("propname");
            var color = ev.color.toHex();
            colorSpan.css('background-color', color);
            if (__this.PropertyChanged)
                __this.PropertyChanged(propertyName, color);
        });
        $("select[id^=pg1_]").change(function (e) {
            var propertyName = $(e.currentTarget).data("propname");
            if (__this.PropertyChanged) {
                __this.PropertyChanged(propertyName, $(e.currentTarget).val());
            }
        });
        $("button[class*='pgBtnSuggestion']").click(function (e) {
            if (!e)
                return;
            if (!e.currentTarget)
                return;
            var div = document.getElementById(__this._OutputDivId);
            if (!div)
                return;
            var propertyName = $(e.currentTarget).data("propname");
            var newDiv = document.createElement("div");
            newDiv.className = "pgTextAreaStyle";
            //var info = e.currentTarget.value;
            var text = e.currentTarget.previousElementSibling;
            div.appendChild(newDiv);
            $(newDiv).load('views/dialogs/TokenSelection.html', function () {
                var list = document.getElementById("selection");
                list.className = "selection-list";
                __this.FillTokens(list, "");
                list.selectedIndex = 0;
                var filter = document.getElementById("title");
                filter.addEventListener('input', function () {
                    __this.FillTokens(list, filter.value);
                    list.selectedIndex = 0;
                });
                filter.addEventListener('keydown', function (e) {
                    var key = e.key;
                    // check if the user wants to move the right
                    if (key.match(/ArrowDown/i)) {
                        if (list.selectedIndex < list.options.length - 1)
                            list.selectedIndex++;
                    }
                    else if (key.match(/ArrowUp/i)) {
                        if (list.selectedIndex > 0)
                            list.selectedIndex--;
                    }
                    else if (key.match(/Enter/i)) {
                        if (text.value)
                            text.value += "_";
                        text.value += "<" + list.selectedOptions[0].text + ">";
                        if (__this.PropertyChanged)
                            __this.PropertyChanged(propertyName, text.value);
                        div.removeChild(newDiv);
                    }
                });
                document.getElementById("saveEmailChanges").addEventListener('click', function () {
                    if (text.value)
                        text.value += "_";
                    text.value += "<" + list.selectedOptions[0].text + ">";
                    if (__this.PropertyChanged)
                        __this.PropertyChanged(propertyName, text.value);
                    div.removeChild(newDiv);
                });
                document.getElementById("discardEmailChanges").addEventListener('click', function () {
                    div.removeChild(newDiv);
                });
            });
        });
        $("button[class*='pgTextArea']").click(function (e) {
            var div = document.getElementById(__this._OutputDivId);
            var propertyName = $(e.currentTarget).data("propname");
            var newDiv = document.createElement("div");
            newDiv.className = "pgTextAreaStyle";
            var info = e.currentTarget.value;
            div.appendChild(newDiv);
            $(newDiv).load('views/dialogs/EmailTemplate.html', function () {
                var list = newDiv.getElementsByClassName("email-field");
                __this.fillEmailList(list, info);
                document.getElementById("saveEmailChanges").addEventListener('click', function () {
                    if (__this.PropertyChanged)
                        __this.PropertyChanged(propertyName, list[0].value + '\n' + list[1].value);
                    div.removeChild(newDiv);
                });
                document.getElementById("discardEmailChanges").addEventListener('click', function () {
                    div.removeChild(newDiv);
                });
            });
        });
        $("input[class*='pgInputNum']").keydown(function (e) {
            var key = e.which || e.keyCode;
            if (!e.shiftKey && !e.altKey && !e.ctrlKey &&
                // numbers   
                key >= 48 && key <= 57 ||
                // Numeric keypad
                key >= 96 && key <= 105 ||
                // comma, period and minus, . on keypad
                key == 190 || key == 188 || key == 109 || key == 110 ||
                // Backspace and Tab and Enter
                key == 8 || key == 9 || key == 13 ||
                // Home and End
                key == 35 || key == 36 ||
                // left and right arrows
                key == 37 || key == 39 ||
                // Del and Ins
                key == 46 || key == 45)
                return true;
            return false;
        });
    };
    PropertyGrid.prototype.splitCamelCaseToString = function (s) {
        return s.split(/(?=[A-Z])/).join(' ');
    };
    PropertyGrid.prototype.RenderGridInput = function (type, outputDivId, cssId, fields, value, propertyName, enabled, clickHandler) {
        var displayName = this.splitCamelCaseToString(propertyName);
        switch (type) {
            case 'input':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input id=\"" + outputDivId + "\" class=\"pgInput\" data-propname='" + propertyName + "' value='" + value + "'" + this.getDisabled(enabled) + "\"></input></div></div>";
            case 'color':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input id=\"" + outputDivId + "\" class=\"pgInputColor\"" + "' value='" + value + "'></input><span data-propname='" + propertyName + "' id=\"color" + outputDivId + "\" class=\"pgBtnColor\" style='background-color:" + value + "'><i></i></span></div></div>";
            case 'dialog':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input id=\"" + outputDivId + "\" class=\"pgInputDialog\" data-propname='" + propertyName + "' value='" + value + "'" + this.getDisabled(false) + "\"></input><button id=\"" + outputDivId + "\" data-propname='" + propertyName + "' class=\"pgDialog\">&hellip;</button></div></div></div>";
            case 'textarea':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><button id=\"" + outputDivId + "\" class=\"pgTextArea\" data-propname='" + propertyName + "' value='" + value + "'" + this.getDisabled(enabled) + "\">" + value + "</button></div></div>";
            case 'input_suggestions':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input id=\"" + outputDivId + "\" class=\"pgInput_suggestion\" data-propname='" + propertyName + "' value='" + value + "'" + this.getDisabled(enabled) + "\"></input>   <button data-propname='" + propertyName + "' id=\"suggestions" + outputDivId + "\" class=\"pgBtnSuggestion\" style='border: 1px solid; text-align:center: float:right'>?</button>   </div></div>";
            case 'num':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input data-propname='" + propertyName + this.getDisabled(enabled) + "' id=\"" + outputDivId + "\" class=\"pgInputNum\"" + this.getDisabled(enabled) + " value='" + value + "'\" type='number'></input></div></div>";
            case 'drop':
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><select id=\"" + outputDivId + "\" class=\"pgInputDrop\"><option value='none'" + this.getDisabled(enabled) + ">none</option><option value='solid'>solid</option><option value='ridge'>ridge</option><option value='dashed'>dashed</option><option value='dotted'>dotted</option><option value='double'>double</option><option value='groove'>groove</option><option value='inset'>inset</option></select></div></div>";
            case 'cdrop':
                //custom drop
                var dropHtml = "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><select id=\"" + outputDivId + "\" class=\"pgInputDrop\" data-propname='" + propertyName + "'" + this.getDisabled(enabled) + ">";
                var items = fields.split('|');
                for (var i = 0; i < items.length; i++) {
                    if (angular.isDefined(value) && items[i].toString() === value.toString())
                        dropHtml += "<option value=\"" + items[i] + "\" selected>" + items[i] + "</option>";
                    else
                        dropHtml += "<option value=\"" + items[i] + "\">" + items[i] + "</option>";
                }
                dropHtml += "</select></div></div>";
                return dropHtml;
            default:
                return "<div id=\"hold" + outputDivId + "\" class=\"pgGroupItem\"><div class=\"pgGroupItemText\">" + displayName + "</div><div class=\"pgInputHolder\"><input id=\"" + outputDivId + "\" class=\"pgInput\"" + this.getDisabled(enabled) + "></input></div></div>";
        }
    };
    PropertyGrid.prototype.getDisabled = function (enabled) {
        if (enabled)
            return "";
        return " disabled ";
    };
    PropertyGrid.prototype.clearValues = function () {
        for (var i = 0; i < this._PropertiesLookup.length; i++) {
            var propLookup = this._PropertiesLookup[i][1];
            var item = document.getElementById(propLookup);
            item.Value = '';
        }
    };
    PropertyGrid.prototype.emptyGrid = function () {
        this._Properties = new Array();
        this._PropertiesLookup = new Array();
        this.groupCount = 0;
        this.subGroupCount = 0;
        this.cssItem = 0;
    };
    PropertyGrid.prototype.hideItems = function () {
        //hide groups and sub groups
        $("div[id*=childpg1_group_]").css('display', 'none');
        $("div[id*=childpg1_subgroup_]").css('display', 'none');
        $("div[id*=imagepg1_group_]").removeClass('bkMinimise').addClass('bkExpand');
        $("div[id*=imagepg1_subgroup_]").removeClass('bkMinimiseSub').addClass('bkExpandSub');
    };
    PropertyGrid.prototype.expand = function (id, sub) {
        if (document.getElementById('child' + id).style.display == "" || document.getElementById('child' + id).style.display == "block") {
            //MAKE SMALL
            document.getElementById('child' + id).style.display = "none";
            if (sub == 'true') {
                $("#image" + id).removeClass('bkMinimiseSub').addClass('bkExpandSub');
            }
            else {
                $("#image" + id).removeClass('bkMinimise').addClass('bkExpand');
            }
        }
        else {
            //SHOW
            document.getElementById('child' + id).style.display = "block";
            if (sub == 'true') {
                $("#image" + id).removeClass('bkExpandSub').addClass('bkMinimiseSub');
            }
            else {
                $("#image" + id).removeClass('bkExpand').addClass('bkMinimise');
            }
        }
    };
    PropertyGrid.prototype.AttachColorPicker = function (propertyName, outputDivId) {
        var div = $("#color" + outputDivId);
        var __this = this;
        div.colorpicker({
            onSubmit: function (hsb, hex, rgb, el) {
                var divE = $(el);
                divE.css("backgroundColor", "#" + hex);
                divE.ColorPickerHide();
                if (__this.PropertyChanged)
                    __this.PropertyChanged(propertyName, "#" + hex);
            },
            onChange: function (hsb, hex, rgb) {
                div.css('backgroundColor', '#' + hex);
                $("input[id='" + outputDivId + "']").val('#' + hex);
            },
            onBeforeShow: function () {
                var color = $("input[id='" + outputDivId + "']").val();
                var thisE = $(this);
                thisE.ColorPickerSetColor($("input[id='" + outputDivId + "']").val());
            }
        });
    };
    PropertyGrid.prototype.retrieveCSSName = function () {
        return this._PropertiesLookup;
    };
    return PropertyGrid;
}());
;
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var lt;
(function (lt) {
    var Annotations;
    (function (Annotations) {
        var JavaScript;
        (function (JavaScript) {
            var AutomationInteractiveMode = /** @class */ (function (_super) {
                __extends(AutomationInteractiveMode, _super);
                function AutomationInteractiveMode() {
                    var _this = _super.call(this) || this;
                    _this.automationId = AutomationInteractiveMode.userModeId;
                    _this._id = _this.automationId;
                    _this.interactiveService_DragStarted = function (sender, e) {
                        if (_this.canStartWork(e)) {
                            _this.onWorkStarted(lt.LeadEventArgs.empty);
                            var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, false);
                            if (!e.isHandled) {
                                _this.workAutomationControl.onAutomationPointerDown(annArgs);
                                e.isHandled = annArgs.isHandled;
                                if (!e.isHandled)
                                    _this.onWorkCompleted(lt.LeadEventArgs.empty);
                            }
                        }
                    };
                    _this.interactiveService_DragDelta = function (sender, e) {
                        if (_this.isWorking) {
                            var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, false);
                            if (!e.isHandled) {
                                _this.workAutomationControl.onAutomationPointerMove(annArgs);
                                e.isHandled = annArgs.isHandled;
                            }
                        }
                    };
                    _this.interactiveService_DragCompleted = function (sender, e) {
                        if (_this.isWorking) {
                            var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, false);
                            if (!e.isHandled) {
                                _this.workAutomationControl.onAutomationPointerUp(annArgs);
                                e.isHandled = annArgs.isHandled;
                                _this.onWorkCompleted(lt.LeadEventArgs.empty);
                            }
                        }
                    };
                    _this.interactiveService_Tap = function (sender, e) {
                        if (!_this.isWorking && _this.canStartWork(e)) {
                            var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, true);
                            if (!e.isHandled) {
                                _this.workAutomationControl.onAutomationPointerUp(annArgs);
                                e.isHandled = annArgs.isHandled;
                            }
                        }
                    };
                    _this.interactiveService_DoubleTap = function (sender, e) {
                        if (_this.canStartWork(e)) {
                            var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, true);
                            if (!e.isHandled) {
                                _this.onWorkStarted(lt.LeadEventArgs.empty);
                                _this.workAutomationControl.onAutomationDoubleClick(annArgs);
                                e.isHandled = annArgs.isHandled;
                                _this.onWorkCompleted(lt.LeadEventArgs.empty);
                            }
                        }
                    };
                    _this.interactiveService_Move = function (sender, e) {
                        if (_this.workAutomationControl == null) {
                            return;
                        }
                        var annArgs = lt.Annotations.JavaScript.AutomationInteractiveMode.convertPointerEventArgs(e, false);
                        _this.workAutomationControl.onAutomationPointerMove(annArgs);
                    };
                    // Hook to left and right mouse button (if supported)
                    _this.mouseButtons = lt.Controls.MouseButtons.left; //| lt.Controls.MouseButtons.right;
                    // Setup our item mode, when the user first click, make this our item
                    _this.autoItemMode = lt.Controls.ImageViewerAutoItemMode.autoSet;
                    // Work on the image
                    _this.itemPart = lt.Controls.ImageViewerItemPart.image;
                    // So selection works even if we click outside the items
                    _this.workOnBounds = false;
                    // Don't  fire drag events on mouse wheel
                    _this.isDragMouseWheelEnabled = false;
                    return _this;
                }
                AutomationInteractiveMode.prototype.get_id = function () { return this._id; };
                AutomationInteractiveMode.prototype.setId = function (value) {
                    this._id = value;
                };
                Object.defineProperty(AutomationInteractiveMode.prototype, "automationControl", {
                    get: function () {
                        return this._automationControl;
                    },
                    set: function (value) {
                        this._automationControl = value;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(AutomationInteractiveMode.prototype, "workAutomationControl", {
                    get: function () {
                        if (this._automationControl != null)
                            return this._automationControl;
                        else
                            return (this.imageViewer);
                    },
                    enumerable: false,
                    configurable: true
                });
                AutomationInteractiveMode.prototype.get_name = function () {
                    return "AutomationInteractiveMode";
                };
                AutomationInteractiveMode.prototype.canStartWork = function (e) {
                    return _super.prototype.canStartWork.call(this, e) && this.workAutomationControl != null;
                };
                AutomationInteractiveMode.prototype.start = function (imageViewer) {
                    _super.prototype.start.call(this, imageViewer);
                    var interactiveService = this.interactiveService;
                    this._dragStartedHandler = interactiveService.dragStarted.add(this.interactiveService_DragStarted);
                    this._dragDeltaHandler = interactiveService.dragDelta.add(this.interactiveService_DragDelta);
                    this._dragCompletedHandler = interactiveService.dragCompleted.add(this.interactiveService_DragCompleted);
                    this._tapHandler = interactiveService.tap.add(this.interactiveService_Tap);
                    this._doubleTapHandler = interactiveService.doubleTap.add(this.interactiveService_DoubleTap);
                    this._moveHandler = interactiveService.move.add(this.interactiveService_Move);
                };
                AutomationInteractiveMode.prototype.stop = function (imageViewer) {
                    if (this.isStarted) {
                        var interactiveService = _super.prototype.get_interactiveService.call(this);
                        interactiveService.dragStarted.remove(this._dragStartedHandler);
                        interactiveService.dragDelta.remove(this._dragDeltaHandler);
                        interactiveService.dragCompleted.remove(this._dragCompletedHandler);
                        interactiveService.tap.remove(this.interactiveService_Tap);
                        interactiveService.doubleTap.remove(this._doubleTapHandler);
                        interactiveService.move.remove(this._moveHandler);
                        _super.prototype.stop.call(this, imageViewer);
                    }
                };
                AutomationInteractiveMode.convertPointerEventArgs = function (e, isDoubleTap) {
                    // Convert the point
                    var point = lt.LeadPointD.create(e.position.x, e.position.y);
                    // Convert the mouse button
                    var mouseButton = lt.Annotations.Engine.AnnMouseButton.none;
                    if (!isDoubleTap) {
                        if (e.mouseButton == lt.Controls.MouseButtons.left)
                            mouseButton = lt.Annotations.Engine.AnnMouseButton.left;
                        if (e.mouseButton == lt.Controls.MouseButtons.right)
                            mouseButton = lt.Annotations.Engine.AnnMouseButton.right;
                    }
                    else {
                        mouseButton = lt.Annotations.Engine.AnnMouseButton.left;
                    }
                    var args = lt.Annotations.Engine.AnnPointerEventArgs.create(mouseButton, point);
                    args.isHandled = e.isHandled;
                    return args;
                };
                return AutomationInteractiveMode;
            }(lt.Controls.ImageViewerInteractiveMode));
            JavaScript.AutomationInteractiveMode = AutomationInteractiveMode;
        })(JavaScript = Annotations.JavaScript || (Annotations.JavaScript = {}));
    })(Annotations = lt.Annotations || (lt.Annotations = {}));
})(lt || (lt = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var lt;
(function (lt) {
    var Annotations;
    (function (Annotations) {
        var JavaScript;
        (function (JavaScript) {
            var AnnCursorType;
            (function (AnnCursorType) {
                AnnCursorType[AnnCursorType["selectObject"] = 0] = "selectObject";
                AnnCursorType[AnnCursorType["selectedObject"] = 1] = "selectedObject";
                AnnCursorType[AnnCursorType["controlPoint"] = 2] = "controlPoint";
                AnnCursorType[AnnCursorType["controlPointNWSE"] = 3] = "controlPointNWSE";
                AnnCursorType[AnnCursorType["controlPointNS"] = 4] = "controlPointNS";
                AnnCursorType[AnnCursorType["controlPointNESW"] = 5] = "controlPointNESW";
                AnnCursorType[AnnCursorType["controlPointWE"] = 6] = "controlPointWE";
                AnnCursorType[AnnCursorType["selectRectangle"] = 7] = "selectRectangle";
                AnnCursorType[AnnCursorType["run"] = 8] = "run";
                AnnCursorType[AnnCursorType["rotateCenterControlPoint"] = 9] = "rotateCenterControlPoint";
                AnnCursorType[AnnCursorType["rotateGripperControlPoint"] = 10] = "rotateGripperControlPoint";
                AnnCursorType[AnnCursorType["Default"] = 11] = "Default";
                AnnCursorType[AnnCursorType["count"] = 12] = "count";
            })(AnnCursorType = JavaScript.AnnCursorType || (JavaScript.AnnCursorType = {}));
            var AutomationManagerHelper = /** @class */ (function () {
                function AutomationManagerHelper(manager, resourcesPath) {
                    // The path to the resources. This is thee default value. Will replace all ##RESOURCES_PATH## in the code
                    this._resourcesPath = "../Resources";
                    this._drawCursors = {};
                    this._objectsImages = {};
                    if (manager == null)
                        alert("Error, AnnAutomationManager is null");
                    this._manager = manager;
                    if (this._manager.renderingEngine == null) {
                        this._manager.renderingEngine = new lt.Annotations.Rendering.AnnHtml5RenderingEngine();
                    }
                    AutomationManagerHelper._automationCursors[AnnCursorType.controlPoint] = "url('##RESOURCES_PATH##/Cursors/Edit/ControlPoint.cur'),default";
                    AutomationManagerHelper._automationCursors[AnnCursorType.rotateCenterControlPoint] = "url('##RESOURCES_PATH##/Cursors/Edit/Anchor.cur'), default";
                    AutomationManagerHelper._automationCursors[AnnCursorType.rotateGripperControlPoint] = "url('##RESOURCES_PATH##/Cursors/Edit/Rotate.cur'),default";
                    AutomationManagerHelper._automationCursors[AnnCursorType.selectObject] = "url('##RESOURCES_PATH##/Cursors/Edit/SelectObject.cur'), default";
                    AutomationManagerHelper._automationCursors[AnnCursorType.selectedObject] = "url('##RESOURCES_PATH##/Cursors/Edit/SelectedObject.cur'),default";
                    AutomationManagerHelper._automationCursors[AnnCursorType.run] = "pointer";
                    // Update the resources
                    this.updateResourcePaths(resourcesPath);
                    // To track modifier keys
                    if (lt.LTHelper.supportsMouse) {
                        // Tell lt.Controls.InteractiveService to listen for modifier keys even if no ImageViewer exists
                        lt.Controls.InteractiveService.registerGlobalModifierKeys();
                        // Initialize the platform callbacks
                        var callbacks = lt.Annotations.Automation.AnnAutomationManager.platformCallbacks;
                        callbacks.checkModifier = AutomationManagerHelper.checkModifierKey;
                    }
                    this.updateAutomationObjects();
                }
                Object.defineProperty(AutomationManagerHelper.prototype, "automationManager", {
                    get: function () {
                        return this._manager;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(AutomationManagerHelper.prototype, "drawCursors", {
                    get: function () {
                        return this._drawCursors;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(AutomationManagerHelper.prototype, "automationCursors", {
                    get: function () {
                        return AutomationManagerHelper._automationCursors;
                    },
                    enumerable: false,
                    configurable: true
                });
                AutomationManagerHelper.prototype.updateResourcePaths = function (resourcesPath) {
                    for (var key in AutomationManagerHelper._drawCursorsTemplate) {
                        var originalValue = AutomationManagerHelper._drawCursorsTemplate[key];
                        var thisValue = originalValue.replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                        this._drawCursors[key] = thisValue;
                    }
                    for (var key in AutomationManagerHelper._objectsImagesTemplate) {
                        var originalValue = AutomationManagerHelper._objectsImagesTemplate[key];
                        var thisValue = originalValue.replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                        this._objectsImages[key] = thisValue;
                    }
                    AutomationManagerHelper._automationCursors[AnnCursorType.controlPoint] = AutomationManagerHelper._automationCursors[AnnCursorType.controlPoint].replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                    AutomationManagerHelper._automationCursors[AnnCursorType.rotateCenterControlPoint] = AutomationManagerHelper._automationCursors[AnnCursorType.rotateCenterControlPoint].replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                    AutomationManagerHelper._automationCursors[AnnCursorType.rotateGripperControlPoint] = AutomationManagerHelper._automationCursors[AnnCursorType.rotateGripperControlPoint].replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                    AutomationManagerHelper._automationCursors[AnnCursorType.selectObject] = AutomationManagerHelper._automationCursors[AnnCursorType.selectObject].replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                    AutomationManagerHelper._automationCursors[AnnCursorType.selectedObject] = AutomationManagerHelper._automationCursors[AnnCursorType.selectedObject].replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                    //ReviewTreeNode.undoImageUrl = AutomationManagerHelper._undoImageUrlTemplate.replace(AutomationManagerHelper._resourcesTamplate, resourcesPath);
                };
                AutomationManagerHelper.prototype.updateAutomationObjects = function () {
                    if (this._manager == null)
                        return;
                    for (var i = 0; i < this._manager.objects.count; i++) {
                        var automationObject = this._manager.objects.item(i);
                        AutomationManagerHelper.updateAutomationObject(automationObject);
                    }
                };
                AutomationManagerHelper.updateAutomationObject = function (automationObject) {
                    if (automationObject.objectTemplate != null && automationObject.objectTemplate.supportsFill && automationObject.objectTemplate.fill == null)
                        automationObject.objectTemplate.fill = lt.Annotations.Engine.AnnSolidColorBrush.create("transparent");
                };
                // Gets the cursor for the automation object with this id
                AutomationManagerHelper.prototype.getAutomationObjectCursor = function (objectId) {
                    //don't add cursors for the these objects
                    if (objectId == lt.Annotations.Engine.AnnObject.imageObjectId)
                        return null;
                    if (objectId == lt.Annotations.Engine.AnnObject.textHiliteObjectId ||
                        objectId == lt.Annotations.Engine.AnnObject.textStrikeoutObjectId ||
                        objectId == lt.Annotations.Engine.AnnObject.textUnderlineObjectId ||
                        objectId == lt.Annotations.Engine.AnnObject.textRedactionObjectId)
                        return "text";
                    if (objectId == lt.Annotations.Engine.AnnObject.stickyNoteObjectId)
                        return "crosshair";
                    var annObject = this._manager.findObjectById(objectId);
                    if (annObject != null) {
                        return this._drawCursors[objectId.toString()];
                    }
                    return null;
                };
                AutomationManagerHelper.prototype.getAutomationObjectImage = function (objectId) {
                    var annObject = this._manager.findObjectById(objectId);
                    if (annObject != null) {
                        return this._objectsImages[objectId.toString()];
                    }
                    return null;
                };
                AutomationManagerHelper.checkModifierKey = function (annKey) {
                    // Map the AnnKeys to our lt.Controls modifier keys so we don't have to listen for keyup/keydown ourself.
                    var AnnKeys = lt.Annotations.Engine.AnnKeys;
                    var ControlsKeys = lt.Controls.Keys;
                    var ControlsModifierKeys = lt.Controls.InteractiveService.modifierKeys;
                    if ((annKey & AnnKeys.shift) == AnnKeys.shift)
                        return (ControlsModifierKeys & ControlsKeys.shift) === ControlsKeys.shift;
                    if ((annKey & lt.Annotations.Engine.AnnKeys.control) == lt.Annotations.Engine.AnnKeys.control)
                        return (ControlsModifierKeys & ControlsKeys.control) === ControlsKeys.control;
                    if ((annKey & lt.Annotations.Engine.AnnKeys.alt) == lt.Annotations.Engine.AnnKeys.alt)
                        return (ControlsModifierKeys & ControlsKeys.alt) === ControlsKeys.alt;
                    return false;
                };
                AutomationManagerHelper.prototype.LoadPackage = function (annPackage) {
                    if (annPackage != null) {
                        // Update the automation objects as we load ...
                        var handler = this._manager.objects.collectionChanged.add(function (sender, e) {
                            if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                                for (var i = 0; i < e.newItems.length; i++)
                                    var automationObject = e.newItems[i];
                                AutomationManagerHelper.updateAutomationObject(automationObject);
                            }
                        });
                        this._manager.loadPackage(annPackage, annPackage.get_friendlyName());
                        this._manager.objects.collectionChanged.remove(handler);
                    }
                };
                AutomationManagerHelper._resourcesTamplate = "##RESOURCES_PATH##";
                AutomationManagerHelper._drawCursorsTemplate = {
                    "-2": "url('##RESOURCES_PATH##/Cursors/Draw/ToolLine.cur'),default",
                    "-3": "url('##RESOURCES_PATH##/Cursors/Draw/ToolRectangle.cur'),default",
                    "-4": "url('##RESOURCES_PATH##/Cursors/Draw/ToolEllipse.cur'),default",
                    "-5": "url('##RESOURCES_PATH##/Cursors/Draw/ToolPolyline.cur'),default",
                    "-6": "url('##RESOURCES_PATH##/Cursors/Draw/ToolPolygon.cur'),default",
                    "-7": "url('##RESOURCES_PATH##/Cursors/Draw/ToolCurve.cur'),default",
                    "-8": "url('##RESOURCES_PATH##/Cursors/Draw/ToolClosedCurve.cur'),default",
                    "-9": "url('##RESOURCES_PATH##/Cursors/Draw/ToolPointer.cur'),default",
                    "-10": "url('##RESOURCES_PATH##/Cursors/Draw/ToolFreehand.cur'),default",
                    "-11": "url('##RESOURCES_PATH##/Cursors/Draw/ToolHilite.cur'),default",
                    "-12": "url('##RESOURCES_PATH##/Cursors/Draw/ToolText.cur'),default",
                    "-14": "url('##RESOURCES_PATH##/Cursors/Draw/ToolTextPointer.cur'),default",
                    "-15": "url('##RESOURCES_PATH##/Cursors/Draw/ToolNote.cur'),default",
                    "-16": "url('##RESOURCES_PATH##/Cursors/Draw/ToolStamp.cur'),default",
                    "-17": "url('##RESOURCES_PATH##/Cursors/Draw/ToolRubberStamp.cur'),default",
                    "-18": "url('##RESOURCES_PATH##/Cursors/Draw/ToolHotspot.cur'),default",
                    "-19": "url('##RESOURCES_PATH##/Cursors/Draw/ToolFreehandHotspot.cur'),default",
                    "-21": "url('##RESOURCES_PATH##/Cursors/Draw/ToolPoint.cur'),default",
                    "-22": "url('##RESOURCES_PATH##/Cursors/Draw/ToolRedaction.cur'),default",
                    "-23": "url('##RESOURCES_PATH##/Cursors/Draw/ToolRuler.cur'),default",
                    "-24": "url('##RESOURCES_PATH##/Cursors/Draw/ToolPolyruler.cur'),default",
                    "-25": "url('##RESOURCES_PATH##/Cursors/Draw/ToolProtractor.cur'),default",
                    "-26": "url('##RESOURCES_PATH##/Cursors/Draw/ToolCrossProduct.cur'),default",
                    "-13": "url('##RESOURCES_PATH##/Cursors/Draw/ToolTextRollup.cur'),default",
                    "-28": "url('##RESOURCES_PATH##/Cursors/Draw/ToolAudio.cur'),default",
                    "-30": "url('##RESOURCES_PATH##/Cursors/Draw/ToolVideo.cur'),default",
                    "-27": "url('##RESOURCES_PATH##/Cursors/Draw/ToolEncrypt.cur'),default"
                };
                AutomationManagerHelper._objectsImagesTemplate = {
                    "-2": "##RESOURCES_PATH##/Images/Icons/Line.png",
                    "-3": "##RESOURCES_PATH##/Images/Icons/Rectangle.png",
                    "-4": "##RESOURCES_PATH##/Images/Icons/Circle.png",
                    "-5": "##RESOURCES_PATH##/Images/Icons/Polyline.png",
                    "-6": "##RESOURCES_PATH##/Images/Icons/Polygon.png",
                    "-7": "##RESOURCES_PATH##/Images/Icons/SCurve.png",
                    "-8": "##RESOURCES_PATH##/Images/Icons/BSpline.png",
                    "-9": "##RESOURCES_PATH##/Images/Icons/Pointer.png",
                    "-10": "##RESOURCES_PATH##/Images/Icons/Pen.png",
                    "-11": "##RESOURCES_PATH##/Images/Icons/Highlight.png",
                    "-12": "##RESOURCES_PATH##/Images/Icons/A.png",
                    "-14": "##RESOURCES_PATH##/Images/Icons/AArrow.png",
                    "-15": "##RESOURCES_PATH##/Images/Icons/Note.png",
                    "-16": "##RESOURCES_PATH##/Images/Icons/Image.png",
                    "-17": "##RESOURCES_PATH##/Images/Icons/Stamp.png",
                    "-18": "##RESOURCES_PATH##/Images/Icons/H.png",
                    "-19": "##RESOURCES_PATH##/Images/Icons/HSquiggles.png",
                    "-21": "##RESOURCES_PATH##/Images/Icons/RoundX.png",
                    "-22": "##RESOURCES_PATH##/Images/Icons/Redact.png",
                    "-23": "##RESOURCES_PATH##/Images/Icons/Ruler.png",
                    "-24": "##RESOURCES_PATH##/Images/Icons/90DegreeRuler.png",
                    "-25": "##RESOURCES_PATH##/Images/Icons/Protractor.png",
                    "-26": "##RESOURCES_PATH##/Images/Icons/Intersect.png",
                    "-13": "##RESOURCES_PATH##/Images/Icons/Pin.png",
                    "-28": "##RESOURCES_PATH##/Images/Icons/Sound.png",
                    "-30": "##RESOURCES_PATH##/Images/Icons/Video.png",
                    "-27": "##RESOURCES_PATH##/Images/Icons/Lock.png",
                    "-33": "##RESOURCES_PATH##/Images/Icons/THighlight.png",
                    "-34": "##RESOURCES_PATH##/Images/Icons/Strikethrough.png",
                    "-35": "##RESOURCES_PATH##/Images/Icons/Underline.png",
                    "-36": "##RESOURCES_PATH##/Images/Icons/TRedact.png",
                    "-32": "##RESOURCES_PATH##/Images/Icons/StickyNotes.png",
                };
                AutomationManagerHelper._undoImageUrlTemplate = "url('##RESOURCES_PATH##/Images/Icons/Undo.png')";
                AutomationManagerHelper._automationCursors = {};
                return AutomationManagerHelper;
            }());
            JavaScript.AutomationManagerHelper = AutomationManagerHelper;
        })(JavaScript = Annotations.JavaScript || (Annotations.JavaScript = {}));
    })(Annotations = lt.Annotations || (lt.Annotations = {}));
})(lt || (lt = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('ltFancyTree', ['$rootScope', function ($root) {
        return {
            restrict: 'A',
            scope: {
                config: '=',
                data: '=',
                disabledItems: '=',
                select: '&',
                activate: '&',
                deactivate: '&',
                api: '=',
            },
            link: function (scope, element, attrs, $rootScope) {
                scope.$watch('config', function (value) {
                    $(element).parent().height($root.windowDimensions.height * .25);
                    value.select = function (event, data) {
                        scope.select({ event: event, data: data });
                    };
                    value.activate = function (event, data) {
                        scope.activate({ event: event, data: data });
                    };
                    value.deactivate = function (event, data) {
                        scope.deactivate({ event: event, data: data });
                    };
                    element.fancytree(value);
                });
                scope.api = scope.api || {};
                scope.api.addNode = function (parentNode, item) {
                    if (parentNode == null) {
                        parentNode = element.fancytree("getRootNode");
                    }
                    return parentNode.addChildren({
                        title: item.id,
                        tooltip: item.tooltip,
                        data: item,
                        folder: item.items && item.items.length > 0
                    });
                };
                scope.api.visit = function (visitFunction) {
                    element.fancytree('getTree').visit(visitFunction);
                };
                scope.api.activateNode = function (node) {
                    if (node != null) {
                        node.setActive();
                        node.setFocus(true);
                        node.scrollIntoView();
                    }
                };
                scope.api.clear = function () {
                    var rootnode = element.fancytree("getRootNode");
                    rootnode.removeChildren();
                };
                scope.api.addData = function (parent, item) {
                    var childNode;
                    if (parent == null) {
                        parent = element.fancytree("getRootNode");
                    }
                    childNode = parent.addChildren({
                        title: item.id,
                        tooltip: item.tooltip,
                        data: item,
                        folder: item.items && item.items.length > 0,
                        selected: scope.disabledItems.indexOf(item.id) == -1,
                    });
                    angular.forEach(item.items, function (child, key) {
                        scope.api.addData(childNode, child);
                    });
                };
                scope.api.setDisabledItems = function (disabledItems) {
                    element.fancytree('getTree').visit(function (node) {
                        var item = node.data;
                        node.setSelected(disabledItems.indexOf(item.id) == -1);
                    });
                };
                scope.api.clearActive = function () {
                    element.fancytree('getTree').visit(function (node) {
                        var item = node.data;
                        node.setActive(false);
                    });
                };
                scope.$watch('data', function (value) {
                    if (value) {
                        var rootNode = element.fancytree("getRootNode");
                        for (var i = 0; i < value.length; i++) {
                            scope.api.addData(rootNode, value[i]);
                        }
                        ;
                        scope.api.clearActive();
                    }
                });
                scope.$watch(function () {
                    return $root.windowDimensions.height;
                }, function (newValue, oldValue) {
                    if (newValue != oldValue) {
                        $(element).parent().height(newValue * .25);
                    }
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Directives;
(function (Directives) {
    var MedicalViewerApi = /** @class */ (function () {
        function MedicalViewerApi(viewer, config) {
            this._viewer = viewer;
            this._config = config;
        }
        Object.defineProperty(MedicalViewerApi.prototype, "selectedItems", {
            get: function () {
                return this._viewer.emptyDivs.selectedItems;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MedicalViewerApi.prototype, "cellCount", {
            get: function () {
                return this._viewer.get_gridLayout().get_rows() * this._viewer.get_gridLayout().get_columns();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MedicalViewerApi.prototype, "canMerge", {
            get: function () {
                return this._viewer.canMerge();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MedicalViewerApi.prototype, "hasLayout", {
            get: function () {
                return !!this._config.studyLayout;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MedicalViewerApi.prototype, "studyLayout", {
            get: function () {
                return this._config.studyLayout;
            },
            set: function (value) {
                this._config.studyLayout = value;
            },
            enumerable: false,
            configurable: true
        });
        MedicalViewerApi.prototype.mergeSelectedCells = function () {
            this._viewer.mergeSelected();
        };
        MedicalViewerApi.prototype.clearLayout = function () {
            delete this._config["studyLayout"];
        };
        return MedicalViewerApi;
    }());
    Directives.MedicalViewerApi = MedicalViewerApi;
})(Directives || (Directives = {}));
var MedicalViewerAction = {
    Offset: 0,
    Scale: 1,
    Magnify: 2,
    WindowLevel: 3,
    Stack: 4,
    AnnRectangle: 5,
    AnnEllipse: 6,
    AnnPointer: 7,
    AnnCurve: 8,
    AnnLine: 9,
    AnnText: 10,
    AnnHighlight: 11,
    AnnRuler: 12,
    AnnPolyRuler: 13,
    AnnProtractor: 14,
    AnnSelect: 15,
    AnnFreeHand: 16,
    SpyGlass: 17,
    ProbeTool: 18,
    AnnPoint: 19,
    AnnPolyline: 20,
    AnnPolygon: 21,
    AnnTextPointer: 22,
    AnnNote: 23,
    CrossHair: 24,
    DragItem: 25,
    LineProfile: 26,
    Cursor3D: 27,
    ShutterRect: 28,
    ShutterEllipse: 29,
    ShutterPolygon: 30,
    ShutterFreeHand: 31,
    Rotate3D: 32,
    PanoramicPolygon: 33,
    CTRTool: 34
};
var Spyglass = {
    Default: 0,
    Invert: 1,
    CLAHE: 2,
    Equalization: 3
};
var CommandManager;
(function (CommandManager) {
    CommandManager.LastCommand = { Action: MedicalViewerAction.WindowLevel, ButtonID: "" };
    CommandManager.Last3DCommand = { Action: MedicalViewerAction.WindowLevel, ButtonID: "" };
    function AssignAction(cell, action, button, buttonid) {
        if (cell.getCommand) {
            if (action == MedicalViewerAction.Rotate3D)
                return false;
            var actionCommand;
            actionCommand = cell.getCommand(action);
            var index = 0;
            var length = cell.viewer.layout.items.count;
            var currentCell;
            actionCommand.linked.clear();
            for (index = 0; index < length; index++) {
                currentCell = cell.viewer.layout.items.get_item(index);
                if (currentCell.tickBoxes && currentCell.tickBoxes.length > 0) {
                    if (currentCell.tickBoxes[0].checked)
                        actionCommand.linked.add(currentCell);
                }
            }
            actionCommand.button = button;
            cell.runCommand(action);
            if (button == lt.Controls.MouseButtons.left) {
                CommandManager.LastCommand.ButtonID = buttonid;
                CommandManager.LastCommand.Action = action;
            }
        }
        else {
            var cell3D = cell;
            var action3D;
            switch (action) {
                case MedicalViewerAction.Offset:
                    action3D = lt.Controls.Medical.Interactive3DAction.offset;
                    break;
                case MedicalViewerAction.WindowLevel:
                    action3D = lt.Controls.Medical.Interactive3DAction.windowLevel;
                    break;
                case MedicalViewerAction.Scale:
                    action3D = lt.Controls.Medical.Interactive3DAction.scale;
                    break;
                case MedicalViewerAction.Rotate3D:
                    action3D = lt.Controls.Medical.Interactive3DAction.rotate3D;
                    break;
                default:
                    return false;
            }
            if (button == lt.Controls.MouseButtons.left) {
                CommandManager.Last3DCommand.ButtonID = buttonid;
                CommandManager.Last3DCommand.Action = action3D;
            }
            cell3D.actions[button] = action3D;
        }
        return true;
    }
    function RunCommand(cell, commandID, buttonID) {
        var assigned = AssignAction(cell, commandID, lt.Controls.MouseButtons.left, buttonID);
        if (!assigned)
            return;
        switch (commandID) {
            case MedicalViewerAction.WindowLevel:
                AssignAction(cell, MedicalViewerAction.Offset, lt.Controls.MouseButtons.right, buttonID);
                AssignAction(cell, MedicalViewerAction.Scale, lt.Controls.MouseButtons.middle, buttonID);
                break;
            case MedicalViewerAction.Scale:
                AssignAction(cell, MedicalViewerAction.WindowLevel, lt.Controls.MouseButtons.right, buttonID);
                AssignAction(cell, MedicalViewerAction.Offset, lt.Controls.MouseButtons.middle, buttonID);
                break;
            default:
                AssignAction(cell, MedicalViewerAction.WindowLevel, lt.Controls.MouseButtons.right, buttonID);
                AssignAction(cell, MedicalViewerAction.Scale, lt.Controls.MouseButtons.middle, buttonID);
                break;
        }
    }
    CommandManager.RunCommand = RunCommand;
})(CommandManager || (CommandManager = {}));
var cellNameCounter = 0;
var SpyglassEffect = Spyglass.Default;
var stretchIntensityLow = 0;
var stretchIntensityHigh = 0;
var MedicalViewerConfig = /** @class */ (function () {
    function MedicalViewerConfig() {
        this.rows = 1;
        this.columns = 2;
        this.splitterSize = Utils.get_splitterSize();
        this.studyLayout = null;
        this.customLayout = null;
        this.hangingProtocol = null;
    }
    return MedicalViewerConfig;
}());
var MedicalViewerCellConfig = /** @class */ (function () {
    function MedicalViewerCellConfig() {
    }
    return MedicalViewerCellConfig;
}());
var MedicalViewerSeries = /** @class */ (function () {
    function MedicalViewerSeries(seriesInstanceUID, patientID, sdID, rows, columns) {
        this.seriesInstanceUID = seriesInstanceUID;
        this.patientID = patientID;
        this.rows = rows || 1;
        this.columns = columns || 1;
        this.forCompare = false;
        this.link = true;
        this.id = UUID.genV4().toString();
        this.sopInstanceUIDS = new Array();
        this.template = null;
        this.dislaySetNumber = undefined;
        this.loadSeriesLayout = true;
        this.structuredDisplayID = sdID;
        this.templateItem;
        this.modality = "";
    }
    return MedicalViewerSeries;
}());
directives.directive('medicalviewer', ["eventService", "$timeout", "$parse", "objectRetrieveService", "queryArchiveService", "optionsService", "dicomLoaderService", "seriesManagerService", "overlayManagerService", "dataService", "cinePlayerService", "tabService", "templateService", function (eventService, $timeout, $parse, objectRetrieveService, queryArchiveService, optionsService, dicomLoaderService, seriesManagerService, overlayManagerService, dataService, cinePlayerService, tabService, templateService) {
        return {
            restrict: 'A',
            scope: {
                viewerConfig: '=',
                series: '=',
                viewerapi: '=',
                cellClicked: '&',
                stackChanged: '&',
                seriesDropped: '&',
                cellSelected: '&',
            },
            link: function (scope, elem, attr) {
                if (attr.viewerId) {
                    elem.attr('id', attr.viewerId);
                }
                // set the licence
                /* License Setup:
                 *
                 * When checking for a client license, failure results in an on-screen alert() message.
                 * You can set the license in three ways:
                 *    - Do nothing, and wait for the default license check in Leadtools.Controls (using LTHelper.licenseDirectory), provided that you set the license and developer key files in the LEADTOOLS folder at the server
                 *    - lt.RasterSupport.setLicenseUri(licenseUri, developerKey, callback)
                 *       - Allows us to set an absolute or relative path to the license file (makes a GET request)
                 *    - lt.RasterSupport.setLicenseText(licenseText, developerKey) or setLicenseBuffer(licenseBuffer, developerKey)
                 *       - Allows us to make our own request for the license and just provide the text or byte array buffer
                 *
                 * See lt.RasterSupport JavaScript documentation for more information.
                 *
                 * Note: If you choose to comment out this code, know that LEADTOOLS will check for the license
                 * using LTHelper.licenseDirectory.
                 */
                /*
                if (lt.RasterSupport.kernelExpired) {
                    // "null" means to use the LTHelper.licenseDirectory
                    lt.RasterSupport.setLicenseUri("https://demo.leadtools.com/licenses/js/LEADTOOLSEVAL.txt", "EVAL", () => {
                        if (!lt.RasterSupport.kernelExpired) {
                            lt.LTHelper.log("LEADTOOLS client license set successfully");
                        } else {
                            var msg = "No LEADTOOLS License\n\nYour license file is missing, invalid or expired. LEADTOOLS will not function. Please contact LEAD Sales for information on obtaining a valid license.";
                            alert(msg);
                        }
                    });
                }
                */
                var viewer = new lt.Controls.Medical.MedicalViewer(elem[0], 0, 0);
                viewer.layout.beginUpdate();
                var divid = viewer.get_divId();
                var config = scope.viewerConfig || new MedicalViewerConfig();
                var numInstances = 0;
                //
                // Mobile devices are 1x1
                if (lt.LTHelper.device == lt.LTDevice.mobile && (!config.studyLayout && !config.customLayout)) {
                    config.rows = 1;
                    config.columns = 1;
                }
                viewer.get_emptyDivs().get_items().add_collectionChanged(emptyDivsCollectionChanged);
                if (config.hangingProtocol) {
                    var hangingProtocol = Utils.clone(config.hangingProtocol);
                    config.hangingProtocol = hangingProtocol;
                    if (!set_gridMode(config, hangingProtocol.Rows, hangingProtocol.Columns)) {
                        var boxes = new Array();
                        angular.forEach(config.hangingProtocol.DisplaySets, function (displaySet, key) {
                            angular.forEach(displaySet.Boxes, function (box, key) {
                                box["displaySetNumber"] = displaySet.DisplaySetNumber;
                                boxes.push(box);
                            });
                        });
                        set_randomMode(config, boxes, function (box) {
                            return angular.isDefined(box["displaySetNumber"]) && box["displaySetNumber"] != -1;
                        });
                    }
                    set_hangingProtocolViewerSettings(viewer, hangingProtocol);
                }
                else if (config.studyLayout) {
                    var studylayout = Utils.clone(config.studyLayout);
                    config.studyLayout = studylayout;
                    if (config.studyLayout.Boxes) {
                        config.studyLayout.Boxes.sort(function (a, b) {
                            return a.ImageBoxNumber - b.ImageBoxNumber;
                        });
                    }
                    if (!set_gridMode(config, studylayout.Rows, studylayout.Columns)) {
                        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.random;
                        viewer.totalCells = config.studyLayout.Boxes.length;
                        resetSeriesArrangement(config.studyLayout.Boxes);
                        rearrangeSeries(config.studyLayout.Boxes);
                        function resetSeriesArrangement(boxes) {
                            var cellLength = Math.min(boxes.length, viewer.layout.items.count);
                            var length = viewer.get_emptyDivs().items.count;
                            for (var index = 0; index < length; index++) {
                                viewer.get_emptyDivs().get_items().get_item(index).set_position(index + cellLength);
                            }
                        }
                        function rearrangeSeries(boxes) {
                            var length = viewer.emptyDivs.items.count;
                            viewer.layout.beginUpdate();
                            for (var index = 0; index < length; index++) {
                                var boxNumber = index + 1;
                                var series = $.grep(config.studyLayout.Series, function (series) {
                                    return series.ImageBoxNumber == boxNumber;
                                });
                                if (series.length == 0) {
                                    var item = viewer.emptyDivs.items.item(index);
                                    var box = boxes[index];
                                    var rect = Utils.createLeadRect(box.Position.leftTop.x, box.Position.leftTop.y, box.Position.rightBottom.x, box.Position.rightBottom.y);
                                    item.bounds = rect;
                                }
                            }
                            viewer.layout.endUpdate();
                        }
                        $.each(config.studyLayout.Boxes, function (index, item) {
                            //if (item.referencedSOPInstanceUID.length == 0) {
                            var cell = viewer.emptyDivs.items.get_item(index); //new lt.Controls.Medical.EmptyCell(viewer.emptyDivs, viewer, UUID.generate(), 1, 1);
                            var rect = Utils.createLeadRect(item.Position.leftTop.x, item.Position.leftTop.y, item.Position.rightBottom.x, item.Position.rightBottom.y);
                            cell.position = item.ImageBoxNumber;
                            cell.bounds = rect;
                            //}
                        });
                    }
                }
                else if (config.customLayout) {
                    try {
                        var layout = JSON.parse(config.customLayout);
                        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.random;
                        viewer.layout.beginUpdate();
                        viewer.totalCells = layout.length;
                        Utils.resetSeriesArrangement(viewer, layout);
                        Utils.rearrangeSeries(viewer, layout);
                    }
                    catch (error) {
                        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.grid;
                    }
                    finally {
                        viewer.layout.endUpdate();
                    }
                }
                viewer.set_emptyCellColor(optionsService.get(OptionNames.EmptyCellBackgroundColor));
                viewer.set_backgroundColor(optionsService.get(OptionNames.BackgroundColor));
                viewer.get_gridLayout().set_rows(config.rows);
                viewer.get_gridLayout().set_columns(config.columns);
                viewer.get_gridLayout().set_splitterSize(config.splitterSize);
                viewer.layout.selectedItems.add_collectionChanged(function (sender, e) {
                    if (e.newItems.length == 1 && e.action == lt.NotifyLeadCollectionChangedAction.add) {
                        var cell = e.newItems[0];
                        cell_mousedown(cell, null);
                    }
                });
                viewer.layout.endUpdate();
                $(elem).resize(function () {
                    // the resize goes into 2 phase, one with the height == 1, which is not a real resize, but a middle phase.
                    // so.. we are ingoring that resize because it's expensive to resize.
                    if (($(elem).width() < 2) || ($(elem).height() < 2))
                        return;
                    // if the size is the same, then don't resize.
                    if (($("#" + divid).width() == $(elem).width()) && ($("#" + divid).height() == $(elem).height()))
                        return;
                    $("#" + divid).width($(elem).width());
                    $("#" + divid).height($(elem).height());
                    viewer.onSizeChanged();
                    //console.error("viewer size changed");
                    $('.btn-group>.dropdown-menu').css('max-height', Math.floor($(window).height() * .75) + "px");
                });
                viewer.add_selectionChanged(function (sender, e) {
                    if (config.OnSelectionChanged) {
                        var count = viewer.layout.selectedItems.count + viewer.emptyDivs.selectedItems.count;
                        config.OnSelectionChanged(count);
                    }
                });
                processEmptyDivs();
                scope.viewerapi = scope.viewerapi || {};
                scope.viewerapi.getMedicalViewer = function () {
                    return viewer;
                };
                scope.viewerapi.get_cellCount = function () {
                    return viewer.get_gridLayout().get_rows() * viewer.get_gridLayout().get_columns();
                };
                scope.viewerapi.replaceSeries = replaceSeries;
                scope.viewerapi.InitializeCell = initializeCell;
                var castViewer = viewer;
                castViewer.InitializeCell = initializeCell;
                if (config.OnApiReady) {
                    var viewerApi = new Directives.MedicalViewerApi(viewer, config);
                    config.OnApiReady(viewerApi);
                }
                scope.$watch('series', function (newValue, oldValue) {
                    var oldValue2 = Utils.RemoveDuplicates(newValue, oldValue);
                    var newValue2 = Utils.RemoveDuplicates(oldValue, newValue);
                    if (oldValue2.length == 0 && newValue2.length == 0) {
                        if (newValue.length == 0)
                            return;
                        newValue2 = newValue;
                    }
                    removeSeries(oldValue2);
                    addSeries(newValue2);
                    deleteUnreferencedSeries();
                }, true);
                viewer.layout.get_items().add_collectionChanged(function (sender, e) {
                    if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                        eventService.publish(EventNames.NewCellsAdded, { cells: e.newItems });
                    }
                    if (e.action == lt.NotifyLeadCollectionChangedAction.remove) {
                        var count = e.newItems.length;
                        for (var i = 0; i < count; i++) {
                            var result = $.grep(scope.series, function (item, index) {
                                return item.id == e.newItems[i].divID;
                            });
                            if (result.length > 0) {
                                var index = scope.series.indexOf(result[0]);
                                scope.series.splice(index, 1);
                            }
                        }
                        var tab = tabService.get_allTabs()[tabService.activeTab];
                        tab.DeleteUnusedengine(viewer);
                    }
                });
                //viewer.emptyDivs.items.add_collectionChanged(function (sender: any, e: lt.NotifyLeadCollectionChangedEventArgs) {
                //    if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                //        for (var i = 0; i < e.newItems.length; i++) {
                //            var emptyCell: lt.Controls.Medical.EmptyCell = e.newItems[i];
                //            emptyCell.backgroundColor = optionsService.get(OptionNames.EmptyCellBackgroundColor);
                //        }
                //    }
                //});
                viewer.emptyDivs.selectedItems.add_collectionChanged(function (sender, e) {
                    if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                        seriesManagerService.set_activeCell('');
                    }
                });
                function set_gridMode(config, rows, columns) {
                    if (rows != -1 && columns != -1) {
                        config.rows = rows;
                        config.columns = columns;
                        viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.grid;
                        return true;
                    }
                    return false;
                }
                function set_hangingProtocolViewerSettings(viewer, hp) {
                    if (viewer == null)
                        return;
                    // **********************
                    // Reference Lines
                    // **********************
                    if (hp.NavigationIndicatorSequence != null && hp.NavigationIndicatorSequence.length > 0) {
                        viewer.showReferenceLine = true;
                    }
                    // **********************
                    // Synchronized Scrolling
                    // **********************
                    // 1. Get a list of the MPR Derived (Generated) planes
                    var mprPlaneDisplaySets = new Array();
                    for (var i = 0; i < hp.DisplaySets.length; i++) {
                        if (hp.DisplaySets[i].ReformattingOperationType != null) {
                            mprPlaneDisplaySets.push(hp.DisplaySets[i].DisplaySetNumber);
                        }
                    }
                    // 2. If any synchronizedScrolling item contains Displaysets that are not MPR generated planes, then turn on enableSynchronization
                    if (hp.SynchronizedScrollingSequence != null) {
                        for (var i = 0; i < hp.SynchronizedScrollingSequence.length; i++) {
                            var reformattedPlanes = false;
                            for (var j = 0; j < hp.SynchronizedScrollingSequence[i].DisplaySetScrollingGroup.length; j++) {
                                var currentDisplaySet = hp.SynchronizedScrollingSequence[i].DisplaySetScrollingGroup[j];
                                if (mprPlaneDisplaySets.indexOf(currentDisplaySet) != -1) {
                                    reformattedPlanes = true;
                                    break;
                                }
                            }
                            if (!reformattedPlanes) {
                                viewer.enableSynchronization = true;
                                break;
                            }
                        }
                    }
                }
                function set_randomMode(config, boxes, findBox) {
                    viewer.cellsArrangement = lt.Controls.Medical.CellsArrangement.random;
                    viewer.totalCells = boxes.length;
                    function resetSeriesArrangement(boxes) {
                        var cellLength = Math.min(boxes.length, viewer.layout.items.count);
                        var length = viewer.get_emptyDivs().items.count;
                        for (var index = 0; index < length; index++) {
                            viewer.get_emptyDivs().get_items().get_item(index).set_position(index + cellLength);
                        }
                    }
                    viewer.layout.beginUpdate();
                    $.each(boxes, function (index, item) {
                        var cell = viewer.emptyDivs.items.item(index);
                        var rect = Utils.createLeadRect(item.Position.leftTop.x, item.Position.leftTop.y, item.Position.rightBottom.x, item.Position.rightBottom.y);
                        cell.set_position(index);
                        cell.bounds = rect;
                        cell["displaySetNumber"] = item["displaySetNumber"];
                    });
                    viewer.layout.endUpdate();
                }
                function processEmptyDivs() {
                    viewer.get_emptyDivs();
                }
                function enableDropTarget(elem) {
                    elem.addEventListener("dragover", dragOverFunction, false);
                    elem.addEventListener("dragenter", emptyFunction, false);
                    elem.addEventListener("dragleave", emptyFunction, false);
                    elem.addEventListener("drop", dropFunction, false);
                }
                function disableDropTarget(elem) {
                    elem.removeEventListener("dragover", dragOverFunction, false);
                    elem.removeEventListener("dragenter", emptyFunction, false);
                    elem.removeEventListener("dragleave", emptyFunction, false);
                    elem.removeEventListener("drop", dropFunction, false);
                }
                function AddParaxialLine(panoramicPolygon, cell, count, e) {
                    var panCell = panoramicPolygon.panoramicCell;
                    var index;
                    var sliceFrame;
                    var paraxialSlice;
                    var length = count;
                    var distance = 100;
                    var frames = [];
                    if (!panoramicPolygon.paraxialCells)
                        panoramicPolygon.paraxialCells = [];
                    if (panoramicPolygon.paraxialCells.length == 0) {
                        var paraxialCell = new lt.Controls.Medical.Derivative3D(cell.viewer, cell, lt.Controls.Medical.RenderingType.server, cell.divID + "_paraxial", 1, 1);
                        panoramicPolygon.paraxialCells.add(paraxialCell);
                        paraxialCell.add_disposing(function () {
                            panoramicPolygon.paraxialCells = [];
                            panoramicPolygon.paraxialSlices.clear();
                            panoramicPolygon.invalidate();
                        });
                        var info = null;
                        if (paraxialCell.frames.count > 0) {
                            info = paraxialCell.frames.get_item(0).information;
                            distance = panoramicPolygon.paraxialSlices.get_item(0).length;
                        }
                        for (index = 0; index < length; index++) {
                            var sliceFrame = new lt.Controls.Medical.SliceFrame(paraxialCell, panCell.engine);
                            paraxialCell.frames.add(sliceFrame);
                            frames.add(sliceFrame);
                            if (info != null)
                                sliceFrame.information = info.clone();
                        }
                        var engine = InitializeDerivativeCell(cell, paraxialCell, seriesManagerService, queryArchiveService, optionsService, overlayManagerService);
                        if (engine) {
                            engine.start("", cell.get_seriesInstanceUID(), cell.get_studyInstanceUID());
                        }
                    }
                    else {
                        var paraxialCell = panoramicPolygon.paraxialCells[0];
                        var info = null;
                        if (paraxialCell.frames.count > 0) {
                            info = paraxialCell.frames.get_item(0).information;
                            distance = panoramicPolygon.paraxialSlices.get_item(0).length;
                        }
                        for (index = 0; index < length; index++) {
                            var sliceFrame = new lt.Controls.Medical.SliceFrame(paraxialCell, panCell.engine);
                            paraxialCell.frames.add(sliceFrame);
                            frames.add(sliceFrame);
                            if (info != null)
                                sliceFrame.information = info.clone();
                        }
                    }
                    paraxialCell.beginUpdate();
                    paraxialCell.arrangement = lt.Controls.Medical.FrameArrangement.grid;
                    paraxialCell.gridLayout.rows = 1;
                    paraxialCell.gridLayout.columns = paraxialCell.frames.count;
                    paraxialCell.endUpdate();
                    panoramicPolygon.createSlice(frames, cell.selectedItem, lt.LeadPointD.create(e.item.userData.x, e.item.userData.y), 25, distance);
                    MakeRoomFor(cell.viewer, 1);
                    cell.invalidate();
                }
                function cell_clicked(cell, e) {
                    if (e.mouseButton == lt.Controls.MouseButtons.right) {
                        var drawable = cell.drawables["Panoramic"];
                        var panoramicPolygon = drawable;
                        if (panoramicPolygon != null) {
                            if (panoramicPolygon.hitTest(cell.selectedItem, e.position.x, e.position.y)) {
                                var menu;
                                switch (panoramicPolygon.hitTestResult) {
                                    case lt.Controls.Medical.DrawablePart.handle:
                                        menu = new lt.Controls.Medical.Menu("Panoramic");
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Delete Point", null, panoramicPolygon.hitTestIndex));
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Delete Polygon", null, panoramicPolygon));
                                        break;
                                    case lt.Controls.Medical.DrawablePart.paraxialHandle:
                                    case lt.Controls.Medical.DrawablePart.paraxialLine:
                                        {
                                            menu = new lt.Controls.Medical.Menu("Panoramic");
                                            menu.items.add(new lt.Controls.Medical.MenuItem("Delete Paraxial Slice", null, {
                                                polygon: panoramicPolygon,
                                                paraxialIndex: panoramicPolygon.hitTestIndex
                                            }));
                                        }
                                        break;
                                    case lt.Controls.Medical.DrawablePart.line:
                                        menu = new lt.Controls.Medical.Menu("Panoramic");
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Add Point", null, { index: panoramicPolygon.hitTestIndex, x: e.position.x, y: e.position.y }));
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Add Paraxial Slice", null, { index: panoramicPolygon.hitTestIndex, x: e.position.x, y: e.position.y }));
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Add (5) Paraxial Slices", null, { index: panoramicPolygon.hitTestIndex, x: e.position.x, y: e.position.y }));
                                        menu.items.add(new lt.Controls.Medical.MenuItem("Delete Polygon", null, panoramicPolygon));
                                        break;
                                    default:
                                        return;
                                }
                                menu.show(cell, e.position.x, e.position.y, lt.LeadRectD.empty);
                                menu.add_menuItemSelected(function (sender, e) {
                                    switch (e.item.text) {
                                        case "Delete Point":
                                            // delete the point
                                            var points = panoramicPolygon.get_points();
                                            points.removeAt(e.item.userData);
                                            cell.invalidate(lt.LeadRectD.empty);
                                            // if you delete the last point, then the case statment is gonna go to the delete polygon block and delete the polygon all together
                                            if (points.count > 1)
                                                break;
                                        case "Delete Polygon":
                                            {
                                                // delete the panoramic cell that is associated with the polygon
                                                var polygon = panoramicPolygon;
                                                if (polygon.panoramicCell instanceof lt.Controls.Medical.PanoramicCell) {
                                                    polygon.panoramicCell.dispose();
                                                }
                                                // delete "panoramic" from the dictionary
                                                delete cell.drawables.Panoramic;
                                                cell.invalidate(lt.LeadRectD.empty);
                                            }
                                            break;
                                        case "Add Point":
                                            // add the point
                                            var points = panoramicPolygon.get_points();
                                            var newPoint = lt.Controls.Medical.Tools.physicalToLogical(cell.selectedItem, lt.LeadPointD.create(e.item.userData.x, e.item.userData.y));
                                            points.insert(e.item.userData.index + 1, newPoint);
                                            cell.invalidate(lt.LeadRectD.empty);
                                            break;
                                        case "Delete Paraxial Slice":
                                            {
                                                var index = e.item.userData.paraxialIndex;
                                                var mprCurve = (e.item.userData.polygon);
                                                var frame = mprCurve.paraxialSlices.get_item(index).frame;
                                                mprCurve.paraxialSlices.removeAt(index);
                                                frame.dispose();
                                                var paraxialCell = mprCurve.paraxialCells[0];
                                                paraxialCell.frames.remove(frame);
                                                mprCurve.invalidate();
                                                if (paraxialCell.frames.count == 0) {
                                                    paraxialCell.dispose();
                                                    mprCurve.paraxialCells = [];
                                                }
                                                else {
                                                    paraxialCell.onSizeChanged();
                                                    paraxialCell.invalidate(lt.LeadRectD.empty);
                                                }
                                            }
                                            break;
                                        case "Add Paraxial Slice":
                                            AddParaxialLine(panoramicPolygon, cell, 1, e);
                                            break;
                                        case "Add (5) Paraxial Slices":
                                            AddParaxialLine(panoramicPolygon, cell, 5, e);
                                            break;
                                    }
                                });
                                return;
                            }
                        }
                        showSelectSeriesContextMenu(cell, e.position.x, e.position.y);
                    }
                }
                function showSelectSeriesContextMenu(sender, x, y) {
                    var menu = new lt.Controls.Medical.Menu("Select Series");
                    var cell = sender;
                    var index = 0;
                    var length = viewer.layout.get_items().count;
                    for (index = 0; index < length; index++) {
                        var item = viewer.layout.get_items().get_item(index);
                        menu.items.add(new lt.Controls.Medical.MenuItem(item.name, null, item));
                    }
                    var div = document.getElementById(cell.viewer.divId);
                    menu.show(cell, x, y, lt.LeadRectD.create(0, 0, div.clientWidth, div.clientHeight));
                    menu.add_menuItemSelected(function (sender, e) {
                        viewer.layout.highlightedItems.clear();
                        var selectedCell = e.item.userData;
                        viewer.layout.beginUpdate();
                        viewer.emptyDivs.beginUpdate();
                        var exploded = viewer.exploded;
                        if (exploded)
                            viewer.explode(cell, false);
                        if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
                            var selectedCellRowPosition = selectedCell.rowPosition;
                            var selectedCellColumnsPosition = selectedCell.columnsPosition;
                            selectedCell.rowPosition = cell.rowPosition;
                            selectedCell.columnsPosition = cell.columnsPosition;
                            cell.rowPosition = selectedCellRowPosition;
                            cell.columnsPosition = selectedCellColumnsPosition;
                        }
                        else {
                            var selectedCellPosition = selectedCell.position;
                            var selectedBounds = selectedCell.bounds;
                            selectedCell.bounds = cell.bounds;
                            cell.bounds = selectedBounds;
                            selectedCell.position = cell.position;
                            cell.position = selectedCellPosition;
                        }
                        if (exploded)
                            viewer.explode(selectedCell, true);
                        viewer.layout.endUpdate();
                        viewer.emptyDivs.endUpdate();
                        cell.selected = false;
                        selectedCell.selected = true;
                        viewer.layoutCells();
                    });
                    menu.add_menuItemHover(function (sender, e) {
                        viewer.layout.highlightedItems.clear();
                        viewer.layout.highlightedItems.add(e.item.userData);
                    });
                    menu.add_menuItemLeave(function (sender, e) {
                        viewer.layout.highlightedItems.clear();
                    });
                }
                function emptyDivsCollectionChanged(e, args) {
                    var index = 0;
                    var length = args.newItems.length;
                    var div = null;
                    if (args.get_action() === lt.NotifyLeadCollectionChangedAction.add) {
                        for (; index < length; index++) {
                            var emptyCell = args.newItems[index];
                            div = emptyCell.div;
                            enableDropTarget(div);
                            $(div).click(function (event) {
                                if (cinePlayerService.isPlaying)
                                    cinePlayerService.stop();
                            });
                            div.addEventListener('mousedown', function (ev) {
                                if (ev.button == 2)
                                    showSelectSeriesContextMenu(emptyCell, ev.offsetX, ev.offsetY);
                            }.bind(this));
                        }
                    }
                    else if (args.get_action() === lt.NotifyLeadCollectionChangedAction.remove) {
                        for (; index < length; index++) {
                            div = args.newItems[index].get_div();
                            disableDropTarget(div);
                        }
                    }
                }
                function dragOverFunction(e) {
                    if (e.preventDefault)
                        e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    return false;
                }
                function dropFunction(e) {
                    var series = e.dataTransfer.getData('Text');
                    if (series.indexOf('overflow') != -1) {
                        return false;
                    }
                    else {
                        if (e.stopPropagation)
                            e.stopPropagation();
                        if (e.preventDefault)
                            e.preventDefault();
                        if (null != series) {
                            var selectedIndex = -1;
                            var div = this;
                            var length = viewer.layout.get_items().get_count();
                            var selectedSeries = null;
                            var cellDiv = null;
                            var userData = null;
                            var items = viewer.layout.get_items();
                            var item;
                            var emptyItems = viewer.get_emptyDivs().get_items();
                            var position;
                            var rowPosition;
                            var colPosition;
                            var bounds;
                            var oldSeriesInstanceUID = null;
                            for (var index = 0; index < length; index++) {
                                var item = items.get_item(index);
                                var divId = item.get_divID();
                                cellDiv = document.getElementById(divId);
                                if (cellDiv == this) {
                                    position = item.get_position();
                                    rowPosition = item.get_rowPosition();
                                    colPosition = item.get_columnsPosition();
                                    bounds = item.get_bounds();
                                    oldSeriesInstanceUID = $('#' + divId).attr('seriesInstanceUID');
                                    break;
                                }
                            }
                            if (position == undefined) {
                                length = emptyItems.get_count();
                                items = emptyItems;
                                for (index = 0; index < length; index++) {
                                    item = emptyItems.get_item(index);
                                    if (item.div.id == e.target.id) {
                                        position = item.get_position();
                                        rowPosition = item.get_rowPosition();
                                        colPosition = item.get_columnsPosition();
                                        bounds = item.get_bounds();
                                        break;
                                    }
                                }
                            }
                            scope.seriesDropped({
                                viewer: viewer,
                                oldSeriesInstanceUID: oldSeriesInstanceUID,
                                seriesInstanceUID: series,
                                position: position,
                                rowPosition: rowPosition,
                                colPosition: colPosition,
                                bounds: bounds
                            });
                        }
                    }
                    return false;
                }
                function emptyFunction(e) { }
                function removeSeries(newValue) {
                    var items = viewer.layout.get_items();
                    var count = items.count;
                    var itemsToDelete = new Array();
                    for (var i = 0; i < count; i++) {
                        var seriesInstanceUID = items.item(i).get_seriesInstanceUID();
                        var result = $.grep(newValue, function (e, index) { return e.seriesInstanceUID == seriesInstanceUID; });
                        if (result.length != 0) {
                            itemsToDelete.push(seriesInstanceUID);
                        }
                        else {
                            // alert('you should not be in here');
                        }
                    }
                    $.each(itemsToDelete, function (index, instanceUID) {
                        deleteSeriesCell(instanceUID);
                    });
                }
                function deleteUnreferencedSeries() {
                    seriesManagerService.remove_UnusedSeries();
                }
                function addSeries(newValue) {
                    var count = newValue.length;
                    if (viewer.exploded) {
                        viewer.explode(viewer.explodedCell, false);
                    }
                    viewer.layout.beginUpdate();
                    for (var i = 0; i < count; i++) {
                        var series = newValue[i];
                        var cell = seriesManagerService.get_seriesCellById(series.id);
                        if (!series.forCompare && !cell) {
                            addSeriesCell(series);
                        }
                        else if (series.forCompare) {
                            addSeriesCell(series);
                        }
                    }
                    viewer.layout.endUpdate();
                }
                function deleteSeriesCell(seriesInstanceUID, sopInstanceUID) {
                    var length = viewer.layout.get_items().get_count();
                    viewer.layout.beginUpdate();
                    for (var index = 0; index < length; index++) {
                        var cell = viewer.layout.get_items().get_item(index);
                        if (cell.get_seriesInstanceUID() == seriesInstanceUID) {
                            var deleteCell = false;
                            if (angular.isDefined(sopInstanceUID)) {
                                var frame;
                                var items = cell.get_selectedItems();
                                var i = -1;
                                if (items.get_count() > 0)
                                    i = cell.get_imageViewer().get_items().indexOf(items.get_item(0));
                                if (i < 0)
                                    i = 0;
                                i = cell.get_currentOffset() + index;
                                frame = cell.get_frames().get_item(index);
                                if (frame.Instance.SOPInstanceUID == sopInstanceUID) {
                                    deleteCell = true;
                                }
                            }
                            else
                                deleteCell = true;
                            var dentalMode = optionsService.isSeriesView();
                            if (dentalMode) {
                                if (deleteCell) {
                                    seriesManagerService.remove_seriesCell(seriesInstanceUID);
                                    break;
                                }
                            }
                        }
                    }
                    viewer.layout.endUpdate();
                }
                function loadResources() {
                    var resources = new lt.Annotations.Engine.AnnResources();
                    var host = document.location.href;
                    var imagesResources = resources.get_images();
                    imagesResources[0] = new lt.Annotations.Engine.AnnPicture("images/objects/Point.png");
                    return resources;
                }
                function set_resources(automationManager) {
                    var resources = loadResources();
                    automationManager.set_resources(resources);
                }
                function FindAnotherLineObjectToAttach(cell, cobbAngles, lineObject) {
                    if (cell == null)
                        return null;
                    if (lineObject == null)
                        return null;
                    var container = cell.selectedItem.attachedFrame.container;
                    if (container == null)
                        return null;
                    var count = 0;
                    if (cobbAngles != null) {
                        count = cobbAngles.length;
                    }
                    var lastObject = container.children.count - 1;
                    var list = new Array((count * 2) + 1);
                    var index;
                    var counter = 0;
                    for (index = 0; index < count; index++) {
                        list[counter++] = cobbAngles[index].line1;
                        list[counter++] = cobbAngles[index].line2;
                    }
                    var annObject;
                    for (index = lastObject; index >= 0; index--) {
                        annObject = container.children.get_item(index);
                        if (annObject instanceof lt.Annotations.Engine.AnnPolylineObject) {
                            if (annObject == lineObject) // If it is the same object we just drew, ignore it.
                                continue;
                            if (list.indexOf(annObject) == -1) // If not already part of a cobb angle, then we found a match
                                return annObject;
                        }
                    }
                    return null;
                }
                function initializeCell(cell, series, position, rowPosition, columnPosition) {
                    var id = cell.get_divID();
                    cell.set_unselectedBorderColor(optionsService.get(OptionNames.UnSelectedBorderColor));
                    cell.set_selectedSubCellBorderColor(optionsService.get(OptionNames.SelectedSubCellBorderColor));
                    cell.set_selectedBorderColor(optionsService.get(OptionNames.SelectedBorderColor));
                    cell.set_highlightedSubCellBorderColor(optionsService.get(OptionNames.SelectedBorderColor));
                    cell.set_showFrameBorder(optionsService.get(OptionNames.ShowFrameBorder));
                    cell.set_seriesInstanceUID(series.seriesInstanceUID);
                    cell.add_mouseDown(cell_mousedown);
                    cell.add_cellClicked(cell_clicked);
                    cell.add_currentOffsetChanged(stack_changed);
                    cell.set_linked(series.link);
                    if (cell.tickBoxes.length > 0) {
                        cell.tickBoxes[0].add_tickBoxClicked(tickBox_clicked);
                    }
                    cell.selectedItems.add_collectionChanged(function (sender, e) {
                        if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                            if (e.newItems.length > 0) {
                                var subCell = e.newItems[0];
                                if (angular.isDefined(subCell)) {
                                    var frame = subCell.get_attachedFrame();
                                    eventService.publish(EventNames.NewSubCellSelected, { subCell: subCell, frame: frame });
                                }
                            }
                        }
                    });
                    cell.automation.add_draw(function (sender, e) {
                        if (cell.selectedItem != null) {
                            switch (CommandManager.LastCommand.Action) {
                                case MedicalViewerAction.ShutterRect:
                                case MedicalViewerAction.ShutterEllipse:
                                case MedicalViewerAction.ShutterFreeHand:
                                case MedicalViewerAction.ShutterPolygon:
                                    if (e.object.id == lt.Annotations.Engine.AnnObject.selectObjectId)
                                        return;
                                    var frame = cell.selectedItem.attachedFrame;
                                    if (e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.end) {
                                        Utils.clearAllShutter(frame, null);
                                        frame.get_shutter().get_objects().add(e.object);
                                        frame.get_shutter().fillStyle = "rgba(0, 0, 0, 1)";
                                    }
                                    break;
                            }
                        }
                        // TM: CobbAngle: BEGIN
                        if (cell.CobbAngleStarted) {
                            if (e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.end) {
                                if (e.object instanceof lt.Annotations.Engine.AnnPolylineObject) {
                                    var container = cell.selectedItem.attachedFrame.container;
                                    // This is the object that was just drawn on the image.  Should be a line (AnnPolylineObject)
                                    var annObject = e.object;
                                    if (annObject instanceof lt.Annotations.Engine.AnnPolylineObject) {
                                        // Cast to line object
                                        var lineObject = annObject;
                                        // Obtain corresponding Frame containing collection of CobbAngles
                                        var myframe = cell.selectedItem.attachedFrame;
                                        // Determine if this is the first line or second line.  Returns NULL if first line.
                                        var secondLine = FindAnotherLineObjectToAttach(cell, myframe.CobbAngles, annObject);
                                        if (secondLine != null) {
                                            // Create CobbAngle collection if none exist
                                            if (myframe.CobbAngles == null) {
                                                myframe.CobbAngles = new Array(1);
                                                // Add CobbAngle to our collection
                                                myframe.CobbAngles[0] = new lt.Controls.Medical.CobbAngle(cell.automation, annObject, secondLine);
                                            }
                                            else {
                                                // Add CobbAngle to our collection
                                                myframe.CobbAngles.push(new lt.Controls.Medical.CobbAngle(cell.automation, annObject, secondLine));
                                            }
                                            // Repaint the cell
                                            cell.invalidate(lt.LeadRectD.empty);
                                        }
                                    }
                                }
                            }
                        }
                        // TM: CobbAngle: END
                    });
                    // TM: CobbAngle: BEGIN
                    cell.automation.add_edit(function () {
                        cell.invalidate(lt.LeadRectD.empty);
                    });
                    // TM: CobbAngle: END
                    // TM: CobbAngle: BEGIN
                    cell.add_postRender(function (sender, e) {
                        // Get a reference to the SubCell
                        var subCell = sender;
                        // Get the bounds for where the subcell will be rendered within the cell
                        var rect = subCell.imageViewer.getItemViewBounds(subCell, lt.Controls.ImageViewerItemPart.view, false);
                        // Get the Frame for the SubCell
                        var frame = subCell.attachedFrame;
                        if (frame != null) {
                            if (frame.CobbAngles != null) {
                                for (var i = 0; i < frame.CobbAngles.length; i++) {
                                    e.context.save();
                                    // Move context position to the subcell bounds
                                    e.context.translate(rect.left, rect.top);
                                    // Draw the CobbAngle to the context
                                    frame.CobbAngles[i].draw(e.context);
                                    // Move the position back to origin.
                                    e.context.restore();
                                }
                            }
                        }
                    });
                    // TM: CobbAngle: END
                    enableDropTarget($('#' + id)[0]);
                    $('#' + id)[0].addEventListener('dragstart', function (ev) {
                        ev.dataTransfer.effectAllowed = 'copy';
                        ev.dataTransfer.setData('Text', 'overflow:' + (ev.target).id);
                    }.bind(this));
                    setupDraggable(cell);
                    if (position) {
                        cell.set_position(position);
                    }
                    else if (series.dislaySetNumber) {
                        cell.set_position(series.dislaySetNumber);
                    }
                    if (rowPosition) {
                        cell.set_rowPosition(rowPosition);
                    }
                    if (columnPosition) {
                        cell.set_columnsPosition(columnPosition);
                    }
                    viewer.layout.get_items().add(cell);
                    intializeActions(cell);
                    seriesManagerService.add_seriesCell(cell);
                    seriesManagerService.set_activeCell(cell.divID);
                    $("#" + id).attr('seriesInstanceUID', cell.get_seriesInstanceUID());
                    $("#" + id).attr('seriesID', series.id);
                    set_resources(cell.get_automationManager());
                }
                function setupDraggable(cell) {
                    var dragMode = new lt.Controls.ImageViewerDragInteractiveMode;
                    cell.imageViewer.interactiveModes.beginUpdate();
                    cell.imageViewer.interactiveModes.add(dragMode);
                    cell.imageViewer.interactiveModes.endUpdate();
                }
                function getMPRType(value) {
                    switch (value) {
                        case 0:
                            return lt.Controls.Medical.CellMPRType.axial;
                        case 1:
                            return lt.Controls.Medical.CellMPRType.sagittal;
                        case 2:
                            return lt.Controls.Medical.CellMPRType.coronal;
                    }
                }
                function getCellByDisplaySetNumber(viewer, parentDisplaySetNumber) {
                    var count = viewer.layout.items.count;
                    for (var i = 0; i < count; i++) {
                        var cell = viewer.layout.items.item(i);
                        var displaySetNumber = cell['displaySetNumber'];
                        if (parentDisplaySetNumber == displaySetNumber)
                            return cell;
                    }
                    return null;
                }
                function addSeriesCell(series, position, rowPosition, columnPosition) {
                    var isMprCell = false;
                    var cell = null;
                    if (series.view != null) {
                        if (series.view.ReformattingOperationView != null) {
                            isMprCell = true;
                            var parentCell = getCellByDisplaySetNumber(viewer, series.view.ParentDisplaySetNumber);
                            cell = createMPRCell(objectRetrieveService, null, seriesManagerService, overlayManagerService, optionsService, viewer, parentCell, getMPRType(series.view.ReformattingOperationView), eventService, false);
                        }
                    }
                    // when we generate the series using the structured display, we check if the user hasn't click another structured display while this one is loading.
                    if (series.structuredDisplayID != undefined) {
                        if (templateService.currentStudyLayoutID != series.structuredDisplayID)
                            return;
                    }
                    if (cell == null) {
                        if (series.type == "stl") {
                            var medicalViewer = viewer;
                            cell = new lt.Controls.Medical.STLCell(viewer, "file.stl", series.id);
                            cell.loadFromURL(objectRetrieveService.GetSTLData(series.seriesInstanceUID));
                            medicalViewer.layout.items.add(cell);
                            medicalViewer.onSizeChanged();
                            cell.seriesInstanceUID = series.seriesInstanceUID;
                            cell.studyInstanceUID = "STL";
                            var seriesInstanceUID = cell.get_seriesInstanceUID();
                            var seriesInfo = seriesManagerService.get_seriesInfo(cell.get_seriesInstanceUID());
                            var newSeriesInfo = jQuery.extend(true, {}, seriesInfo);
                            newSeriesInfo.InstanceUID = seriesInstanceUID;
                            seriesManagerService.add_seriesCell(cell);
                            seriesManagerService.set_activeCell(cell.divID);
                        }
                        else {
                            cell = new lt.Controls.Medical.Cell(viewer, series.id, series.rows, series.columns);
                            cell.beginUpdate();
                            // item for the subCell template.
                            var subCell = cell.imageViewer.items.get_item(0);
                            subCell.templateFrame = series.templateItem;
                            // if the series is part of the template, then apply the template properties on the series once the frame gets attached.
                            if (series.templateItem) {
                                subCell.add_frameAttached(function (sender, e) {
                                    if (e.frame) {
                                        if (e.subCell.templateFrame) {
                                            var templateFrame = e.subCell.templateFrame;
                                            Utils.rotateFrame(e.frame, templateFrame);
                                            if (templateFrame.Flip && !e.frame.flipped)
                                                e.frame.flipped = templateFrame.Flip;
                                            if (templateFrame.Reverse && !e.frame.reversed)
                                                e.frame.reversed = templateFrame.Reverse;
                                            if (e.frame.mrtiInfo) {
                                                if (templateFrame.Invert && !e.frame.inverted)
                                                    e.frame.inverted = templateFrame.Invert;
                                            }
                                            Utils.subCell_setPresentationMode(e.subCell);
                                        }
                                    }
                                });
                            }
                            var SDInstances = viewer.SDInstances;
                            // make sure that the series exist in the SDInstance list or just consider it true.
                            // also, if SDInstances is not defined yet, that means there is no structure display clicked on yet, so make it visible.
                            cell.visibility = SDInstances ? (SDInstances[series.seriesInstanceUID] ? SDInstances[series.seriesInstanceUID] : true) : true;
                            var hideOverlays = optionsService.get(OptionNames.HideOverlays);
                            cell.set_overlayTextVisible(!hideOverlays);
                            var isMedicore = false;
                            if (optionsService.has(OptionNames.UseMedicoreLogo)) {
                                isMedicore = optionsService.get(OptionNames.UseMedicoreLogo);
                            }
                            //if (isMedicore) {
                            //    HideTab_And_ShiftToolbarButtons();
                            //}
                            cell.forCompare = series.forCompare;
                            cell.SortOrderAcsending = true;
                            cell.CurrentSelectedSortOrder = "Axis";
                            if (cell.tickBoxes.length > 0) {
                                if (series.forCompare) {
                                    cell.tickBoxes[0].checked = true;
                                }
                                else {
                                    var dentalMode = optionsService.isSeriesView();
                                    if (dentalMode) {
                                        cell.tickBoxes[0].visible = false;
                                    }
                                }
                            }
                            initializeCell(cell, series, position, rowPosition, columnPosition);
                            //if (templateService.currentStudyLayout && templateService.currentStudyLayout.Boxes) {
                            //    if (templateService.currentStudyLayout.Boxes.length == viewer.layout.get_items().get_count()) {
                            //        eventService.publish(EventNames.EnableSeriesList, { enable: true });
                            //    }
                            //}
                            cell['displaySetNumber'] = series.dislaySetNumber;
                            enableDropTarget($('#' + series.id)[0]);
                            $("#" + series.id).attr('seriesInstanceUID', cell.get_seriesInstanceUID());
                            dicomLoaderService.loadSeries(cell, series.sopInstanceUIDS, series.template, series.modality, false, series.mrtiCell, series.loadSeriesLayout);
                            if (series.forCompare) {
                                cell.runCommand(MedicalViewerAction.Stack);
                            }
                            var firstFrameReady = function (sender, e) {
                                eventService.publish(EventNames.SeriesLoading, null);
                                eventService.publish(EventNames.EnableSeriesList, { enable: true });
                                if (cell) {
                                    var loadingDiv = cell.div.getElementsByClassName('loader' + cell.div.id)[0];
                                    if (loadingDiv) {
                                        cell.div.removeChild(loadingDiv);
                                        loadingDiv.id = '';
                                    }
                                    cell.endUpdate();
                                    if (cell.viewer.layout.selectedItem == null)
                                        cell.viewer.layout.selectedItem = cell;
                                    CommandManager.RunCommand(cell, CommandManager.LastCommand.Action, CommandManager.LastCommand.ButtonID);
                                }
                            };
                            cell.add_firstFrameReady(firstFrameReady);
                            cell.add_disposing(function (sender, e) {
                                cell.remove_firstFrameReady(firstFrameReady);
                            });
                            cell.endUpdate();
                            var loadingDiv = document.createElement("div");
                            loadingDiv.id = 'loader';
                            loadingDiv.className = 'loader' + cell.div.id;
                            cell.div.appendChild(loadingDiv);
                        }
                    }
                    setCellPosition(cell, series.dislaySetNumber);
                    cell.beginUpdate();
                    return cell;
                }
                function setCellPosition(cell, displaySetNumber) {
                    if (angular.isDefined(config.hangingProtocol) && config.hangingProtocol != null) {
                        var displaySet = Utils.findFirst(config.hangingProtocol.DisplaySets, function (set) {
                            return set.DisplaySetNumber == displaySetNumber;
                        });
                        viewer.HangingProtocolEnabled = (displaySet != null);
                        if (displaySet) {
                            var box = displaySet.Boxes[0];
                            if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.random) {
                                var emptyCell = Utils.findFirst(viewer.emptyDivs.items.toArray(), function (cell) {
                                    return cell["displaySetNumber"] == box["displaySetNumber"];
                                });
                                if (emptyCell) {
                                    var bounds = emptyCell.bounds;
                                    viewer.emptyDivs.items.remove(emptyCell);
                                    cell.bounds = bounds;
                                }
                            }
                            else
                                setBoxPosition(box, cell);
                            if (box.ImageBoxLayoutType == Models.ImageBoxLayoutType.Tiled) {
                                cell.beginUpdate();
                                cell.gridLayout.rows = box.ImageBoxTileVerticalDimension;
                                cell.gridLayout.columns = box.ImageBoxTileHorizontalDimension;
                                if (cell.arrangement != 0)
                                    cell.arrangement = 0;
                                cell.endUpdate();
                            }
                            var scrollType = HangingProtocolHelper.ConvertToScrollType(displaySet);
                            cell.set_scrollType(scrollType);
                            HangingProtocolHelper.ConvertToCellCinePlayer(cell, displaySet);
                            cinePlayerService.fps = cell.cinePlayer.FPS;
                            cinePlayerService.directionFromPlayingDirection = cell.cinePlayer.direction;
                            cinePlayerService.loop = cell.cinePlayer.loop;
                            cell.frames.add_collectionChanged(function (sender, e) {
                                if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                                    var windowLevelItem = FindPresetWindowLevelValue(displaySet.VoiType);
                                    for (var i = 0; i < e.newItems.length; i++) {
                                        var frame = e.newItems[i];
                                        frame.horizontalAlignment = HangingProtocolHelper.ConvertToHorizontalAlignmentType(displaySet.DisplaySetHorizontalJustification);
                                        frame.verticalAlignment = HangingProtocolHelper.ConvertToVerticalAlignmentType(displaySet.DisplaySetVerticalJustification);
                                        frame.targetOrientation = displaySet.DisplaySetPatientOrientation;
                                        // Set 
                                        // var item = { VoiType: Models.VoiType.Lung, Text: camelize('LUNG'), Info: { W: 1500, C: -600 } };
                                        if (windowLevelItem != null) {
                                            frame.setWindowLevel(windowLevelItem['Info']['W'], windowLevelItem['Info']['C']);
                                        }
                                        if (displaySet.ShowGrayscaleInverted != null) {
                                            frame.inverted = displaySet.ShowGrayscaleInverted;
                                        }
                                        if (displaySet.ShowImageTrueSizeFlag != null) {
                                            if (displaySet.ShowImageTrueSizeFlag) {
                                                frame.zoom(lt.Controls.Medical.MedicalViewerSizeMode.trueSize, 1);
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                    else if (angular.isDefined(config.studyLayout) && config.studyLayout != null && angular.isDefined(config.studyLayout["Series"])) {
                        var series = $.grep(config.studyLayout.Series, function (item) {
                            if (cell.hasOwnProperty("displaySetNumber")) {
                                return item.ImageBoxNumber == cell["displaySetNumber"];
                            }
                            else {
                                return item.SeriesInstanceUID == cell.seriesInstanceUID;
                            }
                        });
                        if (series.length == 0) {
                            for (var i = 0; i < config.studyLayout.OtherStudies.length; i++) {
                                var study = config.studyLayout.OtherStudies[i];
                                var series = $.grep(study.Series, function (item) {
                                    return item.SeriesInstanceUID == cell.seriesInstanceUID;
                                });
                                if (series.length > 0)
                                    break;
                            }
                        }
                        if (series.length > 0) {
                            var boxes = $.grep(config.studyLayout.Boxes, function (item) {
                                return item.ImageBoxNumber == series[0].ImageBoxNumber;
                            });
                            if (boxes.length > 0) {
                                var box = boxes[0];
                                setBoxPosition(box, cell);
                                if (box.ImageBoxLayoutType == Models.ImageBoxLayoutType.Tiled) {
                                    cell.beginUpdate();
                                    cell.gridLayout.rows = box.ImageBoxTileVerticalDimension;
                                    cell.gridLayout.columns = box.ImageBoxTileHorizontalDimension;
                                    if (cell.arrangement != 0)
                                        cell.arrangement = 0;
                                    cell.endUpdate();
                                }
                                cell.frames.add_collectionChanged(function (sender, e) {
                                    if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                                        for (var i = 0; i < e.newItems.length; i++) {
                                            var frame = e.newItems[i];
                                            frame.horizontalAlignment = HangingProtocolHelper.ConvertToHorizontalAlignmentType(box.HorizontalJustification);
                                            frame.verticalAlignment = HangingProtocolHelper.ConvertToVerticalAlignmentType(box.VerticalJustification);
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                function setBoxPosition(box, cell) {
                    if (box.ColumnPosition != -1 && box.RowPosition != -1) {
                        cell.rowPosition = box.RowPosition;
                        cell.columnsPosition = box.ColumnPosition;
                        cell.numberOfRows = box.NumberOfRows;
                        cell.numberOfColumns = box.NumberOfColumns;
                        if (box.FirstFrame != null) {
                            cell.frames.add_collectionChanged(cellFrame_added);
                            function cellFrame_added(sender, e) {
                                if (e.action == lt.NotifyLeadCollectionChangedAction.add) {
                                    var index = box.FirstFrame.FrameNumber - 1;
                                    for (var i = 0; i < e.newItems.length; i++) {
                                        var frame = e.newItems[i];
                                        if (cell.frames.indexOf(frame) == index) {
                                            cell.frames.remove_collectionChanged(cellFrame_added);
                                            cell.currentOffset = index;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        var rect = Utils.createLeadRect(box.Position.leftTop.x, box.Position.leftTop.y, box.Position.rightBottom.x, box.Position.rightBottom.y);
                        cell.bounds = rect;
                    }
                }
                function getCellWithPosition(rowPosition, colPosition, position) {
                    var index = 0;
                    var length = viewer.layout.items.count;
                    var cell;
                    var grid = viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid;
                    for (index = 0; index < length; index++) {
                        cell = viewer.layout.items.get_item(index);
                        if (grid) {
                            if (rowPosition != -1 && colPosition != -1) {
                                if (cell.rowPosition == rowPosition &&
                                    cell.columnsPosition == colPosition)
                                    return cell;
                            }
                        }
                        else {
                            if (position != -1) {
                                if (cell.position == position)
                                    return cell;
                            }
                        }
                    }
                    return null;
                }
                function disposeAutomation(automation) {
                    if (automation == null)
                        return;
                    automation.get_container().get_children().clear();
                    automation.detach();
                }
                function replaceSeries(oldSeriesInstanceUID, sopInstanceUID, newSeries, position, rowPosition, colPosition, bounds) {
                    var cell;
                    var result = $.grep(scope.series, function (e, index) {
                        return e.seriesInstanceUID == oldSeriesInstanceUID;
                    });
                    if (result.length != 0) {
                        var oldSeries;
                        var index;
                        if (result.length == 1) {
                            var oldSeries = result[0];
                        }
                        else {
                            for (var i = 0; i < result.length; i++) {
                                oldSeries = result[i];
                                if (!oldSeries)
                                    continue;
                                if (!oldSeries.sopInstanceUIDS)
                                    continue;
                                if (oldSeries.sopInstanceUIDS.indexOf(sopInstanceUID) != -1) {
                                    break;
                                }
                            }
                        }
                        index = scope.series.indexOf(oldSeries);
                        //scope.series[index] = newSeries;
                        scope.series.splice(index, 1);
                        //scope.series.push(newSeries);
                        //deleteSeriesCell(oldSeriesInstanceUID, sopInstanceUID);
                    }
                    else {
                        //scope.series.push(newSeries);
                    }
                    viewer.layout.beginUpdate();
                    var oldCell = getCellWithPosition(rowPosition, colPosition, position);
                    if (oldCell != null) {
                        viewer.layout.get_items().remove(oldCell);
                        disposeAutomation(oldCell.get_automation());
                        seriesManagerService.remove_cell(oldCell);
                        oldCell.dispose();
                    }
                    cell = addSeriesCell(newSeries, position, rowPosition, colPosition);
                    if (position != -1)
                        cell.set_position(position);
                    cell.set_rowPosition(rowPosition);
                    cell.set_columnsPosition(colPosition);
                    cell.set_bounds(bounds);
                    viewer.layout.endUpdate();
                    viewer.layoutCells();
                    scope.series.push(newSeries);
                }
                function cinePlayerActive(viewer) {
                    var index;
                    var length = viewer.layout.get_items().get_count();
                    for (index = 0; index < length; index++) {
                        var currentCell = viewer.layout.get_items().get_item(index);
                        if (currentCell.cinePlayer != null) {
                            if (currentCell.cinePlayer.isPlaying)
                                return true;
                        }
                    }
                    return false;
                }
                function updateAnimation() {
                }
                function tickBox_clicked(sender, e) {
                    var parentCell = sender.parent;
                    var viewer = parentCell.viewer;
                    var index;
                    var length = parentCell.viewer.layout.get_items().get_count();
                    for (index = 0; index < length; index++) {
                        var cell = viewer.layout.get_items().get_item(index);
                        if (cell.tickBoxes.length > 0) {
                            if (cinePlayerActive(viewer)) {
                                if (cell.tickBoxes[0].checked) {
                                    if (!cell.cinePlayer.isPlaying) {
                                        cell.cinePlayer.play();
                                    }
                                }
                                else {
                                    if (cell.cinePlayer.isPlaying) {
                                        cell.cinePlayer.stop();
                                    }
                                }
                            }
                        }
                        for (var commandItem in cell.commands) {
                            var command = cell.commands[commandItem];
                            command.linked.clear();
                            var itemIndex;
                            var itemLength = parentCell.viewer.layout.get_items().get_count();
                            for (itemIndex = 0; itemIndex < itemLength; itemIndex++) {
                                var itemCell = parentCell.viewer.layout.get_items().get_item(itemIndex);
                                if (itemCell.tickBoxes.length > 0) {
                                    if (itemCell.tickBoxes[0].checked)
                                        command.linked.add(itemCell);
                                }
                            }
                        }
                    }
                }
                function cell_mousedown(sender, e) {
                    var seriesInstanceUID = sender.get_seriesInstanceUID();
                    var series = dataService.get_Series(seriesInstanceUID);
                    var click = false;
                    if (!angular.isDefined(e))
                        click = true;
                    if (sender != seriesManagerService.get_activeCell()) {
                        seriesManagerService.set_activeCell(sender.divID);
                        eventService.publish(EventNames.ActiveSeriesChanged, { seriesInstanceUID: seriesInstanceUID, id: sender.divID });
                    }
                    if (click) {
                        scope.cellClicked({ seriesInstanceUID: seriesInstanceUID });
                    }
                    if (sender.getCommandInteractiveMode) {
                        var lineProfile = sender.getCommandInteractiveMode(MedicalViewerAction.LineProfile);
                        lineProfile.refresh(sender);
                    }
                }
                function stack_changed(sender, e) {
                    var index = sender.get_currentOffset();
                    var frame = null;
                    if (index != -1) {
                        frame = sender.get_frames().item(index);
                    }
                    scope.stackChanged({ sender: sender, e: e });
                    eventService.publish(EventNames.StackChanged, { viewer: viewer, cell: sender, frame: frame });
                }
                function MakeRoomFor(viewer, roomFor) {
                    var desiredNumber = viewer.layout.items.count + roomFor;
                    if (viewer.cellsArrangement == lt.Controls.Medical.CellsArrangement.grid) {
                        if (desiredNumber >= viewer.gridLayout.rows * viewer.gridLayout.columns) {
                            var rows = Math.round(Math.sqrt(desiredNumber));
                            var col = Math.ceil(desiredNumber / rows);
                            viewer.layout.beginUpdate();
                            viewer.gridLayout.rows = rows;
                            viewer.gridLayout.columns = col;
                            viewer.layout.endUpdate();
                        }
                    }
                }
                function setupPanoramicAction(cell) {
                    var panoramicAction = new lt.Controls.Medical.PanoramicAction(cell);
                    var seriesInfo = seriesManagerService.get_seriesInfo(cell.get_seriesInstanceUID());
                    var tab = tabService.get_allTabs()[tabService.activeTab];
                    var _cell = cell;
                    cell.setCommand(MedicalViewerAction.PanoramicPolygon, panoramicAction);
                }
                function intializeActions(cell) {
                    var spyGlass = new lt.Controls.Medical.SpyGlassAction();
                    var scaleAction = new lt.Controls.Medical.ScaleAction();
                    var probeTool = new lt.Controls.Medical.ProbeToolAction();
                    var lineProfile = new lt.Controls.Medical.LineProfileAction();
                    cell.lineProfile.add_histogramGenerated(histogramGenerated);
                    spyGlass.add_imageRequested(spyGlassRequested);
                    spyGlass.add_chunkLoaded(chunkLoaded);
                    spyGlass.add_positionChanged(spyGlassPositionChanged);
                    probeTool.add_probeToolUpdated(probeToolUpdated);
                    scaleAction.set_button(lt.Controls.MouseButtons.right);
                    cell.setCommand(MedicalViewerAction.Offset, new lt.Controls.Medical.OffsetAction());
                    cell.setCommand(MedicalViewerAction.ProbeTool, probeTool);
                    probeTool.interactiveObject.backgroundColor = "rgba(0, 0, 0, 0.0)";
                    probeTool.interactiveObject.textColor = "rgba(153, 200, 255, 1)";
                    probeTool.interactiveObject.showBorder = false;
                    cell.setCommand(MedicalViewerAction.ShutterRect, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.rectangleObjectId));
                    cell.setCommand(MedicalViewerAction.ShutterEllipse, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.ellipseObjectId));
                    cell.setCommand(MedicalViewerAction.ShutterFreeHand, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.freehandObjectId));
                    cell.setCommand(MedicalViewerAction.ShutterPolygon, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.polygonObjectId));
                    cell.setCommand(MedicalViewerAction.Cursor3D, new lt.Controls.Medical.Cursor3DAction());
                    cell.setCommand(MedicalViewerAction.DragItem, new lt.Controls.Medical.TransformItemAction(cell));
                    cell.setCommand(MedicalViewerAction.LineProfile, lineProfile);
                    cell.setCommand(MedicalViewerAction.Scale, new lt.Controls.Medical.ScaleAction());
                    cell.setCommand(MedicalViewerAction.Magnify, new lt.Controls.Medical.MagnifyAction());
                    cell.setCommand(MedicalViewerAction.WindowLevel, new lt.Controls.Medical.WindowLevelAction());
                    cell.setCommand(MedicalViewerAction.Stack, new lt.Controls.Medical.StackAction());
                    cell.setCommand(MedicalViewerAction.AnnRectangle, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.rectangleObjectId));
                    cell.setCommand(MedicalViewerAction.AnnEllipse, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.ellipseObjectId));
                    cell.setCommand(MedicalViewerAction.AnnPointer, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.pointerObjectId));
                    cell.setCommand(MedicalViewerAction.AnnCurve, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.curveObjectId));
                    cell.setCommand(MedicalViewerAction.AnnLine, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.lineObjectId));
                    cell.setCommand(MedicalViewerAction.AnnText, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.textObjectId));
                    cell.setCommand(MedicalViewerAction.AnnHighlight, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.hiliteObjectId));
                    cell.setCommand(MedicalViewerAction.AnnRuler, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.rulerObjectId));
                    cell.setCommand(MedicalViewerAction.AnnPolyRuler, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.polyRulerObjectId));
                    cell.setCommand(MedicalViewerAction.AnnProtractor, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.protractorObjectId));
                    cell.setCommand(MedicalViewerAction.AnnSelect, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.selectObjectId));
                    cell.setCommand(MedicalViewerAction.AnnFreeHand, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.freehandObjectId));
                    cell.setCommand(MedicalViewerAction.AnnPoint, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.pointObjectId));
                    cell.setCommand(MedicalViewerAction.AnnPolyline, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.polylineObjectId));
                    cell.setCommand(MedicalViewerAction.AnnPolygon, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.polygonObjectId));
                    cell.setCommand(MedicalViewerAction.AnnNote, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.noteObjectId));
                    cell.setCommand(MedicalViewerAction.AnnTextPointer, new lt.Controls.Medical.AutomationInteractiveAction(lt.Annotations.Engine.AnnObject.textPointerObjectId));
                    cell.setCommand(MedicalViewerAction.SpyGlass, spyGlass);
                    setupPanoramicAction(cell);
                    lineProfileInteractiveMode = cell.getCommandInteractiveMode(MedicalViewerAction.LineProfile);
                    cell.add_disposing(onDisposeCell);
                }
                function onDisposeCell(sender, args) {
                    var cell = sender;
                    var probeToolInteractiveMode = cell.getCommandInteractiveMode(MedicalViewerAction.ProbeTool);
                    if (probeToolInteractiveMode == null)
                        return;
                    probeToolInteractiveMode.remove_probeToolUpdated(probeToolUpdated);
                    probeToolInteractiveMode.dispose();
                }
                function probeToolUpdated(sender, args) {
                    var frame = args.get_target();
                    var modality = DicomHelper.getDicomTagValue(frame.JSON, DicomTag.Modality);
                    if (frame.get_isDataReady() && (modality == 'CT')) {
                        var value = lt.Controls.Medical.ProbeToolInteractiveMode.getHuValue(frame, args.get_position().get_x(), args.get_position().get_y(), -1);
                        args.set_pixelValue("Hu = " + value);
                    }
                    else {
                        var rgbValue = lt.Controls.Medical.ProbeToolInteractiveMode.getPixelValue(frame, args.get_position().get_x(), args.get_position().get_y());
                        if (frame.get_isDataReady())
                            args.set_pixelValue("Density = " + rgbValue[0]);
                        else
                            args.set_pixelValue("RGB = " + rgbValue[0] + ", " + rgbValue[1] + ", " + rgbValue[2]);
                    }
                }
                function applyImageProcessingOnSpyGlassCanvas(spyGlass, canvas, backCanvas) {
                    var _spyGlass = spyGlass;
                    var context = canvas.getContext("2d");
                    if (backCanvas != null)
                        context.drawImage(backCanvas, 0, 0);
                    switch (SpyglassEffect) {
                        case Spyglass.Equalization:
                            {
                                if (stretchIntensityHigh == 0)
                                    return;
                                var context = canvas.getContext("2d");
                                var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                                lt.Controls.Medical.ImageProcessing.levelIntensity(imageData, stretchIntensityLow, stretchIntensityHigh);
                                context.putImageData(imageData, 0, 0);
                            }
                            break;
                        case Spyglass.Invert:
                            {
                                var context = canvas.getContext("2d");
                                try {
                                    var imageCanvas = canvas;
                                    var context1 = imageCanvas.getContext('2d');
                                    var imageData = context1.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                                    var pixels = imageData.data;
                                    var length = pixels.length;
                                    for (var i = 0; i < length;) {
                                        pixels[i] = 255 - pixels[i];
                                        pixels[i + 1] = 255 - pixels[i + 1];
                                        pixels[i + 2] = 255 - pixels[i + 2];
                                        i += 4;
                                    }
                                    context.putImageData(imageData, 0, 0);
                                }
                                finally {
                                    pixels = null;
                                    imageData = null;
                                    context = null;
                                }
                            }
                            break;
                        case Spyglass.CLAHE:
                            {
                                var imageCanvas = canvas;
                                var imageContext = imageCanvas.getContext("2d");
                                var imageData = imageContext.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                                var ip = new lt.ImageProcessing();
                                _spyGlass.set_text("Filter: CLAHE (Loading)");
                                ip.set_jsFilePath(_jsFileCorePath);
                                ip.set_command("CLAHE");
                                ip.get_arguments()["alpha"] = 0.65;
                                ip.get_arguments()["tilesize"] = 6;
                                ip.get_arguments()["tilehistcliplimit"] = 0.08;
                                ip.get_arguments()["binsnumber"] = 128;
                                ip.get_arguments()["flags"] = 0x00001;
                                ip.get_arguments()["useProgress"] = false;
                                ip.set_imageData(imageData);
                                ip.add_completed(function (sender, event) {
                                    var spyCanvasContext = null;
                                    if (!canvas)
                                        return;
                                    if (canvas.width == 1)
                                        return;
                                    spyCanvasContext = canvas.getContext("2d");
                                    spyCanvasContext.putImageData(event.get_imageData(), 0, 0);
                                    sender.abort();
                                    if (_spyGlass.get_isWorking()) {
                                        _spyGlass.refresh();
                                        _spyGlass.set_text("Filter: CLAHE");
                                    }
                                });
                                ip.run();
                            }
                            break;
                        default:
                            _spyGlass.set_text("");
                            break;
                    }
                }
                /*function drawTest(args: lt.Controls.Medical.HistogramGeneratedEventArgs) {
                    var testCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.getElementById('testCanvas');
    
                    var context = testCanvas.getContext("2d");
                    context.drawImage(args.canvas, 0, 0);
    
                    length = args.lineHistogramPoints.length;
                    if (length == 0)
                        return;
    
                    context.beginPath();
                    context.strokeStyle = 'black';
                    context.moveTo(args.lineHistogramPoints[0].x, args.lineHistogramPoints[0].y);
                    var pixel: lt.LeadPointD;
                    var index: number = 1;
                    for (index = 1; index < length; index++) {
                        pixel = args.lineHistogramPoints[index];
                        context.lineTo(pixel.x, pixel.y);
                    }
                    context.stroke();
    
    
                    //context.beginPath();
                    //context.strokeStyle = 'black';
                    //context.moveTo(0, 0);
                    //context.lineTo(500, 500);
                    //context.stroke();
    
                }*/
                function histogramGenerated(sender, args) {
                    currentLineProfileFrame = args.frame;
                    lineProfileHistogram = args.histogram;
                    colorType = args.type;
                    lineProfileSliderPosition = 0;
                    RenderLineProfileHistogram(0, 0, false);
                    HistogramUpdated();
                    //drawTest(args);
                }
                function spyGlassRequested(spyGlass, args) {
                    var outputCanvas = args.outputCanvas;
                    var inputCanvas = args.inputCanvas;
                    outputCanvas.width = inputCanvas.width;
                    outputCanvas.height = inputCanvas.height;
                    switch (SpyglassEffect) {
                        case Spyglass.Equalization:
                            spyGlass.set_text("Filter: Revealer");
                            break;
                        case Spyglass.Invert:
                            spyGlass.set_text("Filter: Invert");
                            break;
                        case Spyglass.CLAHE:
                            break;
                        default:
                            spyGlass.set_text("");
                            break;
                    }
                    applyImageProcessingOnSpyGlassCanvas(spyGlass, outputCanvas, inputCanvas);
                }
                function chunkLoaded(spyGlass, args) {
                    applyImageProcessingOnSpyGlassCanvas(spyGlass, args.chunk.canvas, args.chunk.canvas);
                }
                function spyGlassPositionChanged(sender, args) {
                    if (SpyglassEffect != Spyglass.Equalization)
                        return;
                    var displayRect = args.get_displayRect();
                    var subCell = args.get_subCell();
                    var canvas = args.outputCanvas;
                    var inputCanvas = args.inputCanvas;
                    var cell = sender.SubCellAttached;
                    if (displayRect.get_isEmpty())
                        return;
                    if (displayRect.get_width() == 0)
                        return;
                    if (displayRect.get_height() == 0)
                        return;
                    var imageCanvas = subCell.get_parentCell().get_imageViewer().get_foreCanvas();
                    var imageContext = imageCanvas.getContext("2d");
                    var imageData = imageContext.getImageData(displayRect.get_left(), displayRect.get_top(), displayRect.get_width(), displayRect.get_height());
                    var point = lt.Controls.Medical.ImageProcessing.getHistogramPoint(imageData, 10);
                    stretchIntensityLow = point.x;
                    stretchIntensityHigh = point.y;
                    var context;
                    var frame = subCell.attachedFrame;
                    applyImageProcessingOnSpyGlassCanvas(sender, canvas, inputCanvas);
                    var chunkList = args.chunkList;
                    var index = 0;
                    var chunkData;
                    for (index = 0; index < chunkList.length; index++) {
                        chunkData = chunkList[index];
                        context = chunkData.canvas.getContext("2d");
                        context.drawImage(chunkData.backCanvas, 0, 0);
                        imageData = context.getImageData(0, 0, chunkData.rect.width, chunkData.rect.height);
                        lt.Controls.Medical.ImageProcessing.levelIntensity(imageData, stretchIntensityLow, stretchIntensityHigh);
                        context.putImageData(imageData, 0, 0);
                    }
                }
                function createPanZoomInteractiveMode() {
                    var zoomToInteractiveMode = new lt.Controls.ImageViewerPanZoomInteractiveMode();
                    zoomToInteractiveMode.set_idleCursor("default");
                    zoomToInteractiveMode.set_workingCursor("crosshair");
                    zoomToInteractiveMode.set_enablePan(false);
                    zoomToInteractiveMode.set_enableZoom(true);
                    zoomToInteractiveMode.set_enablePinchZoom(false);
                    //zoomToInteractiveMode.set_workOnImageRectangle(false);
                    //zoomToInteractiveMode.add_workStarted(Zoom_Started);
                    //zoomToInteractiveMode.add_workCompleted(Zoom_Completed);
                    zoomToInteractiveMode.set_zoomKeyModifier(lt.Controls.Keys.none);
                    zoomToInteractiveMode.set_mouseButtons(lt.Controls.MouseButtons.right);
                    return zoomToInteractiveMode;
                }
            }
        };
    }]);
//function fixCurves() {
//    if (point[0] == 0) start = point[1];
//    if (point[0] == 1) end = point[1];
//    var points = filter[curves.name];
//    var foundStart = false;
//    var foundEnd = false;
//    for (var i = 0; i < points.length; i++) {
//        var p = points[i];
//        if (p[0] == 0) {
//            foundStart = true;
//            if (point[0] == 0 && p != point) points.splice(i--, 1);
//        } else if (p[0] == 1) {
//            foundEnd = true;
//            if (point[0] == 1 && p != point) points.splice(i--, 1);
//        }
//    }
//    if (!foundStart) points.push([0, start]);
//    if (!foundEnd) points.push([1, end]);
//};
//var a = {
//0: (2) [0, 0]
//1: (2) [0.275, 0.629921875]
//2: (2) [0.725, 0.504921875]
//3: (2) [1, 1]
//}
//function q(a, d, c) {
//    return Math.max(a, Math.min(d, c))
//}
//function splineInterpolate(a) {
//    a = new z(a);
//    for (var d = [], c = 0; 256 > c; c++)
//        d.push(q(0, Math.floor(256 * a.interpolate(c / 255)), 255));
//    return d
//}
//function z(a) {
//    var d = a.length;
//    this.xa = [];
//    this.ya = [];
//    this.u = [];
//    this.y2 = [];
//    a.sort(function (a, b) {
//        return a[0] - b[0]
//    });
//    for (var c = 0; c < d; c++)
//        this.xa.push(a[c][0]),
//            this.ya.push(a[c][1]);
//    this.u[0] = 0;
//    this.y2[0] = 0;
//    for (c = 1; c < d - 1; ++c) {
//        a = this.xa[c + 1] - this.xa[c - 1];
//        var e = (this.xa[c] - this.xa[c - 1]) / a
//            , g = e * this.y2[c - 1] + 2;
//        this.y2[c] = (e - 1) / g;
//        this.u[c] = (6 * ((this.ya[c + 1] - this.ya[c]) / (this.xa[c + 1] - this.xa[c]) - (this.ya[c] - this.ya[c - 1]) / (this.xa[c] - this.xa[c - 1])) / a - e * this.u[c - 1]) / g
//    }
//    this.y2[d - 1] = 0;
//    for (c = d - 2; 0 <= c; --c)
//        this.y2[c] = this.y2[c] * this.y2[c + 1] + this.u[c]
//}
//z.prototype.interpolate = function (a) {
//    for (var d = 0, c = this.ya.length - 1; 1 < c - d;) {
//        var e = c + d >> 1;
//        this.xa[e] > a ? c = e : d = e
//    }
//    var e = this.xa[c] - this.xa[d]
//        , g = (this.xa[c] - a) / e;
//    a = (a - this.xa[d]) / e;
//    return g * this.ya[d] + a * this.ya[c] + ((g * g * g - g) * this.y2[d] + (a * a * a - a) * this.y2[c]) * e * e / 6
//}
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('shakeThat', ['$animate', function ($animate) {
        return {
            require: '^form',
            scope: {
                submit: '&',
                submitted: '='
            },
            link: function (scope, element, attrs, form) {
                // listen on submit event
                element.on('submit', function () {
                    // tell angular to update scope
                    scope.$apply(function () {
                        // everything ok -> call submit fn from controller
                        if (form.$valid)
                            return scope.submit();
                        // show error messages on submit
                        scope.submitted = true;
                        // shake that form
                        $animate.addClass(element, 'shake', function () {
                            $animate.removeClass(element, 'shake');
                        });
                    });
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
directives.directive('propertygrid', ["eventService", "$rootScope", function (eventService, $rootScope) {
        return {
            restrict: 'A',
            scope: {
                items: "=",
                onPropertyChanged: "&",
                onPropertyClicked: "&"
            },
            link: function (scope, elem, attr) {
                var id = elem.attr('id');
                var propertyGrid = new PropertyGrid(id, 'px');
                function addProperty(property) {
                    propertyGrid.addProperty(property.groupName, property.rowType, property.cssName, property.dropFields, property.isSubGroup, property.value, property.propertyName, property.enabled);
                }
                scope.$watch('items', function (newValue) {
                    propertyGrid.clearGrid();
                    if (newValue) {
                        angular.forEach(newValue, function (value, key) {
                            addProperty(value);
                        });
                    }
                    propertyGrid.renderGrid();
                }, true);
                propertyGrid.PropertyChanged = function (name, value) {
                    scope.onPropertyChanged({ name: name, value: value });
                };
                propertyGrid.PropertyClicked = function (name, value) {
                    scope.onPropertyClicked({ name: name, value: value });
                };
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var Button = /** @class */ (function () {
    function Button() {
        this.type = '';
        this.title = '';
        this.name = '';
        this.action = '';
        this.icon = '';
        this.tooltip = '';
        this.items = new Array();
    }
    return Button;
}());
directives.directive('toolbar', ['toolbarService', function (toolbarService) {
        return {
            restrict: "E",
            scope: {
                buttons: '=',
                name: '=',
            },
            replace: true,
            link: function (scope, element, attrs, form) {
                scope.$watch('buttons', function (newValue) {
                    var parent = $(element).parent();
                    toolbarService.buildToolbar(scope, newValue, parent, attrs.key);
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../lib/angular/angular.d.ts" />
var LayoutOptions = /** @class */ (function () {
    function LayoutOptions() {
    }
    return LayoutOptions;
}());
directives.directive('layout', ["eventService", "$compile", "$timeout", function (eventService, $compile, $timeout) {
        return {
            restrict: 'A',
            scope: {
                layoutConfig: "=",
                hideNorth: "=",
                hideSouth: "=",
                hideEast: "=",
                hideWest: "=",
                api: "="
            },
            link: function (scope, elem, attr) {
                var previousState = {};
                var setState = true;
                scope.$watch('layoutConfig', function (value) {
                    var onOpen = value.onopen;
                    var onClose = value.onclose;
                    var onHide = value.onhide;
                    var onShow = value.onshow;
                    if (!value.onresize)
                        value.onresize = onresize;
                    value.onopen = function (pane, item, state) {
                        if (setState) {
                            previousState[pane] = false;
                        }
                        else
                            setState = true;
                        if (onOpen)
                            onOpen(pane);
                    };
                    value.onclose = function (pane, item, state) {
                        if (setState) {
                            previousState[pane] = true;
                        }
                        else
                            setState = true;
                        if (onClose)
                            onClose();
                    };
                    value.onhide = function (pane, item, state) {
                        if (setState) {
                            previousState[pane] = true;
                        }
                        else
                            setState = true;
                        if (onHide)
                            onHide();
                    };
                    value.onshow = function (pane, item, state) {
                        if (setState) {
                            previousState[pane] = false;
                        }
                        else
                            setState = true;
                        if (onShow)
                            onShow();
                    };
                    $(elem).layout(value);
                    $(window).resize(function () {
                        resizeLayout();
                        $timeout(function () {
                            resizeLayout();
                        }, 250);
                    });
                    scope.api = scope.api || {};
                    scope.api.get_state = function (pane) {
                        switch (pane.toLowerCase()) {
                            case "north":
                                return $(elem).layout().state.north;
                            case "south":
                                return $(elem).layout().state.south;
                            case "east":
                                return $(elem).layout().state.east;
                            case "west":
                                return $(elem).layout().state.west;
                        }
                        return undefined;
                    };
                    scope.api.has_children = function (pane) {
                        var layout = $(elem).layout();
                        switch (pane.toLowerCase()) {
                            case "north":
                                return $(layout.panes.north[0].childNodes).length > 0;
                            case "south":
                                return $(layout.panes.south[0].childNodes).length > 0;
                            case "east":
                                return $(layout.panes.east[0].childNodes).length > 0;
                            case "west":
                                return $(layout.panes.west[0].childNodes).length > 0;
                        }
                        return undefined;
                    };
                    scope.api.switchPanes = function (pane1, pane2, buttonid, height) {
                        var layout = $(elem).layout();
                        var state = layout.state;
                        var openPane = null;
                        var closePane = null;
                        var button = $("#" + buttonid);
                        var span = button.find('span:first-child');
                        var destination;
                        var source;
                        var size;
                        //
                        // get source size and resize destination
                        //
                        if (!state[pane1].isHidden) {
                            openPane = pane2;
                            closePane = pane1;
                            size = height ? state[pane1].layoutHeight : state[pane1].layoutWidth;
                            destination = layout.panes[pane2];
                            source = $(layout.panes[pane1][0].childNodes);
                            span.removeClass("fa fa-angle-right");
                            span.addClass("fa fa-angle-left");
                        }
                        else {
                            openPane = pane1;
                            closePane = pane2;
                            size = height ? state[pane2].layoutHeight : state[pane2].layoutWidth;
                            destination = layout.panes[pane1];
                            source = $(layout.panes[pane2][0].childNodes);
                            span.removeClass("fa fa-angle-left");
                            span.addClass("fa fa-angle-right");
                        }
                        if (openPane != null) {
                            layout.hide(closePane);
                            source.appendTo(destination);
                            layout.sizePane(openPane, size);
                            layout.open(openPane);
                            resizeLayout();
                        }
                    };
                    scope.api.togglePane = function (pane1, pane2) {
                        var layout = $(elem).layout();
                        var state = layout.state;
                        if (!state[pane1].isHidden) {
                            layout.toggle(pane1);
                        }
                        else
                            layout.toggle(pane2);
                    };
                    scope.api.openPane = function (pane) {
                        var layout = $(elem).layout();
                        var state = layout.state;
                        if (state[pane].isHidden || state[pane].isClosed) {
                            layout.open(pane, false, false, true);
                            resizeLayout();
                        }
                    };
                    scope.api.closePane = function (pane) {
                        var layout = $(elem).layout();
                        var state = layout.state;
                        if (!state[pane].isClosed) {
                            layout.close(pane);
                            resizeLayout();
                        }
                    };
                    scope.api.refresh = function () {
                        resizeLayout();
                        $timeout(function () {
                            resizeLayout();
                        }, 200);
                    };
                    resizeLayout();
                    function onresize(name, element, state, options, layoutName) {
                        if (name == "north") {
                            eventService.publish(EventNames.NorthPaneResized, { state: state, options: options, element: element });
                        }
                        else if (name == "south") {
                            eventService.publish(EventNames.SouthPaneResized, { state: state, options: options, element: element });
                        }
                        else if (name == "east") {
                            eventService.publish(EventNames.EastPaneResized, { state: state, options: options, element: element });
                        }
                        else if (name == "west") {
                            eventService.publish(EventNames.WestPaneResized, { state: state, options: options, element: element });
                        }
                        else {
                            eventService.publish(EventNames.CenterPaneResized, { state: state, options: options, element: element });
                        }
                    }
                    function resizeLayout() {
                        var position = $(elem).position();
                        var padding = $(elem).css('padding-top');
                        var innerheight = $(elem).innerHeight();
                        var innerWidth = $(elem).innerWidth();
                        //if(innerheight != (Math.ceil($(window).innerHeight() - (position.top + 1)))) {
                        $(elem).innerHeight($(window).height() - (position.top + 1));
                        //}
                        //if (innerWidth != (Math.ceil($(window).innerWidth() - position.left))) {
                        $(elem).innerWidth($(window).innerWidth() - position.left - 1);
                        //}
                        $(elem).layout().resizeAll();
                    }
                    scope.$watch(function () {
                        return $(elem).is(":visible");
                    }, function (value) {
                        if (value) {
                            $timeout(function () {
                                resizeLayout();
                            }, 700);
                        }
                    });
                    scope.$watch("hideNorth", function (newValue) {
                        if (angular.isDefined(newValue)) {
                            if (newValue)
                                $(elem).layout().close('north');
                            else
                                $(elem).layout().open('north');
                        }
                    });
                    scope.$watch("hideSouth", function (newValue) {
                        if (angular.isDefined(newValue)) {
                            if (newValue)
                                $(elem).layout().close('south');
                            else
                                $(elem).layout().open('south');
                        }
                    });
                    scope.$watch("hideEast", function (newValue) {
                        if (angular.isDefined(newValue)) {
                            if (newValue)
                                $(elem).layout().close('east');
                            else
                                $(elem).layout().open('east');
                        }
                    });
                    scope.$watch("hideWest", function (newValue) {
                        if (angular.isDefined(newValue)) {
                            if (newValue)
                                $(elem).layout().close('west');
                            else
                                $(elem).layout().open('west');
                        }
                    });
                    scope.$watch("eastWest", function (newValue) {
                        if (angular.isDefined(newValue)) {
                            var west = scope.api.has_children('west') ? true : false;
                            var pane = west ? 'west' : 'east';
                            if (newValue) {
                                if (!scope.api.get_state(pane).isClosed) {
                                    setState = false;
                                    $(elem).layout().close(pane);
                                }
                            }
                            else {
                                if (!angular.isDefined(previousState[pane]) || !previousState[pane]) {
                                    if (scope.api.get_state(pane).isClosed) {
                                        setState = false;
                                        $(elem).layout().open(pane);
                                    }
                                }
                            }
                        }
                    });
                });
            }
        };
    }]);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Filters;
(function (Filters) {
    var PluralizeFilter = /** @class */ (function () {
        function PluralizeFilter() {
        }
        PluralizeFilter.Factory = function () {
            return function (ordinal, noun) {
                if (ordinal == 1) {
                    return ordinal + ' ' + noun;
                }
                else {
                    var plural = noun;
                    if (noun.substr(noun.length - 2) == 'us') {
                        plural = plural.substr(0, plural.length - 2) + 'i';
                    }
                    else if (noun.substr(noun.length - 2) == 'ch' || noun.charAt(noun.length - 1) == 'x' || noun.charAt(noun.length - 1) == 's') {
                        plural += 'es';
                    }
                    else if (noun.charAt(noun.length - 1) == 'y' && ['a', 'e', 'i', 'o', 'u'].indexOf(noun.charAt(noun.length - 2)) == -1) {
                        plural = plural.substr(0, plural.length - 1) + 'ies';
                    }
                    else if (noun.substr(noun.length - 2) == 'is') {
                        plural = plural.substr(0, plural.length - 2) + 'es';
                    }
                    else {
                        plural += 's';
                    }
                    return ordinal + ' ' + plural;
                }
            };
        };
        return PluralizeFilter;
    }());
    Filters.PluralizeFilter = PluralizeFilter;
})(Filters || (Filters = {}));
filters.filter('pluralize', Filters.PluralizeFilter.Factory);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var Models;
(function (Models) {
    var Toolbar = /** @class */ (function () {
        function Toolbar() {
            this._items = new Array();
        }
        Object.defineProperty(Toolbar.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                this._items = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Toolbar.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                this._name = value;
            },
            enumerable: false,
            configurable: true
        });
        return Toolbar;
    }());
    Models.Toolbar = Toolbar;
    var ToolbarItem = /** @class */ (function () {
        function ToolbarItem() {
            this._items = new Array();
            this._action = '';
            this._cssIconClass = '';
            this._id = '';
            this._title = '';
            this._tooltip = '';
            this._type = '';
            this._visible = true;
        }
        Object.defineProperty(ToolbarItem.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (value) {
                this._title = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._tooltip = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "caption", {
            get: function () {
                return this._caption;
            },
            set: function (value) {
                this._caption = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (value) {
                this._type = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "action", {
            get: function () {
                return this._action;
            },
            set: function (value) {
                this._action = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "shortcut", {
            get: function () {
                return this._shortcut;
            },
            set: function (value) {
                this._shortcut = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "cssIconClass", {
            get: function () {
                return this._cssIconClass;
            },
            set: function (value) {
                this._cssIconClass = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ToolbarItem.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                this._items = value;
            },
            enumerable: false,
            configurable: true
        });
        return ToolbarItem;
    }());
    Models.ToolbarItem = ToolbarItem;
    var ToolbarButton = /** @class */ (function (_super) {
        __extends(ToolbarButton, _super);
        function ToolbarButton() {
            var _this = _super.call(this) || this;
            _this.type = "button";
            return _this;
        }
        return ToolbarButton;
    }(Models.ToolbarItem));
    Models.ToolbarButton = ToolbarButton;
    var ToolbarGroup = /** @class */ (function (_super) {
        __extends(ToolbarGroup, _super);
        function ToolbarGroup() {
            var _this = _super.call(this) || this;
            _this.type = "button";
            return _this;
        }
        return ToolbarGroup;
    }(Models.ToolbarItem));
    Models.ToolbarGroup = ToolbarGroup;
})(Models || (Models = {}));
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var DicomLoaderService = /** @class */ (function () {
    function DicomLoaderService(config, authenticationService, eventService, objectRetrieveService, queryArchiveService, seriesManagerService, $q, overlayManagerService, optionsService, $timeout, cinePlayerService, objectStoreService, templateService) {
        this._eventService = eventService;
        this._objectRetrieveService = objectRetrieveService;
        this._queryArchiveService = queryArchiveService;
        this._objectStoreService = objectStoreService;
        this._seriesManagerService = seriesManagerService;
        this._qService = $q;
        this._overlayManagerService = overlayManagerService;
        this._optionsService = optionsService;
        this._timeout = $timeout;
        this._cinePlayerService = cinePlayerService;
        this._templateService = templateService;
        this._authenticationService = authenticationService;
        this._retrieveLocalUrl = config.urls.serviceUrl + config.urls.objectRetrieveLocalServiceName;
        this._cellInfo = {};
        this._eventService.subscribe(EventNames.OnLoadLayout, this.onLoadLayout.bind(this));
        this._eventService.subscribe(EventNames.OnPresentationInfoLoaded, this.onPresentationInfoLoaded.bind(this));
        this._eventService.subscribe(EventNames.OnInstancesFound, this.onInstancesFound.bind(this));
        this._eventService.subscribe(EventNames.OnDicomJSONRetrieved, this.onDicomJSONRetrieved.bind(this));
        this._eventService.subscribe(EventNames.PresentationStateLoaded, this.onPresentationStateLoaded.bind(this));
    }
    DicomLoaderService.prototype.loadSeries = function (cell, stackInstanceUIDs, template, modality, generateMRTI, mrtiCell, loadSeriesLayout) {
        var loader = this._seriesManagerService.get_seriesLoaderById(cell);
        if (!loader) {
            loader = new DicomLoader(this._retrieveLocalUrl, this._authenticationService, this._objectRetrieveService, this._eventService, this._queryArchiveService, this._qService, this._seriesManagerService, this._objectStoreService, this._optionsService);
            this._seriesManagerService.set_seriesLoader(cell, loader);
        }
        loader.loadSeries(cell, stackInstanceUIDs, template, false, modality, mrtiCell, loadSeriesLayout);
    };
    DicomLoaderService.prototype.get_newLoader = function () {
        return new DicomLoader(this._retrieveLocalUrl, this._authenticationService, this._objectRetrieveService, this._eventService, this._queryArchiveService, this._qService, this._seriesManagerService, this._objectStoreService, this._optionsService);
    };
    DicomLoaderService.prototype.onLoadLayout = function (event, data) {
        this._seriesManagerService.set_layout(data.args.seriesInstanceUID, data.args.id, data.args.layout, data.args.template);
    };
    DicomLoaderService.prototype.onPresentationInfoLoaded = function (event, data) {
        this._seriesManagerService.set_presentationInfo(data.args.seriesInstanceUID, data.args.id, data.args.presentationInfo);
    };
    DicomLoaderService.prototype.onInstancesFound = function (event, data) {
        this._seriesManagerService.set_instances(data.args.seriesInstanceUID, data.args.id, data.args.instances, data.args.stackInstanceUID);
    };
    DicomLoaderService.prototype.onDicomJSONRetrieved = function (event, data) {
        var cell = this._seriesManagerService.get_seriesCellById(data.args.id);
        if (cell != null) {
            this.LoadImages(data.args.seriesInstanceUID, data.args.id, data.args.metadata, data.args.sopInstanceUID);
        }
    };
    DicomLoaderService.prototype.onPresentationStateLoaded = function (event, data) {
        this._seriesManagerService.set_annotationIDs(data.args.seriesInstanceUID, data.args.id, data.args.annotations);
        this._eventService.publish(EventNames.AnnotationsLoaded, { seriesInstanceUID: data.args.seriesInstanceUID, id: data.args.id });
    };
    DicomLoaderService.prototype.getLateralityValue = function (metadata) {
        var element;
        element = metadata[DicomTag.Laterality];
        if (element && element.Value && element.Value.length > 0) {
            return DicomHelper.GetTagText(element);
        }
        element = metadata[DicomTag.ImageLaterality];
        if (element && element.Value && element.Value.length > 0) {
            return DicomHelper.GetTagText(element);
        }
        element = metadata[DicomTag.FrameLaterality];
        if (element && element.Value && element.Value.length > 0) {
            return DicomHelper.GetTagText(element);
        }
        return "";
    };
    DicomLoaderService.prototype.UpdateCineSettings = function (cell, metadata) {
        var preferredPlaybackSequencing = DicomHelper.getDicomTagValue(metadata, DicomTag.PreferredPlaybackSequencing);
        if (preferredPlaybackSequencing != undefined) {
            cell.cinePlayer.direction = (preferredPlaybackSequencing == 1) ? lt.Controls.Medical.PlayingDirection.sweep : lt.Controls.Medical.PlayingDirection.forward;
        }
        var recommendedDisplayFrameRate = DicomHelper.getDicomTagValue(metadata, DicomTag.RecommendedDisplayFrameRate);
        var cineRate = DicomHelper.getDicomTagValue(metadata, DicomTag.CineRate);
        if (cineRate == undefined)
            cineRate = recommendedDisplayFrameRate;
        if (cineRate != undefined) {
            if (cineRate == 0)
                cell.cinePlayer.FPS = 30;
            else
                cell.cinePlayer.FPS = parseInt(cineRate);
        }
        else {
            var frameDelay = DicomHelper.getDicomTagValue(metadata, DicomTag.FrameDelay);
            var frameTime = DicomHelper.getDicomTagValue(metadata, DicomTag.FrameTime);
            var imageTriggerDelay = DicomHelper.getDicomTagValue(metadata, DicomTag.ImageTriggerDelay);
            var actualFrameDuration = DicomHelper.getDicomTagValue(metadata, DicomTag.ActualFrameDuration);
            if (frameTime == undefined)
                frameTime = imageTriggerDelay;
            if (frameTime == undefined)
                frameTime = frameDelay;
            if (frameTime == undefined)
                frameTime = actualFrameDuration;
            if (frameTime != undefined) {
                frameTime = parseFloat(frameTime);
                cell.cinePlayer.FPS = parseInt((1000 / frameTime).toString());
            }
            else {
                var effectiveDuration = DicomHelper.getDicomTagValue(metadata, DicomTag.EffectiveDuration);
                if (effectiveDuration != undefined) {
                    effectiveDuration = parseFloat(effectiveDuration);
                    cell.cinePlayer.FPS = parseInt(((effectiveDuration * 1000) / cell.frames.count).toString());
                }
            }
        }
        //var startTrim = DicomHelper.getDicomTagValue(metadata, DicomTag.StartTrim);
        //var stopTrim = DicomHelper.getDicomTagValue(metadata, DicomTag.StopTrim);
    };
    DicomLoaderService.prototype.AddTag = function (text, index) {
        var newOverlay = new lt.Controls.Medical.OverlayText();
        newOverlay.text = text;
        newOverlay.type = lt.Controls.Medical.OverlayTextType.userData;
        newOverlay.positionIndex = index;
        newOverlay.weight = 1;
        newOverlay.alignment = lt.Controls.Medical.OverlayAlignment.topLeft;
        return newOverlay;
    };
    DicomLoaderService.prototype.AddLabels = function (item, metadata) {
        if (item.forCompare) {
            var patientId = DicomHelper.getPatientName(metadata, DicomTag.PatientName);
            var StudyDescription = DicomHelper.GetTagTextValue(metadata, DicomTag.StudyDescription);
            var StudyDate = DicomHelper.parseDicomDate(DicomHelper.GetTagTextValue(metadata, DicomTag.StudyDate));
            var SeriesDate = DicomHelper.parseDicomDate(DicomHelper.GetTagTextValue(metadata, DicomTag.SeriesDate));
            var SeriesDescription = DicomHelper.GetTagTextValue(metadata, DicomTag.SeriesDescription);
            var cell = item;
            if (cell.labels.count != 0)
                return;
            cell.labels.add(this.AddTag(patientId, 0));
            cell.labels.add(this.AddTag(StudyDescription, 2));
            cell.labels.add(this.AddTag(StudyDate, 3));
            cell.labels.add(this.AddTag(SeriesDescription, 5));
            cell.labels.add(this.AddTag(SeriesDate, 6));
        }
    };
    DicomLoaderService.prototype.updateJSON = function (__this, cellFrame, metadata, doEvent, template, frameIndex) {
        if (metadata != null) {
            var frame = cellFrame;
            var cell = cellFrame.parentCell;
            var information = DicomHelper.GetDicomImageInformation(metadata, frameIndex);
            __this.AddLabels(cell, metadata);
            __this.UpdateCineSettings(cell, metadata);
            var publish = doEvent || true;
            if (!cellFrame.JSON) {
                cellFrame.set_imagePosition(information.position);
                if (information.orientation)
                    cellFrame.imageOrientation = information.orientation;
                cellFrame.viewPosition = information.viewPosition;
                cellFrame.set_imageType(information.imageType);
                cellFrame.set_lossyCompression(information.lossyImageCompression);
                cellFrame.metadata = metadata;
                cellFrame.isWaveForm = information.isWaveForm;
                cellFrame.set_information(information);
                var laterality = __this.getLateralityValue(metadata);
                if (laterality != "") {
                    cellFrame.laterality = laterality;
                }
                cellFrame.JSON = metadata;
            }
            cellFrame.set_rowSpacing(information.rowSpacing);
            cellFrame.set_columnSpacing(information.columnSpacing);
            cellFrame.originalSize = { width: information.get_width(), height: information.get_height() };
            if (template) {
                if (!__this._seriesManagerService.map_frame(cellFrame)) {
                    __this._eventService.publish(EventNames.InstanceOverflow, { instance: cellFrame.Instance, metadata: cellFrame.metadata, frame: 0, parentCell: cellFrame.parentCell });
                }
            }
            if (publish) {
                __this._eventService.publish(EventNames.ImageInformationReady, { seriesInstanceUID: cellFrame.Instance.SeriesInstanceUID, frameIndex: cellFrame.FrameIndex });
            }
            __this._eventService.publish(EventNames.LoadedDicomJSON, { seriesInstanceUID: cellFrame.Instance.SeriesInstanceUID, cellFrame: cellFrame });
            return { xmlData: metadata, cellFrame: cellFrame };
        }
    };
    DicomLoaderService.prototype.loadFrameDicomJSON = function (cellFrame, template, frameIndex, doEvent, json) {
        var __this = this;
        var __frame = cellFrame;
        var __doEvent = doEvent;
        var __template = template;
        if (!__frame.JSON) {
            if (json)
                __this.updateJSON(__this, __frame, json, __doEvent, __template, frameIndex);
            else {
                return this._objectRetrieveService.GetDicomJSON(cellFrame.Instance.StudyInstanceUID, cellFrame.Instance.SeriesInstanceUID, cellFrame.Instance.SOPInstanceUID).then(function (data) {
                    var metadata = JSON.parse(data.data);
                    return __this.updateJSON(__this, __frame, metadata, __doEvent, __template);
                });
            }
        }
    };
    DicomLoaderService.prototype.LoadImages = function (seriesInstanceUID, id, metadata, dataSopInstanceUID) {
        var instances = this._seriesManagerService.get_instances(seriesInstanceUID, id);
        var framesLength = 0;
        var multiFrame = instances.length == 1;
        var cell = this._seriesManagerService.get_seriesCellById(id);
        var loader = this._seriesManagerService.get_seriesLoaderById(cell);
        var information;
        var __this = this;
        var presentationInfo = this._seriesManagerService.get_presentationInfo(seriesInstanceUID, id);
        var template = this._seriesManagerService.get_template(seriesInstanceUID, id);
        if (multiFrame) {
            //framesLength = this.getNumberOfFrames(metadata);
            framesLength = instances[0].NumberOfFrames;
        }
        else {
            framesLength = instances.length;
        }
        var imageDownloaded = function (e, args) {
            if (multiFrame) {
                if (cell.frames.indexOf(args.frame) == 0)
                    __this.loadFrameDicomJSON(args.frame, template, 0, true, metadata);
                var json = cell.frames.get_item(0).metadata;
                var frameIndex;
                for (frameIndex = 1; frameIndex < instance.NumberOfFrames; frameIndex++) {
                    __this.loadFrameDicomJSON(cell.frames.get_item(frameIndex), template, frameIndex, true, metadata);
                }
                __this._eventService.publish(EventNames.ActiveSeriesChanged, { seriesInstanceUID: seriesInstanceUID, id: cell.divID });
            }
            else {
                __this.loadFrameDicomJSON(args.frame, template);
                __this._eventService.publish(EventNames.ActiveSeriesChanged, { seriesInstanceUID: seriesInstanceUID, id: cell.divID });
            }
        };
        var progressCompleted = function (e, args) {
            cell.remove_imageDownloaded(imageDownloaded);
            cell.remove_progressCompleted(progressCompleted);
        };
        var cellDispose = function (e, args) {
            var cell = e;
            cell.remove_imageDownloaded(imageDownloaded);
            cell.remove_progressCompleted(progressCompleted);
            cell.remove_disposing(cellDispose);
        };
        cell.add_imageDownloaded(imageDownloaded);
        cell.add_progressCompleted(progressCompleted);
        cell.add_disposing(cellDispose);
        if (lt.LTHelper.device == lt.LTDevice.mobile) {
            if (framesLength >= __this._optionsService.get(OptionNames.LazyLoadingMobileThreshold)) {
                cell.fullDownload = false;
            }
        }
        else {
            if (framesLength >= __this._optionsService.get(OptionNames.LazyLoadingThreshold)) {
                cell.fullDownload = false;
            }
        }
        cell.marginFramesCount = __this._optionsService.get(OptionNames.LazyLoadingBuffer);
        var modality = DicomHelper.GetTagText(metadata[DicomTag.Modality]);
        cell.length = Math.min(framesLength, cell.get_imageViewer().get_items().count);
        cell.get_progress().set_totalFrames(instances.length);
        cell.studyInstanceUID = DicomHelper.GetTagText(metadata[DicomTag.StudyInstanceUID]);
        for (var instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
            var instance = instances[instanceIndex];
            if (instance == null)
                continue;
            for (var frameIndex = 0; frameIndex < instance.NumberOfFrames; frameIndex++) {
                var cellFrame = this._seriesManagerService.get_cellFrame(seriesInstanceUID, id, instance.SOPInstanceUID, modality != "IO");
                if (cellFrame == undefined) {
                    //
                    // We have a layout but the specified image is not contained in the layout.
                    // Need to add the image to overflow.
                    //
                    this._eventService.publish(EventNames.InstanceOverflow, { instance: instance, xml: metadata, frame: frameIndex, parentCell: cell });
                    cellFrame = new lt.Controls.Medical.Frame(cell);
                    //cellFrame.add_imageDrawn(this.OnImageDrawn.bind(this));
                    cell.get_frames().add(cellFrame);
                }
                var imageDataReady = function (e) {
                    var cell = cellFrame.parentCell;
                    cellFrame.remove_imageDataReady(imageDataReady);
                    __this._eventService.publish(EventNames.ImageDataReady, { cellFrame: cellFrame, id: cell.divID });
                    if (__this._templateService.currentStudyLayout && cellFrame["Instance"]) {
                        if (!angular.isDefined(cell["LoadedPresentationState"])) {
                            var seriesInstanceUID = cell.seriesInstanceUID;
                            var sopInstanceUID = cellFrame["Instance"].SOPInstanceUID;
                            var instances = __this._seriesManagerService.get_instances(seriesInstanceUID, cell.divID);
                            var box = null;
                            if (__this._templateService.currentStudyLayout.Boxes) {
                                Utils.findFirst(__this._templateService.currentStudyLayout.Boxes, function (box) {
                                    var sopBox = Utils.findFirst(instances, function (instance) {
                                        return instance.SOPInstanceUID == box.referencedSOPInstanceUID;
                                    });
                                    if (sopBox && box.ReferencedPresentationStateSOP.length > 0)
                                        return true;
                                    return false;
                                });
                            }
                            if (box) {
                                __this._objectRetrieveService.GetPresentationAnnotations(box.ReferencedPresentationStateSOP, '').then(function (result) {
                                    if (result.status == 200) {
                                        if (result.data && result.data.length > 0) {
                                            var xmlAnnotations = $.parseXML(result.data);
                                            __this._seriesManagerService.add_annotations(cellFrame.parentCell.viewer, xmlAnnotations);
                                            cell["LoadedPresentationState"] = true;
                                        }
                                        else {
                                        }
                                    }
                                }, function (error) {
                                });
                            }
                        }
                    }
                };
                cellFrame.add_imageDataReady(imageDataReady);
                cellFrame.set_instanceNumber(instance.InstanceNumber);
                cellFrame.metadata = (instanceIndex == 0) ? metadata : null;
                cellFrame.Instance = instance;
                cellFrame.FrameNumber = frameIndex + 1;
                cellFrame.FrameIndex = frameIndex;
                cellFrame.SeriesInstanceUID = seriesInstanceUID;
                cellFrame.enableDraw = true;
                if (instance.SOPInstanceUID == dataSopInstanceUID) {
                    if (frameIndex == 0) {
                        information = DicomHelper.GetDicomImageInformation(metadata, frameIndex);
                        cellFrame.set_information(information);
                        cellFrame.set_imagePosition(information.position);
                        cellFrame.set_imageType(information.imageType);
                        cellFrame.set_lossyCompression(information.lossyImageCompression);
                        cellFrame.isWaveForm = information.isWaveForm;
                        loader.SupportWindowLevel = DicomHelper.supportWindowLevel(cell, frameIndex);
                        cellFrame.set_width(information.width);
                        cellFrame.set_height(information.height);
                        cellFrame.set_rowSpacing(information.rowSpacing);
                        cellFrame.set_columnSpacing(information.columnSpacing);
                        cellFrame.originalSize = { width: information.width, height: information.height };
                        cell.set_patientName(DicomHelper.getPatientName(metadata, DicomTag.PatientName));
                        cell.set_seriesNumber(DicomHelper.getDicomTagValue(metadata, DicomTag.SeriesNumber));
                        cell.set_frameOfReferenceUID(information.frameOfReferenceUID);
                        this._overlayManagerService.set_cellOverlays(cell, cellFrame.metadata, cellFrame.isWaveForm);
                    }
                    else {
                        information = DicomHelper.GetDicomImageInformation(metadata);
                        cellFrame.set_information(information);
                        cellFrame.originalSize = { width: information.get_width(), height: information.get_height() };
                        cellFrame.set_width(information.width);
                        cellFrame.set_height(information.height);
                        cellFrame.isWaveForm = information.isWaveForm;
                    }
                }
                else {
                }
            }
        }
        var emptyFrames = $.grep(cell.get_frames().toArray(), function (f) {
            return !angular.isDefined(f.Instance);
        });
        $.each(emptyFrames, function (index, value) {
            var subCell = value.subCell;
            value.enableDraw = false;
            if (subCell != null) {
                subCell.backColor = __this._optionsService.get(OptionNames.EmptyCellBackgroundColor);
            }
        });
        this._eventService.publish(EventNames.LoadingSeriesFrames, { seriesInstanceUID: seriesInstanceUID, id: id });
        this.updateMPRWithOverlays(cell);
    };
    DicomLoaderService.prototype.updateMPRWithOverlays = function (cell) {
        if (cell.derivatives.count != 0) {
            var index = 0;
            var length = cell.derivatives.count;
            for (index = 0; index < length; index++) {
                copyOverlays(cell.derivatives.get_item(index), cell);
            }
        }
    };
    DicomLoaderService.prototype.getNumberOfFrames = function (xmlData) {
        var numberOfFrames = DicomHelper.getDicomTag(xmlData, DicomTag.NumberOfFrames);
        if (null != numberOfFrames && numberOfFrames.length > 0) {
            return parseInt(numberOfFrames.text());
        }
        else {
            return 1;
        }
    };
    DicomLoaderService.$inject = ['app.config', 'authenticationService', 'eventService', 'objectRetrieveService', 'queryArchiveService', 'seriesManagerService', '$q', 'overlayManagerService', 'optionsService', '$timeout', 'cinePlayerService', 'objectStoreService', 'templateService'];
    return DicomLoaderService;
}());
services.service('dicomLoaderService', DicomLoaderService);
var SeriesManagerService = /** @class */ (function () {
    function SeriesManagerService(eventService, optionsService, dialogs, $translate, $modal) {
        var __this = this;
        this._series = {};
        this._eventService = eventService;
        this._optionsService = optionsService;
        this._dialogs = dialogs;
        this._modal = $modal;
        this._overflowImages = [];
        this._cleanupSeries = false;
        eventService.subscribe(EventNames.LoadingSeriesFrames, $.proxy(this.OnLoadSeriesFrames, this));
        $translate('ANNOTATIONS').then(function (translation) {
            __this._annotations = translation;
        });
        $translate('LOADED').then(function (translation) {
            __this._loaded = translation;
        });
        $translate('DIALOGS_NOTIFICATION').then(function (translation) {
            __this._notifyTitle = translation;
        });
        $translate('DIALOGS_ERROR').then(function (translation) {
            __this._errorTitle = translation;
        });
    }
    Object.defineProperty(SeriesManagerService.prototype, "cleanupSeries", {
        get: function () {
            return this._cleanupSeries;
        },
        set: function (value) {
            this._cleanupSeries = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "activeSeriesInstanceUID", {
        get: function () {
            var cell = this.get_activeCell();
            return cell ? cell.seriesInstanceUID : '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "SeriesInstancesList", {
        get: function () {
            return this._seriesInstancesList;
        },
        set: function (value) {
            this._seriesInstancesList = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "currentStructuredDisplay", {
        get: function () {
            return this._currentStructuredDisplay;
        },
        set: function (value) {
            this._currentStructuredDisplay = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "structuredDisplayList", {
        get: function () {
            return this._structuredDisplayList;
        },
        set: function (value) {
            this._structuredDisplayList = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "currentLoadingSeries", {
        get: function () {
            return this._currentLoadingSeries;
        },
        set: function (value) {
            this._currentLoadingSeries = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SeriesManagerService.prototype, "currentPatientSeries", {
        get: function () {
            return this._currentPatientSeries;
        },
        set: function (value) {
            this._currentPatientSeries = value;
        },
        enumerable: false,
        configurable: true
    });
    SeriesManagerService.prototype.createLoadAnnotationUserData = function (medicalViewer, referencedSOPInstanceUIDs, calibrateUsingDPI) {
        var index = 0;
        var length;
        var count = medicalViewer.layout.items.get_count();
        var currentCell;
        var output = [];
        for (index = 0; index < count; index++) {
            currentCell = medicalViewer.layout.get_items().get_item(index);
            var frames = medicalViewer.layout.get_items().get_item(index).get_frames();
            length = frames.count;
            while (length--) {
                var frame = frames.item(length);
                var found = referencedSOPInstanceUIDs.indexOf(frame.Instance.SOPInstanceUID) != -1;
                if (!found)
                    continue;
                var container = frame.get_container();
                var userData = {
                    SourceDpiX: container.mapper.sourceDpiX,
                    SourceDpiY: container.mapper.sourceDpiY,
                    TargetDpiX: container.mapper.targetDpiX,
                    TargetDpiY: container.mapper.targetDpiY,
                    UseRulerCalibrationScale: !calibrateUsingDPI,
                    SOPInstanceUID: frame.Instance.SOPInstanceUID
                };
                output.add(userData);
            }
        }
        return JSON.stringify(output);
    };
    SeriesManagerService.prototype.get_pixelSpacing = function (cell, rowSpacings, columnSpacings) {
        var frames = cell.get_frames();
        var codecs = new lt.Annotations.Engine.AnnCodecs();
        var length = frames.count;
        var calibrated = false;
        var automation = cell.get_automation();
        while (length--) {
            var frame = frames.item(length);
            var container = frame.get_container();
            if (container.mapper.calibrationScale != 1)
                calibrated = true;
            rowSpacings[length] = container.mapper.calibrationScale * frame.rowSpacing;
            columnSpacings[length] = container.mapper.calibrationScale * frame.columnSpacing;
        }
        return calibrated;
    };
    SeriesManagerService.prototype.get_structuredDisplayCalibratedPixelSpacing = function (medicalViewer, rowSpacings, columnSpacings, sopInstanceUIDs) {
        var calibrated = false;
        var index = 0;
        var length;
        var count = medicalViewer.layout.items.get_count();
        var currentCell;
        for (index = 0; index < count; index++) {
            currentCell = medicalViewer.layout.get_items().get_item(index);
            var frames = medicalViewer.layout.get_items().get_item(index).get_frames();
            length = frames.count;
            while (length--) {
                var frame = frames.item(length);
                var container = frame.get_container();
                if (container.mapper.calibrationScale != 1) {
                    calibrated = true;
                    rowSpacings.add(container.mapper.calibrationScale * frame.rowSpacing);
                    columnSpacings.add(container.mapper.calibrationScale * frame.columnSpacing);
                    sopInstanceUIDs.add(frame.Instance.SOPInstanceUID);
                }
            }
        }
        return calibrated;
    };
    SeriesManagerService.prototype.get_allSeries = function () {
        var series = new Array();
        for (var key in this._series) {
            if (this._series.hasOwnProperty(key)) {
                series.push(key);
            }
        }
        return series;
    };
    SeriesManagerService.prototype.get_metaData = function () {
        var cell = this.get_activeCell();
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            var cell3D = cell;
            return cell3D.JSON;
        }
        else {
            var frame = this.get_activeCellFrame();
            return frame.metadata;
        }
    };
    SeriesManagerService.prototype.get_seriesTab = function (seriesInstanceUID) {
        if (this._series[seriesInstanceUID]) {
            return this._series[seriesInstanceUID].tab;
        }
        return null;
    };
    SeriesManagerService.prototype.set_seriesTab = function (seriesInstanceUID, tab) {
        if (!this._series[seriesInstanceUID]) {
            this._series[seriesInstanceUID] = {};
        }
        this._series[seriesInstanceUID].tab = tab;
    };
    SeriesManagerService.prototype.add_seriesCell = function (cell) {
        var seriesInstanceUID = cell.get_seriesInstanceUID();
        if (!this._series[seriesInstanceUID]) {
            this._series[seriesInstanceUID] = {};
        }
        if (!this._series[seriesInstanceUID].cells) {
            this._series[seriesInstanceUID].cells = new Array();
        }
        this._series[seriesInstanceUID].cells.push(cell);
    };
    SeriesManagerService.prototype.dispose_seriesCell = function (seriesInstanceUID) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].cells) {
                angular.forEach(this._series[seriesInstanceUID].cells, function (cell, index) {
                    cell.dispose();
                });
            }
            this._series[seriesInstanceUID] = null;
            delete this._series[seriesInstanceUID];
            if (angular.isDefined(this._overflowImages[seriesInstanceUID])) {
                delete this._overflowImages[seriesInstanceUID];
            }
        }
    };
    SeriesManagerService.prototype.remove_UnusedSeries = function () {
        if (!this._series)
            return;
        var _this = this;
        Object.keys(this._series).forEach(function (key) {
            if (!_this._series[key].cells || _this._series[key].cells.length == 0) {
                _this._series[key] = null;
                delete _this._series[key];
            }
        });
    };
    SeriesManagerService.prototype.remove_seriesCell = function (seriesInstanceUID) {
        var dentalMode = this._optionsService.isSeriesView();
        if (dentalMode) {
            if (this._series[seriesInstanceUID]) {
                if (this._series[seriesInstanceUID].cells) {
                    angular.forEach(this._series[seriesInstanceUID].cells, function (cell, index) {
                        cell.dispose();
                    });
                }
                //this._series[seriesInstanceUID] = null;
                //delete this._series[seriesInstanceUID];
                this._series[seriesInstanceUID].cells = null;
                this._series[seriesInstanceUID].instances = null;
                this._series[seriesInstanceUID].loaders = null;
                if (angular.isDefined(this._overflowImages[seriesInstanceUID])) {
                    delete this._overflowImages[seriesInstanceUID];
                }
            }
        }
        else {
            if (this._series[seriesInstanceUID]) {
                //this._series[seriesInstanceUID] = null;
                //delete this._series[seriesInstanceUID];
                this._series[seriesInstanceUID].cells = null;
                this._series[seriesInstanceUID].instances = null;
                this._series[seriesInstanceUID].loaders = null;
                if (angular.isDefined(this._overflowImages[seriesInstanceUID])) {
                    delete this._overflowImages[seriesInstanceUID];
                }
            }
        }
    };
    SeriesManagerService.prototype.remove_cell = function (cell) {
        if (this._series[cell.seriesInstanceUID]) {
            if (this._series[cell.seriesInstanceUID].cells) {
                var index = this._series[cell.seriesInstanceUID].cells.indexOf(cell);
                if (index != -1) {
                    this._series[cell.seriesInstanceUID].cells.splice(index, 1);
                }
            }
        }
    };
    SeriesManagerService.prototype.set_ShowStudyTimeLine = function (value) {
        this._showStudyTimeLine = value;
    };
    SeriesManagerService.prototype.get_ShowStudyTimeLine = function () {
        return this._showStudyTimeLine;
    };
    SeriesManagerService.prototype.get_activeItem = function () {
        return this._activeCell;
    };
    SeriesManagerService.prototype.set_activeCell = function (id) {
        if (id == null) {
            this._activeCell = null;
        }
        else {
            var cell = this.get_seriesCellById(id);
            this._activeCell = cell;
            if (cell != null) {
                if (cell.get_viewer().layout.selectedItems.indexOf(cell) == -1) {
                    cell.get_viewer().layout.selectedItems.clear();
                }
                cell.set_selected(true);
            }
        }
    };
    SeriesManagerService.prototype.get_activeCell = function () {
        return this._activeCell;
    };
    SeriesManagerService.prototype.get_anyCell = function () {
        for (var key in this._series) {
            if (this._series.hasOwnProperty(key)) {
                if (this._series[key].cells) {
                    var length = this._series[key].cells.length;
                    if (length > 0) {
                        var cell = this._series[key].cells[0];
                        return cell;
                    }
                }
            }
        }
        return null;
    };
    SeriesManagerService.prototype.get_seriesCellById = function (id) {
        for (var key in this._series) {
            if (this._series.hasOwnProperty(key)) {
                if (this._series[key].cells) {
                    var length = this._series[key].cells.length;
                    for (var index = 0; index < length; index++) {
                        var cell = this._series[key].cells[index];
                        if (cell.get_divID() == id) {
                            return cell;
                        }
                    }
                }
            }
        }
        return null;
    };
    SeriesManagerService.prototype.set_seriesLoader = function (cell, loader) {
        var seriesInstanceUID = cell.get_seriesInstanceUID();
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].loaders) {
                this._series[seriesInstanceUID].loaders = {};
            }
            this._series[seriesInstanceUID].loaders[cell.get_divID()] = loader;
        }
    };
    SeriesManagerService.prototype.get_seriesLoaderById = function (cell) {
        if (cell != null && this._series[cell.get_seriesInstanceUID()]) {
            if (this._series[cell.get_seriesInstanceUID()].loaders) {
                var loaders = this._series[cell.get_seriesInstanceUID()].loaders;
                for (var key in loaders) {
                    if (loaders.hasOwnProperty(key)) {
                        if (key == cell.divID) {
                            return loaders[key];
                        }
                    }
                }
            }
        }
        return null;
    };
    SeriesManagerService.prototype.set_seriesInfo = function (seriesInstanceUID, info) {
        if (this._series[seriesInstanceUID]) {
            this._series[seriesInstanceUID].info = info;
        }
    };
    SeriesManagerService.prototype.get_seriesInfo = function (seriesInstanceUID) {
        if (this._series[seriesInstanceUID]) {
            return this._series[seriesInstanceUID].info;
        }
        return null;
    };
    SeriesManagerService.prototype.set_layout = function (seriesInstanceUID, id, layout, template) {
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].layouts) {
                this._series[seriesInstanceUID].layouts = {};
            }
            if (!this._series[seriesInstanceUID].templates) {
                this._series[seriesInstanceUID].templates = {};
            }
            if (layout && layout.Boxes.length > 0) {
                this._series[seriesInstanceUID].layouts[id] = layout;
            }
            if (template) {
                this._series[seriesInstanceUID].templates[id] = template;
            }
        }
    };
    SeriesManagerService.prototype.get_layout = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].layouts) {
                if (this._series[seriesInstanceUID].layouts[id]) {
                    return this._series[seriesInstanceUID].layouts[id];
                }
            }
        }
        return null;
    };
    SeriesManagerService.prototype.get_template = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].templates) {
                return this._series[seriesInstanceUID].templates[id];
            }
        }
        return null;
    };
    SeriesManagerService.prototype.set_presentationInfo = function (seriesInstanceUID, id, presentationInfo) {
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].presentationInfo) {
                this._series[seriesInstanceUID].presentationInfo = {};
            }
            this._series[seriesInstanceUID].presentationInfo[id] = presentationInfo;
            if (this._series[seriesInstanceUID].instances && this._series[seriesInstanceUID].instances[id]) {
                this.sortImageInformation(seriesInstanceUID, id, this._series[seriesInstanceUID].presentationInfo[id]);
            }
        }
    };
    SeriesManagerService.prototype.get_presentationInfo = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].presentationInfo && this._series[seriesInstanceUID].presentationInfo[id]) {
                return this._series[seriesInstanceUID].presentationInfo[id];
            }
        }
        return null;
    };
    SeriesManagerService.prototype.set_instances = function (seriesInstanceUID, id, instances, stackInstanceUID) {
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].instances) {
                this._series[seriesInstanceUID].instances = {};
            }
            this._series[seriesInstanceUID].instances[id] = instances;
            {
                var template = this._series[seriesInstanceUID].templates[id];
                //this.sortImageInformation(seriesInstanceUID, id, this._series[seriesInstanceUID].presentationInfo[id]);
                var cell = this.get_seriesCellById(id);
                if (!cell)
                    return;
                cell.stackInstanceUID = stackInstanceUID;
                if (template && template.Frames.length > 0) {
                    Utils.createViewerLayout(cell, template);
                }
                else {
                    var medicalViewer = cell.viewer;
                    if (!medicalViewer.HangingProtocolEnabled) {
                        var layout = this._series[seriesInstanceUID].layouts[id];
                        if (layout) {
                            if (!this._series[seriesInstanceUID].sopMappings) {
                                this._series[seriesInstanceUID].sopMappings = {};
                            }
                            this._series[seriesInstanceUID].sopMappings[id] = this.buildLayoutMappings(layout);
                            this.map_Frames(seriesInstanceUID, id, layout);
                            this.setCustomLayout(this.get_seriesCellById(id), layout);
                        }
                    }
                }
            }
        }
    };
    SeriesManagerService.prototype.get_instances = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].instances && this._series[seriesInstanceUID].instances[id]) {
                return this._series[seriesInstanceUID].instances[id];
            }
        }
        return new Array();
    };
    SeriesManagerService.prototype.set_sopMappings = function (seriesInstanceUID, id, mappings, layout) {
        if (!this._series[seriesInstanceUID].sopMappings) {
            this._series[seriesInstanceUID].sopMappings = {};
        }
        this._series[seriesInstanceUID].sopMappings[id] = mappings;
        this.map_Frames(seriesInstanceUID, id, layout);
    };
    SeriesManagerService.prototype.get_sopMappings = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].sopMappings && this._series[seriesInstanceUID].sopMappings[id]) {
                return this._series[seriesInstanceUID].sopMappings[id];
            }
        }
        return null;
    };
    SeriesManagerService.prototype.delete_sopMappings = function (seriesInstanceUID) {
        if (this._series[seriesInstanceUID]) {
            delete this._series[seriesInstanceUID].sopMappings;
        }
    };
    SeriesManagerService.prototype.get_cellFrame = function (seriesInstanceUID, id, sopInstanceUID, getNew) {
        if (this._series[seriesInstanceUID]) {
            var sopMappings = this.get_sopMappings(seriesInstanceUID, id);
            var cell = this.get_seriesCellById(id);
            getNew = getNew || false;
            if (sopMappings == null) {
                var cellFrame = new lt.Controls.Medical.Frame(cell);
                cell.get_frames().add(cellFrame);
                return cellFrame;
            }
            else if (sopInstanceUID in sopMappings) {
                return cell.get_frames().get_item(sopMappings[sopInstanceUID]);
            }
            else if (getNew) {
                var cellFrame = new lt.Controls.Medical.Frame(cell);
                cell.get_frames().add(cellFrame);
                return cellFrame;
            }
        }
        return null;
    };
    SeriesManagerService.prototype.get_cellFrameByIndex = function (seriesInstanceUID, id, frameIndex) {
        if (this._series[seriesInstanceUID]) {
            var cell = this.get_seriesCellById(id);
            var frames = cell.get_frames();
            return frames.item(frameIndex);
        }
        return undefined;
    };
    SeriesManagerService.prototype.get_activeSubCellIndex = function (cell) {
        if (this._series[cell.seriesInstanceUID]) {
            var index = -1;
            var items = cell.get_selectedItems();
            if (items.get_count() > 0)
                index = cell.get_imageViewer().get_items().indexOf(items.get_item(0));
            if (index < 0)
                index = 0;
            return index;
        }
        return -1;
    };
    SeriesManagerService.prototype.get_viewerCount = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID]) {
            var cell = this.get_seriesCellById(id);
            return cell.get_imageViewer().get_items().get_count();
        }
        return -1;
    };
    SeriesManagerService.prototype.get_activeViewer = function () {
        var cell = this.get_activeCell();
        if (cell) {
            var items = cell.get_selectedItems();
            if (items.get_count() > 0) {
                return items.get_item(0);
            }
        }
        return null;
    };
    SeriesManagerService.prototype.get_activeItemForCell = function (cell) {
        if (cell) {
            var items = cell.get_selectedItems();
            if (items.get_count() > 0) {
                return items.get_item(0);
            }
        }
        return null;
    };
    SeriesManagerService.prototype.get_activeCellFrame = function () {
        var cell = this.get_activeCell();
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            cell = cell.referenceCell;
        }
        if (cell) {
            var index = this.get_activeSubCellIndex(cell);
            if (index == -1)
                return null;
            var subCell = (cell.imageViewer.items.get_item(index));
            return (subCell.attachedFrame);
        }
        return null;
    };
    SeriesManagerService.prototype.set_annotationIDs = function (seriesInstanceUID, id, annotationIds) {
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].annotations) {
                this._series[seriesInstanceUID].annotations = {};
            }
            this._series[seriesInstanceUID].annotations[id] = annotationIds;
        }
    };
    SeriesManagerService.prototype.get_annotationIDs = function (seriesInstanceUID, id) {
        if (this._series[seriesInstanceUID] && angular.isDefined(this._series[seriesInstanceUID].annotations)) {
            return this._series[seriesInstanceUID].annotations[id];
        }
        return new Array();
    };
    SeriesManagerService.prototype.remove_annotationID = function (seriesInstanceUID, id, annotationId) {
        if (this._series[seriesInstanceUID]) {
            if (this._series[seriesInstanceUID].annotations) {
                var item = $.grep(this._series[seriesInstanceUID].annotations[id], function (annotation, index) { return annotation.SOPInstanceUID == annotationId; });
                if (item.length > 0) {
                    var index = this._series[seriesInstanceUID].annotations[id].indexOf(item[0]);
                    this._series[seriesInstanceUID].annotations[id].splice(index, 1);
                }
            }
        }
    };
    SeriesManagerService.prototype.get_maxAllowedStackIndex = function (cell) {
        if (cell) {
            if (cell instanceof lt.Controls.Medical.Cell3D)
                return 1;
            if (!cell.frames)
                return 1;
            var items = cell.get_imageViewer().get_items();
            if (items.count == 1) {
                return Math.max(1, cell.get_frames().get_count() - cell.get_imageViewer().get_items().get_count() + 1);
            }
            else {
                var selectedItem = cell.get_selectedItem();
                return Math.max(1, cell.get_frames().get_count() - cell.get_imageViewer().get_items().get_count() + 1);
            }
        }
        return -1;
    };
    SeriesManagerService.prototype.add_annotationID = function (seriesInstanceUID, id, annotationId) {
        if (this._series[seriesInstanceUID]) {
            if (!this._series[seriesInstanceUID].annotations) {
                this._series[seriesInstanceUID].annotations = new Array();
            }
            this._series[seriesInstanceUID].annotations[id].push(annotationId);
        }
    };
    SeriesManagerService.prototype.add_annotations = function (viewer, annotations) {
        var cellCount = viewer.layout.items.count;
        var cellIndex = 0;
        var cell;
        for (cellIndex = 0; cellIndex < cellCount; cellIndex++) {
            cell = viewer.layout.items.get_item(cellIndex);
            if (this._series[cell.seriesInstanceUID]) {
                try {
                    if (!cell.get_frames)
                        continue;
                    var length = cell.get_frames().get_count();
                    var codecs = new lt.Annotations.Engine.AnnCodecs();
                    var sopInstanceIndexMap = {};
                    var baseIndex = 0;
                    var frames = cell.get_frames();
                    var annInfo = codecs.getInfoFromXmlDocument(annotations);
                    var pages = annInfo.get_pages();
                    var pagesCount = pages.length;
                    while (baseIndex < length) {
                        var sopInstanceUID = frames.item(baseIndex).Instance.SOPInstanceUID;
                        if (sopInstanceIndexMap[sopInstanceUID] == undefined) {
                            sopInstanceIndexMap[sopInstanceUID] = baseIndex;
                        }
                        baseIndex++;
                    }
                    var allRulersSameCalibration = this._optionsService.get(OptionNames.AllRulersSameCalibration);
                    while (pagesCount--) {
                        var loadContainer = codecs.loadFromXmlDocument(annotations, pages[pagesCount]);
                        if (loadContainer) {
                            // We want the RotateCenter to be automatically recalculated.
                            // It rotate center is empty (x = Nan, y = Nan), it is automatically recalculated.
                            // But in the deserialization, the NaN is converted to 0 so the RotateCenter is set to (0,0)
                            // The workaround is to just automatically set the  RoateCenter to be (x = Nan, y = Nan)
                            var calibrationScale = 1;
                            var children = loadContainer.get_children();
                            if (children) {
                                var children_count = children.get_count();
                                for (var i = 0; i < children_count; i++) {
                                    var child = children.get_item(i);
                                    if (child) {
                                        child.set_rotateCenter(lt.LeadPointD.empty);
                                        if (child instanceof lt.Annotations.Engine.AnnPolyRulerObject) {
                                            var ruler = child;
                                            ruler.tickMarksLength = lt.LeadLengthD.create(240);
                                            ruler.showGauge = true;
                                            ruler.gaugeLength = lt.LeadLengthD.create(360);
                                        }
                                        if (allRulersSameCalibration) {
                                            if (child.hasOwnProperty(calibrationScale)) {
                                                calibrationScale = child[calibrationScale];
                                                child.calibrate(lt.LeadLengthD.create(1), lt.Annotations.Engine.AnnUnit.unit, lt.LeadLengthD.create(1), lt.Annotations.Engine.AnnUnit.unit);
                                            }
                                        }
                                    }
                                }
                            }
                            var annData = JSON.parse(loadContainer.get_userData());
                            var sopInstance = annData.ReferencedImageSequence.ReferencedSopInstanceUid;
                            var refFrames = annData.ReferencedImageSequence.ReferencedFrameNumber;
                            var framesCount = refFrames.length;
                            var automation = cell.get_automation();
                            for (var index = 0; index < framesCount; index++) {
                                var srcChildren = loadContainer.get_children();
                                if (srcChildren.count == 0)
                                    continue;
                                if (sopInstanceIndexMap[sopInstance] == undefined)
                                    continue;
                                var frameIndex = sopInstanceIndexMap[sopInstance] + refFrames[index] - 1;
                                var frame = cell.get_frames().get_item(frameIndex);
                                if (frame)
                                    var container = frame.container;
                                var destChildren = container.get_children();
                                var childrenCount = srcChildren.get_count();
                                for (var i = 0; i < childrenCount; i++) {
                                    var child = srcChildren.get_item(i);
                                    destChildren.add(child);
                                }
                                var calibrateUsingDPI = this._optionsService.get(OptionNames.CalibrateUsingDpi);
                                if (!calibrateUsingDPI) {
                                    if (allRulersSameCalibration) {
                                        container.mapper.calibrate(lt.LeadLengthD.create(1), lt.Annotations.Engine.AnnUnit.unit, lt.LeadLengthD.create(calibrationScale), lt.Annotations.Engine.AnnUnit.unit);
                                    }
                                    else {
                                        container.mapper.calibrationScale = (lt.LeadLengthD.create(1), lt.Annotations.Engine.AnnUnit.unit, lt.LeadLengthD.create(loadContainer.mapper.calibrationScale), lt.Annotations.Engine.AnnUnit.unit);
                                    }
                                }
                                automation.set_active(true);
                                automation.invalidate(lt.LeadRectD.empty);
                            }
                        }
                        automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
                    }
                }
                catch (er) {
                    this._dialogs.error(this._errorTitle, "Invalid annotations data: " + er);
                }
            }
        }
    };
    SeriesManagerService.prototype.capture_currentFrame = function (burnAnnotations) {
        var burn = burnAnnotations || false;
        var canvas = this.cloneCanvas();
        var canvasData;
        if (burn) {
            this.burnAnnotations(canvas);
        }
        canvasData = canvas.toDataURL("image/png");
        return canvasData;
    };
    SeriesManagerService.prototype.get_calibratedStructuredDisplayAnnotations = function (cell, seriesInstances, referencedSeries, calibrateUsingDPI) {
        if (this._series[cell.seriesInstanceUID]) {
            var frames = cell.get_frames();
            var codecs = new lt.Annotations.Engine.AnnCodecs();
            var length = frames.count;
            var annotationsData = "";
            var automation = cell.get_automation();
            var medicalViewer = cell.viewer;
            var index = 0;
            var count = medicalViewer.layout.items.get_count();
            var counter = 1;
            var currentCell;
            for (index = 0; index < count; index++) {
                currentCell = medicalViewer.layout.get_items().get_item(index);
                frames = medicalViewer.layout.get_items().get_item(index).get_frames();
                length = frames.count;
                while (length--) {
                    var frame = frames.item(length);
                    var container = frame.get_container();
                    if (automation != null) {
                        var instance = frame.Instance;
                        if (angular.isDefined(container) && container.children.count > 0) {
                            var userData = new Models.AnnUserData();
                            var refSop = new Models.SopInstanceReference();
                            var sopInstanceUID = instance.SOPInstanceUID;
                            var seriesInstanceUID = currentCell.seriesInstanceUID;
                            // if the the series is mapped then see if the instanceUID is mapped as well. (mapped means that the series/instance is dervied, therefore use the derived instance UID instead.)
                            if (seriesInstances[currentCell.seriesInstanceUID]) {
                                // if the mppaed instance UID exist, then use it instead of the original instance UID.
                                var mappedArray = seriesInstances[currentCell.seriesInstanceUID].MappedSopInstanceUIDs;
                                if (mappedArray[instance.SOPInstanceUID]) {
                                    seriesInstanceUID = seriesInstances[currentCell.seriesInstanceUID].InstanceUID;
                                    sopInstanceUID = mappedArray[instance.SOPInstanceUID];
                                }
                            }
                            // if the the series is not mapped (derived), then just add the series to the list of referencedSeries that will be added to the annotation presentation state.
                            referencedSeries.add(seriesInstanceUID);
                            refSop.ReferencedSopClassUid = instance.SOPClassUID;
                            refSop.ReferencedSopInstanceUid = sopInstanceUID;
                            refSop.ReferencedFrameNumber.push(frame.FrameNumber);
                            userData.ImageSize = this.getImageSize(frame);
                            userData.ReferencedImageSequence = refSop;
                            userData.SeriesInstanceUID = seriesInstanceUID;
                            userData.MapResolution =
                                {
                                    SourceDpiX: container.mapper.sourceDpiX,
                                    SourceDpiY: container.mapper.sourceDpiY,
                                    TargetDpiX: container.mapper.targetDpiX,
                                    TargetDpiY: container.mapper.targetDpiY,
                                    UseRulerCalibrationScale: !calibrateUsingDPI
                                };
                            container.userData = JSON.stringify(userData);
                            annotationsData = codecs.save(container, lt.Annotations.Engine.AnnFormat.annotations, annotationsData, counter);
                            counter++;
                        }
                    }
                }
            }
            return annotationsData;
        }
        return "";
    };
    SeriesManagerService.prototype.get_allCellsAnnotations = function (cell, referencedSeries, calibrateUsingDPI) {
        if (this._series[cell.seriesInstanceUID]) {
            var frames = cell.get_frames();
            var codecs = new lt.Annotations.Engine.AnnCodecs();
            var length = frames.count;
            var annotationsData = "";
            var automation = cell.get_automation();
            var medicalViewer = cell.viewer;
            var index = 0;
            var count = medicalViewer.layout.items.get_count();
            var counter = 1;
            var currentCell;
            for (index = 0; index < count; index++) {
                currentCell = medicalViewer.layout.get_items().get_item(index);
                frames = medicalViewer.layout.get_items().get_item(index).get_frames();
                if (!frames)
                    continue;
                length = frames.count;
                while (length--) {
                    var frame = frames.item(length);
                    var container = frame.get_container();
                    if (automation != null) {
                        var instance = frame.Instance;
                        if (angular.isDefined(container) && container.children.count > 0) {
                            var userData = new Models.AnnUserData();
                            var refSop = new Models.SopInstanceReference();
                            refSop.ReferencedSopClassUid = instance.SOPClassUID;
                            refSop.ReferencedSopInstanceUid = instance.SOPInstanceUID;
                            refSop.ReferencedFrameNumber.push(frame.FrameNumber);
                            userData.ImageSize = this.getImageSize(frame);
                            userData.SeriesInstanceUID = currentCell.seriesInstanceUID;
                            userData.ReferencedImageSequence = refSop;
                            userData.MapResolution =
                                {
                                    SourceDpiX: container.mapper.sourceDpiX,
                                    SourceDpiY: container.mapper.sourceDpiY,
                                    TargetDpiX: container.mapper.targetDpiX,
                                    TargetDpiY: container.mapper.targetDpiY,
                                    UseRulerCalibrationScale: !calibrateUsingDPI
                                };
                            container.userData = JSON.stringify(userData);
                            annotationsData = codecs.save(container, lt.Annotations.Engine.AnnFormat.annotations, annotationsData, counter);
                            counter++;
                            if (referencedSeries) {
                                if (referencedSeries.indexOf(currentCell.seriesInstanceUID) == -1) {
                                    referencedSeries.add(currentCell.seriesInstanceUID);
                                }
                            }
                        }
                    }
                }
            }
            return annotationsData;
        }
        return "";
    };
    SeriesManagerService.prototype.get_Annotations = function (cell, list) {
        if (this._series[cell.seriesInstanceUID]) {
            var frames = cell.get_frames();
            var codecs = new lt.Annotations.Engine.AnnCodecs();
            var length = frames.count;
            var annotationsData = "";
            var automation = cell.get_automation();
            while (length--) {
                var frame = frames.item(length);
                var container = frame.get_container();
                if (automation != null) {
                    var instance = frame.Instance;
                    if (angular.isDefined(container) && container.children.count > 0) {
                        var userData = new Models.AnnUserData();
                        var refSop = new Models.SopInstanceReference();
                        refSop.ReferencedSopClassUid = instance.SOPClassUID;
                        refSop.ReferencedSopInstanceUid = list[instance.SOPInstanceUID];
                        refSop.ReferencedFrameNumber.push(frame.FrameNumber);
                        userData.SeriesInstanceUID = cell.seriesInstanceUID;
                        userData.ImageSize = this.getImageSize(frame);
                        userData.ReferencedImageSequence = refSop;
                        container.userData = JSON.stringify(userData);
                        annotationsData = codecs.save(container, lt.Annotations.Engine.AnnFormat.annotations, annotationsData, length + 1);
                    }
                }
            }
            return annotationsData;
        }
        return "";
    };
    SeriesManagerService.prototype.get_cellAnnotations = function (cell, calibrateUsingDPI) {
        if (this._series[cell.seriesInstanceUID]) {
            var frames = cell.get_frames();
            var codecs = new lt.Annotations.Engine.AnnCodecs();
            var length = frames.count;
            var annotationsData = "";
            var automation = cell.get_automation();
            while (length--) {
                var frame = frames.item(length);
                var container = frame.get_container();
                if (automation != null) {
                    var instance = frame.Instance;
                    if (angular.isDefined(container) && container.children.count > 0) {
                        var userData = new Models.AnnUserData();
                        var refSop = new Models.SopInstanceReference();
                        refSop.ReferencedSopClassUid = instance.SOPClassUID;
                        refSop.ReferencedSopInstanceUid = instance.SOPInstanceUID;
                        refSop.ReferencedFrameNumber.push(frame.FrameNumber);
                        userData.SeriesInstanceUID = cell.seriesInstanceUID;
                        userData.ImageSize = this.getImageSize(frame);
                        userData.ReferencedImageSequence = refSop;
                        userData.MapResolution =
                            {
                                SourceDpiX: container.mapper.sourceDpiX,
                                SourceDpiY: container.mapper.sourceDpiY,
                                TargetDpiX: container.mapper.targetDpiX,
                                TargetDpiY: container.mapper.targetDpiY,
                                UseRulerCalibrationScale: !calibrateUsingDPI
                            };
                        container.userData = JSON.stringify(userData);
                        annotationsData = codecs.save(container, lt.Annotations.Engine.AnnFormat.annotations, annotationsData, length + 1);
                    }
                }
            }
            return annotationsData;
        }
        return "";
    };
    SeriesManagerService.prototype.enumerateFrames = function (cell, frameFunction, cell3DFunction) {
        if (this._series[cell.seriesInstanceUID] && frameFunction) {
            var viewer = cell.viewer;
            var frames;
            var length;
            var cellIndex = 0;
            var cellCount = viewer.layout.items.count;
            for (cellIndex = 0; cellIndex < cellCount; cellIndex++) {
                cell = viewer.layout.items.get_item(cellIndex);
                if (cell instanceof lt.Controls.Medical.Cell3D) {
                    if (cell3DFunction)
                        cell3DFunction(cell);
                    continue;
                }
                frames = cell.get_frames();
                length = frames.count;
                if (cell.tickBoxes.length > 0) {
                    if (!cell.tickBoxes[0].checked && !cell.selected)
                        continue;
                    for (var index = 0; index < length; index++) {
                        try {
                            frameFunction(frames.item(index), index);
                        }
                        catch (err) {
                        }
                    }
                }
            }
        }
    };
    SeriesManagerService.prototype.withinVisibleRange = function (cell, frameIndex) {
        if (this._series[cell.seriesInstanceUID]) {
            var cellFrame = null;
            if (frameIndex < 0 || frameIndex >= cell.frames.count) {
                return false;
            }
            cellFrame = cell.frames.item(frameIndex);
            return cell.withinVisibleRange(frameIndex);
        }
        return false;
    };
    SeriesManagerService.prototype.isImageDataAvailable = function (cell, frameIndex) {
        if (this._series[cell.seriesInstanceUID]) {
            var frames = cell.frames;
            var cellFrame = null;
            if (frameIndex < 0 || frameIndex >= frames.count) {
                return false;
            }
            cellFrame = frames.item(frameIndex);
            return cellFrame.get_isPNGDataReady();
        }
        return false;
    };
    SeriesManagerService.prototype.isDataReady = function (cell, frameIndex) {
        if (this._series[cell.seriesInstanceUID]) {
            // the data is always ready for the 3D since it's done on the server
            if (cell instanceof lt.Controls.Medical.Cell3D)
                return true;
            var frames = cell.frames;
            if (!frames)
                return false;
            var cellFrame = null;
            if (frameIndex < 0 || frameIndex >= frames.count) {
                return false;
            }
            cellFrame = frames.item(frameIndex);
            return cellFrame.get_isDataReady();
        }
        return false;
    };
    SeriesManagerService.prototype.deleteSelectedAnnotations = function () {
        var cell = this.get_activeCell();
        if (cell) {
            var automation = cell.get_automation();
            if (automation != null && automation.canDeleteObjects) {
                if (automation.currentEditObject != null)
                    automation.deleteSelectedObjects();
                else
                    alert('no annotation found to delete');
            }
            else
                alert('no annotation found to delete');
        }
    };
    SeriesManagerService.prototype.clearAnnotations = function () {
        var cell = this.get_activeCell();
        if (cell) {
            var cell = this.get_activeCell();
            var automation = cell.get_automation();
            var frame = this.get_activeCellFrame();
            var children = frame.get_container().get_children();
            var count = children.count;
            if (count == 0) {
                alert('no annotation found');
            }
            else {
                children.clear();
                automation.invalidate(lt.LeadRectD.empty);
            }
        }
    };
    SeriesManagerService.prototype.clearAllAnnotations = function () {
        var cell = this.get_activeCell();
        if (cell) {
            var length = cell.get_frames().get_count();
            var automation = cell.get_automation();
            var annFound = false;
            for (var index = 0; index < length; index++) {
                var frame = cell.get_frames().item(index);
                var children = frame.get_container().get_children();
                var count = children.count;
                if (count != 0) {
                    annFound = true;
                    children.clear();
                }
            }
            if (!annFound) {
                alert('no annotations found');
            }
            else
                automation.invalidate(lt.LeadRectD.empty);
        }
    };
    SeriesManagerService.prototype.buildLayoutMappings = function (layout) {
        var map = new AssociativeArray();
        var length = layout.Boxes ? layout.Boxes.length : 0;
        for (var index = 0; index < length; index++) {
            var box = layout.Boxes[index];
            var referencedSopInstanceUID = box.referencedSOPInstanceUID && box.referencedSOPInstanceUID.length > 0 ? box.referencedSOPInstanceUID[0] : "DUMMY_ID_" + index;
            map[referencedSopInstanceUID] = index;
        }
        return map;
    };
    SeriesManagerService.prototype.map_Frames = function (seriesInstanceUID, id, layout) {
        var sopMappings = this.get_sopMappings(seriesInstanceUID, id);
        if (sopMappings) {
            var frameMapping = null;
            var cell = this.get_seriesCellById(id);
            var sopLength = sopMappings.Size();
            var boxLength = layout.Boxes.length;
            var unmappedFrames = new Array();
            var mappedFrames = new Array();
            for (var i = 0; i < boxLength; i++) {
                var box = layout.Boxes[i];
                var referencedSopInstanceUID = box.referencedSOPInstanceUID && box.referencedSOPInstanceUID ? box.referencedSOPInstanceUID[0] : null;
                if (angular.isDefined(sopMappings[referencedSopInstanceUID])) {
                    if (frameMapping == null) {
                        frameMapping = {};
                    }
                    frameMapping[i] = sopMappings[referencedSopInstanceUID];
                    //frameMapping[sopMappings[referencedSopInstanceUID]] = i;
                    mappedFrames.push(sopMappings[referencedSopInstanceUID]);
                }
                else {
                    unmappedFrames.push(i);
                }
            }
            //
            // Find all frames not mapped
            //   
            if (frameMapping != null && unmappedFrames.length > 0) {
                for (var i = 0; i < boxLength; i++) {
                    if (unmappedFrames.indexOf(i) != -1) {
                        for (var j = 0; j < boxLength; j++) {
                            if (!angular.isDefined(frameMapping[j])) {
                                frameMapping[j] = i;
                                break;
                            }
                        }
                    }
                }
            }
        }
    };
    SeriesManagerService.prototype.sortImageInformation = function (seriesInstanceUID, id, presentationInfo) {
        var findIndex = 0;
        var frame = new Models.FramePresentationInfo();
        var framesLength = 0;
        var lastIndex = 0;
        var cell = this.get_seriesCellById(id);
        if (cell != null) {
            var instanceLength = this._series[seriesInstanceUID].instances[id].length;
            var instanceCounter = 0;
            if (!this._series[seriesInstanceUID].imagesInformation) {
                this._series[seriesInstanceUID].imagesInformation = {};
            }
            this._series[seriesInstanceUID].imagesInformation[id] = [];
            for (; instanceCounter < instanceLength; instanceCounter++) {
                var index = 0;
                var instance = this._series[seriesInstanceUID].instances[id][instanceCounter];
                if (instance != null) {
                    findIndex = this.findSOP(presentationInfo, instance.SOPInstanceUID);
                    framesLength = presentationInfo[findIndex].PagesPresentationInfo.length;
                    for (; index < framesLength; index++) {
                        this._series[seriesInstanceUID].imagesInformation[id][index + lastIndex] = DicomHelper.PreparePresentationInformation(presentationInfo[findIndex], index);
                    }
                    lastIndex += framesLength;
                }
            }
        }
    };
    SeriesManagerService.prototype.setCustomLayout = function (cell, layout) {
        var length = layout.Boxes.length;
        var imageViewer = cell.get_imageViewer();
        var medicalViewer = cell.viewer;
        var numInstances;
        var instances = this.get_instances(cell.get_seriesInstanceUID(), cell.get_divID());
        imageViewer.beginUpdate();
        cell.set_arrangement(1);
        imageViewer.items.clear();
        cell.updateSubCellCount(length);
        cell.templateId = layout.TemplateId;
        numInstances = length;
        for (var index = 0; index < length; index++) {
            var box = layout.Boxes[index];
            var item = (imageViewer.get_items().get_item(index));
            var bounds = Utils.createLeadRect(box.Position.leftTop.x, box.Position.leftTop.y, box.Position.rightBottom.x, box.Position.rightBottom.y);
            if (!bounds.isEmpty) {
                var cellFrame = new lt.Controls.Medical.Frame(cell);
                var subCell = item;
                //var viewer: lt.Controls.ImageViewer;
                item.set_bounds(bounds);
                cell.get_frames().add(cellFrame);
                //subCell = cellFrame.get_subCell();
                if (subCell != null) {
                    subCell.backColor = this._optionsService.get(OptionNames.EmptyCellBackgroundColor);
                }
            }
        }
        cell.onSizeChanged();
        imageViewer.endUpdate();
    };
    SeriesManagerService.prototype.set_framesMapping = function (cell, frames) {
        var framesMapping = null;
        var cellFrames = cell.frames.toArray();
        var imageViewer = cell.imageViewer;
        var length = imageViewer.items.count;
        for (var index = 0; index < length; index++) {
            var subCell = (imageViewer.items.item(index));
            if (subCell.templateFrame) {
                var cellFrame = Utils.findFirst(cellFrames, function (cellFrame) {
                    return !subCell.isMapped && Utils.isInstanceInFrame(subCell.templateFrame, cellFrame);
                });
                if (framesMapping == null)
                    framesMapping = {};
                if (cellFrame) {
                    var frameIndex = cellFrames.indexOf(cellFrame);
                    framesMapping[index] = cell.frames.indexOf(cellFrame);
                    cellFrames.splice(frameIndex, 1);
                    subCell.isMapped = true;
                }
                else {
                    framesMapping[index] = -1;
                }
            }
        }
        cell.set_framesMappingIndex(framesMapping);
        return cellFrames;
    };
    SeriesManagerService.prototype.map_frame = function (cellFrame) {
        var mapped;
        var cell = cellFrame.parentCell;
        var imageViewer = cell.imageViewer;
        var length = imageViewer.items.count;
        var framesMapping = cell.framesMappingIndex;
        for (var index = 0; index < length; index++) {
            var subCell = (imageViewer.items.item(index));
            mapped = !subCell.isMapped && Utils.isInstanceInFrame(subCell.templateFrame, cellFrame);
            if (mapped) {
                break;
            }
        }
        if (mapped) {
            subCell.isMapped = true;
            subCell.set_attachedFrame(cellFrame);
        }
        return mapped;
    };
    SeriesManagerService.prototype.addPostRender = function (viewer, cell) {
        viewer.add_postRenderItem(function (sender, e) {
            if (e.part == lt.Controls.ImageViewerItemPart.item) {
                var context = e.context;
                var item = e.item;
                var bounds;
                var transform;
                var index = cell.frames.indexOf(item.attachedFrame);
                var text;
                var viewerIndex = cell.get_derivatives().indexOf(viewer);
                context.save();
                bounds = viewer.getItemBounds(item, lt.Controls.ImageViewerItemPart.content);
                if (angular.isDefined(item.attachedFrame)) {
                    var instance = item.attachedFrame.Instance;
                    text = instance.SOPInstanceUID;
                    text = text.substr(text.length - 6, 5) + ': ' + instance.InstanceNumber;
                }
                else {
                    text = index.toString();
                }
                text = '(' + index.toString() + ') ' + text;
                context.font = "12px serif";
                context.fillStyle = 'red';
                context.textBaseline = "top";
                context.fillText(text, bounds.left, bounds.top, bounds.width);
                context.restore();
            }
        });
    };
    SeriesManagerService.prototype.add_seriesOverflow = function (data) {
        var seriesInstanceUID = data.instance.SeriesInstanceUID;
        if (!angular.isDefined(this._overflowImages[seriesInstanceUID])) {
            this._overflowImages[seriesInstanceUID] = [];
        }
        if (!angular.isDefined(this._overflowImages[seriesInstanceUID].metadata)) {
            this._overflowImages[seriesInstanceUID].metadata = data.metadata;
        }
        this._overflowImages[seriesInstanceUID].push(data);
    };
    SeriesManagerService.prototype.get_seriesOverflow = function (seriesInstanceUID) {
        if (angular.isDefined(this._overflowImages[seriesInstanceUID])) {
            return this._overflowImages[seriesInstanceUID];
        }
        return [];
    };
    SeriesManagerService.prototype.get_seriesOverflowJSON = function (seriesInstanceUID) {
        if (angular.isDefined(this._overflowImages[seriesInstanceUID]) && angular.isDefined(this._overflowImages[seriesInstanceUID].metadata)) {
            return this._overflowImages[seriesInstanceUID].metadata;
        }
        return null;
    };
    SeriesManagerService.prototype.clear_seriesOverflow = function (seriesInstanceUID) {
        if (angular.isDefined(this._overflowImages[seriesInstanceUID])) {
            delete this._overflowImages[seriesInstanceUID].metadata;
            this._overflowImages[seriesInstanceUID] = [];
        }
    };
    SeriesManagerService.prototype.findSOP = function (presentationInfo, sopInstanceUID) {
        var index = 0;
        var findIndex = 0;
        var length = presentationInfo.length;
        for (; index < length; index++) {
            if (presentationInfo[index].SOPInstanceUID == sopInstanceUID)
                return index;
        }
        return -1;
    };
    SeriesManagerService.prototype.OnLoadSeriesFrames = function (event, data) {
        var cell = this.get_seriesCellById(data.args.id);
        if (cell) {
            var automation = cell.get_automation();
            var __this = this;
            if (automation) {
                automation.add_editText(function (sender, e) {
                    __this.automation_editText(sender, e, cell);
                });
                automation.add_currentDesignerChanged(function (sender, e) {
                    __this.automation_CurrentDesignerChanged(sender, e, cell);
                });
                automation.add_draw(function (sender, e) {
                    __this.automation_AnnotationDraw(sender, e);
                });
                __this.setDefaults(automation.get_manager());
                __this.setThumbPreferences(automation.get_manager().get_renderingEngine().get_renderers());
            }
        }
    };
    SeriesManagerService.prototype.automation_editText = function (sender, e, cell) {
        if (lt.LTHelper.device == lt.LTDevice.tablet || lt.LTHelper.device == lt.LTDevice.mobile) {
            var modalInstance = this._modal.open({
                templateUrl: 'views/dialogs/Prompt.html',
                controller: Controllers.PromptController,
                backdrop: 'static',
                resolve: {
                    label: function () {
                        return "Text";
                    },
                    text: function () {
                        return e.get_textObject().get_text();
                    }
                }
            });
            modalInstance.result.then(function (text) {
                var automation = cell.get_automation();
                e.get_textObject().set_text(text);
                automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
            });
        }
        else {
            var textElement = document.createElement("textArea");
            var viewer = cell.get_imageViewer();
            var automation = cell.get_automation();
            var parent = viewer.get_mainDiv().parentNode;
            var __this = this;
            textElement.id = 'textObject';
            textElement.style.left = e.get_bounds().get_left() + 'px';
            textElement.style.top = e.get_bounds().get_top() + 'px';
            textElement.style.position = 'absolute';
            textElement.style.zIndex = '100';
            textElement.style.height = e.get_bounds().get_height() + 'px';
            textElement.style.width = e.get_bounds().get_width() + 'px';
            textElement.userData = e.get_textObject();
            textElement.value = e.get_textObject().get_text();
            textElement.style.color = e.get_textObject().get_textForeground().get_color();
            textElement.style.fontFamily = e.get_textObject().get_font().get_fontFamilyName();
            textElement.style.fontSize = e.get_textObject().get_font().get_fontSize() + 'pt';
            textElement.wrap = "off";
            parent.appendChild(textElement);
            //automation.automationControl.automationLostFocus.invoke(this, lt.LeadEventArgs.empty);
            textElement.focus();
            textElement.addEventListener("focusout", function () {
                var parent = viewer.get_mainDiv().parentNode;
                var child = document.getElementById('textObject');
                if (child) {
                    __this.automation_GotFocus(sender, e, cell, textElement.id);
                }
            });
            this.moveCaretToEnd(textElement);
            window.setTimeout(function () {
                __this.moveCaretToEnd(textElement);
            }, 1);
        }
    };
    SeriesManagerService.prototype.moveCaretToEnd = function (element) {
        if (typeof element.selectionStart == "number") {
            element.selectionStart = element.selectionEnd = element.value.length;
        }
        else if (typeof (element["createTextRange"]) != "undefined") {
            element.focus();
            var range = element["createTextRange"];
            range.collapse(false);
            range.select();
        }
    };
    SeriesManagerService.prototype.automation_GotFocus = function (sender, e, cell, id) {
        var viewer = cell.get_imageViewer();
        var automation = cell.get_automation();
        var parent = viewer.get_foreCanvas().parentNode;
        var child = document.getElementById(id);
        if (child) {
            child.userData.set_text(child.value);
            parent.removeChild(child);
            automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
        }
    };
    SeriesManagerService.prototype.automation_CurrentDesignerChanged = function (sender, e, cell) {
        var automation = sender;
        this._eventService.publish(EventNames.CurrentDesignerChanged, { seriesInstanceUID: cell.get_seriesInstanceUID, automation: automation, selectedObject: automation.get_currentEditObject() });
        automation.get_automationControl().automationInvalidate(lt.LeadRectD.empty);
    };
    SeriesManagerService.prototype.automation_AnnotationDraw = function (sender, e) {
        if (e.operationStatus == lt.Annotations.Engine.AnnDesignerOperationStatus.start) {
            if (!this._stroke) {
                this._stroke = lt.Annotations.Engine.AnnSolidColorBrush.create(this._optionsService.get(OptionNames.AnnotationStrokeColor));
            }
            e.object.stroke.stroke = this._stroke;
            if (e.object['tickMarksStroke']) {
                e.object['tickMarksStroke'].stroke = this._stroke;
            }
            if (e.object['textForeground']) {
                if (!this._textColor) {
                    this._textColor = lt.Annotations.Engine.AnnSolidColorBrush.create(this._optionsService.get(OptionNames.AnnotationTextColor));
                }
                e.object['textForeground'] = this._textColor;
            }
            if (e.object['hiliteColor']) {
                if (!this._hilightColor) {
                    this._hilightColor = this._optionsService.get(OptionNames.AnnotationHiliteColor);
                }
                e.object['hiliteColor'] = this._hilightColor;
            }
        }
    };
    SeriesManagerService.prototype.setDefaults = function (manager) {
        var result = $.grep(Array(manager.objects.toArray()), function (item) { return item.id == lt.Annotations.Engine.AnnObject.rulerObjectId; });
        if (result.length > 0) {
            var rulerObject = result[0].objectTemplate;
            rulerObject.set_measurementUnit(lt.Annotations.Engine.AnnUnit.millimeter);
        }
    };
    SeriesManagerService.prototype.setThumbPreferences = function (renderers) {
        var bigThumbSize = 72 * 2;
        var smallThumbSize = 72;
        var locationThumbStyle = new lt.Annotations.Rendering.AnnRectangleThumbStyle();
        var rotateCenterThumbStyle = new lt.Annotations.Rendering.AnnEllipseThumbStyle();
        var rotateGripperThumbStyle = new lt.Annotations.Rendering.AnnEllipseThumbStyle();
        if (lt.LTHelper.device == lt.LTDevice.desktop) {
            locationThumbStyle.set_size(lt.LeadSizeD.create(smallThumbSize, smallThumbSize));
        }
        else {
            locationThumbStyle.set_size(lt.LeadSizeD.create(bigThumbSize, bigThumbSize));
        }
        locationThumbStyle.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create('black'), lt.LeadLengthD.create(1)));
        locationThumbStyle.set_fill(lt.Annotations.Engine.AnnSolidColorBrush.create('rgba(173, 216, 230, .4)'));
        rotateCenterThumbStyle.set_size(lt.LeadSizeD.create(smallThumbSize * 0.75, smallThumbSize * 0.75));
        rotateCenterThumbStyle.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create('black'), lt.LeadLengthD.create(1)));
        rotateCenterThumbStyle.set_fill(lt.Annotations.Engine.AnnSolidColorBrush.create('rgba(144, 238, 144, .4)'));
        rotateGripperThumbStyle.set_size(lt.LeadSizeD.create(bigThumbSize * 0.75, bigThumbSize * 0.75));
        rotateGripperThumbStyle.set_stroke(lt.Annotations.Engine.AnnStroke.create(lt.Annotations.Engine.AnnSolidColorBrush.create('black'), lt.LeadLengthD.create(1)));
        rotateGripperThumbStyle.set_fill(lt.Annotations.Engine.AnnSolidColorBrush.create('rgba(144, 238, 144, .4)'));
        for (var $key2 in renderers) {
            var item = { key: $key2, value: renderers[$key2] };
            var renderer = item.value;
            renderer.set_locationsThumbStyle(locationThumbStyle);
            renderer.set_rotateCenterThumbStyle(rotateCenterThumbStyle);
            renderer.set_rotateGripperThumbStyle(rotateGripperThumbStyle);
        }
    };
    SeriesManagerService.prototype.cloneCanvas = function (overlayCanvas) {
        var rect;
        var canvas;
        var cell = this.get_activeCell();
        if (cell instanceof lt.Controls.Medical.Cell3D) {
            var cell3D = cell;
            canvas = cell3D.image;
            rect = lt.LeadRectD.create(0, 0, cell3D.image.naturalWidth, cell3D.image.naturalHeight);
        }
        else {
            var viewer = cell.get_imageViewer();
            var activeItem = viewer.get_activeItem();
            activeItem.foregroundSize = 1024;
            canvas = activeItem.getForeground();
            //rect = viewer.getItemViewBounds(activeItem, lt.Controls.ImageViewerItemPart.view, true); 
        }
        var clonedCanvas = document.createElement('canvas');
        clonedCanvas.width = canvas.width;
        clonedCanvas.height = canvas.height;
        clonedCanvas.style.left = '0px';
        clonedCanvas.style.top = '0px';
        clonedCanvas.style.width = canvas.width + 'px';
        clonedCanvas.style.height = canvas.height + 'px';
        //blit
        var context = clonedCanvas.getContext('2d');
        context.fillStyle = '#0';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
        if (overlayCanvas)
            context.drawImage(overlayCanvas, 0, 0);
        return clonedCanvas;
    };
    SeriesManagerService.prototype.burnAnnotations = function (canvas) {
        var automation = this.get_activeCell().get_automation();
        if (!automation)
            return;
        var engine = new lt.Annotations.Rendering.AnnHtml5RenderingEngine();
        engine.attach(automation.get_activeContainer(), canvas.getContext('2d'));
        engine.burn();
    };
    SeriesManagerService.prototype.getImageSize = function (cellFrame) {
        var originalSize = cellFrame.mrtiInfo.fullSize;
        return { Width: originalSize.width, Height: originalSize.height };
    };
    SeriesManagerService.$inject = ['eventService', 'optionsService', 'dialogs', '$translate', '$modal'];
    return SeriesManagerService;
}());
services.service('seriesManagerService', SeriesManagerService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var CinePlayerService = /** @class */ (function () {
    function CinePlayerService(seriesManagerService, eventService) {
        this._seriesInstanceUID = "";
        this._updating = false;
        this._fps = 30;
        this._maxSkip = 10;
        this._currentFrame = 1;
        this._loop = true;
        this._direction = "Forward";
        this._seriesManagerService = seriesManagerService;
        this._eventService = eventService;
    }
    Object.defineProperty(CinePlayerService.prototype, "fps", {
        get: function () {
            return this._fps;
        },
        set: function (value) {
            this._fps = value;
            this.updatePlayer();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "maxSkip", {
        get: function () {
            return this._maxSkip;
        },
        set: function (value) {
            this._maxSkip = value;
            this.updatePlayer();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "isPlaying", {
        get: function () {
            if (this._cinePlayer == null)
                return false;
            return this._cinePlayer.isPlaying;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "currentFrame", {
        get: function () {
            return this._currentFrame;
        },
        set: function (value) {
            this._currentFrame = value;
            this.updatePlayer();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "loop", {
        get: function () {
            return this._loop;
        },
        set: function (value) {
            this._loop = value;
            this.updatePlayer();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (value) {
            this._direction = value;
            this.updatePlayer();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CinePlayerService.prototype, "directionFromPlayingDirection", {
        set: function (playingDirection) {
            switch (playingDirection) {
                case lt.Controls.Medical.PlayingDirection.forward:
                    this.direction = "Forward";
                    break;
                case lt.Controls.Medical.PlayingDirection.backward:
                    this.direction = "Backward";
                    break;
                case lt.Controls.Medical.PlayingDirection.sweep:
                    this.direction = "Sweep";
                    break;
                case lt.Controls.Medical.PlayingDirection.shuffle:
                    this.direction = "Shuffle";
                    break;
            }
        },
        enumerable: false,
        configurable: true
    });
    CinePlayerService.prototype.set_frameChanged = function (frameChanged) {
        if (angular.isDefined(frameChanged)) {
            this._frameChanged = frameChanged;
        }
        return this._frameChanged;
    };
    CinePlayerService.prototype.attachCell = function (cell) {
        var wasPlaying;
        if (this._cinePlayer != null) {
            if (this._cinePlayer.isPlaying) {
                this.stop();
                wasPlaying = true;
            }
        }
        this._seriesInstanceUID = cell.seriesInstanceUID;
        this._cell = cell;
        this._cinePlayer = this._cell.cinePlayer; //  new lt.Controls.Medical.CinePlayer();
    };
    Object.defineProperty(CinePlayerService.prototype, "cell", {
        get: function () {
            return this._cell;
        },
        enumerable: false,
        configurable: true
    });
    CinePlayerService.prototype.start = function () {
        if (this._cinePlayer.isPlaying)
            return;
        this.updatePlayer();
        this._playerStoppedHandle = this._eventService.subscribe(EventNames.PlayerStopped, this.playerStopped.bind(this));
        this._cinePlayer.add_frameChanged(this.frameChanged.bind(this));
        //this._cinePlayer.set_frameChanged
        var count = this._cell.viewer.layout.items.count;
        var index = 0;
        var cell;
        var checkedTickBoxFound = false;
        for (index = 0; index < count; index++) {
            cell = this._cell.viewer.layout.items.get_item(index);
            if (cell.tickBoxes.length > 0) {
                if (cell.tickBoxes[0].checked) {
                    checkedTickBoxFound = true;
                    cell.cinePlayer.play();
                }
            }
        }
        if (!checkedTickBoxFound) {
            this._cell.cinePlayer.play();
        }
    };
    CinePlayerService.prototype.stop = function () {
        var count = this._cell.viewer.layout.items.count;
        var index = 0;
        var cell;
        for (index = 0; index < count; index++) {
            cell = this._cell.viewer.layout.items.get_item(index);
            if (cell.cinePlayer.isPlaying) {
                cell.cinePlayer.stop();
            }
        }
        this._eventService.unsubscribe(this._playerStoppedHandle);
    };
    CinePlayerService.prototype.first = function () {
        if (this._cinePlayer.isPlaying)
            return;
        if (this._cell) {
            this._cell.set_currentOffset(0);
        }
    };
    CinePlayerService.prototype.last = function () {
        if (this._cinePlayer.isPlaying)
            return;
        if (this._cell) {
            this._cell.set_currentOffset(this._seriesManagerService.get_maxAllowedStackIndex(this._cell) - 1);
        }
    };
    CinePlayerService.prototype.previous = function () {
        if (this._cinePlayer.isPlaying)
            return;
        if (this._cell) {
            this._cell.set_currentOffset(Math.max(this._cell.get_currentOffset() - 1, 0));
        }
    };
    CinePlayerService.prototype.next = function () {
        if (this._cinePlayer.isPlaying)
            return;
        if (this._cell) {
            this._cell.set_currentOffset(Math.min(this._cell.get_currentOffset() + 1, this._seriesManagerService.get_maxAllowedStackIndex(this._cell)));
        }
    };
    CinePlayerService.prototype.updateCellCine = function (cell) {
        var fps = this._fps;
        var maxSkip = this._maxSkip;
        var currentFrame = this._currentFrame;
        if (this._updating) {
            return;
        }
        if (cell == null || cell.cinePlayer == null)
            return;
        this._updating = true;
        if (!this.is_pos_int(fps) || fps == 0) {
            this._fps = cell.cinePlayer.FPS;
        }
        if (!this.is_pos_int(maxSkip)) {
            this._maxSkip = cell.cinePlayer.maxSkip;
        }
        if (!this.is_pos_int(currentFrame) || (currentFrame < 0 || currentFrame > this._seriesManagerService.get_maxAllowedStackIndex(this._cell))) {
            this.currentFrame = this._cell.get_currentOffset() + 1;
        }
        cell.cinePlayer.FPS = fps;
        cell.cinePlayer.maxSkip = maxSkip;
        cell.cinePlayer.loop = this.loop;
        switch (this.direction) {
            case "Forward":
                cell.cinePlayer.direction = lt.Controls.Medical.PlayingDirection.forward;
                break;
            case "Backward":
                cell.cinePlayer.direction = lt.Controls.Medical.PlayingDirection.backward;
                break;
            case "Shuffle":
                cell.cinePlayer.direction = lt.Controls.Medical.PlayingDirection.shuffle;
                break;
            case "Sweep":
                cell.cinePlayer.direction = lt.Controls.Medical.PlayingDirection.sweep;
                break;
        }
        //cell.cinePlayer.currentFrame = this.currentFrame;
        //cell.set_currentOffset(currentFrame - 1);
        this._updating = false;
    };
    CinePlayerService.prototype.updatePlayer = function () {
        if (this._cell == null)
            return;
        var count = this._cell.viewer.layout.items.count;
        var index = 0;
        var cell;
        var checkedTickBoxFound = false;
        for (index = 0; index < count; index++) {
            cell = this._cell.viewer.layout.items.get_item(index);
            if (cell.tickBoxes.length > 0) {
                if (cell.tickBoxes[0].checked) {
                    checkedTickBoxFound = true;
                    this.updateCellCine(cell);
                }
            }
        }
        if (!checkedTickBoxFound) {
            this.updateCellCine(this._cell);
        }
    };
    CinePlayerService.prototype.frameChanged = function (sender, frame) {
        var index = frame.frameIndex;
        var frameIndex = index >= 0 ? index : 0;
        //this._cell.set_currentOffset(frameIndex);
        this._currentFrame = frameIndex;
        if (this._frameChanged) {
            this._frameChanged(frameIndex);
        }
    };
    CinePlayerService.prototype.playerStopped = function (event, data) {
        this._eventService.unsubscribe(this._playerStoppedHandle);
    };
    CinePlayerService.prototype.is_pos_int = function (value) {
        if ((parseFloat(value) == parseInt(value, 10)) && !isNaN(value)) {
            return parseInt(value, 10) >= 0;
        }
        else {
            return false;
        }
    };
    CinePlayerService.$inject = ['seriesManagerService', 'eventService'];
    return CinePlayerService;
}());
services.service('cinePlayerService', CinePlayerService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
/// <reference path="../../Scripts/controllers/OverlaySettingsController.ts" />
var OverlayManagerService = /** @class */ (function () {
    function OverlayManagerService(optionsService, eventService) {
        this._optionsService = null;
        this._defaultOverlayTags = null;
        this._optionsService = optionsService;
    }
    OverlayManagerService.prototype.getOverlayTags = function () {
        var data = this._optionsService.get(OptionNames.OverlaySettings);
        var tags;
        if (data == null || data == "") {
            if (this._defaultOverlayTags == null) {
                this._defaultOverlayTags = new Controllers.OverlayTags();
                this.BuildDefaultOverlay();
                this._optionsService.set(OptionNames.OverlaySettings, JSON.stringify(this._defaultOverlayTags));
            }
            tags = this._defaultOverlayTags;
        }
        else {
            tags = JSON.parse(data);
        }
        return tags;
    };
    OverlayManagerService.prototype.saveOverlayTags = function (overlayTags) {
        return this._optionsService.saveDefaultOptions({ OverlaySettings: JSON.stringify(overlayTags) });
    };
    OverlayManagerService.prototype.getOverlayType = function (option) {
        switch (option) {
            case "Window Level":
                return lt.Controls.Medical.OverlayTextType.windowLevel;
            case "Instance Number":
                return lt.Controls.Medical.OverlayTextType.instanceNumber;
            case "User Data":
                return lt.Controls.Medical.OverlayTextType.userData;
            case "Image Quality":
                return lt.Controls.Medical.OverlayTextType.imageQuality;
            case "Frame Number":
                return lt.Controls.Medical.OverlayTextType.frameNumber;
            case "Left Orientation":
                return lt.Controls.Medical.OverlayTextType.leftOrientation;
            case "Right Orientation":
                return lt.Controls.Medical.OverlayTextType.rightOrientation;
            case "Top Orientation":
                return lt.Controls.Medical.OverlayTextType.topOrientation;
            case "Bottom Orientation":
                return lt.Controls.Medical.OverlayTextType.bottomOrientation;
        }
        return lt.Controls.Medical.OverlayTextType.userData;
    };
    OverlayManagerService.prototype.getOverlayTypeName = function (type) {
        switch (type) {
            case lt.Controls.Medical.OverlayTextType.windowLevel:
                return "WindowLevel";
            case lt.Controls.Medical.OverlayTextType.instanceNumber:
                return "InstanceNumber";
            case lt.Controls.Medical.OverlayTextType.userData:
                return "UserData";
            case lt.Controls.Medical.OverlayTextType.imageQuality:
                return "Image Quality";
            case lt.Controls.Medical.OverlayTextType.frameNumber:
                return "FrameNumber";
            case lt.Controls.Medical.OverlayTextType.leftOrientation:
                return "LeftOrientation";
            case lt.Controls.Medical.OverlayTextType.rightOrientation:
                return "RightOrientation";
            case lt.Controls.Medical.OverlayTextType.topOrientation:
                return "TopOrientation";
            case lt.Controls.Medical.OverlayTextType.bottomOrientation:
                return "BottomOrientation";
        }
        return "UserData";
    };
    OverlayManagerService.prototype.AddTag = function (cell, text, alignment, overlayType, positionIndex, color) {
        var overlay = new lt.Controls.Medical.OverlayText();
        overlay.set_text(text);
        overlay.set_alignment(alignment);
        overlay.set_type(overlayType);
        overlay.set_positionIndex(positionIndex);
        overlay.set_color(color == undefined ? "#FFFFFF" : color);
        if (overlayType == lt.Controls.Medical.OverlayTextType.windowLevel) {
            overlay.set_weight(10);
        }
        if (!(cell instanceof lt.Controls.Medical.Cell3D) && !(cell instanceof lt.Controls.Medical.STLCell))
            cell.get_overlays().add(overlay);
        else {
            var cell3D = cell;
            cell3D.labels.add(overlay);
        }
    };
    OverlayManagerService.prototype.AddDefaultTag = function (location, title, dicomTag, overlayType, color) {
        var tag;
        tag = new Controllers.OverlayTag();
        tag.tag = dicomTag;
        tag.title = title;
        tag.overlayType = overlayType;
        tag.id = UUID.generate();
        tag.color = color == undefined ? "#FFFFFF" : color;
        location.push(tag);
    };
    OverlayManagerService.prototype.BuildDefaultOverlay = function () {
        this.AddDefaultTag(this._defaultOverlayTags.topRight, "Name: ", DicomTag.PatientName);
        this.AddDefaultTag(this._defaultOverlayTags.topRight, "PID: ", DicomTag.PatientID);
        this.AddDefaultTag(this._defaultOverlayTags.topRight, "Sex: ", DicomTag.PatientSex);
        this.AddDefaultTag(this._defaultOverlayTags.topRight, "DOB: ", DicomTag.PatientBirthDate);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "", undefined, lt.Controls.Medical.OverlayTextType.frameNumber);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "Acc#: ", DicomTag.AccessionNumber);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "Study Date: ", DicomTag.StudyDate);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "Study: ", DicomTag.StudyDescription);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "Series: ", DicomTag.SeriesDescription);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "Se#: ", DicomTag.SeriesNumber);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "", undefined, lt.Controls.Medical.OverlayTextType.instanceNumber);
        this.AddDefaultTag(this._defaultOverlayTags.topLeft, "", undefined, lt.Controls.Medical.OverlayTextType.windowLevel);
        this.AddDefaultTag(this._defaultOverlayTags.topRight, "", undefined, lt.Controls.Medical.OverlayTextType.laterality);
        this.AddDefaultTag(this._defaultOverlayTags.bottomLeft, "", undefined, lt.Controls.Medical.OverlayTextType.imageQuality, "#FF0000");
        this.AddDefaultTag(this._defaultOverlayTags.centerLeft, "", undefined, lt.Controls.Medical.OverlayTextType.leftOrientation);
        this.AddDefaultTag(this._defaultOverlayTags.centerTop, "", undefined, lt.Controls.Medical.OverlayTextType.topOrientation);
        this.AddDefaultTag(this._defaultOverlayTags.centerRight, "", undefined, lt.Controls.Medical.OverlayTextType.rightOrientation);
        this.AddDefaultTag(this._defaultOverlayTags.centerBottom, "", undefined, lt.Controls.Medical.OverlayTextType.bottomOrientation);
        this.AddDefaultTag(this._defaultOverlayTags.bottomRight, "", undefined, lt.Controls.Medical.OverlayTextType.mprType);
        this.AddDefaultTag(this._defaultOverlayTags.bottomLeft, "", undefined, lt.Controls.Medical.OverlayTextType.fieldOfView);
    };
    OverlayManagerService.prototype.set_cellOverlays = function (cell, metadata, isWaveForm) {
        var myCell = cell;
        var overlays = this.getOverlayTags();
        var currentAlignment;
        var addTagFunction = function (index, value) {
            var overlayTag = value;
            if (currentAlignment == lt.Controls.Medical.OverlayAlignment.bottomRight)
                index += 1;
            if (overlayTag.tag != null && overlayTag.tag.length > 0) {
                var element;
                element = metadata[overlayTag.tag];
                var text = '';
                if (element && element.Value && element.Value.length > 0 && element.vr == 'PN') {
                    text = DicomHelper.getPatientName(metadata, overlayTag.tag);
                }
                else {
                    text = element ? DicomHelper.get_TagValue(metadata, overlayTag.tag) : '';
                }
                if (element && element.Value && element.Value.length > 0 && element.vr == 'DA')
                    text = DicomHelper.parseDicomDate(text);
                if (element && element.Value && element.Value.length > 0 && element.vr == 'TM')
                    text = DicomHelper.parseDicomTime(text);
                this.AddTag(cell, overlayTag.title + text, currentAlignment, lt.Controls.Medical.OverlayTextType.userData, index, isWaveForm ? "rgba(0, 0, 0, 1)" : overlayTag.color);
            }
            else if (overlayTag.overlayType != null) {
                if (!isWaveForm) {
                    this.AddTag(cell, overlayTag.title, currentAlignment, overlayTag.overlayType, index, overlayTag.color);
                }
            }
        };
        if (cell.beginUpdate)
            cell.beginUpdate();
        currentAlignment = lt.Controls.Medical.OverlayAlignment.topRight;
        $.each(overlays.topRight, $.proxy(addTagFunction, this));
        currentAlignment = lt.Controls.Medical.OverlayAlignment.topLeft;
        $.each(overlays.topLeft, $.proxy(addTagFunction, this));
        if (!(cell instanceof lt.Controls.Medical.Cell3D) && !(cell instanceof lt.Controls.Medical.STLCell)) {
            currentAlignment = lt.Controls.Medical.OverlayAlignment.bottomRight;
            $.each(overlays.bottomRight, $.proxy(addTagFunction, this));
            currentAlignment = lt.Controls.Medical.OverlayAlignment.bottomLeft;
            $.each(overlays.bottomLeft, $.proxy(addTagFunction, this));
            currentAlignment = lt.Controls.Medical.OverlayAlignment.centerLeft;
            $.each(overlays.centerLeft, $.proxy(addTagFunction, this));
            currentAlignment = lt.Controls.Medical.OverlayAlignment.centerTop;
            $.each(overlays.centerTop, $.proxy(addTagFunction, this));
            currentAlignment = lt.Controls.Medical.OverlayAlignment.centerRight;
            $.each(overlays.centerRight, $.proxy(addTagFunction, this));
            currentAlignment = lt.Controls.Medical.OverlayAlignment.centerBottom;
            $.each(overlays.centerBottom, $.proxy(addTagFunction, this));
        }
        if (cell.endUpdate)
            cell.endUpdate();
    };
    OverlayManagerService.prototype.cell_hasOverlays = function (cell) {
        return cell.overlays.count > 0;
    };
    OverlayManagerService.$inject = ['optionsService', 'eventService'];
    return OverlayManagerService;
}());
services.service('overlayManagerService', OverlayManagerService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var DataService = /** @class */ (function () {
    function DataService(config, eventService, optionsService) {
        this._series = new Array();
        this._patients = new Array();
        this._eventService = eventService;
        this._optionsService = optionsService;
    }
    DataService.prototype.set_Series = function (series) {
        this._series = series;
        this._patients = new Array();
        if (series && series.length > 0) {
            if (!this._optionsService.get(OptionNames.SearchStructuredDisplay))
                this.filterPresentationState();
            this.extractPatients();
        }
        else
            this._patients.length = 0;
    };
    DataService.prototype.clearSeries = function () {
        this._series.splice(0, this._series.length);
    };
    DataService.prototype.add_series = function (series) {
        if (!this._series) {
            this._series = [];
        }
        if (series.Patient == null) {
            if (this._patients != null && this._patients.length > 0) {
                series.Patient = this._patients[0];
            }
        }
        this._series.push(series);
    };
    DataService.prototype.get_Series = function (instanceUid) {
        if (this._series && this._series.length > 0) {
            var series = $.grep(this._series, function (e) {
                return e.InstanceUID == instanceUid;
            });
            if (series.length > 0)
                return series[0];
        }
        return null;
    };
    DataService.prototype.get_allSeries = function () {
        return this._series;
    };
    DataService.prototype.filterPresentationState = function () {
        var length = this._series.length;
        while (length--) {
            if (this._series[length].Modality == "PR" || this._series[length].Modality == "SD") {
                this._series.splice(length, 1);
            }
        }
    };
    DataService.prototype.extractPatients = function () {
        var unique = {};
        var length = this._series.length;
        for (var i = 0; i < length; i++) {
            if (!unique[this._series[i].Patient.ID]) {
                var item = {};
                item.ID = this._series[i].Patient.ID;
                item.Sex = this._series[i].Patient.Sex;
                if (this._series[i].Patient.Name)
                    item.Name = this._series[i].Patient.Name.replace('^', ', ').replace(/\^/g, ' ');
                item.BirthDate = this._series[i].Patient.BirthDate;
                item.Series = [];
                item.Series.push(this._series[i]);
                this._patients.push(item);
                unique[this._series[i].Patient.ID] = item;
            }
            else {
                unique[this._series[i].Patient.ID].Series.push(this._series[i]);
            }
        }
    };
    DataService.$inject = ['app.config', 'eventService', 'optionsService'];
    return DataService;
}());
services.service('dataService', DataService);
/*! ************************************************************* */
/*! Copyright (c) 1991-2022 LEAD Technologies, Inc.               */
/*! All Rights Reserved.                                          */
/*! ************************************************************* */
var ToolbarService = /** @class */ (function () {
    function ToolbarService(optionsService, $commangular, hotkeys, eventService) {
        this._optionsService = optionsService;
        this._disabledToolbarItems = new Array();
        this._commangular = $commangular;
        this._oldCSS = {};
        this._hotkeys = hotkeys;
        this._eventService = eventService;
    }
    ToolbarService.prototype.filterToolbar = function (item) {
        if (ToolbarService.isNativeMobile && (item.id === "PopupCapture" || item.id === "WaveformBasicAudio"))
            return false;
        if (this._dentalMode) {
            if (item.id === "LayoutCompose")
                return false;
            if (item.id === "HangingProtocol")
                return false;
            if (item.id === "SaveStructuredDisplay")
                return false;
            if (item.id === "DeleteStudyStructuredDisplay")
                return false;
            if (item.id === "StudyLayout")
                return false;
            return true;
        }
        else
            return true;
    };
    ToolbarService.prototype.checkDentalEffects = function (viewer, cell, tabId) {
        if (!viewer && !cell) {
            this.unpress("Perio" + tabId);
            this.unpress("Endo" + tabId);
            this.unpress("Dentin" + tabId);
            return;
        }
        if ((!cell.selectedItem) || (!cell.selectedItem.attachedFrame)) {
            this.unpress("Perio" + tabId);
            this.unpress("Endo" + tabId);
            this.unpress("Dentin" + tabId);
            return;
        }
        if (cell instanceof lt.Controls.Medical.Cell) {
            if (cell.selectedItem) {
                var frame = cell.selectedItem.attachedFrame;
                var index = 0;
                var length = frame.imageProcessingList.count;
                if (frame == null)
                    return;
                var commandName = null;
                for (index = 0; index < length; index++) {
                    var command = frame.imageProcessingList.get_item(index).get_command();
                    switch (command) {
                        case "Perio":
                        case "Endo":
                        case "Dentin":
                            commandName = command;
                            break;
                    }
                }
                this.unpress("Perio" + tabId);
                this.unpress("Endo" + tabId);
                this.unpress("Dentin" + tabId);
                if (commandName)
                    this.press(commandName + tabId);
            }
        }
    };
    ToolbarService.prototype.load = function () {
        return null;
    };
    ToolbarService.prototype.getToolbars = function () {
        if (this._toolbars == null) {
            var names = JSON.parse(this._optionsService.get(OptionNames.Toolbars));
            if (names.length == 0) {
                names = new Array();
                names.push('main');
            }
            this._toolbars = new Array();
            for (var i = 0; i < names.length; i++) {
                var name = "Toolbar_" + names[i];
                this._dentalMode = this._optionsService.isSeriesView();
                var toolbarString = this._optionsService.get(name).replace(/(\r\n|\n|\r|\t)/gm, "");
                var toolbar = JSON.parse(toolbarString.trim());
                //disabled items
                toolbar.items = toolbar.items.filter(this.filterToolbar);
                this._toolbars.push(toolbar);
            }
        }
        return this._toolbars;
    };
    ToolbarService.prototype.getDisabledItems = function (name) {
        try {
            var items = JSON.parse(this._optionsService.get("DisabledToolbarItems_" + name));
        }
        catch (e) {
            items = new Array();
        }
        return items;
    };
    ToolbarService.prototype.isEnabled = function (name) {
        var item = $("#" + name);
        if (item.length > 0 && jQuery.hasData(item[0])) {
            return !jQuery.data(item[0], "isDisabled")();
        }
        return false;
    };
    ToolbarService.prototype.switchIcon = function (oldIcon, newIcon) {
        this.switchItem(oldIcon, newIcon);
    };
    ToolbarService.prototype.enable = function (name, check) {
        var enable = true;
        if (check != undefined && this.isFunction(check))
            enable = check();
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                if (enable)
                    this.enableItem(name[i]);
                else
                    this.disableItem(name[i]);
            }
        }
        else {
            if (enable)
                this.enableItem(name);
            else
                this.disableItem(name);
        }
    };
    ToolbarService.prototype.hilightBorder = function (name, width, color) {
        var item = $();
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                item = $("#" + name[i]);
                this.hilightItem(name, item, width, color);
            }
        }
        else {
            item = $("#" + name);
            this.hilightItem(name, item, width, color);
        }
    };
    ToolbarService.prototype.unhilightBorder = function (name) {
        var item = $();
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                item = $("#" + name[i]);
                this.unhilightItem(name, item);
            }
        }
        else {
            item = $("#" + name);
            this.unhilightItem(name, item);
        }
    };
    ToolbarService.prototype.press = function (id) {
        var iconId = "#" + id + "_icon";
        var originalId = $(iconId).attr('original-id');
        $(iconId).removeClass(originalId);
        $(iconId).addClass(originalId + "Pressed");
    };
    ToolbarService.prototype.unpress = function (id) {
        var iconId = "#" + id + "_icon";
        var originalId = $(iconId).attr('original-id');
        $(iconId).removeClass(originalId + "Pressed");
        $(iconId).addClass(originalId);
    };
    ToolbarService.prototype.updateIcon = function (iconId, trueClass, falseClass, check) {
        var classBool = check();
        if (classBool) {
            if ($(iconId).hasClass(falseClass)) {
                $(iconId).removeClass(falseClass);
                $(iconId).addClass(trueClass);
            }
        }
        else {
            if ($(iconId).hasClass(trueClass)) {
                $(iconId).removeClass(trueClass);
                $(iconId).addClass(falseClass);
            }
        }
    };
    ToolbarService.prototype.updateClass = function (id, trueClass, falseClass, check) {
        var iconId = "#" + id;
        var parentID = $(iconId).attr('parentid');
        var iconId = "#" + id + "_icon";
        this.updateIcon(iconId, trueClass, falseClass, check);
        if (parentID) {
            var parent = $("#" + parentID + "_dropdown")[0].childNodes[0];
            this.updateIcon(parent, trueClass, falseClass, check);
        }
    };
    ToolbarService.prototype.hilightItem = function (name, item, width, color) {
        this.saveCss(name, item);
        item.css("border", width);
        item.css("border-style", "solid");
        item.css("border-color", color);
    };
    ToolbarService.prototype.saveCss = function (name, item) {
        if (typeof this._oldCSS[name] == 'undefined')
            this._oldCSS[name] = {};
        this._oldCSS[name].border = item.css("border");
        this._oldCSS[name].borderStyle = item.css("border-style");
        this._oldCSS[name].borderColor = item.css("border-color");
    };
    ToolbarService.prototype.unhilightItem = function (name, item) {
        if (typeof this._oldCSS[name] != 'undefined') {
            item.css("border", this._oldCSS[name].border);
            item.css("border-style", this._oldCSS[name].borderStyle);
            item.css("border-color", this._oldCSS[name].borderColor);
        }
    };
    ToolbarService.prototype.disable = function (name) {
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                this.disableItem(name[i]);
            }
        }
        else {
            this.disableItem(name);
        }
    };
    ToolbarService.prototype.hide = function (name) {
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                var item = $("#" + name[i]);
                item.hide();
            }
        }
        else {
            var item = $("#" + name);
            item.hide();
        }
    };
    ToolbarService.prototype.show = function (name) {
        if (name instanceof Array) {
            for (var i = 0; i < name.length; i++) {
                var item = $("#" + name[i]);
                item.show();
            }
        }
        else {
            var item = $("#" + name);
            item.show();
        }
    };
    ToolbarService.prototype.disableItem = function (name) {
        var item = $("#" + name);
        if (item.length > 0 && jQuery.hasData(item[0])) {
            if (!jQuery.data(item[0], "isDisabled")()) {
                jQuery.data(item[0], "disable")();
            }
        }
    };
    ToolbarService.prototype.isFunction = function (object) {
        return typeof (object) === 'function';
    };
    ToolbarService.prototype.enableItem = function (name) {
        var item = $("#" + name);
        if (item.length > 0 && jQuery.hasData(item[0])) {
            if (jQuery.data(item[0], "isDisabled")()) {
                jQuery.data(item[0], "enable")();
            }
        }
    };
    ToolbarService.prototype.switchItem = function (name, newName) {
        var item = $("#" + name);
        if (item.length > 0 && jQuery.hasData(item[0])) {
            if (jQuery.data(item[0], "isDisabled")()) {
                jQuery.data(item[0], "enable")();
            }
        }
    };
    ToolbarService.prototype.loadDefault = function (toolbars) {
        var toolbar = new Models.Toolbar();
        toolbar.name = "Main";
        toolbars.push(toolbar);
        this.addToolbarButton(toolbar, "PanZoom", "", "toolBarItem Pan");
        this.addToolbarButton(toolbar, "Zoom", "", "toolBarItem Zoom");
        this.addToolbarButton(toolbar, "Magnify", "", "toolBarItem Magnify");
        this.addToolbarButton(toolbar, "WindowLevel", "", "toolBarItem WindowLevel");
        //
        // Window Level goes here
        //
        this.addToolbarButton(toolbar, "Stack", "", "toolBarItem Stack");
        this.addToolbarButton(toolbar, "Reload", "", "toolBarItem Reload");
        this.addToolbarButton(toolbar, "RotateClock", "", "toolBarItem RotateClock");
        this.addToolbarButton(toolbar, "RotateCounterClock", "", "toolBarItem RotateCounterClock");
        this.addToolbarButton(toolbar, "Flip", "", "toolBarItem Flip");
        this.addToolbarButton(toolbar, "Reverse", "", "toolBarItem Reverse");
        this.addToolbarButton(toolbar, "FitImage", "", "toolBarItem FitImage");
        this.addToolbarButton(toolbar, "OneToOne", "", "toolBarItem OneToOne");
        this.addToolbarButton(toolbar, "TrueSizeDisplay", "", "toolBarItem TrueSizeDisplay");
    };
    ToolbarService.prototype.addToolbarButton = function (toolbar, action, title, cssClass) {
        var item = new Models.ToolbarButton();
        item.action = action;
        item.tooltip = title;
        item.cssIconClass = cssClass || "";
        toolbar.items.push(item);
    };
    ToolbarService.prototype.GetEnabledItems = function (button) {
        var index = 0;
        var length = button.items.length;
        var items = [];
        for (index = 0; index < length; index++) {
            if ($.inArray(button.items[index].id, this._disabledToolbarItems) == -1) {
                items.add(button.items[index]);
            }
        }
        return items;
    };
    ToolbarService.prototype.processItem = function (button, parent, buttonKey) {
        var __this = this;
        var items = this.GetEnabledItems(button);
        // if this button is not a group and it's disabled, then don't show it.
        if (($.inArray(button.id, this._disabledToolbarItems) == -1) || (items.length > 0)) {
            if (items && items.length > 0) {
                if (button.type == "group") {
                    var group = $('<div class="btn-group" style="float: none !important"></div>');
                    $(parent).append(group);
                    parent = group;
                }
                else {
                    parent = __this.addDropDown(parent, items[0], buttonKey);
                }
                var firstInMenu = true;
                var noItemDivider = false;
                angular.forEach(button.items, function (value, key) {
                    if ($.inArray(value.id, __this._disabledToolbarItems) == -1) {
                        if (value.type != 'seperator') {
                            if (firstInMenu) {
                                parent.append('<li class="menuBar"></li>');
                                firstInMenu = false;
                            }
                            else {
                                if (!noItemDivider) {
                                    parent.append('<li class="itemDivider"></li>');
                                }
                                noItemDivider = false;
                            }
                            __this.addOption(parent, value, buttonKey);
                        }
                        else {
                            __this.addOption(parent, value, buttonKey);
                            noItemDivider = true;
                        }
                    }
                });
            }
            else {
                if (button.type == "button") {
                    __this.addButton(parent, button, buttonKey);
                }
                else if (button.type == "seperator") {
                    __this.addSeperator(parent, button, buttonKey);
                }
            }
        }
    };
    ToolbarService.prototype.addShortcut = function (button) {
        var __this = this;
        if (button.shortcut && button.shortcut.length) {
            this._hotkeys.add({
                combo: button.shortcut,
                description: button.tooltip,
                callback: function () {
                    __this.runCommand(button.action, button.id);
                }
            });
        }
    };
    ToolbarService.prototype.processCaption = function (inputCaption) {
        if (inputCaption) {
            var index = inputCaption.toLowerCase().indexOf("pdf");
            if (index != -1) {
                if (!this._optionsService.get(OptionNames.PrintLayout)) {
                    return "Print To JPG";
                }
            }
        }
        return inputCaption;
    };
    ToolbarService.prototype.addButton = function (parent, button, buttonKey) {
        //var navbutton: any = $('<button class="btn btn-default toolbar-button" style="margin:0px; padding:0px">' + '' + '</button>');
        var navbutton = $('<button onfocus="blur();" class="btn btn-default toolbar-button">' + '' + '</button>');
        navbutton.tabStop = false;
        var id = button.id + buttonKey;
        navbutton.attr('id', id);
        navbutton.attr('type', 'button');
        navbutton.attr('data-toggle', 'button');
        if (button.tooltip && button.tooltip.length > 0) {
            navbutton.attr('title', button.tooltip);
            navbutton.attr('data-container', 'body');
        }
        if (button.cssIconClass) {
            var icon = $("<div class='toolBarItem " + button.cssIconClass + "'> </div>");
            icon.attr('id', id + "_icon");
            icon.attr('original-id', button.id);
            navbutton.append(icon);
        }
        if (button.cssIconClass) {
            var caption = this.processCaption(button.caption);
            var icon = $("<i class='toolBarItemText'>" + caption + "</i>");
            navbutton.append(icon);
        }
        $.data(navbutton[0], "enable", function () {
            var menuIcon = "#" + id + "_icon";
            navbutton.removeAttr('disabled');
            navbutton.removeClass('btn-disabled');
            $(menuIcon).removeClass("Disabled" + button.cssIconClass);
            $(menuIcon).addClass(button.cssIconClass);
        });
        $.data(navbutton[0], "disable", function () {
            var menuIcon = "#" + id + "_icon";
            navbutton.attr('disabled', 'disabled');
            navbutton.addClass('btn-disabled');
            $(menuIcon).removeClass(button.cssIconClass);
            $(menuIcon).addClass("Disabled" + button.cssIconClass);
        });
        $.data(navbutton[0], "isDisabled", function () {
            return (navbutton.attr('disabled') != undefined);
        });
        var __this = this;
        this.addShortcut(button);
        if (button.action != null) {
            navbutton.on("click", function (e) {
                __this.runCommand(button.action, id);
            });
        }
        $(parent).append(navbutton);
        if (angular.isDefined(button['visible']) && Utils.toBoolean(button.visible, true) == false) {
            this.hide(id);
        }
        if (angular.isDefined(button['disabled']) && Utils.toBoolean(button.disabled, false) == true) {
            this.disable(id);
        }
    };
    ToolbarService.prototype.addSeperator = function (parent, button, buttonKey) {
        var span = $('<span style="width:3px"></span>');
        $(parent).append(span);
    };
    ToolbarService.prototype.addDropDown = function (parent, button, buttonKey) {
        var group = $('<div class="btn-group " style="float: none !important"></div>');
        var ul = $('<ul class="dropdown-menu"></ul>');
        var dropDown = $('<button class="btn btn-default dropdown-toggle toolbar-button" data-toggle="dropdown"></button>');
        var btn = $('<button onfocus="blur();" class="btn btn-default toolbar-button">' + '' + '</button>');
        var dropDownIcon;
        var __this = this;
        var id = button.id + buttonKey;
        if (button.cssIconClass) {
            dropDownIcon = $("<i class='toolBarItem " + button.cssIconClass + "'> </i>");
            btn.append(dropDownIcon);
        }
        var iconText;
        if (button.cssIconClass) {
            var caption = this.processCaption(button.caption);
            iconText = $("<i class='toolBarItemText'>" + caption + "</i>");
            btn.append(iconText);
        }
        btn.attr('id', id + "_dropdown");
        btn.attr('type', "button");
        btn.data('action', button.action);
        btn.attr('title', button.tooltip);
        btn.attr('data-container', 'body');
        btn.attr('original-id', button.id);
        btn.on("click", function () {
            var currentAction = btn.data('action');
            if (currentAction && currentAction.length > 0) {
                __this.runCommand(currentAction, id);
            }
        });
        dropDown.attr('id', id);
        $.data(dropDown[0], "enable", function () {
            btn.removeAttr('disabled');
            dropDown.removeAttr('disabled');
        });
        $.data(dropDown[0], "disable", function () {
            dropDown.attr('disabled', 'disabled');
            btn.attr('disabled', 'disabled');
        });
        $.data(dropDown[0], "isDisabled", function () {
            return (dropDown.attr('disabled') != undefined);
        });
        $.data(ul[0], "dropdown", id + "_dropdown");
        $.data(ul[0], "dropDownIcon", dropDownIcon);
        $.data(ul[0], "iconName", button.cssIconClass);
        $.data(ul[0], "iconText", iconText);
        group.append(btn);
        dropDown.append('<span class="caret"></span>');
        group.append(dropDown);
        group.append(ul);
        parent.append(group);
        return ul;
    };
    ToolbarService.prototype.addOption = function (parent, button, buttonKey) {
        if (button.type == 'seperator') {
            parent.append('<li class="divider"></li>');
        }
        else {
            var id = button.id + buttonKey;
            var li = $('<li></li>');
            var anchor = $('<a href="javascript:void(0)" target="_self">' + '' + '</a>');
            if (button.cssIconClass) {
                var menuIcon = $("<i class='toolBarItemOption " + button.cssIconClass + "' style='height: 30px; width: 30px;'></i>" + "<i class='menuItemText' >" + button.tooltip + "</i>");
                menuIcon.attr("id", id + "_icon");
                menuIcon.attr('original-id', button.id);
                anchor.append(menuIcon);
            }
            anchor.attr('id', id);
            anchor.attr('type', 'button');
            // add parent.
            if (parent != null)
                anchor.attr('parentID', parent[0].previousElementSibling.id);
            if (button.tooltip && button.tooltip.length > 0) {
                anchor.attr('title', button.tooltip);
                anchor.attr('data-container', 'body');
            }
            $.data(anchor[0], "enable", function () {
                var menuIcon = "#" + id + "_icon";
                anchor.removeAttr('disabled');
                $(menuIcon).removeClass("Disabled" + button.cssIconClass);
                $(menuIcon).addClass(button.cssIconClass);
                if ($.hasData(parent[0])) {
                    var iconName = $.data(parent[0], "iconName");
                    if (iconName == ("Disabled" + button.cssIconClass)) {
                        var dropDown = $("#" + $.data(parent[0], "dropdown"));
                        var iconName = $.data(parent[0], "iconName");
                        var currentIcon = $.data(parent[0], "dropDownIcon");
                        __this.setIcon(button.cssIconClass, iconName, currentIcon, parent);
                        if (dropDown.length > 0) {
                            dropDown.removeAttr('disabled');
                        }
                    }
                }
            });
            $.data(anchor[0], "switch", function () {
                var menuIcon = "#" + id + "_icon";
                anchor.attr('disabled', 'disabled');
                $(menuIcon).removeClass(button.cssIconClass);
                $(menuIcon).addClass("Disabled" + button.cssIconClass);
                if ($.hasData(parent[0])) {
                    var iconName = $.data(parent[0], "iconName");
                    if (iconName == button.cssIconClass) {
                        var dropDown = $("#" + $.data(parent[0], "dropdown"));
                        var iconName = $.data(parent[0], "iconName");
                        var currentIcon = $.data(parent[0], "dropDownIcon");
                        __this.setIcon("Disabled" + button.cssIconClass, iconName, currentIcon, parent);
                        if (dropDown.length > 0) {
                            dropDown.attr('disabled', 'disabled');
                        }
                    }
                }
            });
            $.data(anchor[0], "disable", function () {
                var menuIcon = "#" + id + "_icon";
                anchor.attr('disabled', 'disabled');
                $(menuIcon).removeClass(button.cssIconClass);
                $(menuIcon).addClass("Disabled" + button.cssIconClass);
                if ($.hasData(parent[0])) {
                    var iconName = $.data(parent[0], "iconName");
                    if (iconName == button.cssIconClass) {
                        var dropDown = $("#" + $.data(parent[0], "dropdown"));
                        var iconName = $.data(parent[0], "iconName");
                        var currentIcon = $.data(parent[0], "dropDownIcon");
                        __this.setIcon("Disabled" + button.cssIconClass, iconName, currentIcon, parent);
                        if (dropDown.length > 0) {
                            dropDown.attr('disabled', 'disabled');
                        }
                    }
                }
            });
            $.data(anchor[0], "isDisabled", function () {
                return (anchor.attr('disabled') != undefined);
            });
            li.append(anchor);
            parent.append(li);
            var __this = this;
            if (button.action != null) {
                anchor.on("click", function () {
                    var name = $(this).attr('id');
                    if ($.hasData(parent[0])) {
                        var dropDown = $("#" + $.data(parent[0], "dropdown"));
                        if (dropDown.length > 0) {
                            var currentIcon = $.data(parent[0], "dropDownIcon");
                            var iconText = $.data(parent[0], "iconText");
                            if (currentIcon && currentIcon.length > 0) {
                                var iconName = $.data(parent[0], "iconName");
                                var enabled = __this.isEnabled(button.id + buttonKey);
                                var newIconName = enabled ? button.cssIconClass : "Disabled" + button.cssIconClass;
                                iconText[0].innerText = button.caption;
                                __this.setIcon(newIconName, iconName, currentIcon, parent);
                                //dropDown.children[1].outerText = newCaption;
                                if (!enabled) {
                                    dropDown.attr('disabled', 'disabled');
                                }
                                else {
                                    dropDown.removeAttr('disabled');
                                }
                                dropDown.data('action', button.action);
                                dropDown.attr('title', button.tooltip);
                            }
                        }
                    }
                    __this.runCommand(button.action, id);
                });
            }
        }
    };
    ToolbarService.prototype.setIcon = function (newIcon, icon, currentIcon, parent) {
        if (icon && icon.length > 0)
            currentIcon.removeClass(icon);
        currentIcon.addClass(newIcon);
        $.data(parent[0], "iconName", newIcon);
    };
    ToolbarService.prototype.runCommand = function (command, buttonId) {
        var btnCommand = commangularProvider.findCommand(command);
        if (btnCommand && btnCommand.descriptors && btnCommand.descriptors.length >= 1) {
            if (btnCommand.descriptors[0].command != undefined) {
                this._commangular.dispatch(command, { buttonId: buttonId });
            }
        }
    };
    ToolbarService.prototype.buildToolbar = function (scope, buttons, parent, buttonKey) {
        var __this = this;
        buttonKey = buttonKey || '';
        this._disabledToolbarItems = this.getDisabledItems(scope.name);
        angular.forEach(buttons, function (value, key) {
            __this.processItem(value, parent, buttonKey);
        });
        this._eventService.publish(EventNames.ToolbarCreated, buttonKey);
    };
    ToolbarService.prototype.getCommands = function () {
        var commands = new Array();
        this.traverse(this.getToolbars()[0].items, commands);
        return commands;
    };
    ToolbarService.prototype.traverse = function (buttons, commands) {
        var __this = this;
        angular.forEach(buttons, function (value, key) {
            if (value.action) {
                commands.push(value.action);
            }
            if (value.items && value.items.length > 0) {
                __this.traverse(value.items, commands);
            }
        });
    };
    ToolbarService.$inject = ['optionsService', '$commangular', 'hotkeys', 'eventService'];
    ToolbarService.isNativeMobile = false;
    return ToolbarService;
}());
services.service('toolbarService', ToolbarService);
//# sourceMappingURL=MedicalViewerDemo.js.map